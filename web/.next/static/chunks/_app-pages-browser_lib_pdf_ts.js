"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_lib_pdf_ts"],{

/***/ "(app-pages-browser)/./lib/pdf.ts":
/*!********************!*\
  !*** ./lib/pdf.ts ***!
  \********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatPDFError: function() { return /* binding */ formatPDFError; },\n/* harmony export */   loadPdfFromFile: function() { return /* binding */ loadPdfFromFile; },\n/* harmony export */   loadPdfWithPassword: function() { return /* binding */ loadPdfWithPassword; },\n/* harmony export */   processPDFFile: function() { return /* binding */ processPDFFile; },\n/* harmony export */   renderPdfPageToDataURL: function() { return /* binding */ renderPdfPageToDataURL; }\n/* harmony export */ });\n/* __next_internal_client_entry_do_not_use__ loadPdfFromFile,loadPdfWithPassword,renderPdfPageToDataURL,processPDFFile,formatPDFError auto */ // Dynamic imports to avoid SSR issues\nlet pdfjsLib = null;\nconst loadPDFJS = async ()=>{\n    if (pdfjsLib) return pdfjsLib;\n    if (false) {}\n    try {\n        pdfjsLib = await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_pdfjs-dist_5_4_149_node_modules_pdfjs-dist_build_pdf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! pdfjs-dist */ \"(app-pages-browser)/../node_modules/.pnpm/pdfjs-dist@5.4.149/node_modules/pdfjs-dist/build/pdf.mjs\"));\n        // Configure worker path for Next.js (served from /public)\n        pdfjsLib.GlobalWorkerOptions.workerSrc = \"/pdf.worker.min.js\";\n        return pdfjsLib;\n    } catch (error) {\n        console.error(\"Failed to load PDF.js:\", error);\n        return null;\n    }\n};\n// Load PDF from file with proper error handling\nasync function loadPdfFromFile(file) {\n    const pdfjs = await loadPDFJS();\n    if (!pdfjs) {\n        const error = new Error(\"PDF.js failed to load\");\n        error.type = \"missing-worker\";\n        error.message = \"PDF worker missing (dev): run pnpm -C web postinstall & restart dev.\";\n        throw error;\n    }\n    try {\n        const buffer = new Uint8Array(await file.arrayBuffer());\n        const pdf = await pdfjs.getDocument({\n            data: buffer\n        }).promise;\n        return pdf;\n    } catch (error) {\n        var _error_message;\n        const pdfError = new Error(\"Failed to load PDF\");\n        if (error.name === \"PasswordException\") {\n            pdfError.type = \"password-required\";\n            pdfError.message = \"This PDF requires a password\";\n        } else if (error.name === \"InvalidPDFException\") {\n            pdfError.type = \"corrupted\";\n            pdfError.message = \"This PDF file appears to be corrupted or invalid\";\n        } else if ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes(\"worker\")) {\n            pdfError.type = \"missing-worker\";\n            pdfError.message = \"PDF worker missing (dev): run pnpm -C web postinstall & restart dev.\";\n        } else {\n            pdfError.type = \"unknown\";\n            pdfError.message = \"Failed to process PDF: \".concat(error.message || \"Unknown error\");\n        }\n        pdfError.originalError = error;\n        throw pdfError;\n    }\n}\n// Load PDF with password support\nasync function loadPdfWithPassword(file, getPassword) {\n    const pdfjs = await loadPDFJS();\n    if (!pdfjs) {\n        const error = new Error(\"PDF.js failed to load\");\n        error.type = \"missing-worker\";\n        error.message = \"PDF worker missing (dev): run pnpm -C web postinstall & restart dev.\";\n        throw error;\n    }\n    try {\n        const buffer = new Uint8Array(await file.arrayBuffer());\n        const loadingTask = pdfjs.getDocument({\n            data: buffer\n        });\n        loadingTask.onPassword = async (updatePassword, reason)=>{\n            // reason === 1: need password, 2: wrong password\n            const isRetry = reason === 2;\n            const password = await getPassword();\n            if (password === null) {\n                // User cancelled\n                throw new Error(\"Password required\");\n            }\n            updatePassword(password);\n        };\n        return await loadingTask.promise;\n    } catch (error) {\n        const pdfError = new Error(\"Failed to load PDF\");\n        if (error.message === \"Password required\") {\n            pdfError.type = \"password-required\";\n            pdfError.message = \"Password is required to open this PDF\";\n        } else if (error.name === \"PasswordException\") {\n            pdfError.type = \"wrong-password\";\n            pdfError.message = \"Incorrect password\";\n        } else {\n            pdfError.type = \"unknown\";\n            pdfError.message = \"Failed to process PDF: \".concat(error.message || \"Unknown error\");\n        }\n        pdfError.originalError = error;\n        throw pdfError;\n    }\n}\n// Render PDF page to high-quality data URL\nasync function renderPdfPageToDataURL(pdf, pageNumber) {\n    let scale = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 2.0;\n    try {\n        const page = await pdf.getPage(pageNumber);\n        const viewport = page.getViewport({\n            scale\n        });\n        const canvas = document.createElement(\"canvas\");\n        const context = canvas.getContext(\"2d\");\n        canvas.width = Math.floor(viewport.width);\n        canvas.height = Math.floor(viewport.height);\n        const renderContext = {\n            canvasContext: context,\n            viewport: viewport\n        };\n        await page.render(renderContext).promise;\n        return {\n            dataURL: canvas.toDataURL(\"image/png\", 0.95),\n            width: canvas.width,\n            height: canvas.height,\n            pageNumber\n        };\n    } catch (error) {\n        throw new Error(\"Failed to render page \".concat(pageNumber, \": \").concat(error.message));\n    }\n}\n// Create password prompt dialog\nfunction createPasswordDialog() {\n    let isRetry = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n    return new Promise((resolve)=>{\n        const overlay = document.createElement(\"div\");\n        overlay.style.cssText = \"\\n      position: fixed;\\n      top: 0;\\n      left: 0;\\n      width: 100%;\\n      height: 100%;\\n      background: rgba(0, 0, 0, 0.5);\\n      display: flex;\\n      align-items: center;\\n      justify-content: center;\\n      z-index: 10000;\\n    \";\n        const dialog = document.createElement(\"div\");\n        dialog.style.cssText = \"\\n      background: white;\\n      padding: 24px;\\n      border-radius: 8px;\\n      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);\\n      min-width: 400px;\\n    \";\n        const title = document.createElement(\"h3\");\n        title.textContent = isRetry ? \"Incorrect Password\" : \"Password Required\";\n        title.style.cssText = \"\\n      margin: 0 0 16px 0;\\n      font-size: 18px;\\n      font-weight: 600;\\n      color: \".concat(isRetry ? \"#dc2626\" : \"#1f2937\", \";\\n    \");\n        const message = document.createElement(\"p\");\n        message.textContent = isRetry ? \"The password you entered is incorrect. Please try again.\" : \"This PDF is password protected. Please enter the password to continue.\";\n        message.style.cssText = \"\\n      margin: 0 0 16px 0;\\n      color: #6b7280;\\n    \";\n        const input = document.createElement(\"input\");\n        input.type = \"password\";\n        input.placeholder = \"Enter password\";\n        input.style.cssText = \"\\n      width: 100%;\\n      padding: 12px;\\n      border: 1px solid #d1d5db;\\n      border-radius: 6px;\\n      font-size: 14px;\\n      margin-bottom: 16px;\\n      box-sizing: border-box;\\n    \";\n        const buttonContainer = document.createElement(\"div\");\n        buttonContainer.style.cssText = \"\\n      display: flex;\\n      gap: 12px;\\n      justify-content: flex-end;\\n    \";\n        const cancelButton = document.createElement(\"button\");\n        cancelButton.textContent = \"Cancel\";\n        cancelButton.style.cssText = \"\\n      padding: 10px 20px;\\n      border: 1px solid #d1d5db;\\n      border-radius: 6px;\\n      background: white;\\n      cursor: pointer;\\n      font-weight: 500;\\n    \";\n        const submitButton = document.createElement(\"button\");\n        submitButton.textContent = \"Open PDF\";\n        submitButton.style.cssText = \"\\n      padding: 10px 20px;\\n      border: none;\\n      border-radius: 6px;\\n      background: #3b82f6;\\n      color: white;\\n      cursor: pointer;\\n      font-weight: 500;\\n    \";\n        const cleanup = ()=>{\n            if (document.body.contains(overlay)) {\n                document.body.removeChild(overlay);\n            }\n        };\n        const handleSubmit = ()=>{\n            const password = input.value.trim();\n            if (password) {\n                cleanup();\n                resolve(password);\n            }\n        };\n        const handleCancel = ()=>{\n            cleanup();\n            resolve(null);\n        };\n        cancelButton.addEventListener(\"click\", handleCancel);\n        submitButton.addEventListener(\"click\", handleSubmit);\n        input.addEventListener(\"keydown\", (e)=>{\n            if (e.key === \"Enter\") {\n                handleSubmit();\n            } else if (e.key === \"Escape\") {\n                handleCancel();\n            }\n        });\n        // Close on outside click\n        overlay.addEventListener(\"click\", (e)=>{\n            if (e.target === overlay) {\n                handleCancel();\n            }\n        });\n        buttonContainer.appendChild(cancelButton);\n        buttonContainer.appendChild(submitButton);\n        dialog.appendChild(title);\n        dialog.appendChild(message);\n        dialog.appendChild(input);\n        dialog.appendChild(buttonContainer);\n        overlay.appendChild(dialog);\n        document.body.appendChild(overlay);\n        input.focus();\n    });\n}\n// Main PDF processing function with all error handling\nasync function processPDFFile(file, onSuccess, onError) {\n    try {\n        // First try without password\n        const pdf = await loadPdfFromFile(file);\n        onSuccess(pdf);\n    } catch (error) {\n        if (error.type === \"password-required\") {\n            // Try with password prompt\n            try {\n                let attempts = 0;\n                const getPassword = async ()=>{\n                    attempts++;\n                    const isRetry = attempts > 1;\n                    return await createPasswordDialog(isRetry);\n                };\n                const pdf = await loadPdfWithPassword(file, getPassword);\n                onSuccess(pdf);\n            } catch (passwordError) {\n                onError(passwordError);\n            }\n        } else {\n            onError(error);\n        }\n    }\n}\n// Helper function to format error messages for user display\nfunction formatPDFError(error) {\n    switch(error.type){\n        case \"missing-worker\":\n            return \"❌ PDF worker missing (dev): run pnpm -C web postinstall & restart dev.\";\n        case \"password-required\":\n            return \"\\uD83D\\uDD12 This PDF requires a password to open.\";\n        case \"wrong-password\":\n            return \"❌ Incorrect password. Please try again.\";\n        case \"corrupted\":\n            return \"❌ This PDF file appears to be corrupted or invalid.\";\n        case \"cors-blocked\":\n            return \"❌ Cannot access this PDF due to security restrictions. Try uploading the file directly.\";\n        default:\n            return \"❌ Failed to process PDF: \".concat(error.message);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LGNBQWM7b0JBQ2xCMkQ7b0JBQ0EsTUFBTXRELFVBQVVzRCxXQUFXO29CQUMzQixPQUFPLE1BQU0vQixxQkFBcUJ2QjtnQkFDcEM7Z0JBRUEsTUFBTWQsTUFBTSxNQUFNUSxvQkFBb0JoQixNQUFNaUI7Z0JBQzVDeUQsVUFBVWxFO1lBQ1osRUFBRSxPQUFPcUUsZUFBb0I7Z0JBQzNCRixRQUFRRTtZQUNWO1FBQ0YsT0FBTztZQUNMRixRQUFROUU7UUFDVjtJQUNGO0FBQ0Y7QUFFQSw0REFBNEQ7QUFDckQsU0FBU2lGLGVBQWVqRixLQUFtQjtJQUNoRCxPQUFRQSxNQUFNTSxJQUFJO1FBQ2hCLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVDtZQUNFLE9BQU8sNEJBQTBDLE9BQWROLE1BQU1PLE9BQU87SUFDcEQ7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvcGRmLnRzPzIyMTUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG4vLyBEeW5hbWljIGltcG9ydHMgdG8gYXZvaWQgU1NSIGlzc3Vlc1xubGV0IHBkZmpzTGliOiBhbnkgPSBudWxsO1xuXG5jb25zdCBsb2FkUERGSlMgPSBhc3luYyAoKSA9PiB7XG4gIGlmIChwZGZqc0xpYikgcmV0dXJuIHBkZmpzTGliO1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBudWxsO1xuICBcbiAgdHJ5IHtcbiAgICBwZGZqc0xpYiA9IGF3YWl0IGltcG9ydCgncGRmanMtZGlzdCcpO1xuICAgIFxuICAgIC8vIENvbmZpZ3VyZSB3b3JrZXIgcGF0aCBmb3IgTmV4dC5qcyAoc2VydmVkIGZyb20gL3B1YmxpYylcbiAgICBwZGZqc0xpYi5HbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYyA9ICcvcGRmLndvcmtlci5taW4uanMnO1xuICAgIFxuICAgIHJldHVybiBwZGZqc0xpYjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9hZCBQREYuanM6JywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIFBERlBhZ2VSZW5kZXJSZXN1bHQge1xuICBkYXRhVVJMOiBzdHJpbmc7XG4gIHdpZHRoOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xuICBwYWdlTnVtYmVyOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUERGTG9hZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICB0eXBlOiAnbWlzc2luZy13b3JrZXInIHwgJ3Bhc3N3b3JkLXJlcXVpcmVkJyB8ICd3cm9uZy1wYXNzd29yZCcgfCAnY29ycy1ibG9ja2VkJyB8ICdjb3JydXB0ZWQnIHwgJ3Vua25vd24nO1xuICBvcmlnaW5hbEVycm9yPzogRXJyb3I7XG59XG5cbi8vIExvYWQgUERGIGZyb20gZmlsZSB3aXRoIHByb3BlciBlcnJvciBoYW5kbGluZ1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRQZGZGcm9tRmlsZShmaWxlOiBGaWxlKTogUHJvbWlzZTxhbnk+IHtcbiAgY29uc3QgcGRmanMgPSBhd2FpdCBsb2FkUERGSlMoKTtcbiAgaWYgKCFwZGZqcykge1xuICAgIGNvbnN0IGVycm9yOiBQREZMb2FkRXJyb3IgPSBuZXcgRXJyb3IoJ1BERi5qcyBmYWlsZWQgdG8gbG9hZCcpIGFzIFBERkxvYWRFcnJvcjtcbiAgICBlcnJvci50eXBlID0gJ21pc3Npbmctd29ya2VyJztcbiAgICBlcnJvci5tZXNzYWdlID0gJ1BERiB3b3JrZXIgbWlzc2luZyAoZGV2KTogcnVuIHBucG0gLUMgd2ViIHBvc3RpbnN0YWxsICYgcmVzdGFydCBkZXYuJztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgZmlsZS5hcnJheUJ1ZmZlcigpKTtcbiAgICBjb25zdCBwZGYgPSBhd2FpdCBwZGZqcy5nZXREb2N1bWVudCh7IGRhdGE6IGJ1ZmZlciB9KS5wcm9taXNlO1xuICAgIHJldHVybiBwZGY7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zdCBwZGZFcnJvcjogUERGTG9hZEVycm9yID0gbmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBQREYnKSBhcyBQREZMb2FkRXJyb3I7XG4gICAgXG4gICAgaWYgKGVycm9yLm5hbWUgPT09ICdQYXNzd29yZEV4Y2VwdGlvbicpIHtcbiAgICAgIHBkZkVycm9yLnR5cGUgPSAncGFzc3dvcmQtcmVxdWlyZWQnO1xuICAgICAgcGRmRXJyb3IubWVzc2FnZSA9ICdUaGlzIFBERiByZXF1aXJlcyBhIHBhc3N3b3JkJztcbiAgICB9IGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdJbnZhbGlkUERGRXhjZXB0aW9uJykge1xuICAgICAgcGRmRXJyb3IudHlwZSA9ICdjb3JydXB0ZWQnO1xuICAgICAgcGRmRXJyb3IubWVzc2FnZSA9ICdUaGlzIFBERiBmaWxlIGFwcGVhcnMgdG8gYmUgY29ycnVwdGVkIG9yIGludmFsaWQnO1xuICAgIH0gZWxzZSBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ3dvcmtlcicpKSB7XG4gICAgICBwZGZFcnJvci50eXBlID0gJ21pc3Npbmctd29ya2VyJztcbiAgICAgIHBkZkVycm9yLm1lc3NhZ2UgPSAnUERGIHdvcmtlciBtaXNzaW5nIChkZXYpOiBydW4gcG5wbSAtQyB3ZWIgcG9zdGluc3RhbGwgJiByZXN0YXJ0IGRldi4nO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZGZFcnJvci50eXBlID0gJ3Vua25vd24nO1xuICAgICAgcGRmRXJyb3IubWVzc2FnZSA9IGBGYWlsZWQgdG8gcHJvY2VzcyBQREY6ICR7ZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YDtcbiAgICB9XG4gICAgXG4gICAgcGRmRXJyb3Iub3JpZ2luYWxFcnJvciA9IGVycm9yO1xuICAgIHRocm93IHBkZkVycm9yO1xuICB9XG59XG5cbi8vIExvYWQgUERGIHdpdGggcGFzc3dvcmQgc3VwcG9ydFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRQZGZXaXRoUGFzc3dvcmQoXG4gIGZpbGU6IEZpbGUsIFxuICBnZXRQYXNzd29yZDogKCkgPT4gUHJvbWlzZTxzdHJpbmcgfCBudWxsPlxuKTogUHJvbWlzZTxhbnk+IHtcbiAgY29uc3QgcGRmanMgPSBhd2FpdCBsb2FkUERGSlMoKTtcbiAgaWYgKCFwZGZqcykge1xuICAgIGNvbnN0IGVycm9yOiBQREZMb2FkRXJyb3IgPSBuZXcgRXJyb3IoJ1BERi5qcyBmYWlsZWQgdG8gbG9hZCcpIGFzIFBERkxvYWRFcnJvcjtcbiAgICBlcnJvci50eXBlID0gJ21pc3Npbmctd29ya2VyJztcbiAgICBlcnJvci5tZXNzYWdlID0gJ1BERiB3b3JrZXIgbWlzc2luZyAoZGV2KTogcnVuIHBucG0gLUMgd2ViIHBvc3RpbnN0YWxsICYgcmVzdGFydCBkZXYuJztcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgZmlsZS5hcnJheUJ1ZmZlcigpKTtcbiAgICBjb25zdCBsb2FkaW5nVGFzayA9IHBkZmpzLmdldERvY3VtZW50KHsgZGF0YTogYnVmZmVyIH0pO1xuICAgIFxuICAgIGxvYWRpbmdUYXNrLm9uUGFzc3dvcmQgPSBhc3luYyAodXBkYXRlUGFzc3dvcmQsIHJlYXNvbikgPT4ge1xuICAgICAgLy8gcmVhc29uID09PSAxOiBuZWVkIHBhc3N3b3JkLCAyOiB3cm9uZyBwYXNzd29yZFxuICAgICAgY29uc3QgaXNSZXRyeSA9IHJlYXNvbiA9PT0gMjtcbiAgICAgIGNvbnN0IHBhc3N3b3JkID0gYXdhaXQgZ2V0UGFzc3dvcmQoKTtcbiAgICAgIFxuICAgICAgaWYgKHBhc3N3b3JkID09PSBudWxsKSB7XG4gICAgICAgIC8vIFVzZXIgY2FuY2VsbGVkXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGFzc3dvcmQgcmVxdWlyZWQnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdXBkYXRlUGFzc3dvcmQocGFzc3dvcmQpO1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIGF3YWl0IGxvYWRpbmdUYXNrLnByb21pc2U7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zdCBwZGZFcnJvcjogUERGTG9hZEVycm9yID0gbmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBQREYnKSBhcyBQREZMb2FkRXJyb3I7XG4gICAgXG4gICAgaWYgKGVycm9yLm1lc3NhZ2UgPT09ICdQYXNzd29yZCByZXF1aXJlZCcpIHtcbiAgICAgIHBkZkVycm9yLnR5cGUgPSAncGFzc3dvcmQtcmVxdWlyZWQnO1xuICAgICAgcGRmRXJyb3IubWVzc2FnZSA9ICdQYXNzd29yZCBpcyByZXF1aXJlZCB0byBvcGVuIHRoaXMgUERGJztcbiAgICB9IGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdQYXNzd29yZEV4Y2VwdGlvbicpIHtcbiAgICAgIHBkZkVycm9yLnR5cGUgPSAnd3JvbmctcGFzc3dvcmQnO1xuICAgICAgcGRmRXJyb3IubWVzc2FnZSA9ICdJbmNvcnJlY3QgcGFzc3dvcmQnO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZGZFcnJvci50eXBlID0gJ3Vua25vd24nO1xuICAgICAgcGRmRXJyb3IubWVzc2FnZSA9IGBGYWlsZWQgdG8gcHJvY2VzcyBQREY6ICR7ZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YDtcbiAgICB9XG4gICAgXG4gICAgcGRmRXJyb3Iub3JpZ2luYWxFcnJvciA9IGVycm9yO1xuICAgIHRocm93IHBkZkVycm9yO1xuICB9XG59XG5cbi8vIFJlbmRlciBQREYgcGFnZSB0byBoaWdoLXF1YWxpdHkgZGF0YSBVUkxcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZW5kZXJQZGZQYWdlVG9EYXRhVVJMKFxuICBwZGY6IGFueSwgXG4gIHBhZ2VOdW1iZXI6IG51bWJlciwgXG4gIHNjYWxlOiBudW1iZXIgPSAyLjBcbik6IFByb21pc2U8UERGUGFnZVJlbmRlclJlc3VsdD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHBhZ2UgPSBhd2FpdCBwZGYuZ2V0UGFnZShwYWdlTnVtYmVyKTtcbiAgICBjb25zdCB2aWV3cG9ydCA9IHBhZ2UuZ2V0Vmlld3BvcnQoeyBzY2FsZSB9KTtcbiAgICBcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJykhO1xuICAgIFxuICAgIGNhbnZhcy53aWR0aCA9IE1hdGguZmxvb3Iodmlld3BvcnQud2lkdGgpO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBNYXRoLmZsb29yKHZpZXdwb3J0LmhlaWdodCk7XG4gICAgXG4gICAgY29uc3QgcmVuZGVyQ29udGV4dCA9IHtcbiAgICAgIGNhbnZhc0NvbnRleHQ6IGNvbnRleHQsXG4gICAgICB2aWV3cG9ydDogdmlld3BvcnRcbiAgICB9IGFzIGFueTtcbiAgICBcbiAgICBhd2FpdCBwYWdlLnJlbmRlcihyZW5kZXJDb250ZXh0KS5wcm9taXNlO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBkYXRhVVJMOiBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnLCAwLjk1KSxcbiAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsXG4gICAgICBwYWdlTnVtYmVyXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHJlbmRlciBwYWdlICR7cGFnZU51bWJlcn06ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgfVxufVxuXG4vLyBDcmVhdGUgcGFzc3dvcmQgcHJvbXB0IGRpYWxvZ1xuZnVuY3Rpb24gY3JlYXRlUGFzc3dvcmREaWFsb2coaXNSZXRyeTogYm9vbGVhbiA9IGZhbHNlKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IG92ZXJsYXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBvdmVybGF5LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICB0b3A6IDA7XG4gICAgICBsZWZ0OiAwO1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuNSk7XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgei1pbmRleDogMTAwMDA7XG4gICAgYDtcblxuICAgIGNvbnN0IGRpYWxvZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRpYWxvZy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgYmFja2dyb3VuZDogd2hpdGU7XG4gICAgICBwYWRkaW5nOiAyNHB4O1xuICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgYm94LXNoYWRvdzogMCA0cHggMjBweCByZ2JhKDAsIDAsIDAsIDAuMTUpO1xuICAgICAgbWluLXdpZHRoOiA0MDBweDtcbiAgICBgO1xuXG4gICAgY29uc3QgdGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMycpO1xuICAgIHRpdGxlLnRleHRDb250ZW50ID0gaXNSZXRyeSA/ICdJbmNvcnJlY3QgUGFzc3dvcmQnIDogJ1Bhc3N3b3JkIFJlcXVpcmVkJztcbiAgICB0aXRsZS5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgbWFyZ2luOiAwIDAgMTZweCAwO1xuICAgICAgZm9udC1zaXplOiAxOHB4O1xuICAgICAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgICAgIGNvbG9yOiAke2lzUmV0cnkgPyAnI2RjMjYyNicgOiAnIzFmMjkzNyd9O1xuICAgIGA7XG5cbiAgICBjb25zdCBtZXNzYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICAgIG1lc3NhZ2UudGV4dENvbnRlbnQgPSBpc1JldHJ5IFxuICAgICAgPyAnVGhlIHBhc3N3b3JkIHlvdSBlbnRlcmVkIGlzIGluY29ycmVjdC4gUGxlYXNlIHRyeSBhZ2Fpbi4nXG4gICAgICA6ICdUaGlzIFBERiBpcyBwYXNzd29yZCBwcm90ZWN0ZWQuIFBsZWFzZSBlbnRlciB0aGUgcGFzc3dvcmQgdG8gY29udGludWUuJztcbiAgICBtZXNzYWdlLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBtYXJnaW46IDAgMCAxNnB4IDA7XG4gICAgICBjb2xvcjogIzZiNzI4MDtcbiAgICBgO1xuXG4gICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIGlucHV0LnR5cGUgPSAncGFzc3dvcmQnO1xuICAgIGlucHV0LnBsYWNlaG9sZGVyID0gJ0VudGVyIHBhc3N3b3JkJztcbiAgICBpbnB1dC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICBwYWRkaW5nOiAxMnB4O1xuICAgICAgYm9yZGVyOiAxcHggc29saWQgI2QxZDVkYjtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDZweDtcbiAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XG4gICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIGA7XG5cbiAgICBjb25zdCBidXR0b25Db250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBidXR0b25Db250YWluZXIuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBnYXA6IDEycHg7XG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xuICAgIGA7XG5cbiAgICBjb25zdCBjYW5jZWxCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICBjYW5jZWxCdXR0b24udGV4dENvbnRlbnQgPSAnQ2FuY2VsJztcbiAgICBjYW5jZWxCdXR0b24uc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIHBhZGRpbmc6IDEwcHggMjBweDtcbiAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNkMWQ1ZGI7XG4gICAgICBib3JkZXItcmFkaXVzOiA2cHg7XG4gICAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbiAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgIGZvbnQtd2VpZ2h0OiA1MDA7XG4gICAgYDtcblxuICAgIGNvbnN0IHN1Ym1pdEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIHN1Ym1pdEJ1dHRvbi50ZXh0Q29udGVudCA9ICdPcGVuIFBERic7XG4gICAgc3VibWl0QnV0dG9uLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBwYWRkaW5nOiAxMHB4IDIwcHg7XG4gICAgICBib3JkZXI6IG5vbmU7XG4gICAgICBib3JkZXItcmFkaXVzOiA2cHg7XG4gICAgICBiYWNrZ3JvdW5kOiAjM2I4MmY2O1xuICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgICBgO1xuXG4gICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgIGlmIChkb2N1bWVudC5ib2R5LmNvbnRhaW5zKG92ZXJsYXkpKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQob3ZlcmxheSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGhhbmRsZVN1Ym1pdCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHBhc3N3b3JkID0gaW5wdXQudmFsdWUudHJpbSgpO1xuICAgICAgaWYgKHBhc3N3b3JkKSB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgcmVzb2x2ZShwYXNzd29yZCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGhhbmRsZUNhbmNlbCA9ICgpID0+IHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgfTtcblxuICAgIGNhbmNlbEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZUNhbmNlbCk7XG4gICAgc3VibWl0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlU3VibWl0KTtcbiAgICBcbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGUpID0+IHtcbiAgICAgIGlmIChlLmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgICBoYW5kbGVTdWJtaXQoKTtcbiAgICAgIH0gZWxzZSBpZiAoZS5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgIGhhbmRsZUNhbmNlbCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2xvc2Ugb24gb3V0c2lkZSBjbGlja1xuICAgIG92ZXJsYXkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgaWYgKGUudGFyZ2V0ID09PSBvdmVybGF5KSB7XG4gICAgICAgIGhhbmRsZUNhbmNlbCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYnV0dG9uQ29udGFpbmVyLmFwcGVuZENoaWxkKGNhbmNlbEJ1dHRvbik7XG4gICAgYnV0dG9uQ29udGFpbmVyLmFwcGVuZENoaWxkKHN1Ym1pdEJ1dHRvbik7XG4gICAgZGlhbG9nLmFwcGVuZENoaWxkKHRpdGxlKTtcbiAgICBkaWFsb2cuYXBwZW5kQ2hpbGQobWVzc2FnZSk7XG4gICAgZGlhbG9nLmFwcGVuZENoaWxkKGlucHV0KTtcbiAgICBkaWFsb2cuYXBwZW5kQ2hpbGQoYnV0dG9uQ29udGFpbmVyKTtcbiAgICBvdmVybGF5LmFwcGVuZENoaWxkKGRpYWxvZyk7XG5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG92ZXJsYXkpO1xuICAgIGlucHV0LmZvY3VzKCk7XG4gIH0pO1xufVxuXG4vLyBNYWluIFBERiBwcm9jZXNzaW5nIGZ1bmN0aW9uIHdpdGggYWxsIGVycm9yIGhhbmRsaW5nXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1BERkZpbGUoXG4gIGZpbGU6IEZpbGUsIFxuICBvblN1Y2Nlc3M6IChwZGY6IGFueSkgPT4gdm9pZCxcbiAgb25FcnJvcjogKGVycm9yOiBQREZMb2FkRXJyb3IpID0+IHZvaWRcbik6IFByb21pc2U8dm9pZD4ge1xuICB0cnkge1xuICAgIC8vIEZpcnN0IHRyeSB3aXRob3V0IHBhc3N3b3JkXG4gICAgY29uc3QgcGRmID0gYXdhaXQgbG9hZFBkZkZyb21GaWxlKGZpbGUpO1xuICAgIG9uU3VjY2VzcyhwZGYpO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgaWYgKGVycm9yLnR5cGUgPT09ICdwYXNzd29yZC1yZXF1aXJlZCcpIHtcbiAgICAgIC8vIFRyeSB3aXRoIHBhc3N3b3JkIHByb21wdFxuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGF0dGVtcHRzID0gMDtcbiAgICAgICAgY29uc3QgZ2V0UGFzc3dvcmQgPSBhc3luYyAoKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiA9PiB7XG4gICAgICAgICAgYXR0ZW1wdHMrKztcbiAgICAgICAgICBjb25zdCBpc1JldHJ5ID0gYXR0ZW1wdHMgPiAxO1xuICAgICAgICAgIHJldHVybiBhd2FpdCBjcmVhdGVQYXNzd29yZERpYWxvZyhpc1JldHJ5KTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHBkZiA9IGF3YWl0IGxvYWRQZGZXaXRoUGFzc3dvcmQoZmlsZSwgZ2V0UGFzc3dvcmQpO1xuICAgICAgICBvblN1Y2Nlc3MocGRmKTtcbiAgICAgIH0gY2F0Y2ggKHBhc3N3b3JkRXJyb3I6IGFueSkge1xuICAgICAgICBvbkVycm9yKHBhc3N3b3JkRXJyb3IgYXMgUERGTG9hZEVycm9yKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb25FcnJvcihlcnJvciBhcyBQREZMb2FkRXJyb3IpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZm9ybWF0IGVycm9yIG1lc3NhZ2VzIGZvciB1c2VyIGRpc3BsYXlcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRQREZFcnJvcihlcnJvcjogUERGTG9hZEVycm9yKTogc3RyaW5nIHtcbiAgc3dpdGNoIChlcnJvci50eXBlKSB7XG4gICAgY2FzZSAnbWlzc2luZy13b3JrZXInOlxuICAgICAgcmV0dXJuICfinYwgUERGIHdvcmtlciBtaXNzaW5nIChkZXYpOiBydW4gcG5wbSAtQyB3ZWIgcG9zdGluc3RhbGwgJiByZXN0YXJ0IGRldi4nO1xuICAgIGNhc2UgJ3Bhc3N3b3JkLXJlcXVpcmVkJzpcbiAgICAgIHJldHVybiAn8J+UkiBUaGlzIFBERiByZXF1aXJlcyBhIHBhc3N3b3JkIHRvIG9wZW4uJztcbiAgICBjYXNlICd3cm9uZy1wYXNzd29yZCc6XG4gICAgICByZXR1cm4gJ+KdjCBJbmNvcnJlY3QgcGFzc3dvcmQuIFBsZWFzZSB0cnkgYWdhaW4uJztcbiAgICBjYXNlICdjb3JydXB0ZWQnOlxuICAgICAgcmV0dXJuICfinYwgVGhpcyBQREYgZmlsZSBhcHBlYXJzIHRvIGJlIGNvcnJ1cHRlZCBvciBpbnZhbGlkLic7XG4gICAgY2FzZSAnY29ycy1ibG9ja2VkJzpcbiAgICAgIHJldHVybiAn4p2MIENhbm5vdCBhY2Nlc3MgdGhpcyBQREYgZHVlIHRvIHNlY3VyaXR5IHJlc3RyaWN0aW9ucy4gVHJ5IHVwbG9hZGluZyB0aGUgZmlsZSBkaXJlY3RseS4nO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYOKdjCBGYWlsZWQgdG8gcHJvY2VzcyBQREY6ICR7ZXJyb3IubWVzc2FnZX1gO1xuICB9XG59XG4iXSwibmFtZXMiOlsicGRmanNMaWIiLCJsb2FkUERGSlMiLCJHbG9iYWxXb3JrZXJPcHRpb25zIiwid29ya2VyU3JjIiwiZXJyb3IiLCJjb25zb2xlIiwibG9hZFBkZkZyb21GaWxlIiwiZmlsZSIsInBkZmpzIiwiRXJyb3IiLCJ0eXBlIiwibWVzc2FnZSIsImJ1ZmZlciIsIlVpbnQ4QXJyYXkiLCJhcnJheUJ1ZmZlciIsInBkZiIsImdldERvY3VtZW50IiwiZGF0YSIsInByb21pc2UiLCJwZGZFcnJvciIsIm5hbWUiLCJpbmNsdWRlcyIsIm9yaWdpbmFsRXJyb3IiLCJsb2FkUGRmV2l0aFBhc3N3b3JkIiwiZ2V0UGFzc3dvcmQiLCJsb2FkaW5nVGFzayIsIm9uUGFzc3dvcmQiLCJ1cGRhdGVQYXNzd29yZCIsInJlYXNvbiIsImlzUmV0cnkiLCJwYXNzd29yZCIsInJlbmRlclBkZlBhZ2VUb0RhdGFVUkwiLCJwYWdlTnVtYmVyIiwic2NhbGUiLCJwYWdlIiwiZ2V0UGFnZSIsInZpZXdwb3J0IiwiZ2V0Vmlld3BvcnQiLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjb250ZXh0IiwiZ2V0Q29udGV4dCIsIndpZHRoIiwiTWF0aCIsImZsb29yIiwiaGVpZ2h0IiwicmVuZGVyQ29udGV4dCIsImNhbnZhc0NvbnRleHQiLCJyZW5kZXIiLCJkYXRhVVJMIiwidG9EYXRhVVJMIiwiY3JlYXRlUGFzc3dvcmREaWFsb2ciLCJQcm9taXNlIiwicmVzb2x2ZSIsIm92ZXJsYXkiLCJzdHlsZSIsImNzc1RleHQiLCJkaWFsb2ciLCJ0aXRsZSIsInRleHRDb250ZW50IiwiaW5wdXQiLCJwbGFjZWhvbGRlciIsImJ1dHRvbkNvbnRhaW5lciIsImNhbmNlbEJ1dHRvbiIsInN1Ym1pdEJ1dHRvbiIsImNsZWFudXAiLCJib2R5IiwiY29udGFpbnMiLCJyZW1vdmVDaGlsZCIsImhhbmRsZVN1Ym1pdCIsInZhbHVlIiwidHJpbSIsImhhbmRsZUNhbmNlbCIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwia2V5IiwidGFyZ2V0IiwiYXBwZW5kQ2hpbGQiLCJmb2N1cyIsInByb2Nlc3NQREZGaWxlIiwib25TdWNjZXNzIiwib25FcnJvciIsImF0dGVtcHRzIiwicGFzc3dvcmRFcnJvciIsImZvcm1hdFBERkVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/pdf.ts\n"));

/***/ })

}]);