"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fabric@5.5.2";
exports.ids = ["vendor-chunks/fabric@5.5.2"];
exports.modules = {

/***/ "(ssr)/../node_modules/.pnpm/fabric@5.5.2/node_modules/fabric/dist/fabric.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/.pnpm/fabric@5.5.2/node_modules/fabric/dist/fabric.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* build: `node build.js modules=ALL exclude=gestures,accessors,erasing requirejs minifier=uglifyjs` */ /*! Fabric.js Copyright 2008-2015, Printio (Juriy Zaytsev, Maxim Chernyak) */ \nvar fabric = fabric || {\n    version: \"5.5.2\"\n};\nif (true) {\n    exports.fabric = fabric;\n} else {}\n/* _AMD_END_ */ if (typeof document !== \"undefined\" && \"undefined\" !== \"undefined\") {} else {\n    // assume we're running under node.js when document/window are not present\n    var jsdom = __webpack_require__(/*! jsdom */ \"jsdom\");\n    var virtualWindow = new jsdom.JSDOM(decodeURIComponent(\"%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E\"), {\n        features: {\n            FetchExternalResources: [\n                \"img\"\n            ]\n        },\n        resources: \"usable\"\n    }).window;\n    fabric.document = virtualWindow.document;\n    fabric.jsdomImplForWrapper = (__webpack_require__(/*! jsdom/lib/jsdom/living/generated/utils */ \"(ssr)/../node_modules/.pnpm/jsdom@19.0.0_canvas@2.11.2/node_modules/jsdom/lib/jsdom/living/generated/utils.js\").implForWrapper);\n    fabric.nodeCanvas = (__webpack_require__(/*! jsdom/lib/jsdom/utils */ \"(ssr)/../node_modules/.pnpm/jsdom@19.0.0_canvas@2.11.2/node_modules/jsdom/lib/jsdom/utils.js\").Canvas);\n    fabric.window = virtualWindow;\n    DOMParser = fabric.window.DOMParser;\n}\n/**\n * True when in environment that supports touch events\n * @type boolean\n */ fabric.isTouchSupported = \"ontouchstart\" in fabric.window || \"ontouchstart\" in fabric.document || fabric.window && fabric.window.navigator && fabric.window.navigator.maxTouchPoints > 0;\n/**\n * True when in environment that's probably Node.js\n * @type boolean\n */ fabric.isLikelyNode = typeof Buffer !== \"undefined\" && \"undefined\" === \"undefined\";\n/* _FROM_SVG_START_ */ /**\n * Attributes parsed from all SVG elements\n * @type array\n */ fabric.SHARED_ATTRIBUTES = [\n    \"display\",\n    \"transform\",\n    \"fill\",\n    \"fill-opacity\",\n    \"fill-rule\",\n    \"opacity\",\n    \"stroke\",\n    \"stroke-dasharray\",\n    \"stroke-linecap\",\n    \"stroke-dashoffset\",\n    \"stroke-linejoin\",\n    \"stroke-miterlimit\",\n    \"stroke-opacity\",\n    \"stroke-width\",\n    \"id\",\n    \"paint-order\",\n    \"vector-effect\",\n    \"instantiated_by_use\",\n    \"clip-path\"\n];\n/* _FROM_SVG_END_ */ /**\n * Pixel per Inch as a default value set to 96. Can be changed for more realistic conversion.\n */ fabric.DPI = 96;\nfabric.reNum = \"(?:[-+]?(?:\\\\d+|\\\\d*\\\\.\\\\d+)(?:[eE][-+]?\\\\d+)?)\";\nfabric.commaWsp = \"(?:\\\\s+,?\\\\s*|,\\\\s*)\";\nfabric.rePathCommand = /([-+]?((\\d+\\.\\d+)|((\\d+)|(\\.\\d+)))(?:[eE][-+]?\\d+)?)/ig;\nfabric.reNonWord = /[ \\n\\.,;!\\?\\-]/;\nfabric.fontPaths = {};\nfabric.iMatrix = [\n    1,\n    0,\n    0,\n    1,\n    0,\n    0\n];\nfabric.svgNS = \"http://www.w3.org/2000/svg\";\n/**\n * Pixel limit for cache canvases. 1Mpx , 4Mpx should be fine.\n * @since 1.7.14\n * @type Number\n * @default\n */ fabric.perfLimitSizeTotal = 2097152;\n/**\n * Pixel limit for cache canvases width or height. IE fixes the maximum at 5000\n * @since 1.7.14\n * @type Number\n * @default\n */ fabric.maxCacheSideLimit = 4096;\n/**\n * Lowest pixel limit for cache canvases, set at 256PX\n * @since 1.7.14\n * @type Number\n * @default\n */ fabric.minCacheSideLimit = 256;\n/**\n * Cache Object for widths of chars in text rendering.\n */ fabric.charWidthsCache = {};\n/**\n * if webgl is enabled and available, textureSize will determine the size\n * of the canvas backend\n * @since 2.0.0\n * @type Number\n * @default\n */ fabric.textureSize = 2048;\n/**\n * When 'true', style information is not retained when copy/pasting text, making\n * pasted text use destination style.\n * Defaults to 'false'.\n * @type Boolean\n * @default\n */ fabric.disableStyleCopyPaste = false;\n/**\n * Enable webgl for filtering picture is available\n * A filtering backend will be initialized, this will both take memory and\n * time since a default 2048x2048 canvas will be created for the gl context\n * @since 2.0.0\n * @type Boolean\n * @default\n */ fabric.enableGLFiltering = true;\n/**\n * Device Pixel Ratio\n * @see https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/SettingUptheCanvas/SettingUptheCanvas.html\n */ fabric.devicePixelRatio = fabric.window.devicePixelRatio || fabric.window.webkitDevicePixelRatio || fabric.window.mozDevicePixelRatio || 1;\n/**\n * Browser-specific constant to adjust CanvasRenderingContext2D.shadowBlur value,\n * which is unitless and not rendered equally across browsers.\n *\n * Values that work quite well (as of October 2017) are:\n * - Chrome: 1.5\n * - Edge: 1.75\n * - Firefox: 0.9\n * - Safari: 0.95\n *\n * @since 2.0.0\n * @type Number\n * @default 1\n */ fabric.browserShadowBlurConstant = 1;\n/**\n * This object contains the result of arc to bezier conversion for faster retrieving if the same arc needs to be converted again.\n * It was an internal variable, is accessible since version 2.3.4\n */ fabric.arcToSegmentsCache = {};\n/**\n * This object keeps the results of the boundsOfCurve calculation mapped by the joined arguments necessary to calculate it.\n * It does speed up calculation, if you parse and add always the same paths, but in case of heavy usage of freedrawing\n * you do not get any speed benefit and you get a big object in memory.\n * The object was a private variable before, while now is appended to the lib so that you have access to it and you\n * can eventually clear it.\n * It was an internal variable, is accessible since version 2.3.4\n */ fabric.boundsOfCurveCache = {};\n/**\n * If disabled boundsOfCurveCache is not used. For apps that make heavy usage of pencil drawing probably disabling it is better\n * @default true\n */ fabric.cachesBoundsOfCurve = true;\n/**\n * Skip performance testing of setupGLContext and force the use of putImageData that seems to be the one that works best on\n * Chrome + old hardware. if your users are experiencing empty images after filtering you may try to force this to true\n * this has to be set before instantiating the filtering backend ( before filtering the first image )\n * @type Boolean\n * @default false\n */ fabric.forceGLPutImageData = false;\nfabric.initFilterBackend = function() {\n    if (fabric.enableGLFiltering && fabric.isWebglSupported && fabric.isWebglSupported(fabric.textureSize)) {\n        console.log(\"max texture size: \" + fabric.maxTextureSize);\n        return new fabric.WebglFilterBackend({\n            tileSize: fabric.textureSize\n        });\n    } else if (fabric.Canvas2dFilterBackend) {\n        return new fabric.Canvas2dFilterBackend();\n    }\n};\nif (typeof document !== \"undefined\" && \"undefined\" !== \"undefined\") {}\n(function() {\n    /**\n   * @private\n   * @param {String} eventName\n   * @param {Function} handler\n   */ function _removeEventListener(eventName, handler) {\n        if (!this.__eventListeners[eventName]) {\n            return;\n        }\n        var eventListener = this.__eventListeners[eventName];\n        if (handler) {\n            eventListener[eventListener.indexOf(handler)] = false;\n        } else {\n            fabric.util.array.fill(eventListener, false);\n        }\n    }\n    /**\n   * Observes specified event\n   * @memberOf fabric.Observable\n   * @alias on\n   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})\n   * @param {Function} handler Function that receives a notification when an event of the specified type occurs\n   * @return {Self} thisArg\n   * @chainable\n   */ function on(eventName, handler) {\n        if (!this.__eventListeners) {\n            this.__eventListeners = {};\n        }\n        // one object with key/value pairs was passed\n        if (arguments.length === 1) {\n            for(var prop in eventName){\n                this.on(prop, eventName[prop]);\n            }\n        } else {\n            if (!this.__eventListeners[eventName]) {\n                this.__eventListeners[eventName] = [];\n            }\n            this.__eventListeners[eventName].push(handler);\n        }\n        return this;\n    }\n    function _once(eventName, handler) {\n        var _handler = (function() {\n            handler.apply(this, arguments);\n            this.off(eventName, _handler);\n        }).bind(this);\n        this.on(eventName, _handler);\n    }\n    function once(eventName, handler) {\n        // one object with key/value pairs was passed\n        if (arguments.length === 1) {\n            for(var prop in eventName){\n                _once.call(this, prop, eventName[prop]);\n            }\n        } else {\n            _once.call(this, eventName, handler);\n        }\n        return this;\n    }\n    /**\n   * Stops event observing for a particular event handler. Calling this method\n   * without arguments removes all handlers for all events\n   * @memberOf fabric.Observable\n   * @alias off\n   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})\n   * @param {Function} handler Function to be deleted from EventListeners\n   * @return {Self} thisArg\n   * @chainable\n   */ function off(eventName, handler) {\n        if (!this.__eventListeners) {\n            return this;\n        }\n        // remove all key/value pairs (event name -> event handler)\n        if (arguments.length === 0) {\n            for(eventName in this.__eventListeners){\n                _removeEventListener.call(this, eventName);\n            }\n        } else if (arguments.length === 1 && typeof arguments[0] === \"object\") {\n            for(var prop in eventName){\n                _removeEventListener.call(this, prop, eventName[prop]);\n            }\n        } else {\n            _removeEventListener.call(this, eventName, handler);\n        }\n        return this;\n    }\n    /**\n   * Fires event with an optional options object\n   * @memberOf fabric.Observable\n   * @param {String} eventName Event name to fire\n   * @param {Object} [options] Options object\n   * @return {Self} thisArg\n   * @chainable\n   */ function fire(eventName, options) {\n        if (!this.__eventListeners) {\n            return this;\n        }\n        var listenersForEvent = this.__eventListeners[eventName];\n        if (!listenersForEvent) {\n            return this;\n        }\n        for(var i = 0, len = listenersForEvent.length; i < len; i++){\n            listenersForEvent[i] && listenersForEvent[i].call(this, options || {});\n        }\n        this.__eventListeners[eventName] = listenersForEvent.filter(function(value) {\n            return value !== false;\n        });\n        return this;\n    }\n    /**\n   * @namespace fabric.Observable\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#events}\n   * @see {@link http://fabricjs.com/events|Events demo}\n   */ fabric.Observable = {\n        fire: fire,\n        on: on,\n        once: once,\n        off: off\n    };\n})();\n/**\n * @namespace fabric.Collection\n */ fabric.Collection = {\n    _objects: [],\n    /**\n   * Adds objects to collection, Canvas or Group, then renders canvas\n   * (if `renderOnAddRemove` is not `false`).\n   * in case of Group no changes to bounding box are made.\n   * Objects should be instances of (or inherit from) fabric.Object\n   * Use of this function is highly discouraged for groups.\n   * you can add a bunch of objects with the add method but then you NEED\n   * to run a addWithUpdate call for the Group class or position/bbox will be wrong.\n   * @param {...fabric.Object} object Zero or more fabric instances\n   * @return {Self} thisArg\n   * @chainable\n   */ add: function() {\n        this._objects.push.apply(this._objects, arguments);\n        if (this._onObjectAdded) {\n            for(var i = 0, length = arguments.length; i < length; i++){\n                this._onObjectAdded(arguments[i]);\n            }\n        }\n        this.renderOnAddRemove && this.requestRenderAll();\n        return this;\n    },\n    /**\n   * Inserts an object into collection at specified index, then renders canvas (if `renderOnAddRemove` is not `false`)\n   * An object should be an instance of (or inherit from) fabric.Object\n   * Use of this function is highly discouraged for groups.\n   * you can add a bunch of objects with the insertAt method but then you NEED\n   * to run a addWithUpdate call for the Group class or position/bbox will be wrong.\n   * @param {Object} object Object to insert\n   * @param {Number} index Index to insert object at\n   * @param {Boolean} nonSplicing When `true`, no splicing (shifting) of objects occurs\n   * @return {Self} thisArg\n   * @chainable\n   */ insertAt: function(object, index, nonSplicing) {\n        var objects = this._objects;\n        if (nonSplicing) {\n            objects[index] = object;\n        } else {\n            objects.splice(index, 0, object);\n        }\n        this._onObjectAdded && this._onObjectAdded(object);\n        this.renderOnAddRemove && this.requestRenderAll();\n        return this;\n    },\n    /**\n   * Removes objects from a collection, then renders canvas (if `renderOnAddRemove` is not `false`)\n   * @param {...fabric.Object} object Zero or more fabric instances\n   * @return {Self} thisArg\n   * @chainable\n   */ remove: function() {\n        var objects = this._objects, index, somethingRemoved = false;\n        for(var i = 0, length = arguments.length; i < length; i++){\n            index = objects.indexOf(arguments[i]);\n            // only call onObjectRemoved if an object was actually removed\n            if (index !== -1) {\n                somethingRemoved = true;\n                objects.splice(index, 1);\n                this._onObjectRemoved && this._onObjectRemoved(arguments[i]);\n            }\n        }\n        this.renderOnAddRemove && somethingRemoved && this.requestRenderAll();\n        return this;\n    },\n    /**\n   * Executes given function for each object in this group\n   * @param {Function} callback\n   *                   Callback invoked with current object as first argument,\n   *                   index - as second and an array of all objects - as third.\n   *                   Callback is invoked in a context of Global Object (e.g. `window`)\n   *                   when no `context` argument is given\n   *\n   * @param {Object} context Context (aka thisObject)\n   * @return {Self} thisArg\n   * @chainable\n   */ forEachObject: function(callback, context) {\n        var objects = this.getObjects();\n        for(var i = 0, len = objects.length; i < len; i++){\n            callback.call(context, objects[i], i, objects);\n        }\n        return this;\n    },\n    /**\n   * Returns an array of children objects of this instance\n   * Type parameter introduced in 1.3.10\n   * since 2.3.5 this method return always a COPY of the array;\n   * @param {String} [type] When specified, only objects of this type are returned\n   * @return {Array}\n   */ getObjects: function(type) {\n        if (typeof type === \"undefined\") {\n            return this._objects.concat();\n        }\n        return this._objects.filter(function(o) {\n            return o.type === type;\n        });\n    },\n    /**\n   * Returns object at specified index\n   * @param {Number} index\n   * @return {Self} thisArg\n   */ item: function(index) {\n        return this._objects[index];\n    },\n    /**\n   * Returns true if collection contains no objects\n   * @return {Boolean} true if collection is empty\n   */ isEmpty: function() {\n        return this._objects.length === 0;\n    },\n    /**\n   * Returns a size of a collection (i.e: length of an array containing its objects)\n   * @return {Number} Collection size\n   */ size: function() {\n        return this._objects.length;\n    },\n    /**\n   * Returns true if collection contains an object\n   * @param {Object} object Object to check against\n   * @param {Boolean} [deep=false] `true` to check all descendants, `false` to check only `_objects`\n   * @return {Boolean} `true` if collection contains an object\n   */ contains: function(object, deep) {\n        if (this._objects.indexOf(object) > -1) {\n            return true;\n        } else if (deep) {\n            return this._objects.some(function(obj) {\n                return typeof obj.contains === \"function\" && obj.contains(object, true);\n            });\n        }\n        return false;\n    },\n    /**\n   * Returns number representation of a collection complexity\n   * @return {Number} complexity\n   */ complexity: function() {\n        return this._objects.reduce(function(memo, current) {\n            memo += current.complexity ? current.complexity() : 0;\n            return memo;\n        }, 0);\n    }\n};\n/**\n * @namespace fabric.CommonMethods\n */ fabric.CommonMethods = {\n    /**\n   * Sets object's properties from options\n   * @param {Object} [options] Options object\n   */ _setOptions: function(options) {\n        for(var prop in options){\n            this.set(prop, options[prop]);\n        }\n    },\n    /**\n   * @private\n   * @param {Object} [filler] Options object\n   * @param {String} [property] property to set the Gradient to\n   */ _initGradient: function(filler, property) {\n        if (filler && filler.colorStops && !(filler instanceof fabric.Gradient)) {\n            this.set(property, new fabric.Gradient(filler));\n        }\n    },\n    /**\n   * @private\n   * @param {Object} [filler] Options object\n   * @param {String} [property] property to set the Pattern to\n   * @param {Function} [callback] callback to invoke after pattern load\n   */ _initPattern: function(filler, property, callback) {\n        if (filler && filler.source && !(filler instanceof fabric.Pattern)) {\n            this.set(property, new fabric.Pattern(filler, callback));\n        } else {\n            callback && callback();\n        }\n    },\n    /**\n   * @private\n   */ _setObject: function(obj) {\n        for(var prop in obj){\n            this._set(prop, obj[prop]);\n        }\n    },\n    /**\n   * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.\n   * @param {String|Object} key Property name or object (if object, iterate over the object properties)\n   * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ set: function(key, value) {\n        if (typeof key === \"object\") {\n            this._setObject(key);\n        } else {\n            this._set(key, value);\n        }\n        return this;\n    },\n    _set: function(key, value) {\n        this[key] = value;\n    },\n    /**\n   * Toggles specified property from `true` to `false` or from `false` to `true`\n   * @param {String} property Property to toggle\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ toggle: function(property) {\n        var value = this.get(property);\n        if (typeof value === \"boolean\") {\n            this.set(property, !value);\n        }\n        return this;\n    },\n    /**\n   * Basic getter\n   * @param {String} property Property name\n   * @return {*} value of a property\n   */ get: function(property) {\n        return this[property];\n    }\n};\n(function(global) {\n    var sqrt = Math.sqrt, atan2 = Math.atan2, pow = Math.pow, PiBy180 = Math.PI / 180, PiBy2 = Math.PI / 2;\n    /**\n   * @namespace fabric.util\n   */ fabric.util = {\n        /**\n     * Calculate the cos of an angle, avoiding returning floats for known results\n     * @static\n     * @memberOf fabric.util\n     * @param {Number} angle the angle in radians or in degree\n     * @return {Number}\n     */ cos: function(angle) {\n            if (angle === 0) {\n                return 1;\n            }\n            if (angle < 0) {\n                // cos(a) = cos(-a)\n                angle = -angle;\n            }\n            var angleSlice = angle / PiBy2;\n            switch(angleSlice){\n                case 1:\n                case 3:\n                    return 0;\n                case 2:\n                    return -1;\n            }\n            return Math.cos(angle);\n        },\n        /**\n     * Calculate the sin of an angle, avoiding returning floats for known results\n     * @static\n     * @memberOf fabric.util\n     * @param {Number} angle the angle in radians or in degree\n     * @return {Number}\n     */ sin: function(angle) {\n            if (angle === 0) {\n                return 0;\n            }\n            var angleSlice = angle / PiBy2, sign = 1;\n            if (angle < 0) {\n                // sin(-a) = -sin(a)\n                sign = -1;\n            }\n            switch(angleSlice){\n                case 1:\n                    return sign;\n                case 2:\n                    return 0;\n                case 3:\n                    return -sign;\n            }\n            return Math.sin(angle);\n        },\n        /**\n     * Removes value from an array.\n     * Presence of value (and its position in an array) is determined via `Array.prototype.indexOf`\n     * @static\n     * @memberOf fabric.util\n     * @param {Array} array\n     * @param {*} value\n     * @return {Array} original array\n     */ removeFromArray: function(array, value) {\n            var idx = array.indexOf(value);\n            if (idx !== -1) {\n                array.splice(idx, 1);\n            }\n            return array;\n        },\n        /**\n     * Returns random number between 2 specified ones.\n     * @static\n     * @memberOf fabric.util\n     * @param {Number} min lower limit\n     * @param {Number} max upper limit\n     * @return {Number} random value (between min and max)\n     */ getRandomInt: function(min, max) {\n            return Math.floor(Math.random() * (max - min + 1)) + min;\n        },\n        /**\n     * Transforms degrees to radians.\n     * @static\n     * @memberOf fabric.util\n     * @param {Number} degrees value in degrees\n     * @return {Number} value in radians\n     */ degreesToRadians: function(degrees) {\n            return degrees * PiBy180;\n        },\n        /**\n     * Transforms radians to degrees.\n     * @static\n     * @memberOf fabric.util\n     * @param {Number} radians value in radians\n     * @return {Number} value in degrees\n     */ radiansToDegrees: function(radians) {\n            return radians / PiBy180;\n        },\n        /**\n     * Rotates `point` around `origin` with `radians`\n     * @static\n     * @memberOf fabric.util\n     * @param {fabric.Point} point The point to rotate\n     * @param {fabric.Point} origin The origin of the rotation\n     * @param {Number} radians The radians of the angle for the rotation\n     * @return {fabric.Point} The new rotated point\n     */ rotatePoint: function(point, origin, radians) {\n            var newPoint = new fabric.Point(point.x - origin.x, point.y - origin.y), v = fabric.util.rotateVector(newPoint, radians);\n            return new fabric.Point(v.x, v.y).addEquals(origin);\n        },\n        /**\n     * Rotates `vector` with `radians`\n     * @static\n     * @memberOf fabric.util\n     * @param {Object} vector The vector to rotate (x and y)\n     * @param {Number} radians The radians of the angle for the rotation\n     * @return {Object} The new rotated point\n     */ rotateVector: function(vector, radians) {\n            var sin = fabric.util.sin(radians), cos = fabric.util.cos(radians), rx = vector.x * cos - vector.y * sin, ry = vector.x * sin + vector.y * cos;\n            return {\n                x: rx,\n                y: ry\n            };\n        },\n        /**\n     * Creates a vetor from points represented as a point\n     * @static\n     * @memberOf fabric.util\n     *\n     * @typedef {Object} Point\n     * @property {number} x\n     * @property {number} y\n     *\n     * @param {Point} from\n     * @param {Point} to\n     * @returns {Point} vector\n     */ createVector: function(from, to) {\n            return new fabric.Point(to.x - from.x, to.y - from.y);\n        },\n        /**\n     * Calculates angle between 2 vectors using dot product\n     * @static\n     * @memberOf fabric.util\n     * @param {Point} a\n     * @param {Point} b\n     * @returns the angle in radian between the vectors\n     */ calcAngleBetweenVectors: function(a, b) {\n            return Math.acos((a.x * b.x + a.y * b.y) / (Math.hypot(a.x, a.y) * Math.hypot(b.x, b.y)));\n        },\n        /**\n     * @static\n     * @memberOf fabric.util\n     * @param {Point} v\n     * @returns {Point} vector representing the unit vector of pointing to the direction of `v`\n     */ getHatVector: function(v) {\n            return new fabric.Point(v.x, v.y).multiply(1 / Math.hypot(v.x, v.y));\n        },\n        /**\n     * @static\n     * @memberOf fabric.util\n     * @param {Point} A\n     * @param {Point} B\n     * @param {Point} C\n     * @returns {{ vector: Point, angle: number }} vector representing the bisector of A and A's angle\n     */ getBisector: function(A, B, C) {\n            var AB = fabric.util.createVector(A, B), AC = fabric.util.createVector(A, C);\n            var alpha = fabric.util.calcAngleBetweenVectors(AB, AC);\n            //  check if alpha is relative to AB->BC\n            var ro = fabric.util.calcAngleBetweenVectors(fabric.util.rotateVector(AB, alpha), AC);\n            var phi = alpha * (ro === 0 ? 1 : -1) / 2;\n            return {\n                vector: fabric.util.getHatVector(fabric.util.rotateVector(AB, phi)),\n                angle: alpha\n            };\n        },\n        /**\n     * Project stroke width on points returning 2 projections for each point as follows:\n     * - `miter`: 2 points corresponding to the outer boundary and the inner boundary of stroke.\n     * - `bevel`: 2 points corresponding to the bevel boundaries, tangent to the bisector.\n     * - `round`: same as `bevel`\n     * Used to calculate object's bounding box\n     * @static\n     * @memberOf fabric.util\n     * @param {Point[]} points\n     * @param {Object} options\n     * @param {number} options.strokeWidth\n     * @param {'miter'|'bevel'|'round'} options.strokeLineJoin\n     * @param {number} options.strokeMiterLimit https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-miterlimit\n     * @param {boolean} options.strokeUniform\n     * @param {number} options.scaleX\n     * @param {number} options.scaleY\n     * @param {boolean} [openPath] whether the shape is open or not, affects the calculations of the first and last points\n     * @returns {fabric.Point[]} array of size 2n/4n of all suspected points\n     */ projectStrokeOnPoints: function(points, options, openPath) {\n            var coords = [], s = options.strokeWidth / 2, strokeUniformScalar = options.strokeUniform ? new fabric.Point(1 / options.scaleX, 1 / options.scaleY) : new fabric.Point(1, 1), getStrokeHatVector = function(v) {\n                var scalar = s / Math.hypot(v.x, v.y);\n                return new fabric.Point(v.x * scalar * strokeUniformScalar.x, v.y * scalar * strokeUniformScalar.y);\n            };\n            if (points.length <= 1) {\n                return coords;\n            }\n            points.forEach(function(p, index) {\n                var A = new fabric.Point(p.x, p.y), B, C;\n                if (index === 0) {\n                    C = points[index + 1];\n                    B = openPath ? getStrokeHatVector(fabric.util.createVector(C, A)).addEquals(A) : points[points.length - 1];\n                } else if (index === points.length - 1) {\n                    B = points[index - 1];\n                    C = openPath ? getStrokeHatVector(fabric.util.createVector(B, A)).addEquals(A) : points[0];\n                } else {\n                    B = points[index - 1];\n                    C = points[index + 1];\n                }\n                var bisector = fabric.util.getBisector(A, B, C), bisectorVector = bisector.vector, alpha = bisector.angle, scalar, miterVector;\n                if (options.strokeLineJoin === \"miter\") {\n                    scalar = -s / Math.sin(alpha / 2);\n                    miterVector = new fabric.Point(bisectorVector.x * scalar * strokeUniformScalar.x, bisectorVector.y * scalar * strokeUniformScalar.y);\n                    if (Math.hypot(miterVector.x, miterVector.y) / s <= options.strokeMiterLimit) {\n                        coords.push(A.add(miterVector));\n                        coords.push(A.subtract(miterVector));\n                        return;\n                    }\n                }\n                scalar = -s * Math.SQRT2;\n                miterVector = new fabric.Point(bisectorVector.x * scalar * strokeUniformScalar.x, bisectorVector.y * scalar * strokeUniformScalar.y);\n                coords.push(A.add(miterVector));\n                coords.push(A.subtract(miterVector));\n            });\n            return coords;\n        },\n        /**\n     * Apply transform t to point p\n     * @static\n     * @memberOf fabric.util\n     * @param  {fabric.Point} p The point to transform\n     * @param  {Array} t The transform\n     * @param  {Boolean} [ignoreOffset] Indicates that the offset should not be applied\n     * @return {fabric.Point} The transformed point\n     */ transformPoint: function(p, t, ignoreOffset) {\n            if (ignoreOffset) {\n                return new fabric.Point(t[0] * p.x + t[2] * p.y, t[1] * p.x + t[3] * p.y);\n            }\n            return new fabric.Point(t[0] * p.x + t[2] * p.y + t[4], t[1] * p.x + t[3] * p.y + t[5]);\n        },\n        /**\n     * Returns coordinates of points's bounding rectangle (left, top, width, height)\n     * @param {Array} points 4 points array\n     * @param {Array} [transform] an array of 6 numbers representing a 2x3 transform matrix\n     * @return {Object} Object with left, top, width, height properties\n     */ makeBoundingBoxFromPoints: function(points, transform) {\n            if (transform) {\n                for(var i = 0; i < points.length; i++){\n                    points[i] = fabric.util.transformPoint(points[i], transform);\n                }\n            }\n            var xPoints = [\n                points[0].x,\n                points[1].x,\n                points[2].x,\n                points[3].x\n            ], minX = fabric.util.array.min(xPoints), maxX = fabric.util.array.max(xPoints), width = maxX - minX, yPoints = [\n                points[0].y,\n                points[1].y,\n                points[2].y,\n                points[3].y\n            ], minY = fabric.util.array.min(yPoints), maxY = fabric.util.array.max(yPoints), height = maxY - minY;\n            return {\n                left: minX,\n                top: minY,\n                width: width,\n                height: height\n            };\n        },\n        /**\n     * Invert transformation t\n     * @static\n     * @memberOf fabric.util\n     * @param {Array} t The transform\n     * @return {Array} The inverted transform\n     */ invertTransform: function(t) {\n            var a = 1 / (t[0] * t[3] - t[1] * t[2]), r = [\n                a * t[3],\n                -a * t[1],\n                -a * t[2],\n                a * t[0]\n            ], o = fabric.util.transformPoint({\n                x: t[4],\n                y: t[5]\n            }, r, true);\n            r[4] = -o.x;\n            r[5] = -o.y;\n            return r;\n        },\n        /**\n     * A wrapper around Number#toFixed, which contrary to native method returns number, not string.\n     * @static\n     * @memberOf fabric.util\n     * @param {Number|String} number number to operate on\n     * @param {Number} fractionDigits number of fraction digits to \"leave\"\n     * @return {Number}\n     */ toFixed: function(number, fractionDigits) {\n            return parseFloat(Number(number).toFixed(fractionDigits));\n        },\n        /**\n     * Converts from attribute value to pixel value if applicable.\n     * Returns converted pixels or original value not converted.\n     * @param {Number|String} value number to operate on\n     * @param {Number} fontSize\n     * @return {Number|String}\n     */ parseUnit: function(value, fontSize) {\n            var unit = /\\D{0,2}$/.exec(value), number = parseFloat(value);\n            if (!fontSize) {\n                fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;\n            }\n            switch(unit[0]){\n                case \"mm\":\n                    return number * fabric.DPI / 25.4;\n                case \"cm\":\n                    return number * fabric.DPI / 2.54;\n                case \"in\":\n                    return number * fabric.DPI;\n                case \"pt\":\n                    return number * fabric.DPI / 72; // or * 4 / 3\n                case \"pc\":\n                    return number * fabric.DPI / 72 * 12; // or * 16\n                case \"em\":\n                    return number * fontSize;\n                default:\n                    return number;\n            }\n        },\n        /**\n     * Function which always returns `false`.\n     * @static\n     * @memberOf fabric.util\n     * @return {Boolean}\n     */ falseFunction: function() {\n            return false;\n        },\n        /**\n     * Returns klass \"Class\" object of given namespace\n     * @memberOf fabric.util\n     * @param {String} type Type of object (eg. 'circle')\n     * @param {String} namespace Namespace to get klass \"Class\" object from\n     * @return {Object} klass \"Class\"\n     */ getKlass: function(type, namespace) {\n            // capitalize first letter only\n            type = fabric.util.string.camelize(type.charAt(0).toUpperCase() + type.slice(1));\n            return fabric.util.resolveNamespace(namespace)[type];\n        },\n        /**\n     * Returns array of attributes for given svg that fabric parses\n     * @memberOf fabric.util\n     * @param {String} type Type of svg element (eg. 'circle')\n     * @return {Array} string names of supported attributes\n     */ getSvgAttributes: function(type) {\n            var attributes = [\n                \"instantiated_by_use\",\n                \"style\",\n                \"id\",\n                \"class\"\n            ];\n            switch(type){\n                case \"linearGradient\":\n                    attributes = attributes.concat([\n                        \"x1\",\n                        \"y1\",\n                        \"x2\",\n                        \"y2\",\n                        \"gradientUnits\",\n                        \"gradientTransform\"\n                    ]);\n                    break;\n                case \"radialGradient\":\n                    attributes = attributes.concat([\n                        \"gradientUnits\",\n                        \"gradientTransform\",\n                        \"cx\",\n                        \"cy\",\n                        \"r\",\n                        \"fx\",\n                        \"fy\",\n                        \"fr\"\n                    ]);\n                    break;\n                case \"stop\":\n                    attributes = attributes.concat([\n                        \"offset\",\n                        \"stop-color\",\n                        \"stop-opacity\"\n                    ]);\n                    break;\n            }\n            return attributes;\n        },\n        /**\n     * Returns object of given namespace\n     * @memberOf fabric.util\n     * @param {String} namespace Namespace string e.g. 'fabric.Image.filter' or 'fabric'\n     * @return {Object} Object for given namespace (default fabric)\n     */ resolveNamespace: function(namespace) {\n            if (!namespace) {\n                return fabric;\n            }\n            var parts = namespace.split(\".\"), len = parts.length, i, obj = global || fabric.window;\n            for(i = 0; i < len; ++i){\n                obj = obj[parts[i]];\n            }\n            return obj;\n        },\n        /**\n     * Loads image element from given url and passes it to a callback\n     * @memberOf fabric.util\n     * @param {String} url URL representing an image\n     * @param {Function} callback Callback; invoked with loaded image\n     * @param {*} [context] Context to invoke callback in\n     * @param {Object} [crossOrigin] crossOrigin value to set image element to\n     */ loadImage: function(url, callback, context, crossOrigin) {\n            if (!url) {\n                callback && callback.call(context, url);\n                return;\n            }\n            var img = fabric.util.createImage();\n            /** @ignore */ var onLoadCallback = function() {\n                callback && callback.call(context, img, false);\n                img = img.onload = img.onerror = null;\n            };\n            img.onload = onLoadCallback;\n            /** @ignore */ img.onerror = function() {\n                fabric.log(\"Error loading \" + img.src);\n                callback && callback.call(context, null, true);\n                img = img.onload = img.onerror = null;\n            };\n            // data-urls appear to be buggy with crossOrigin\n            // https://github.com/kangax/fabric.js/commit/d0abb90f1cd5c5ef9d2a94d3fb21a22330da3e0a#commitcomment-4513767\n            // see https://code.google.com/p/chromium/issues/detail?id=315152\n            //     https://bugzilla.mozilla.org/show_bug.cgi?id=935069\n            // crossOrigin null is the same as not set.\n            if (url.indexOf(\"data\") !== 0 && crossOrigin !== undefined && crossOrigin !== null) {\n                img.crossOrigin = crossOrigin;\n            }\n            // IE10 / IE11-Fix: SVG contents from data: URI\n            // will only be available if the IMG is present\n            // in the DOM (and visible)\n            if (url.substring(0, 14) === \"data:image/svg\") {\n                img.onload = null;\n                fabric.util.loadImageInDom(img, onLoadCallback);\n            }\n            img.src = url;\n        },\n        /**\n     * Attaches SVG image with data: URL to the dom\n     * @memberOf fabric.util\n     * @param {Object} img Image object with data:image/svg src\n     * @param {Function} callback Callback; invoked with loaded image\n     * @return {Object} DOM element (div containing the SVG image)\n     */ loadImageInDom: function(img, onLoadCallback) {\n            var div = fabric.document.createElement(\"div\");\n            div.style.width = div.style.height = \"1px\";\n            div.style.left = div.style.top = \"-100%\";\n            div.style.position = \"absolute\";\n            div.appendChild(img);\n            fabric.document.querySelector(\"body\").appendChild(div);\n            /**\n       * Wrap in function to:\n       *   1. Call existing callback\n       *   2. Cleanup DOM\n       */ img.onload = function() {\n                onLoadCallback();\n                div.parentNode.removeChild(div);\n                div = null;\n            };\n        },\n        /**\n     * Creates corresponding fabric instances from their object representations\n     * @static\n     * @memberOf fabric.util\n     * @param {Array} objects Objects to enliven\n     * @param {Function} callback Callback to invoke when all objects are created\n     * @param {String} namespace Namespace to get klass \"Class\" object from\n     * @param {Function} reviver Method for further parsing of object elements,\n     * called after each fabric object created.\n     */ enlivenObjects: function(objects, callback, namespace, reviver) {\n            objects = objects || [];\n            var enlivenedObjects = [], numLoadedObjects = 0, numTotalObjects = objects.length;\n            function onLoaded() {\n                if (++numLoadedObjects === numTotalObjects) {\n                    callback && callback(enlivenedObjects.filter(function(obj) {\n                        // filter out undefined objects (objects that gave error)\n                        return obj;\n                    }));\n                }\n            }\n            if (!numTotalObjects) {\n                callback && callback(enlivenedObjects);\n                return;\n            }\n            objects.forEach(function(o, index) {\n                // if sparse array\n                if (!o || !o.type) {\n                    onLoaded();\n                    return;\n                }\n                var klass = fabric.util.getKlass(o.type, namespace);\n                klass.fromObject(o, function(obj, error) {\n                    error || (enlivenedObjects[index] = obj);\n                    reviver && reviver(o, obj, error);\n                    onLoaded();\n                });\n            });\n        },\n        /**\n     * Creates corresponding fabric instances residing in an object, e.g. `clipPath`\n     * @see {@link fabric.Object.ENLIVEN_PROPS}\n     * @param {Object} object\n     * @param {Object} [context] assign enlived props to this object (pass null to skip this)\n     * @param {(objects:fabric.Object[]) => void} callback\n     */ enlivenObjectEnlivables: function(object, context, callback) {\n            var enlivenProps = fabric.Object.ENLIVEN_PROPS.filter(function(key) {\n                return !!object[key];\n            });\n            fabric.util.enlivenObjects(enlivenProps.map(function(key) {\n                return object[key];\n            }), function(enlivedProps) {\n                var objects = {};\n                enlivenProps.forEach(function(key, index) {\n                    objects[key] = enlivedProps[index];\n                    context && (context[key] = enlivedProps[index]);\n                });\n                callback && callback(objects);\n            });\n        },\n        /**\n     * Create and wait for loading of patterns\n     * @static\n     * @memberOf fabric.util\n     * @param {Array} patterns Objects to enliven\n     * @param {Function} callback Callback to invoke when all objects are created\n     * called after each fabric object created.\n     */ enlivenPatterns: function(patterns, callback) {\n            patterns = patterns || [];\n            function onLoaded() {\n                if (++numLoadedPatterns === numPatterns) {\n                    callback && callback(enlivenedPatterns);\n                }\n            }\n            var enlivenedPatterns = [], numLoadedPatterns = 0, numPatterns = patterns.length;\n            if (!numPatterns) {\n                callback && callback(enlivenedPatterns);\n                return;\n            }\n            patterns.forEach(function(p, index) {\n                if (p && p.source) {\n                    new fabric.Pattern(p, function(pattern) {\n                        enlivenedPatterns[index] = pattern;\n                        onLoaded();\n                    });\n                } else {\n                    enlivenedPatterns[index] = p;\n                    onLoaded();\n                }\n            });\n        },\n        /**\n     * Groups SVG elements (usually those retrieved from SVG document)\n     * @static\n     * @memberOf fabric.util\n     * @param {Array} elements SVG elements to group\n     * @param {Object} [options] Options object\n     * @param {String} path Value to set sourcePath to\n     * @return {fabric.Object|fabric.Group}\n     */ groupSVGElements: function(elements, options, path) {\n            var object;\n            if (elements && elements.length === 1) {\n                if (typeof path !== \"undefined\") {\n                    elements[0].sourcePath = path;\n                }\n                return elements[0];\n            }\n            if (options) {\n                if (options.width && options.height) {\n                    options.centerPoint = {\n                        x: options.width / 2,\n                        y: options.height / 2\n                    };\n                } else {\n                    delete options.width;\n                    delete options.height;\n                }\n            }\n            object = new fabric.Group(elements, options);\n            if (typeof path !== \"undefined\") {\n                object.sourcePath = path;\n            }\n            return object;\n        },\n        /**\n     * Populates an object with properties of another object\n     * @static\n     * @memberOf fabric.util\n     * @param {Object} source Source object\n     * @param {Object} destination Destination object\n     * @return {Array} properties Properties names to include\n     */ populateWithProperties: function(source, destination, properties) {\n            if (properties && Array.isArray(properties)) {\n                for(var i = 0, len = properties.length; i < len; i++){\n                    if (properties[i] in source) {\n                        destination[properties[i]] = source[properties[i]];\n                    }\n                }\n            }\n        },\n        /**\n     * Creates canvas element\n     * @static\n     * @memberOf fabric.util\n     * @return {CanvasElement} initialized canvas element\n     */ createCanvasElement: function() {\n            return fabric.document.createElement(\"canvas\");\n        },\n        /**\n     * Creates a canvas element that is a copy of another and is also painted\n     * @param {CanvasElement} canvas to copy size and content of\n     * @static\n     * @memberOf fabric.util\n     * @return {CanvasElement} initialized canvas element\n     */ copyCanvasElement: function(canvas) {\n            var newCanvas = fabric.util.createCanvasElement();\n            newCanvas.width = canvas.width;\n            newCanvas.height = canvas.height;\n            newCanvas.getContext(\"2d\").drawImage(canvas, 0, 0);\n            return newCanvas;\n        },\n        /**\n     * since 2.6.0 moved from canvas instance to utility.\n     * @param {CanvasElement} canvasEl to copy size and content of\n     * @param {String} format 'jpeg' or 'png', in some browsers 'webp' is ok too\n     * @param {Number} quality <= 1 and > 0\n     * @static\n     * @memberOf fabric.util\n     * @return {String} data url\n     */ toDataURL: function(canvasEl, format, quality) {\n            return canvasEl.toDataURL(\"image/\" + format, quality);\n        },\n        /**\n     * Creates image element (works on client and node)\n     * @static\n     * @memberOf fabric.util\n     * @return {HTMLImageElement} HTML image element\n     */ createImage: function() {\n            return fabric.document.createElement(\"img\");\n        },\n        /**\n     * Multiply matrix A by matrix B to nest transformations\n     * @static\n     * @memberOf fabric.util\n     * @param  {Array} a First transformMatrix\n     * @param  {Array} b Second transformMatrix\n     * @param  {Boolean} is2x2 flag to multiply matrices as 2x2 matrices\n     * @return {Array} The product of the two transform matrices\n     */ multiplyTransformMatrices: function(a, b, is2x2) {\n            // Matrix multiply a * b\n            return [\n                a[0] * b[0] + a[2] * b[1],\n                a[1] * b[0] + a[3] * b[1],\n                a[0] * b[2] + a[2] * b[3],\n                a[1] * b[2] + a[3] * b[3],\n                is2x2 ? 0 : a[0] * b[4] + a[2] * b[5] + a[4],\n                is2x2 ? 0 : a[1] * b[4] + a[3] * b[5] + a[5]\n            ];\n        },\n        /**\n     * Decomposes standard 2x3 matrix into transform components\n     * @static\n     * @memberOf fabric.util\n     * @param  {Array} a transformMatrix\n     * @return {Object} Components of transform\n     */ qrDecompose: function(a) {\n            var angle = atan2(a[1], a[0]), denom = pow(a[0], 2) + pow(a[1], 2), scaleX = sqrt(denom), scaleY = (a[0] * a[3] - a[2] * a[1]) / scaleX, skewX = atan2(a[0] * a[2] + a[1] * a[3], denom);\n            return {\n                angle: angle / PiBy180,\n                scaleX: scaleX,\n                scaleY: scaleY,\n                skewX: skewX / PiBy180,\n                skewY: 0,\n                translateX: a[4],\n                translateY: a[5]\n            };\n        },\n        /**\n     * Returns a transform matrix starting from an object of the same kind of\n     * the one returned from qrDecompose, useful also if you want to calculate some\n     * transformations from an object that is not enlived yet\n     * @static\n     * @memberOf fabric.util\n     * @param  {Object} options\n     * @param  {Number} [options.angle] angle in degrees\n     * @return {Number[]} transform matrix\n     */ calcRotateMatrix: function(options) {\n            if (!options.angle) {\n                return fabric.iMatrix.concat();\n            }\n            var theta = fabric.util.degreesToRadians(options.angle), cos = fabric.util.cos(theta), sin = fabric.util.sin(theta);\n            return [\n                cos,\n                sin,\n                -sin,\n                cos,\n                0,\n                0\n            ];\n        },\n        /**\n     * Returns a transform matrix starting from an object of the same kind of\n     * the one returned from qrDecompose, useful also if you want to calculate some\n     * transformations from an object that is not enlived yet.\n     * is called DimensionsTransformMatrix because those properties are the one that influence\n     * the size of the resulting box of the object.\n     * @static\n     * @memberOf fabric.util\n     * @param  {Object} options\n     * @param  {Number} [options.scaleX]\n     * @param  {Number} [options.scaleY]\n     * @param  {Boolean} [options.flipX]\n     * @param  {Boolean} [options.flipY]\n     * @param  {Number} [options.skewX]\n     * @param  {Number} [options.skewY]\n     * @return {Number[]} transform matrix\n     */ calcDimensionsMatrix: function(options) {\n            var scaleX = typeof options.scaleX === \"undefined\" ? 1 : options.scaleX, scaleY = typeof options.scaleY === \"undefined\" ? 1 : options.scaleY, scaleMatrix = [\n                options.flipX ? -scaleX : scaleX,\n                0,\n                0,\n                options.flipY ? -scaleY : scaleY,\n                0,\n                0\n            ], multiply = fabric.util.multiplyTransformMatrices, degreesToRadians = fabric.util.degreesToRadians;\n            if (options.skewX) {\n                scaleMatrix = multiply(scaleMatrix, [\n                    1,\n                    0,\n                    Math.tan(degreesToRadians(options.skewX)),\n                    1\n                ], true);\n            }\n            if (options.skewY) {\n                scaleMatrix = multiply(scaleMatrix, [\n                    1,\n                    Math.tan(degreesToRadians(options.skewY)),\n                    0,\n                    1\n                ], true);\n            }\n            return scaleMatrix;\n        },\n        /**\n     * Returns a transform matrix starting from an object of the same kind of\n     * the one returned from qrDecompose, useful also if you want to calculate some\n     * transformations from an object that is not enlived yet\n     * @static\n     * @memberOf fabric.util\n     * @param  {Object} options\n     * @param  {Number} [options.angle]\n     * @param  {Number} [options.scaleX]\n     * @param  {Number} [options.scaleY]\n     * @param  {Boolean} [options.flipX]\n     * @param  {Boolean} [options.flipY]\n     * @param  {Number} [options.skewX]\n     * @param  {Number} [options.skewX]\n     * @param  {Number} [options.translateX]\n     * @param  {Number} [options.translateY]\n     * @return {Number[]} transform matrix\n     */ composeMatrix: function(options) {\n            var matrix = [\n                1,\n                0,\n                0,\n                1,\n                options.translateX || 0,\n                options.translateY || 0\n            ], multiply = fabric.util.multiplyTransformMatrices;\n            if (options.angle) {\n                matrix = multiply(matrix, fabric.util.calcRotateMatrix(options));\n            }\n            if (options.scaleX !== 1 || options.scaleY !== 1 || options.skewX || options.skewY || options.flipX || options.flipY) {\n                matrix = multiply(matrix, fabric.util.calcDimensionsMatrix(options));\n            }\n            return matrix;\n        },\n        /**\n     * reset an object transform state to neutral. Top and left are not accounted for\n     * @static\n     * @memberOf fabric.util\n     * @param  {fabric.Object} target object to transform\n     */ resetObjectTransform: function(target) {\n            target.scaleX = 1;\n            target.scaleY = 1;\n            target.skewX = 0;\n            target.skewY = 0;\n            target.flipX = false;\n            target.flipY = false;\n            target.rotate(0);\n        },\n        /**\n     * Extract Object transform values\n     * @static\n     * @memberOf fabric.util\n     * @param  {fabric.Object} target object to read from\n     * @return {Object} Components of transform\n     */ saveObjectTransform: function(target) {\n            return {\n                scaleX: target.scaleX,\n                scaleY: target.scaleY,\n                skewX: target.skewX,\n                skewY: target.skewY,\n                angle: target.angle,\n                left: target.left,\n                flipX: target.flipX,\n                flipY: target.flipY,\n                top: target.top\n            };\n        },\n        /**\n     * Returns true if context has transparent pixel\n     * at specified location (taking tolerance into account)\n     * @param {CanvasRenderingContext2D} ctx context\n     * @param {Number} x x coordinate\n     * @param {Number} y y coordinate\n     * @param {Number} tolerance Tolerance\n     */ isTransparent: function(ctx, x, y, tolerance) {\n            // If tolerance is > 0 adjust start coords to take into account.\n            // If moves off Canvas fix to 0\n            if (tolerance > 0) {\n                if (x > tolerance) {\n                    x -= tolerance;\n                } else {\n                    x = 0;\n                }\n                if (y > tolerance) {\n                    y -= tolerance;\n                } else {\n                    y = 0;\n                }\n            }\n            var _isTransparent = true, i, temp, imageData = ctx.getImageData(x, y, tolerance * 2 || 1, tolerance * 2 || 1), l = imageData.data.length;\n            // Split image data - for tolerance > 1, pixelDataSize = 4;\n            for(i = 3; i < l; i += 4){\n                temp = imageData.data[i];\n                _isTransparent = temp <= 0;\n                if (_isTransparent === false) {\n                    break; // Stop if colour found\n                }\n            }\n            imageData = null;\n            return _isTransparent;\n        },\n        /**\n     * Parse preserveAspectRatio attribute from element\n     * @param {string} attribute to be parsed\n     * @return {Object} an object containing align and meetOrSlice attribute\n     */ parsePreserveAspectRatioAttribute: function(attribute) {\n            var meetOrSlice = \"meet\", alignX = \"Mid\", alignY = \"Mid\", aspectRatioAttrs = attribute.split(\" \"), align;\n            if (aspectRatioAttrs && aspectRatioAttrs.length) {\n                meetOrSlice = aspectRatioAttrs.pop();\n                if (meetOrSlice !== \"meet\" && meetOrSlice !== \"slice\") {\n                    align = meetOrSlice;\n                    meetOrSlice = \"meet\";\n                } else if (aspectRatioAttrs.length) {\n                    align = aspectRatioAttrs.pop();\n                }\n            }\n            //divide align in alignX and alignY\n            alignX = align !== \"none\" ? align.slice(1, 4) : \"none\";\n            alignY = align !== \"none\" ? align.slice(5, 8) : \"none\";\n            return {\n                meetOrSlice: meetOrSlice,\n                alignX: alignX,\n                alignY: alignY\n            };\n        },\n        /**\n     * Clear char widths cache for the given font family or all the cache if no\n     * fontFamily is specified.\n     * Use it if you know you are loading fonts in a lazy way and you are not waiting\n     * for custom fonts to load properly when adding text objects to the canvas.\n     * If a text object is added when its own font is not loaded yet, you will get wrong\n     * measurement and so wrong bounding boxes.\n     * After the font cache is cleared, either change the textObject text content or call\n     * initDimensions() to trigger a recalculation\n     * @memberOf fabric.util\n     * @param {String} [fontFamily] font family to clear\n     */ clearFabricFontCache: function(fontFamily) {\n            fontFamily = (fontFamily || \"\").toLowerCase();\n            if (!fontFamily) {\n                fabric.charWidthsCache = {};\n            } else if (fabric.charWidthsCache[fontFamily]) {\n                delete fabric.charWidthsCache[fontFamily];\n            }\n        },\n        /**\n     * Given current aspect ratio, determines the max width and height that can\n     * respect the total allowed area for the cache.\n     * @memberOf fabric.util\n     * @param {Number} ar aspect ratio\n     * @param {Number} maximumArea Maximum area you want to achieve\n     * @return {Object.x} Limited dimensions by X\n     * @return {Object.y} Limited dimensions by Y\n     */ limitDimsByArea: function(ar, maximumArea) {\n            var roughWidth = Math.sqrt(maximumArea * ar), perfLimitSizeY = Math.floor(maximumArea / roughWidth);\n            return {\n                x: Math.floor(roughWidth),\n                y: perfLimitSizeY\n            };\n        },\n        capValue: function(min, value, max) {\n            return Math.max(min, Math.min(value, max));\n        },\n        /**\n     * Finds the scale for the object source to fit inside the object destination,\n     * keeping aspect ratio intact.\n     * respect the total allowed area for the cache.\n     * @memberOf fabric.util\n     * @param {Object | fabric.Object} source\n     * @param {Number} source.height natural unscaled height of the object\n     * @param {Number} source.width natural unscaled width of the object\n     * @param {Object | fabric.Object} destination\n     * @param {Number} destination.height natural unscaled height of the object\n     * @param {Number} destination.width natural unscaled width of the object\n     * @return {Number} scale factor to apply to source to fit into destination\n     */ findScaleToFit: function(source, destination) {\n            return Math.min(destination.width / source.width, destination.height / source.height);\n        },\n        /**\n     * Finds the scale for the object source to cover entirely the object destination,\n     * keeping aspect ratio intact.\n     * respect the total allowed area for the cache.\n     * @memberOf fabric.util\n     * @param {Object | fabric.Object} source\n     * @param {Number} source.height natural unscaled height of the object\n     * @param {Number} source.width natural unscaled width of the object\n     * @param {Object | fabric.Object} destination\n     * @param {Number} destination.height natural unscaled height of the object\n     * @param {Number} destination.width natural unscaled width of the object\n     * @return {Number} scale factor to apply to source to cover destination\n     */ findScaleToCover: function(source, destination) {\n            return Math.max(destination.width / source.width, destination.height / source.height);\n        },\n        /**\n     * given an array of 6 number returns something like `\"matrix(...numbers)\"`\n     * @memberOf fabric.util\n     * @param {Array} transform an array with 6 numbers\n     * @return {String} transform matrix for svg\n     * @return {Object.y} Limited dimensions by Y\n     */ matrixToSVG: function(transform) {\n            return \"matrix(\" + transform.map(function(value) {\n                return fabric.util.toFixed(value, fabric.Object.NUM_FRACTION_DIGITS);\n            }).join(\" \") + \")\";\n        },\n        /**\n     * given an object and a transform, apply the inverse transform to the object,\n     * this is equivalent to remove from that object that transformation, so that\n     * added in a space with the removed transform, the object will be the same as before.\n     * Removing from an object a transform that scale by 2 is like scaling it by 1/2.\n     * Removing from an object a transfrom that rotate by 30deg is like rotating by 30deg\n     * in the opposite direction.\n     * This util is used to add objects inside transformed groups or nested groups.\n     * @memberOf fabric.util\n     * @param {fabric.Object} object the object you want to transform\n     * @param {Array} transform the destination transform\n     */ removeTransformFromObject: function(object, transform) {\n            var inverted = fabric.util.invertTransform(transform), finalTransform = fabric.util.multiplyTransformMatrices(inverted, object.calcOwnMatrix());\n            fabric.util.applyTransformToObject(object, finalTransform);\n        },\n        /**\n     * given an object and a transform, apply the transform to the object.\n     * this is equivalent to change the space where the object is drawn.\n     * Adding to an object a transform that scale by 2 is like scaling it by 2.\n     * This is used when removing an object from an active selection for example.\n     * @memberOf fabric.util\n     * @param {fabric.Object} object the object you want to transform\n     * @param {Array} transform the destination transform\n     */ addTransformToObject: function(object, transform) {\n            fabric.util.applyTransformToObject(object, fabric.util.multiplyTransformMatrices(transform, object.calcOwnMatrix()));\n        },\n        /**\n     * discard an object transform state and apply the one from the matrix.\n     * @memberOf fabric.util\n     * @param {fabric.Object} object the object you want to transform\n     * @param {Array} transform the destination transform\n     */ applyTransformToObject: function(object, transform) {\n            var options = fabric.util.qrDecompose(transform), center = new fabric.Point(options.translateX, options.translateY);\n            object.flipX = false;\n            object.flipY = false;\n            object.set(\"scaleX\", options.scaleX);\n            object.set(\"scaleY\", options.scaleY);\n            object.skewX = options.skewX;\n            object.skewY = options.skewY;\n            object.angle = options.angle;\n            object.setPositionByOrigin(center, \"center\", \"center\");\n        },\n        /**\n     * given a width and height, return the size of the bounding box\n     * that can contains the box with width/height with applied transform\n     * described in options.\n     * Use to calculate the boxes around objects for controls.\n     * @memberOf fabric.util\n     * @param {Number} width\n     * @param {Number} height\n     * @param {Object} options\n     * @param {Number} options.scaleX\n     * @param {Number} options.scaleY\n     * @param {Number} options.skewX\n     * @param {Number} options.skewY\n     * @return {Object.x} width of containing\n     * @return {Object.y} height of containing\n     */ sizeAfterTransform: function(width, height, options) {\n            var dimX = width / 2, dimY = height / 2, points = [\n                {\n                    x: -dimX,\n                    y: -dimY\n                },\n                {\n                    x: dimX,\n                    y: -dimY\n                },\n                {\n                    x: -dimX,\n                    y: dimY\n                },\n                {\n                    x: dimX,\n                    y: dimY\n                }\n            ], transformMatrix = fabric.util.calcDimensionsMatrix(options), bbox = fabric.util.makeBoundingBoxFromPoints(points, transformMatrix);\n            return {\n                x: bbox.width,\n                y: bbox.height\n            };\n        },\n        /**\n     * Merges 2 clip paths into one visually equal clip path\n     *\n     * **IMPORTANT**:\\\n     * Does **NOT** clone the arguments, clone them proir if necessary.\n     *\n     * Creates a wrapper (group) that contains one clip path and is clipped by the other so content is kept where both overlap.\n     * Use this method if both the clip paths may have nested clip paths of their own, so assigning one to the other's clip path property is not possible.\n     *\n     * In order to handle the `inverted` property we follow logic described in the following cases:\\\n     * **(1)** both clip paths are inverted - the clip paths pass the inverted prop to the wrapper and loose it themselves.\\\n     * **(2)** one is inverted and the other isn't - the wrapper shouldn't become inverted and the inverted clip path must clip the non inverted one to produce an identical visual effect.\\\n     * **(3)** both clip paths are not inverted - wrapper and clip paths remain unchanged.\n     *\n     * @memberOf fabric.util\n     * @param {fabric.Object} c1\n     * @param {fabric.Object} c2\n     * @returns {fabric.Object} merged clip path\n     */ mergeClipPaths: function(c1, c2) {\n            var a = c1, b = c2;\n            if (a.inverted && !b.inverted) {\n                //  case (2)\n                a = c2;\n                b = c1;\n            }\n            //  `b` becomes `a`'s clip path so we transform `b` to `a` coordinate plane\n            fabric.util.applyTransformToObject(b, fabric.util.multiplyTransformMatrices(fabric.util.invertTransform(a.calcTransformMatrix()), b.calcTransformMatrix()));\n            //  assign the `inverted` prop to the wrapping group\n            var inverted = a.inverted && b.inverted;\n            if (inverted) {\n                //  case (1)\n                a.inverted = b.inverted = false;\n            }\n            return new fabric.Group([\n                a\n            ], {\n                clipPath: b,\n                inverted: inverted\n            });\n        },\n        /**\n     * @memberOf fabric.util\n     * @param {Object} prevStyle first style to compare\n     * @param {Object} thisStyle second style to compare\n     * @param {boolean} forTextSpans whether to check overline, underline, and line-through properties\n     * @return {boolean} true if the style changed\n     */ hasStyleChanged: function(prevStyle, thisStyle, forTextSpans) {\n            forTextSpans = forTextSpans || false;\n            return prevStyle.fill !== thisStyle.fill || prevStyle.stroke !== thisStyle.stroke || prevStyle.strokeWidth !== thisStyle.strokeWidth || prevStyle.fontSize !== thisStyle.fontSize || prevStyle.fontFamily !== thisStyle.fontFamily || prevStyle.fontWeight !== thisStyle.fontWeight || prevStyle.fontStyle !== thisStyle.fontStyle || prevStyle.textBackgroundColor !== thisStyle.textBackgroundColor || prevStyle.deltaY !== thisStyle.deltaY || forTextSpans && (prevStyle.overline !== thisStyle.overline || prevStyle.underline !== thisStyle.underline || prevStyle.linethrough !== thisStyle.linethrough);\n        },\n        /**\n     * Returns the array form of a text object's inline styles property with styles grouped in ranges\n     * rather than per character. This format is less verbose, and is better suited for storage\n     * so it is used in serialization (not during runtime).\n     * @memberOf fabric.util\n     * @param {object} styles per character styles for a text object\n     * @param {String} text the text string that the styles are applied to\n     * @return {{start: number, end: number, style: object}[]}\n     */ stylesToArray: function(styles, text) {\n            // clone style structure to prevent mutation\n            var styles = fabric.util.object.clone(styles, true), textLines = text.split(\"\\n\"), charIndex = -1, prevStyle = {}, stylesArray = [];\n            //loop through each textLine\n            for(var i = 0; i < textLines.length; i++){\n                if (!styles[i]) {\n                    //no styles exist for this line, so add the line's length to the charIndex total\n                    charIndex += textLines[i].length;\n                    continue;\n                }\n                //loop through each character of the current line\n                for(var c = 0; c < textLines[i].length; c++){\n                    charIndex++;\n                    var thisStyle = styles[i][c];\n                    //check if style exists for this character\n                    if (thisStyle && Object.keys(thisStyle).length > 0) {\n                        var styleChanged = fabric.util.hasStyleChanged(prevStyle, thisStyle, true);\n                        if (styleChanged) {\n                            stylesArray.push({\n                                start: charIndex,\n                                end: charIndex + 1,\n                                style: thisStyle\n                            });\n                        } else {\n                            //if style is the same as previous character, increase end index\n                            stylesArray[stylesArray.length - 1].end++;\n                        }\n                    }\n                    prevStyle = thisStyle || {};\n                }\n            }\n            return stylesArray;\n        },\n        /**\n     * Returns the object form of the styles property with styles that are assigned per\n     * character rather than grouped by range. This format is more verbose, and is\n     * only used during runtime (not for serialization/storage)\n     * @memberOf fabric.util\n     * @param {Array} styles the serialized form of a text object's styles\n     * @param {String} text the text string that the styles are applied to\n     * @return {Object}\n     */ stylesFromArray: function(styles, text) {\n            if (!Array.isArray(styles)) {\n                return styles;\n            }\n            var textLines = text.split(\"\\n\"), charIndex = -1, styleIndex = 0, stylesObject = {};\n            //loop through each textLine\n            for(var i = 0; i < textLines.length; i++){\n                //loop through each character of the current line\n                for(var c = 0; c < textLines[i].length; c++){\n                    charIndex++;\n                    //check if there's a style collection that includes the current character\n                    if (styles[styleIndex] && styles[styleIndex].start <= charIndex && charIndex < styles[styleIndex].end) {\n                        //create object for line index if it doesn't exist\n                        stylesObject[i] = stylesObject[i] || {};\n                        //assign a style at this character's index\n                        stylesObject[i][c] = Object.assign({}, styles[styleIndex].style);\n                        //if character is at the end of the current style collection, move to the next\n                        if (charIndex === styles[styleIndex].end - 1) {\n                            styleIndex++;\n                        }\n                    }\n                }\n            }\n            return stylesObject;\n        }\n    };\n})( true ? exports : 0);\n(function() {\n    var _join = Array.prototype.join, commandLengths = {\n        m: 2,\n        l: 2,\n        h: 1,\n        v: 1,\n        c: 6,\n        s: 4,\n        q: 4,\n        t: 2,\n        a: 7\n    }, repeatedCommands = {\n        m: \"l\",\n        M: \"L\"\n    };\n    function segmentToBezier(th2, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY) {\n        var costh2 = fabric.util.cos(th2), sinth2 = fabric.util.sin(th2), costh3 = fabric.util.cos(th3), sinth3 = fabric.util.sin(th3), toX = cosTh * rx * costh3 - sinTh * ry * sinth3 + cx1, toY = sinTh * rx * costh3 + cosTh * ry * sinth3 + cy1, cp1X = fromX + mT * (-cosTh * rx * sinth2 - sinTh * ry * costh2), cp1Y = fromY + mT * (-sinTh * rx * sinth2 + cosTh * ry * costh2), cp2X = toX + mT * (cosTh * rx * sinth3 + sinTh * ry * costh3), cp2Y = toY + mT * (sinTh * rx * sinth3 - cosTh * ry * costh3);\n        return [\n            \"C\",\n            cp1X,\n            cp1Y,\n            cp2X,\n            cp2Y,\n            toX,\n            toY\n        ];\n    }\n    /* Adapted from http://dxr.mozilla.org/mozilla-central/source/content/svg/content/src/nsSVGPathDataParser.cpp\n   * by Andrea Bogazzi code is under MPL. if you don't have a copy of the license you can take it here\n   * http://mozilla.org/MPL/2.0/\n   */ function arcToSegments(toX, toY, rx, ry, large, sweep, rotateX) {\n        var PI = Math.PI, th = rotateX * PI / 180, sinTh = fabric.util.sin(th), cosTh = fabric.util.cos(th), fromX = 0, fromY = 0;\n        rx = Math.abs(rx);\n        ry = Math.abs(ry);\n        var px = -cosTh * toX * 0.5 - sinTh * toY * 0.5, py = -cosTh * toY * 0.5 + sinTh * toX * 0.5, rx2 = rx * rx, ry2 = ry * ry, py2 = py * py, px2 = px * px, pl = rx2 * ry2 - rx2 * py2 - ry2 * px2, root = 0;\n        if (pl < 0) {\n            var s = Math.sqrt(1 - pl / (rx2 * ry2));\n            rx *= s;\n            ry *= s;\n        } else {\n            root = (large === sweep ? -1.0 : 1.0) * Math.sqrt(pl / (rx2 * py2 + ry2 * px2));\n        }\n        var cx = root * rx * py / ry, cy = -root * ry * px / rx, cx1 = cosTh * cx - sinTh * cy + toX * 0.5, cy1 = sinTh * cx + cosTh * cy + toY * 0.5, mTheta = calcVectorAngle(1, 0, (px - cx) / rx, (py - cy) / ry), dtheta = calcVectorAngle((px - cx) / rx, (py - cy) / ry, (-px - cx) / rx, (-py - cy) / ry);\n        if (sweep === 0 && dtheta > 0) {\n            dtheta -= 2 * PI;\n        } else if (sweep === 1 && dtheta < 0) {\n            dtheta += 2 * PI;\n        }\n        // Convert into cubic bezier segments <= 90deg\n        var segments = Math.ceil(Math.abs(dtheta / PI * 2)), result = [], mDelta = dtheta / segments, mT = 8 / 3 * Math.sin(mDelta / 4) * Math.sin(mDelta / 4) / Math.sin(mDelta / 2), th3 = mTheta + mDelta;\n        for(var i = 0; i < segments; i++){\n            result[i] = segmentToBezier(mTheta, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY);\n            fromX = result[i][5];\n            fromY = result[i][6];\n            mTheta = th3;\n            th3 += mDelta;\n        }\n        return result;\n    }\n    /*\n   * Private\n   */ function calcVectorAngle(ux, uy, vx, vy) {\n        var ta = Math.atan2(uy, ux), tb = Math.atan2(vy, vx);\n        if (tb >= ta) {\n            return tb - ta;\n        } else {\n            return 2 * Math.PI - (ta - tb);\n        }\n    }\n    /**\n   * Calculate bounding box of a beziercurve\n   * @param {Number} x0 starting point\n   * @param {Number} y0\n   * @param {Number} x1 first control point\n   * @param {Number} y1\n   * @param {Number} x2 secondo control point\n   * @param {Number} y2\n   * @param {Number} x3 end of bezier\n   * @param {Number} y3\n   */ // taken from http://jsbin.com/ivomiq/56/edit  no credits available for that.\n    // TODO: can we normalize this with the starting points set at 0 and then translated the bbox?\n    function getBoundsOfCurve(x0, y0, x1, y1, x2, y2, x3, y3) {\n        var argsString;\n        if (fabric.cachesBoundsOfCurve) {\n            argsString = _join.call(arguments);\n            if (fabric.boundsOfCurveCache[argsString]) {\n                return fabric.boundsOfCurveCache[argsString];\n            }\n        }\n        var sqrt = Math.sqrt, min = Math.min, max = Math.max, abs = Math.abs, tvalues = [], bounds = [\n            [],\n            []\n        ], a, b, c, t, t1, t2, b2ac, sqrtb2ac;\n        b = 6 * x0 - 12 * x1 + 6 * x2;\n        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n        c = 3 * x1 - 3 * x0;\n        for(var i = 0; i < 2; ++i){\n            if (i > 0) {\n                b = 6 * y0 - 12 * y1 + 6 * y2;\n                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n                c = 3 * y1 - 3 * y0;\n            }\n            if (abs(a) < 1e-12) {\n                if (abs(b) < 1e-12) {\n                    continue;\n                }\n                t = -c / b;\n                if (0 < t && t < 1) {\n                    tvalues.push(t);\n                }\n                continue;\n            }\n            b2ac = b * b - 4 * c * a;\n            if (b2ac < 0) {\n                continue;\n            }\n            sqrtb2ac = sqrt(b2ac);\n            t1 = (-b + sqrtb2ac) / (2 * a);\n            if (0 < t1 && t1 < 1) {\n                tvalues.push(t1);\n            }\n            t2 = (-b - sqrtb2ac) / (2 * a);\n            if (0 < t2 && t2 < 1) {\n                tvalues.push(t2);\n            }\n        }\n        var x, y, j = tvalues.length, jlen = j, mt;\n        while(j--){\n            t = tvalues[j];\n            mt = 1 - t;\n            x = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n            bounds[0][j] = x;\n            y = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n            bounds[1][j] = y;\n        }\n        bounds[0][jlen] = x0;\n        bounds[1][jlen] = y0;\n        bounds[0][jlen + 1] = x3;\n        bounds[1][jlen + 1] = y3;\n        var result = [\n            {\n                x: min.apply(null, bounds[0]),\n                y: min.apply(null, bounds[1])\n            },\n            {\n                x: max.apply(null, bounds[0]),\n                y: max.apply(null, bounds[1])\n            }\n        ];\n        if (fabric.cachesBoundsOfCurve) {\n            fabric.boundsOfCurveCache[argsString] = result;\n        }\n        return result;\n    }\n    /**\n   * Converts arc to a bunch of bezier curves\n   * @param {Number} fx starting point x\n   * @param {Number} fy starting point y\n   * @param {Array} coords Arc command\n   */ function fromArcToBeziers(fx, fy, coords) {\n        var rx = coords[1], ry = coords[2], rot = coords[3], large = coords[4], sweep = coords[5], tx = coords[6], ty = coords[7], segsNorm = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);\n        for(var i = 0, len = segsNorm.length; i < len; i++){\n            segsNorm[i][1] += fx;\n            segsNorm[i][2] += fy;\n            segsNorm[i][3] += fx;\n            segsNorm[i][4] += fy;\n            segsNorm[i][5] += fx;\n            segsNorm[i][6] += fy;\n        }\n        return segsNorm;\n    }\n    ;\n    /**\n   * This function take a parsed SVG path and make it simpler for fabricJS logic.\n   * simplification consist of: only UPPERCASE absolute commands ( relative converted to absolute )\n   * S converted in C, T converted in Q, A converted in C.\n   * @param {Array} path the array of commands of a parsed svg path for fabric.Path\n   * @return {Array} the simplified array of commands of a parsed svg path for fabric.Path\n   */ function makePathSimpler(path) {\n        // x and y represent the last point of the path. the previous command point.\n        // we add them to each relative command to make it an absolute comment.\n        // we also swap the v V h H with L, because are easier to transform.\n        var x = 0, y = 0, len = path.length, // x1 and y1 represent the last point of the subpath. the subpath is started with\n        // m or M command. When a z or Z command is drawn, x and y need to be resetted to\n        // the last x1 and y1.\n        x1 = 0, y1 = 0, current, i, converted, // previous will host the letter of the previous command, to handle S and T.\n        // controlX and controlY will host the previous reflected control point\n        destinationPath = [], previous, controlX, controlY;\n        for(i = 0; i < len; ++i){\n            converted = false;\n            current = path[i].slice(0);\n            switch(current[0]){\n                case \"l\":\n                    current[0] = \"L\";\n                    current[1] += x;\n                    current[2] += y;\n                // falls through\n                case \"L\":\n                    x = current[1];\n                    y = current[2];\n                    break;\n                case \"h\":\n                    current[1] += x;\n                // falls through\n                case \"H\":\n                    current[0] = \"L\";\n                    current[2] = y;\n                    x = current[1];\n                    break;\n                case \"v\":\n                    current[1] += y;\n                // falls through\n                case \"V\":\n                    current[0] = \"L\";\n                    y = current[1];\n                    current[1] = x;\n                    current[2] = y;\n                    break;\n                case \"m\":\n                    current[0] = \"M\";\n                    current[1] += x;\n                    current[2] += y;\n                // falls through\n                case \"M\":\n                    x = current[1];\n                    y = current[2];\n                    x1 = current[1];\n                    y1 = current[2];\n                    break;\n                case \"c\":\n                    current[0] = \"C\";\n                    current[1] += x;\n                    current[2] += y;\n                    current[3] += x;\n                    current[4] += y;\n                    current[5] += x;\n                    current[6] += y;\n                // falls through\n                case \"C\":\n                    controlX = current[3];\n                    controlY = current[4];\n                    x = current[5];\n                    y = current[6];\n                    break;\n                case \"s\":\n                    current[0] = \"S\";\n                    current[1] += x;\n                    current[2] += y;\n                    current[3] += x;\n                    current[4] += y;\n                // falls through\n                case \"S\":\n                    // would be sScC but since we are swapping sSc for C, we check just that.\n                    if (previous === \"C\") {\n                        // calculate reflection of previous control points\n                        controlX = 2 * x - controlX;\n                        controlY = 2 * y - controlY;\n                    } else {\n                        // If there is no previous command or if the previous command was not a C, c, S, or s,\n                        // the control point is coincident with the current point\n                        controlX = x;\n                        controlY = y;\n                    }\n                    x = current[3];\n                    y = current[4];\n                    current[0] = \"C\";\n                    current[5] = current[3];\n                    current[6] = current[4];\n                    current[3] = current[1];\n                    current[4] = current[2];\n                    current[1] = controlX;\n                    current[2] = controlY;\n                    // current[3] and current[4] are NOW the second control point.\n                    // we keep it for the next reflection.\n                    controlX = current[3];\n                    controlY = current[4];\n                    break;\n                case \"q\":\n                    current[0] = \"Q\";\n                    current[1] += x;\n                    current[2] += y;\n                    current[3] += x;\n                    current[4] += y;\n                // falls through\n                case \"Q\":\n                    controlX = current[1];\n                    controlY = current[2];\n                    x = current[3];\n                    y = current[4];\n                    break;\n                case \"t\":\n                    current[0] = \"T\";\n                    current[1] += x;\n                    current[2] += y;\n                // falls through\n                case \"T\":\n                    if (previous === \"Q\") {\n                        // calculate reflection of previous control point\n                        controlX = 2 * x - controlX;\n                        controlY = 2 * y - controlY;\n                    } else {\n                        // If there is no previous command or if the previous command was not a Q, q, T or t,\n                        // assume the control point is coincident with the current point\n                        controlX = x;\n                        controlY = y;\n                    }\n                    current[0] = \"Q\";\n                    x = current[1];\n                    y = current[2];\n                    current[1] = controlX;\n                    current[2] = controlY;\n                    current[3] = x;\n                    current[4] = y;\n                    break;\n                case \"a\":\n                    current[0] = \"A\";\n                    current[6] += x;\n                    current[7] += y;\n                // falls through\n                case \"A\":\n                    converted = true;\n                    destinationPath = destinationPath.concat(fromArcToBeziers(x, y, current));\n                    x = current[6];\n                    y = current[7];\n                    break;\n                case \"z\":\n                case \"Z\":\n                    x = x1;\n                    y = y1;\n                    break;\n                default:\n            }\n            if (!converted) {\n                destinationPath.push(current);\n            }\n            previous = current[0];\n        }\n        return destinationPath;\n    }\n    ;\n    /**\n   * Calc length from point x1,y1 to x2,y2\n   * @param {Number} x1 starting point x\n   * @param {Number} y1 starting point y\n   * @param {Number} x2 starting point x\n   * @param {Number} y2 starting point y\n   * @return {Number} length of segment\n   */ function calcLineLength(x1, y1, x2, y2) {\n        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    }\n    // functions for the Cubic beizer\n    // taken from: https://github.com/konvajs/konva/blob/7.0.5/src/shapes/Path.ts#L350\n    function CB1(t) {\n        return t * t * t;\n    }\n    function CB2(t) {\n        return 3 * t * t * (1 - t);\n    }\n    function CB3(t) {\n        return 3 * t * (1 - t) * (1 - t);\n    }\n    function CB4(t) {\n        return (1 - t) * (1 - t) * (1 - t);\n    }\n    function getPointOnCubicBezierIterator(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {\n        return function(pct) {\n            var c1 = CB1(pct), c2 = CB2(pct), c3 = CB3(pct), c4 = CB4(pct);\n            return {\n                x: p4x * c1 + p3x * c2 + p2x * c3 + p1x * c4,\n                y: p4y * c1 + p3y * c2 + p2y * c3 + p1y * c4\n            };\n        };\n    }\n    function getTangentCubicIterator(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {\n        return function(pct) {\n            var invT = 1 - pct, tangentX = 3 * invT * invT * (p2x - p1x) + 6 * invT * pct * (p3x - p2x) + 3 * pct * pct * (p4x - p3x), tangentY = 3 * invT * invT * (p2y - p1y) + 6 * invT * pct * (p3y - p2y) + 3 * pct * pct * (p4y - p3y);\n            return Math.atan2(tangentY, tangentX);\n        };\n    }\n    function QB1(t) {\n        return t * t;\n    }\n    function QB2(t) {\n        return 2 * t * (1 - t);\n    }\n    function QB3(t) {\n        return (1 - t) * (1 - t);\n    }\n    function getPointOnQuadraticBezierIterator(p1x, p1y, p2x, p2y, p3x, p3y) {\n        return function(pct) {\n            var c1 = QB1(pct), c2 = QB2(pct), c3 = QB3(pct);\n            return {\n                x: p3x * c1 + p2x * c2 + p1x * c3,\n                y: p3y * c1 + p2y * c2 + p1y * c3\n            };\n        };\n    }\n    function getTangentQuadraticIterator(p1x, p1y, p2x, p2y, p3x, p3y) {\n        return function(pct) {\n            var invT = 1 - pct, tangentX = 2 * invT * (p2x - p1x) + 2 * pct * (p3x - p2x), tangentY = 2 * invT * (p2y - p1y) + 2 * pct * (p3y - p2y);\n            return Math.atan2(tangentY, tangentX);\n        };\n    }\n    // this will run over a path segment ( a cubic or quadratic segment) and approximate it\n    // with 100 segemnts. This will good enough to calculate the length of the curve\n    function pathIterator(iterator, x1, y1) {\n        var tempP = {\n            x: x1,\n            y: y1\n        }, p, tmpLen = 0, perc;\n        for(perc = 1; perc <= 100; perc += 1){\n            p = iterator(perc / 100);\n            tmpLen += calcLineLength(tempP.x, tempP.y, p.x, p.y);\n            tempP = p;\n        }\n        return tmpLen;\n    }\n    /**\n   * Given a pathInfo, and a distance in pixels, find the percentage from 0 to 1\n   * that correspond to that pixels run over the path.\n   * The percentage will be then used to find the correct point on the canvas for the path.\n   * @param {Array} segInfo fabricJS collection of information on a parsed path\n   * @param {Number} distance from starting point, in pixels.\n   * @return {Object} info object with x and y ( the point on canvas ) and angle, the tangent on that point;\n   */ function findPercentageForDistance(segInfo, distance) {\n        var perc = 0, tmpLen = 0, iterator = segInfo.iterator, tempP = {\n            x: segInfo.x,\n            y: segInfo.y\n        }, p, nextLen, nextStep = 0.01, angleFinder = segInfo.angleFinder, lastPerc;\n        // nextStep > 0.0001 covers 0.00015625 that 1/64th of 1/100\n        // the path\n        while(tmpLen < distance && nextStep > 0.0001){\n            p = iterator(perc);\n            lastPerc = perc;\n            nextLen = calcLineLength(tempP.x, tempP.y, p.x, p.y);\n            // compare tmpLen each cycle with distance, decide next perc to test.\n            if (nextLen + tmpLen > distance) {\n                // we discard this step and we make smaller steps.\n                perc -= nextStep;\n                nextStep /= 2;\n            } else {\n                tempP = p;\n                perc += nextStep;\n                tmpLen += nextLen;\n            }\n        }\n        p.angle = angleFinder(lastPerc);\n        return p;\n    }\n    /**\n   * Run over a parsed and simplifed path and extrac some informations.\n   * informations are length of each command and starting point\n   * @param {Array} path fabricJS parsed path commands\n   * @return {Array} path commands informations\n   */ function getPathSegmentsInfo(path) {\n        var totalLength = 0, len = path.length, current, //x2 and y2 are the coords of segment start\n        //x1 and y1 are the coords of the current point\n        x1 = 0, y1 = 0, x2 = 0, y2 = 0, info = [], iterator, tempInfo, angleFinder;\n        for(var i = 0; i < len; i++){\n            current = path[i];\n            tempInfo = {\n                x: x1,\n                y: y1,\n                command: current[0]\n            };\n            switch(current[0]){\n                case \"M\":\n                    tempInfo.length = 0;\n                    x2 = x1 = current[1];\n                    y2 = y1 = current[2];\n                    break;\n                case \"L\":\n                    tempInfo.length = calcLineLength(x1, y1, current[1], current[2]);\n                    x1 = current[1];\n                    y1 = current[2];\n                    break;\n                case \"C\":\n                    iterator = getPointOnCubicBezierIterator(x1, y1, current[1], current[2], current[3], current[4], current[5], current[6]);\n                    angleFinder = getTangentCubicIterator(x1, y1, current[1], current[2], current[3], current[4], current[5], current[6]);\n                    tempInfo.iterator = iterator;\n                    tempInfo.angleFinder = angleFinder;\n                    tempInfo.length = pathIterator(iterator, x1, y1);\n                    x1 = current[5];\n                    y1 = current[6];\n                    break;\n                case \"Q\":\n                    iterator = getPointOnQuadraticBezierIterator(x1, y1, current[1], current[2], current[3], current[4]);\n                    angleFinder = getTangentQuadraticIterator(x1, y1, current[1], current[2], current[3], current[4]);\n                    tempInfo.iterator = iterator;\n                    tempInfo.angleFinder = angleFinder;\n                    tempInfo.length = pathIterator(iterator, x1, y1);\n                    x1 = current[3];\n                    y1 = current[4];\n                    break;\n                case \"Z\":\n                case \"z\":\n                    // we add those in order to ease calculations later\n                    tempInfo.destX = x2;\n                    tempInfo.destY = y2;\n                    tempInfo.length = calcLineLength(x1, y1, x2, y2);\n                    x1 = x2;\n                    y1 = y2;\n                    break;\n            }\n            totalLength += tempInfo.length;\n            info.push(tempInfo);\n        }\n        info.push({\n            length: totalLength,\n            x: x1,\n            y: y1\n        });\n        return info;\n    }\n    function getPointOnPath(path, distance, infos) {\n        if (!infos) {\n            infos = getPathSegmentsInfo(path);\n        }\n        var i = 0;\n        while(distance - infos[i].length > 0 && i < infos.length - 2){\n            distance -= infos[i].length;\n            i++;\n        }\n        // var distance = infos[infos.length - 1] * perc;\n        var segInfo = infos[i], segPercent = distance / segInfo.length, command = segInfo.command, segment = path[i], info;\n        switch(command){\n            case \"M\":\n                return {\n                    x: segInfo.x,\n                    y: segInfo.y,\n                    angle: 0\n                };\n            case \"Z\":\n            case \"z\":\n                info = new fabric.Point(segInfo.x, segInfo.y).lerp(new fabric.Point(segInfo.destX, segInfo.destY), segPercent);\n                info.angle = Math.atan2(segInfo.destY - segInfo.y, segInfo.destX - segInfo.x);\n                return info;\n            case \"L\":\n                info = new fabric.Point(segInfo.x, segInfo.y).lerp(new fabric.Point(segment[1], segment[2]), segPercent);\n                info.angle = Math.atan2(segment[2] - segInfo.y, segment[1] - segInfo.x);\n                return info;\n            case \"C\":\n                return findPercentageForDistance(segInfo, distance);\n            case \"Q\":\n                return findPercentageForDistance(segInfo, distance);\n        }\n    }\n    /**\n   *\n   * @param {string} pathString\n   * @return {(string|number)[][]} An array of SVG path commands\n   * @example <caption>Usage</caption>\n   * parsePath('M 3 4 Q 3 5 2 1 4 0 Q 9 12 2 1 4 0') === [\n   *   ['M', 3, 4],\n   *   ['Q', 3, 5, 2, 1, 4, 0],\n   *   ['Q', 9, 12, 2, 1, 4, 0],\n   * ];\n   *\n   */ function parsePath(pathString) {\n        var result = [], coords = [], currentPath, parsed, re = fabric.rePathCommand, rNumber = \"[-+]?(?:\\\\d*\\\\.\\\\d+|\\\\d+\\\\.?)(?:[eE][-+]?\\\\d+)?\\\\s*\", rNumberCommaWsp = \"(\" + rNumber + \")\" + fabric.commaWsp, rFlagCommaWsp = \"([01])\" + fabric.commaWsp + \"?\", rArcSeq = rNumberCommaWsp + \"?\" + rNumberCommaWsp + \"?\" + rNumberCommaWsp + rFlagCommaWsp + rFlagCommaWsp + rNumberCommaWsp + \"?(\" + rNumber + \")\", regArcArgumentSequence = new RegExp(rArcSeq, \"g\"), match, coordsStr, // one of commands (m,M,l,L,q,Q,c,C,etc.) followed by non-command characters (i.e. command values)\n        path;\n        if (!pathString || !pathString.match) {\n            return result;\n        }\n        path = pathString.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);\n        for(var i = 0, coordsParsed, len = path.length; i < len; i++){\n            currentPath = path[i];\n            coordsStr = currentPath.slice(1).trim();\n            coords.length = 0;\n            var command = currentPath.charAt(0);\n            coordsParsed = [\n                command\n            ];\n            if (command.toLowerCase() === \"a\") {\n                // arcs have special flags that apparently don't require spaces so handle special\n                for(var args; args = regArcArgumentSequence.exec(coordsStr);){\n                    for(var j = 1; j < args.length; j++){\n                        coords.push(args[j]);\n                    }\n                }\n            } else {\n                while(match = re.exec(coordsStr)){\n                    coords.push(match[0]);\n                }\n            }\n            for(var j = 0, jlen = coords.length; j < jlen; j++){\n                parsed = parseFloat(coords[j]);\n                if (!isNaN(parsed)) {\n                    coordsParsed.push(parsed);\n                }\n            }\n            var commandLength = commandLengths[command.toLowerCase()], repeatedCommand = repeatedCommands[command] || command;\n            if (coordsParsed.length - 1 > commandLength) {\n                for(var k = 1, klen = coordsParsed.length; k < klen; k += commandLength){\n                    result.push([\n                        command\n                    ].concat(coordsParsed.slice(k, k + commandLength)));\n                    command = repeatedCommand;\n                }\n            } else {\n                result.push(coordsParsed);\n            }\n        }\n        return result;\n    }\n    ;\n    /**\n   *\n   * Converts points to a smooth SVG path\n   * @param {{ x: number,y: number }[]} points Array of points\n   * @param {number} [correction] Apply a correction to the path (usually we use `width / 1000`). If value is undefined 0 is used as the correction value.\n   * @return {(string|number)[][]} An array of SVG path commands\n   */ function getSmoothPathFromPoints(points, correction) {\n        var path = [], i, p1 = new fabric.Point(points[0].x, points[0].y), p2 = new fabric.Point(points[1].x, points[1].y), len = points.length, multSignX = 1, multSignY = 0, manyPoints = len > 2;\n        correction = correction || 0;\n        if (manyPoints) {\n            multSignX = points[2].x < p2.x ? -1 : points[2].x === p2.x ? 0 : 1;\n            multSignY = points[2].y < p2.y ? -1 : points[2].y === p2.y ? 0 : 1;\n        }\n        path.push([\n            \"M\",\n            p1.x - multSignX * correction,\n            p1.y - multSignY * correction\n        ]);\n        for(i = 1; i < len; i++){\n            if (!p1.eq(p2)) {\n                var midPoint = p1.midPointFrom(p2);\n                // p1 is our bezier control point\n                // midpoint is our endpoint\n                // start point is p(i-1) value.\n                path.push([\n                    \"Q\",\n                    p1.x,\n                    p1.y,\n                    midPoint.x,\n                    midPoint.y\n                ]);\n            }\n            p1 = points[i];\n            if (i + 1 < points.length) {\n                p2 = points[i + 1];\n            }\n        }\n        if (manyPoints) {\n            multSignX = p1.x > points[i - 2].x ? 1 : p1.x === points[i - 2].x ? 0 : -1;\n            multSignY = p1.y > points[i - 2].y ? 1 : p1.y === points[i - 2].y ? 0 : -1;\n        }\n        path.push([\n            \"L\",\n            p1.x + multSignX * correction,\n            p1.y + multSignY * correction\n        ]);\n        return path;\n    }\n    /**\n   * Transform a path by transforming each segment.\n   * it has to be a simplified path or it won't work.\n   * WARNING: this depends from pathOffset for correct operation\n   * @param {Array} path fabricJS parsed and simplified path commands\n   * @param {Array} transform matrix that represent the transformation\n   * @param {Object} [pathOffset] the fabric.Path pathOffset\n   * @param {Number} pathOffset.x\n   * @param {Number} pathOffset.y\n   * @returns {Array} the transformed path\n   */ function transformPath(path, transform, pathOffset) {\n        if (pathOffset) {\n            transform = fabric.util.multiplyTransformMatrices(transform, [\n                1,\n                0,\n                0,\n                1,\n                -pathOffset.x,\n                -pathOffset.y\n            ]);\n        }\n        return path.map(function(pathSegment) {\n            var newSegment = pathSegment.slice(0), point = {};\n            for(var i = 1; i < pathSegment.length - 1; i += 2){\n                point.x = pathSegment[i];\n                point.y = pathSegment[i + 1];\n                point = fabric.util.transformPoint(point, transform);\n                newSegment[i] = point.x;\n                newSegment[i + 1] = point.y;\n            }\n            return newSegment;\n        });\n    }\n    /**\n   * Join path commands to go back to svg format\n   * @param {Array} pathData fabricJS parsed path commands\n   * @return {String} joined path 'M 0 0 L 20 30'\n   */ fabric.util.joinPath = function(pathData) {\n        return pathData.map(function(segment) {\n            return segment.join(\" \");\n        }).join(\" \");\n    };\n    fabric.util.parsePath = parsePath;\n    fabric.util.makePathSimpler = makePathSimpler;\n    fabric.util.getSmoothPathFromPoints = getSmoothPathFromPoints;\n    fabric.util.getPathSegmentsInfo = getPathSegmentsInfo;\n    fabric.util.getBoundsOfCurve = getBoundsOfCurve;\n    fabric.util.getPointOnPath = getPointOnPath;\n    fabric.util.transformPath = transformPath;\n})();\n(function() {\n    var slice = Array.prototype.slice;\n    /**\n   * Invokes method on all items in a given array\n   * @memberOf fabric.util.array\n   * @param {Array} array Array to iterate over\n   * @param {String} method Name of a method to invoke\n   * @return {Array}\n   */ function invoke(array, method) {\n        var args = slice.call(arguments, 2), result = [];\n        for(var i = 0, len = array.length; i < len; i++){\n            result[i] = args.length ? array[i][method].apply(array[i], args) : array[i][method].call(array[i]);\n        }\n        return result;\n    }\n    /**\n   * Finds maximum value in array (not necessarily \"first\" one)\n   * @memberOf fabric.util.array\n   * @param {Array} array Array to iterate over\n   * @param {String} byProperty\n   * @return {*}\n   */ function max(array, byProperty) {\n        return find(array, byProperty, function(value1, value2) {\n            return value1 >= value2;\n        });\n    }\n    /**\n   * Finds minimum value in array (not necessarily \"first\" one)\n   * @memberOf fabric.util.array\n   * @param {Array} array Array to iterate over\n   * @param {String} byProperty\n   * @return {*}\n   */ function min(array, byProperty) {\n        return find(array, byProperty, function(value1, value2) {\n            return value1 < value2;\n        });\n    }\n    /**\n   * @private\n   */ function fill(array, value) {\n        var k = array.length;\n        while(k--){\n            array[k] = value;\n        }\n        return array;\n    }\n    /**\n   * @private\n   */ function find(array, byProperty, condition) {\n        if (!array || array.length === 0) {\n            return;\n        }\n        var i = array.length - 1, result = byProperty ? array[i][byProperty] : array[i];\n        if (byProperty) {\n            while(i--){\n                if (condition(array[i][byProperty], result)) {\n                    result = array[i][byProperty];\n                }\n            }\n        } else {\n            while(i--){\n                if (condition(array[i], result)) {\n                    result = array[i];\n                }\n            }\n        }\n        return result;\n    }\n    /**\n   * @namespace fabric.util.array\n   */ fabric.util.array = {\n        fill: fill,\n        invoke: invoke,\n        min: min,\n        max: max\n    };\n})();\n(function() {\n    /**\n   * Copies all enumerable properties of one js object to another\n   * this does not and cannot compete with generic utils.\n   * Does not clone or extend fabric.Object subclasses.\n   * This is mostly for internal use and has extra handling for fabricJS objects\n   * it skips the canvas and group properties in deep cloning.\n   * @memberOf fabric.util.object\n   * @param {Object} destination Where to copy to\n   * @param {Object} source Where to copy from\n   * @param {Boolean} [deep] Whether to extend nested objects\n   * @return {Object}\n   */ function extend(destination, source, deep) {\n        // JScript DontEnum bug is not taken care of\n        // the deep clone is for internal use, is not meant to avoid\n        // javascript traps or cloning html element or self referenced objects.\n        if (deep) {\n            if (!fabric.isLikelyNode && source instanceof Element) {\n                // avoid cloning deep images, canvases,\n                destination = source;\n            } else if (source instanceof Array) {\n                destination = [];\n                for(var i = 0, len = source.length; i < len; i++){\n                    destination[i] = extend({}, source[i], deep);\n                }\n            } else if (source && typeof source === \"object\") {\n                for(var property in source){\n                    if (property === \"canvas\" || property === \"group\") {\n                        // we do not want to clone this props at all.\n                        // we want to keep the keys in the copy\n                        destination[property] = null;\n                    } else if (source.hasOwnProperty(property)) {\n                        destination[property] = extend({}, source[property], deep);\n                    }\n                }\n            } else {\n                // this sounds odd for an extend but is ok for recursive use\n                destination = source;\n            }\n        } else {\n            for(var property in source){\n                destination[property] = source[property];\n            }\n        }\n        return destination;\n    }\n    /**\n   * Creates an empty object and copies all enumerable properties of another object to it\n   * This method is mostly for internal use, and not intended for duplicating shapes in canvas. \n   * @memberOf fabric.util.object\n   * @param {Object} object Object to clone\n   * @param {Boolean} [deep] Whether to clone nested objects\n   * @return {Object}\n   */ //TODO: this function return an empty object if you try to clone null\n    function clone(object, deep) {\n        return extend({}, object, deep);\n    }\n    /** @namespace fabric.util.object */ fabric.util.object = {\n        extend: extend,\n        clone: clone\n    };\n    fabric.util.object.extend(fabric.util, fabric.Observable);\n})();\n(function() {\n    /**\n   * Camelizes a string\n   * @memberOf fabric.util.string\n   * @param {String} string String to camelize\n   * @return {String} Camelized version of a string\n   */ function camelize(string) {\n        return string.replace(/-+(.)?/g, function(match, character) {\n            return character ? character.toUpperCase() : \"\";\n        });\n    }\n    /**\n   * Capitalizes a string\n   * @memberOf fabric.util.string\n   * @param {String} string String to capitalize\n   * @param {Boolean} [firstLetterOnly] If true only first letter is capitalized\n   * and other letters stay untouched, if false first letter is capitalized\n   * and other letters are converted to lowercase.\n   * @return {String} Capitalized version of a string\n   */ function capitalize(string, firstLetterOnly) {\n        return string.charAt(0).toUpperCase() + (firstLetterOnly ? string.slice(1) : string.slice(1).toLowerCase());\n    }\n    /**\n   * Escapes XML in a string\n   * @memberOf fabric.util.string\n   * @param {String} string String to escape\n   * @return {String} Escaped version of a string\n   */ function escapeXml(string) {\n        return string.replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&apos;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n    }\n    /**\n   * Divide a string in the user perceived single units\n   * @memberOf fabric.util.string\n   * @param {String} textstring String to escape\n   * @return {Array} array containing the graphemes\n   */ function graphemeSplit(textstring) {\n        var i = 0, chr, graphemes = [];\n        for(i = 0, chr; i < textstring.length; i++){\n            if ((chr = getWholeChar(textstring, i)) === false) {\n                continue;\n            }\n            graphemes.push(chr);\n        }\n        return graphemes;\n    }\n    // taken from mdn in the charAt doc page.\n    function getWholeChar(str, i) {\n        var code = str.charCodeAt(i);\n        if (isNaN(code)) {\n            return \"\"; // Position not found\n        }\n        if (code < 0xD800 || code > 0xDFFF) {\n            return str.charAt(i);\n        }\n        // High surrogate (could change last hex to 0xDB7F to treat high private\n        // surrogates as single characters)\n        if (0xD800 <= code && code <= 0xDBFF) {\n            if (str.length <= i + 1) {\n                throw \"High surrogate without following low surrogate\";\n            }\n            var next = str.charCodeAt(i + 1);\n            if (0xDC00 > next || next > 0xDFFF) {\n                throw \"High surrogate without following low surrogate\";\n            }\n            return str.charAt(i) + str.charAt(i + 1);\n        }\n        // Low surrogate (0xDC00 <= code && code <= 0xDFFF)\n        if (i === 0) {\n            throw \"Low surrogate without preceding high surrogate\";\n        }\n        var prev = str.charCodeAt(i - 1);\n        // (could change last hex to 0xDB7F to treat high private\n        // surrogates as single characters)\n        if (0xD800 > prev || prev > 0xDBFF) {\n            throw \"Low surrogate without preceding high surrogate\";\n        }\n        // We can pass over low surrogates now as the second component\n        // in a pair which we have already processed\n        return false;\n    }\n    /**\n   * String utilities\n   * @namespace fabric.util.string\n   */ fabric.util.string = {\n        camelize: camelize,\n        capitalize: capitalize,\n        escapeXml: escapeXml,\n        graphemeSplit: graphemeSplit\n    };\n})();\n(function() {\n    var slice = Array.prototype.slice, emptyFunction = function() {}, IS_DONTENUM_BUGGY = function() {\n        for(var p in {\n            toString: 1\n        }){\n            if (p === \"toString\") {\n                return false;\n            }\n        }\n        return true;\n    }(), /** @ignore */ addMethods = function(klass, source, parent) {\n        for(var property in source){\n            if (property in klass.prototype && typeof klass.prototype[property] === \"function\" && (source[property] + \"\").indexOf(\"callSuper\") > -1) {\n                klass.prototype[property] = function(property) {\n                    return function() {\n                        var superclass = this.constructor.superclass;\n                        this.constructor.superclass = parent;\n                        var returnValue = source[property].apply(this, arguments);\n                        this.constructor.superclass = superclass;\n                        if (property !== \"initialize\") {\n                            return returnValue;\n                        }\n                    };\n                }(property);\n            } else {\n                klass.prototype[property] = source[property];\n            }\n            if (IS_DONTENUM_BUGGY) {\n                if (source.toString !== Object.prototype.toString) {\n                    klass.prototype.toString = source.toString;\n                }\n                if (source.valueOf !== Object.prototype.valueOf) {\n                    klass.prototype.valueOf = source.valueOf;\n                }\n            }\n        }\n    };\n    function Subclass() {}\n    function callSuper(methodName) {\n        var parentMethod = null, _this = this;\n        // climb prototype chain to find method not equal to callee's method\n        while(_this.constructor.superclass){\n            var superClassMethod = _this.constructor.superclass.prototype[methodName];\n            if (_this[methodName] !== superClassMethod) {\n                parentMethod = superClassMethod;\n                break;\n            }\n            // eslint-disable-next-line\n            _this = _this.constructor.superclass.prototype;\n        }\n        if (!parentMethod) {\n            return console.log(\"tried to callSuper \" + methodName + \", method not found in prototype chain\", this);\n        }\n        return arguments.length > 1 ? parentMethod.apply(this, slice.call(arguments, 1)) : parentMethod.call(this);\n    }\n    /**\n   * Helper for creation of \"classes\".\n   * @memberOf fabric.util\n   * @param {Function} [parent] optional \"Class\" to inherit from\n   * @param {Object} [properties] Properties shared by all instances of this class\n   *                  (be careful modifying objects defined here as this would affect all instances)\n   */ function createClass() {\n        var parent = null, properties = slice.call(arguments, 0);\n        if (typeof properties[0] === \"function\") {\n            parent = properties.shift();\n        }\n        function klass() {\n            this.initialize.apply(this, arguments);\n        }\n        klass.superclass = parent;\n        klass.subclasses = [];\n        if (parent) {\n            Subclass.prototype = parent.prototype;\n            klass.prototype = new Subclass();\n            parent.subclasses.push(klass);\n        }\n        for(var i = 0, length = properties.length; i < length; i++){\n            addMethods(klass, properties[i], parent);\n        }\n        if (!klass.prototype.initialize) {\n            klass.prototype.initialize = emptyFunction;\n        }\n        klass.prototype.constructor = klass;\n        klass.prototype.callSuper = callSuper;\n        return klass;\n    }\n    fabric.util.createClass = createClass;\n})();\n(function() {\n    // since ie11 can use addEventListener but they do not support options, i need to check\n    var couldUseAttachEvent = !!fabric.document.createElement(\"div\").attachEvent, touchEvents = [\n        \"touchstart\",\n        \"touchmove\",\n        \"touchend\"\n    ];\n    /**\n   * Adds an event listener to an element\n   * @function\n   * @memberOf fabric.util\n   * @param {HTMLElement} element\n   * @param {String} eventName\n   * @param {Function} handler\n   */ fabric.util.addListener = function(element, eventName, handler, options) {\n        element && element.addEventListener(eventName, handler, couldUseAttachEvent ? false : options);\n    };\n    /**\n   * Removes an event listener from an element\n   * @function\n   * @memberOf fabric.util\n   * @param {HTMLElement} element\n   * @param {String} eventName\n   * @param {Function} handler\n   */ fabric.util.removeListener = function(element, eventName, handler, options) {\n        element && element.removeEventListener(eventName, handler, couldUseAttachEvent ? false : options);\n    };\n    function getTouchInfo(event) {\n        var touchProp = event.changedTouches;\n        if (touchProp && touchProp[0]) {\n            return touchProp[0];\n        }\n        return event;\n    }\n    fabric.util.getPointer = function(event) {\n        var element = event.target, scroll = fabric.util.getScrollLeftTop(element), _evt = getTouchInfo(event);\n        return {\n            x: _evt.clientX + scroll.left,\n            y: _evt.clientY + scroll.top\n        };\n    };\n    fabric.util.isTouchEvent = function(event) {\n        return touchEvents.indexOf(event.type) > -1 || event.pointerType === \"touch\";\n    };\n})();\n(function() {\n    /**\n   * Cross-browser wrapper for setting element's style\n   * @memberOf fabric.util\n   * @param {HTMLElement} element\n   * @param {Object} styles\n   * @return {HTMLElement} Element that was passed as a first argument\n   */ function setStyle(element, styles) {\n        var elementStyle = element.style;\n        if (!elementStyle) {\n            return element;\n        }\n        if (typeof styles === \"string\") {\n            element.style.cssText += \";\" + styles;\n            return styles.indexOf(\"opacity\") > -1 ? setOpacity(element, styles.match(/opacity:\\s*(\\d?\\.?\\d*)/)[1]) : element;\n        }\n        for(var property in styles){\n            if (property === \"opacity\") {\n                setOpacity(element, styles[property]);\n            } else {\n                var normalizedProperty = property === \"float\" || property === \"cssFloat\" ? typeof elementStyle.styleFloat === \"undefined\" ? \"cssFloat\" : \"styleFloat\" : property;\n                elementStyle.setProperty(normalizedProperty, styles[property]);\n            }\n        }\n        return element;\n    }\n    var parseEl = fabric.document.createElement(\"div\"), supportsOpacity = typeof parseEl.style.opacity === \"string\", supportsFilters = typeof parseEl.style.filter === \"string\", reOpacity = /alpha\\s*\\(\\s*opacity\\s*=\\s*([^\\)]+)\\)/, /** @ignore */ setOpacity = function(element) {\n        return element;\n    };\n    if (supportsOpacity) {\n        /** @ignore */ setOpacity = function(element, value) {\n            element.style.opacity = value;\n            return element;\n        };\n    } else if (supportsFilters) {\n        /** @ignore */ setOpacity = function(element, value) {\n            var es = element.style;\n            if (element.currentStyle && !element.currentStyle.hasLayout) {\n                es.zoom = 1;\n            }\n            if (reOpacity.test(es.filter)) {\n                value = value >= 0.9999 ? \"\" : \"alpha(opacity=\" + value * 100 + \")\";\n                es.filter = es.filter.replace(reOpacity, value);\n            } else {\n                es.filter += \" alpha(opacity=\" + value * 100 + \")\";\n            }\n            return element;\n        };\n    }\n    fabric.util.setStyle = setStyle;\n})();\n(function() {\n    var _slice = Array.prototype.slice;\n    /**\n   * Takes id and returns an element with that id (if one exists in a document)\n   * @memberOf fabric.util\n   * @param {String|HTMLElement} id\n   * @return {HTMLElement|null}\n   */ function getById(id) {\n        return typeof id === \"string\" ? fabric.document.getElementById(id) : id;\n    }\n    var sliceCanConvertNodelists, /**\n       * Converts an array-like object (e.g. arguments or NodeList) to an array\n       * @memberOf fabric.util\n       * @param {Object} arrayLike\n       * @return {Array}\n       */ toArray = function(arrayLike) {\n        return _slice.call(arrayLike, 0);\n    };\n    try {\n        sliceCanConvertNodelists = toArray(fabric.document.childNodes) instanceof Array;\n    } catch (err) {}\n    if (!sliceCanConvertNodelists) {\n        toArray = function(arrayLike) {\n            var arr = new Array(arrayLike.length), i = arrayLike.length;\n            while(i--){\n                arr[i] = arrayLike[i];\n            }\n            return arr;\n        };\n    }\n    /**\n   * Creates specified element with specified attributes\n   * @memberOf fabric.util\n   * @param {String} tagName Type of an element to create\n   * @param {Object} [attributes] Attributes to set on an element\n   * @return {HTMLElement} Newly created element\n   */ function makeElement(tagName, attributes) {\n        var el = fabric.document.createElement(tagName);\n        for(var prop in attributes){\n            if (prop === \"class\") {\n                el.className = attributes[prop];\n            } else if (prop === \"for\") {\n                el.htmlFor = attributes[prop];\n            } else {\n                el.setAttribute(prop, attributes[prop]);\n            }\n        }\n        return el;\n    }\n    /**\n   * Adds class to an element\n   * @memberOf fabric.util\n   * @param {HTMLElement} element Element to add class to\n   * @param {String} className Class to add to an element\n   */ function addClass(element, className) {\n        if (element && (\" \" + element.className + \" \").indexOf(\" \" + className + \" \") === -1) {\n            element.className += (element.className ? \" \" : \"\") + className;\n        }\n    }\n    /**\n   * Wraps element with another element\n   * @memberOf fabric.util\n   * @param {HTMLElement} element Element to wrap\n   * @param {HTMLElement|String} wrapper Element to wrap with\n   * @param {Object} [attributes] Attributes to set on a wrapper\n   * @return {HTMLElement} wrapper\n   */ function wrapElement(element, wrapper, attributes) {\n        if (typeof wrapper === \"string\") {\n            wrapper = makeElement(wrapper, attributes);\n        }\n        if (element.parentNode) {\n            element.parentNode.replaceChild(wrapper, element);\n        }\n        wrapper.appendChild(element);\n        return wrapper;\n    }\n    /**\n   * Returns element scroll offsets\n   * @memberOf fabric.util\n   * @param {HTMLElement} element Element to operate on\n   * @return {Object} Object with left/top values\n   */ function getScrollLeftTop(element) {\n        var left = 0, top = 0, docElement = fabric.document.documentElement, body = fabric.document.body || {\n            scrollLeft: 0,\n            scrollTop: 0\n        };\n        // While loop checks (and then sets element to) .parentNode OR .host\n        //  to account for ShadowDOM. We still want to traverse up out of ShadowDOM,\n        //  but the .parentNode of a root ShadowDOM node will always be null, instead\n        //  it should be accessed through .host. See http://stackoverflow.com/a/24765528/4383938\n        while(element && (element.parentNode || element.host)){\n            // Set element to element parent, or 'host' in case of ShadowDOM\n            element = element.parentNode || element.host;\n            if (element === fabric.document) {\n                left = body.scrollLeft || docElement.scrollLeft || 0;\n                top = body.scrollTop || docElement.scrollTop || 0;\n            } else {\n                left += element.scrollLeft || 0;\n                top += element.scrollTop || 0;\n            }\n            if (element.nodeType === 1 && element.style.position === \"fixed\") {\n                break;\n            }\n        }\n        return {\n            left: left,\n            top: top\n        };\n    }\n    /**\n   * Returns offset for a given element\n   * @function\n   * @memberOf fabric.util\n   * @param {HTMLElement} element Element to get offset for\n   * @return {Object} Object with \"left\" and \"top\" properties\n   */ function getElementOffset(element) {\n        var docElem, doc = element && element.ownerDocument, box = {\n            left: 0,\n            top: 0\n        }, offset = {\n            left: 0,\n            top: 0\n        }, scrollLeftTop, offsetAttributes = {\n            borderLeftWidth: \"left\",\n            borderTopWidth: \"top\",\n            paddingLeft: \"left\",\n            paddingTop: \"top\"\n        };\n        if (!doc) {\n            return offset;\n        }\n        for(var attr in offsetAttributes){\n            offset[offsetAttributes[attr]] += parseInt(getElementStyle(element, attr), 10) || 0;\n        }\n        docElem = doc.documentElement;\n        if (typeof element.getBoundingClientRect !== \"undefined\") {\n            box = element.getBoundingClientRect();\n        }\n        scrollLeftTop = getScrollLeftTop(element);\n        return {\n            left: box.left + scrollLeftTop.left - (docElem.clientLeft || 0) + offset.left,\n            top: box.top + scrollLeftTop.top - (docElem.clientTop || 0) + offset.top\n        };\n    }\n    /**\n   * Returns style attribute value of a given element\n   * @memberOf fabric.util\n   * @param {HTMLElement} element Element to get style attribute for\n   * @param {String} attr Style attribute to get for element\n   * @return {String} Style attribute value of the given element.\n   */ var getElementStyle;\n    if (fabric.document.defaultView && fabric.document.defaultView.getComputedStyle) {\n        getElementStyle = function(element, attr) {\n            var style = fabric.document.defaultView.getComputedStyle(element, null);\n            return style ? style[attr] : undefined;\n        };\n    } else {\n        getElementStyle = function(element, attr) {\n            var value = element.style[attr];\n            if (!value && element.currentStyle) {\n                value = element.currentStyle[attr];\n            }\n            return value;\n        };\n    }\n    (function() {\n        var style = fabric.document.documentElement.style, selectProp = \"userSelect\" in style ? \"userSelect\" : \"MozUserSelect\" in style ? \"MozUserSelect\" : \"WebkitUserSelect\" in style ? \"WebkitUserSelect\" : \"KhtmlUserSelect\" in style ? \"KhtmlUserSelect\" : \"\";\n        /**\n     * Makes element unselectable\n     * @memberOf fabric.util\n     * @param {HTMLElement} element Element to make unselectable\n     * @return {HTMLElement} Element that was passed in\n     */ function makeElementUnselectable(element) {\n            if (typeof element.onselectstart !== \"undefined\") {\n                element.onselectstart = fabric.util.falseFunction;\n            }\n            if (selectProp) {\n                element.style[selectProp] = \"none\";\n            } else if (typeof element.unselectable === \"string\") {\n                element.unselectable = \"on\";\n            }\n            return element;\n        }\n        /**\n     * Makes element selectable\n     * @memberOf fabric.util\n     * @param {HTMLElement} element Element to make selectable\n     * @return {HTMLElement} Element that was passed in\n     */ function makeElementSelectable(element) {\n            if (typeof element.onselectstart !== \"undefined\") {\n                element.onselectstart = null;\n            }\n            if (selectProp) {\n                element.style[selectProp] = \"\";\n            } else if (typeof element.unselectable === \"string\") {\n                element.unselectable = \"\";\n            }\n            return element;\n        }\n        fabric.util.makeElementUnselectable = makeElementUnselectable;\n        fabric.util.makeElementSelectable = makeElementSelectable;\n    })();\n    function getNodeCanvas(element) {\n        var impl = fabric.jsdomImplForWrapper(element);\n        return impl._canvas || impl._image;\n    }\n    ;\n    function cleanUpJsdomNode(element) {\n        if (!fabric.isLikelyNode) {\n            return;\n        }\n        var impl = fabric.jsdomImplForWrapper(element);\n        if (impl) {\n            impl._image = null;\n            impl._canvas = null;\n            // unsure if necessary\n            impl._currentSrc = null;\n            impl._attributes = null;\n            impl._classList = null;\n        }\n    }\n    function setImageSmoothing(ctx, value) {\n        ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled || ctx.webkitImageSmoothingEnabled || ctx.mozImageSmoothingEnabled || ctx.msImageSmoothingEnabled || ctx.oImageSmoothingEnabled;\n        ctx.imageSmoothingEnabled = value;\n    }\n    /**\n   * setImageSmoothing sets the context imageSmoothingEnabled property.\n   * Used by canvas and by ImageObject.\n   * @memberOf fabric.util\n   * @since 4.0.0\n   * @param {HTMLRenderingContext2D} ctx to set on\n   * @param {Boolean} value true or false\n   */ fabric.util.setImageSmoothing = setImageSmoothing;\n    fabric.util.getById = getById;\n    fabric.util.toArray = toArray;\n    fabric.util.addClass = addClass;\n    fabric.util.makeElement = makeElement;\n    fabric.util.wrapElement = wrapElement;\n    fabric.util.getScrollLeftTop = getScrollLeftTop;\n    fabric.util.getElementOffset = getElementOffset;\n    fabric.util.getNodeCanvas = getNodeCanvas;\n    fabric.util.cleanUpJsdomNode = cleanUpJsdomNode;\n})();\n(function() {\n    function addParamToUrl(url, param) {\n        return url + (/\\?/.test(url) ? \"&\" : \"?\") + param;\n    }\n    function emptyFn() {}\n    /**\n   * Cross-browser abstraction for sending XMLHttpRequest\n   * @memberOf fabric.util\n   * @param {String} url URL to send XMLHttpRequest to\n   * @param {Object} [options] Options object\n   * @param {String} [options.method=\"GET\"]\n   * @param {String} [options.parameters] parameters to append to url in GET or in body\n   * @param {String} [options.body] body to send with POST or PUT request\n   * @param {Function} options.onComplete Callback to invoke when request is completed\n   * @return {XMLHttpRequest} request\n   */ function request(url, options) {\n        options || (options = {});\n        var method = options.method ? options.method.toUpperCase() : \"GET\", onComplete = options.onComplete || function() {}, xhr = new fabric.window.XMLHttpRequest(), body = options.body || options.parameters;\n        /** @ignore */ xhr.onreadystatechange = function() {\n            if (xhr.readyState === 4) {\n                onComplete(xhr);\n                xhr.onreadystatechange = emptyFn;\n            }\n        };\n        if (method === \"GET\") {\n            body = null;\n            if (typeof options.parameters === \"string\") {\n                url = addParamToUrl(url, options.parameters);\n            }\n        }\n        xhr.open(method, url, true);\n        if (method === \"POST\" || method === \"PUT\") {\n            xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        }\n        xhr.send(body);\n        return xhr;\n    }\n    fabric.util.request = request;\n})();\n/**\n * Wrapper around `console.log` (when available)\n * @param {*} [values] Values to log\n */ fabric.log = console.log;\n/**\n * Wrapper around `console.warn` (when available)\n * @param {*} [values] Values to log as a warning\n */ fabric.warn = console.warn;\n(function() {\n    var extend = fabric.util.object.extend, clone = fabric.util.object.clone;\n    /**\n   * @typedef {Object} AnimationOptions\n   * Animation of a value or list of values.\n   * When using lists, think of something like this:\n   * fabric.util.animate({\n   *   startValue: [1, 2, 3],\n   *   endValue: [2, 4, 6],\n   *   onChange: function([a, b, c]) {\n   *     canvas.zoomToPoint({x: b, y: c}, a)\n   *     canvas.renderAll()\n   *   }\n   * });\n   * @example\n   * @property {Function} [onChange] Callback; invoked on every value change\n   * @property {Function} [onComplete] Callback; invoked when value change is completed\n   * @example\n   * // Note: startValue, endValue, and byValue must match the type\n   * var animationOptions = { startValue: 0, endValue: 1, byValue: 0.25 }\n   * var animationOptions = { startValue: [0, 1], endValue: [1, 2], byValue: [0.25, 0.25] }\n   * @property {number | number[]} [startValue=0] Starting value\n   * @property {number | number[]} [endValue=100] Ending value\n   * @property {number | number[]} [byValue=100] Value to modify the property by\n   * @property {Function} [easing] Easing function\n   * @property {Number} [duration=500] Duration of change (in ms)\n   * @property {Function} [abort] Additional function with logic. If returns true, animation aborts.\n   *\n   * @typedef {() => void} CancelFunction\n   *\n   * @typedef {Object} AnimationCurrentState\n   * @property {number | number[]} currentValue value in range [`startValue`, `endValue`]\n   * @property {number} completionRate value in range [0, 1]\n   * @property {number} durationRate value in range [0, 1]\n   *\n   * @typedef {(AnimationOptions & AnimationCurrentState & { cancel: CancelFunction }} AnimationContext\n   */ /**\n   * Array holding all running animations\n   * @memberof fabric\n   * @type {AnimationContext[]}\n   */ var RUNNING_ANIMATIONS = [];\n    fabric.util.object.extend(RUNNING_ANIMATIONS, {\n        /**\n     * cancel all running animations at the next requestAnimFrame\n     * @returns {AnimationContext[]}\n     */ cancelAll: function() {\n            var animations = this.splice(0);\n            animations.forEach(function(animation) {\n                animation.cancel();\n            });\n            return animations;\n        },\n        /**\n     * cancel all running animations attached to canvas at the next requestAnimFrame\n     * @param {fabric.Canvas} canvas\n     * @returns {AnimationContext[]}\n     */ cancelByCanvas: function(canvas) {\n            if (!canvas) {\n                return [];\n            }\n            var cancelled = this.filter(function(animation) {\n                return typeof animation.target === \"object\" && animation.target.canvas === canvas;\n            });\n            cancelled.forEach(function(animation) {\n                animation.cancel();\n            });\n            return cancelled;\n        },\n        /**\n     * cancel all running animations for target at the next requestAnimFrame\n     * @param {*} target\n     * @returns {AnimationContext[]}\n     */ cancelByTarget: function(target) {\n            var cancelled = this.findAnimationsByTarget(target);\n            cancelled.forEach(function(animation) {\n                animation.cancel();\n            });\n            return cancelled;\n        },\n        /**\n     *\n     * @param {CancelFunction} cancelFunc the function returned by animate\n     * @returns {number}\n     */ findAnimationIndex: function(cancelFunc) {\n            return this.indexOf(this.findAnimation(cancelFunc));\n        },\n        /**\n     *\n     * @param {CancelFunction} cancelFunc the function returned by animate\n     * @returns {AnimationContext | undefined} animation's options object\n     */ findAnimation: function(cancelFunc) {\n            return this.find(function(animation) {\n                return animation.cancel === cancelFunc;\n            });\n        },\n        /**\n     *\n     * @param {*} target the object that is assigned to the target property of the animation context\n     * @returns {AnimationContext[]} array of animation options object associated with target\n     */ findAnimationsByTarget: function(target) {\n            if (!target) {\n                return [];\n            }\n            return this.filter(function(animation) {\n                return animation.target === target;\n            });\n        }\n    });\n    function noop() {\n        return false;\n    }\n    function defaultEasing(t, b, c, d) {\n        return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;\n    }\n    /**\n   * Changes value from one to another within certain period of time, invoking callbacks as value is being changed.\n   * @memberOf fabric.util\n   * @param {AnimationOptions} [options] Animation options\n   * @example\n   * // Note: startValue, endValue, and byValue must match the type\n   * fabric.util.animate({ startValue: 0, endValue: 1, byValue: 0.25 })\n   * fabric.util.animate({ startValue: [0, 1], endValue: [1, 2], byValue: [0.25, 0.25] })\n   * @returns {CancelFunction} cancel function\n   */ function animate(options) {\n        options || (options = {});\n        var cancel = false, context, removeFromRegistry = function() {\n            var index = fabric.runningAnimations.indexOf(context);\n            return index > -1 && fabric.runningAnimations.splice(index, 1)[0];\n        };\n        context = extend(clone(options), {\n            cancel: function() {\n                cancel = true;\n                return removeFromRegistry();\n            },\n            currentValue: \"startValue\" in options ? options.startValue : 0,\n            completionRate: 0,\n            durationRate: 0\n        });\n        fabric.runningAnimations.push(context);\n        requestAnimFrame(function(timestamp) {\n            var start = timestamp || +new Date(), duration = options.duration || 500, finish = start + duration, time, onChange = options.onChange || noop, abort = options.abort || noop, onComplete = options.onComplete || noop, easing = options.easing || defaultEasing, isMany = \"startValue\" in options ? options.startValue.length > 0 : false, startValue = \"startValue\" in options ? options.startValue : 0, endValue = \"endValue\" in options ? options.endValue : 100, byValue = options.byValue || (isMany ? startValue.map(function(value, i) {\n                return endValue[i] - startValue[i];\n            }) : endValue - startValue);\n            options.onStart && options.onStart();\n            (function tick(ticktime) {\n                time = ticktime || +new Date();\n                var currentTime = time > finish ? duration : time - start, timePerc = currentTime / duration, current = isMany ? startValue.map(function(_value, i) {\n                    return easing(currentTime, startValue[i], byValue[i], duration);\n                }) : easing(currentTime, startValue, byValue, duration), valuePerc = isMany ? Math.abs((current[0] - startValue[0]) / byValue[0]) : Math.abs((current - startValue) / byValue);\n                //  update context\n                context.currentValue = isMany ? current.slice() : current;\n                context.completionRate = valuePerc;\n                context.durationRate = timePerc;\n                if (cancel) {\n                    return;\n                }\n                if (abort(current, valuePerc, timePerc)) {\n                    removeFromRegistry();\n                    return;\n                }\n                if (time > finish) {\n                    //  update context\n                    context.currentValue = isMany ? endValue.slice() : endValue;\n                    context.completionRate = 1;\n                    context.durationRate = 1;\n                    //  execute callbacks\n                    onChange(isMany ? endValue.slice() : endValue, 1, 1);\n                    onComplete(endValue, 1, 1);\n                    removeFromRegistry();\n                    return;\n                } else {\n                    onChange(current, valuePerc, timePerc);\n                    requestAnimFrame(tick);\n                }\n            })(start);\n        });\n        return context.cancel;\n    }\n    var _requestAnimFrame = fabric.window.requestAnimationFrame || fabric.window.webkitRequestAnimationFrame || fabric.window.mozRequestAnimationFrame || fabric.window.oRequestAnimationFrame || fabric.window.msRequestAnimationFrame || function(callback) {\n        return fabric.window.setTimeout(callback, 1000 / 60);\n    };\n    var _cancelAnimFrame = fabric.window.cancelAnimationFrame || fabric.window.clearTimeout;\n    /**\n   * requestAnimationFrame polyfill based on http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n   * In order to get a precise start time, `requestAnimFrame` should be called as an entry into the method\n   * @memberOf fabric.util\n   * @param {Function} callback Callback to invoke\n   * @param {DOMElement} element optional Element to associate with animation\n   */ function requestAnimFrame() {\n        return _requestAnimFrame.apply(fabric.window, arguments);\n    }\n    function cancelAnimFrame() {\n        return _cancelAnimFrame.apply(fabric.window, arguments);\n    }\n    fabric.util.animate = animate;\n    fabric.util.requestAnimFrame = requestAnimFrame;\n    fabric.util.cancelAnimFrame = cancelAnimFrame;\n    fabric.runningAnimations = RUNNING_ANIMATIONS;\n})();\n(function() {\n    // Calculate an in-between color. Returns a \"rgba()\" string.\n    // Credit: Edwin Martin <edwin@bitstorm.org>\n    //         http://www.bitstorm.org/jquery/color-animation/jquery.animate-colors.js\n    function calculateColor(begin, end, pos) {\n        var color = \"rgba(\" + parseInt(begin[0] + pos * (end[0] - begin[0]), 10) + \",\" + parseInt(begin[1] + pos * (end[1] - begin[1]), 10) + \",\" + parseInt(begin[2] + pos * (end[2] - begin[2]), 10);\n        color += \",\" + (begin && end ? parseFloat(begin[3] + pos * (end[3] - begin[3])) : 1);\n        color += \")\";\n        return color;\n    }\n    /**\n   * Changes the color from one to another within certain period of time, invoking callbacks as value is being changed.\n   * @memberOf fabric.util\n   * @param {String} fromColor The starting color in hex or rgb(a) format.\n   * @param {String} toColor The starting color in hex or rgb(a) format.\n   * @param {Number} [duration] Duration of change (in ms).\n   * @param {Object} [options] Animation options\n   * @param {Function} [options.onChange] Callback; invoked on every value change\n   * @param {Function} [options.onComplete] Callback; invoked when value change is completed\n   * @param {Function} [options.colorEasing] Easing function. Note that this function only take two arguments (currentTime, duration). Thus the regular animation easing functions cannot be used.\n   * @param {Function} [options.abort] Additional function with logic. If returns true, onComplete is called.\n   * @returns {Function} abort function\n   */ function animateColor(fromColor, toColor, duration, options) {\n        var startColor = new fabric.Color(fromColor).getSource(), endColor = new fabric.Color(toColor).getSource(), originalOnComplete = options.onComplete, originalOnChange = options.onChange;\n        options = options || {};\n        return fabric.util.animate(fabric.util.object.extend(options, {\n            duration: duration || 500,\n            startValue: startColor,\n            endValue: endColor,\n            byValue: endColor,\n            easing: function(currentTime, startValue, byValue, duration) {\n                var posValue = options.colorEasing ? options.colorEasing(currentTime, duration) : 1 - Math.cos(currentTime / duration * (Math.PI / 2));\n                return calculateColor(startValue, byValue, posValue);\n            },\n            // has to take in account for color restoring;\n            onComplete: function(current, valuePerc, timePerc) {\n                if (originalOnComplete) {\n                    return originalOnComplete(calculateColor(endColor, endColor, 0), valuePerc, timePerc);\n                }\n            },\n            onChange: function(current, valuePerc, timePerc) {\n                if (originalOnChange) {\n                    if (Array.isArray(current)) {\n                        return originalOnChange(calculateColor(current, current, 0), valuePerc, timePerc);\n                    }\n                    originalOnChange(current, valuePerc, timePerc);\n                }\n            }\n        }));\n    }\n    fabric.util.animateColor = animateColor;\n})();\n(function() {\n    function normalize(a, c, p, s) {\n        if (a < Math.abs(c)) {\n            a = c;\n            s = p / 4;\n        } else {\n            //handle the 0/0 case:\n            if (c === 0 && a === 0) {\n                s = p / (2 * Math.PI) * Math.asin(1);\n            } else {\n                s = p / (2 * Math.PI) * Math.asin(c / a);\n            }\n        }\n        return {\n            a: a,\n            c: c,\n            p: p,\n            s: s\n        };\n    }\n    function elastic(opts, t, d) {\n        return opts.a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p);\n    }\n    /**\n   * Cubic easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutCubic(t, b, c, d) {\n        return c * ((t = t / d - 1) * t * t + 1) + b;\n    }\n    /**\n   * Cubic easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutCubic(t, b, c, d) {\n        t /= d / 2;\n        if (t < 1) {\n            return c / 2 * t * t * t + b;\n        }\n        return c / 2 * ((t -= 2) * t * t + 2) + b;\n    }\n    /**\n   * Quartic easing in\n   * @memberOf fabric.util.ease\n   */ function easeInQuart(t, b, c, d) {\n        return c * (t /= d) * t * t * t + b;\n    }\n    /**\n   * Quartic easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutQuart(t, b, c, d) {\n        return -c * ((t = t / d - 1) * t * t * t - 1) + b;\n    }\n    /**\n   * Quartic easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutQuart(t, b, c, d) {\n        t /= d / 2;\n        if (t < 1) {\n            return c / 2 * t * t * t * t + b;\n        }\n        return -c / 2 * ((t -= 2) * t * t * t - 2) + b;\n    }\n    /**\n   * Quintic easing in\n   * @memberOf fabric.util.ease\n   */ function easeInQuint(t, b, c, d) {\n        return c * (t /= d) * t * t * t * t + b;\n    }\n    /**\n   * Quintic easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutQuint(t, b, c, d) {\n        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;\n    }\n    /**\n   * Quintic easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutQuint(t, b, c, d) {\n        t /= d / 2;\n        if (t < 1) {\n            return c / 2 * t * t * t * t * t + b;\n        }\n        return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;\n    }\n    /**\n   * Sinusoidal easing in\n   * @memberOf fabric.util.ease\n   */ function easeInSine(t, b, c, d) {\n        return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;\n    }\n    /**\n   * Sinusoidal easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutSine(t, b, c, d) {\n        return c * Math.sin(t / d * (Math.PI / 2)) + b;\n    }\n    /**\n   * Sinusoidal easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutSine(t, b, c, d) {\n        return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;\n    }\n    /**\n   * Exponential easing in\n   * @memberOf fabric.util.ease\n   */ function easeInExpo(t, b, c, d) {\n        return t === 0 ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;\n    }\n    /**\n   * Exponential easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutExpo(t, b, c, d) {\n        return t === d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;\n    }\n    /**\n   * Exponential easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutExpo(t, b, c, d) {\n        if (t === 0) {\n            return b;\n        }\n        if (t === d) {\n            return b + c;\n        }\n        t /= d / 2;\n        if (t < 1) {\n            return c / 2 * Math.pow(2, 10 * (t - 1)) + b;\n        }\n        return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;\n    }\n    /**\n   * Circular easing in\n   * @memberOf fabric.util.ease\n   */ function easeInCirc(t, b, c, d) {\n        return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;\n    }\n    /**\n   * Circular easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutCirc(t, b, c, d) {\n        return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;\n    }\n    /**\n   * Circular easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutCirc(t, b, c, d) {\n        t /= d / 2;\n        if (t < 1) {\n            return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;\n        }\n        return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;\n    }\n    /**\n   * Elastic easing in\n   * @memberOf fabric.util.ease\n   */ function easeInElastic(t, b, c, d) {\n        var s = 1.70158, p = 0, a = c;\n        if (t === 0) {\n            return b;\n        }\n        t /= d;\n        if (t === 1) {\n            return b + c;\n        }\n        if (!p) {\n            p = d * 0.3;\n        }\n        var opts = normalize(a, c, p, s);\n        return -elastic(opts, t, d) + b;\n    }\n    /**\n   * Elastic easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutElastic(t, b, c, d) {\n        var s = 1.70158, p = 0, a = c;\n        if (t === 0) {\n            return b;\n        }\n        t /= d;\n        if (t === 1) {\n            return b + c;\n        }\n        if (!p) {\n            p = d * 0.3;\n        }\n        var opts = normalize(a, c, p, s);\n        return opts.a * Math.pow(2, -10 * t) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p) + opts.c + b;\n    }\n    /**\n   * Elastic easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutElastic(t, b, c, d) {\n        var s = 1.70158, p = 0, a = c;\n        if (t === 0) {\n            return b;\n        }\n        t /= d / 2;\n        if (t === 2) {\n            return b + c;\n        }\n        if (!p) {\n            p = d * (0.3 * 1.5);\n        }\n        var opts = normalize(a, c, p, s);\n        if (t < 1) {\n            return -0.5 * elastic(opts, t, d) + b;\n        }\n        return opts.a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p) * 0.5 + opts.c + b;\n    }\n    /**\n   * Backwards easing in\n   * @memberOf fabric.util.ease\n   */ function easeInBack(t, b, c, d, s) {\n        if (s === undefined) {\n            s = 1.70158;\n        }\n        return c * (t /= d) * t * ((s + 1) * t - s) + b;\n    }\n    /**\n   * Backwards easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutBack(t, b, c, d, s) {\n        if (s === undefined) {\n            s = 1.70158;\n        }\n        return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;\n    }\n    /**\n   * Backwards easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutBack(t, b, c, d, s) {\n        if (s === undefined) {\n            s = 1.70158;\n        }\n        t /= d / 2;\n        if (t < 1) {\n            return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;\n        }\n        return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;\n    }\n    /**\n   * Bouncing easing in\n   * @memberOf fabric.util.ease\n   */ function easeInBounce(t, b, c, d) {\n        return c - easeOutBounce(d - t, 0, c, d) + b;\n    }\n    /**\n   * Bouncing easing out\n   * @memberOf fabric.util.ease\n   */ function easeOutBounce(t, b, c, d) {\n        if ((t /= d) < 1 / 2.75) {\n            return c * (7.5625 * t * t) + b;\n        } else if (t < 2 / 2.75) {\n            return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;\n        } else if (t < 2.5 / 2.75) {\n            return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;\n        } else {\n            return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;\n        }\n    }\n    /**\n   * Bouncing easing in and out\n   * @memberOf fabric.util.ease\n   */ function easeInOutBounce(t, b, c, d) {\n        if (t < d / 2) {\n            return easeInBounce(t * 2, 0, c, d) * 0.5 + b;\n        }\n        return easeOutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;\n    }\n    /**\n   * Easing functions\n   * See <a href=\"http://gizma.com/easing/\">Easing Equations by Robert Penner</a>\n   * @namespace fabric.util.ease\n   */ fabric.util.ease = {\n        /**\n     * Quadratic easing in\n     * @memberOf fabric.util.ease\n     */ easeInQuad: function(t, b, c, d) {\n            return c * (t /= d) * t + b;\n        },\n        /**\n     * Quadratic easing out\n     * @memberOf fabric.util.ease\n     */ easeOutQuad: function(t, b, c, d) {\n            return -c * (t /= d) * (t - 2) + b;\n        },\n        /**\n     * Quadratic easing in and out\n     * @memberOf fabric.util.ease\n     */ easeInOutQuad: function(t, b, c, d) {\n            t /= d / 2;\n            if (t < 1) {\n                return c / 2 * t * t + b;\n            }\n            return -c / 2 * (--t * (t - 2) - 1) + b;\n        },\n        /**\n     * Cubic easing in\n     * @memberOf fabric.util.ease\n     */ easeInCubic: function(t, b, c, d) {\n            return c * (t /= d) * t * t + b;\n        },\n        easeOutCubic: easeOutCubic,\n        easeInOutCubic: easeInOutCubic,\n        easeInQuart: easeInQuart,\n        easeOutQuart: easeOutQuart,\n        easeInOutQuart: easeInOutQuart,\n        easeInQuint: easeInQuint,\n        easeOutQuint: easeOutQuint,\n        easeInOutQuint: easeInOutQuint,\n        easeInSine: easeInSine,\n        easeOutSine: easeOutSine,\n        easeInOutSine: easeInOutSine,\n        easeInExpo: easeInExpo,\n        easeOutExpo: easeOutExpo,\n        easeInOutExpo: easeInOutExpo,\n        easeInCirc: easeInCirc,\n        easeOutCirc: easeOutCirc,\n        easeInOutCirc: easeInOutCirc,\n        easeInElastic: easeInElastic,\n        easeOutElastic: easeOutElastic,\n        easeInOutElastic: easeInOutElastic,\n        easeInBack: easeInBack,\n        easeOutBack: easeOutBack,\n        easeInOutBack: easeInOutBack,\n        easeInBounce: easeInBounce,\n        easeOutBounce: easeOutBounce,\n        easeInOutBounce: easeInOutBounce\n    };\n})();\n(function(global) {\n    \"use strict\";\n    /**\n   * @name fabric\n   * @namespace\n   */ var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, clone = fabric.util.object.clone, toFixed = fabric.util.toFixed, parseUnit = fabric.util.parseUnit, multiplyTransformMatrices = fabric.util.multiplyTransformMatrices, svgValidTagNames = [\n        \"path\",\n        \"circle\",\n        \"polygon\",\n        \"polyline\",\n        \"ellipse\",\n        \"rect\",\n        \"line\",\n        \"image\",\n        \"text\"\n    ], svgViewBoxElements = [\n        \"symbol\",\n        \"image\",\n        \"marker\",\n        \"pattern\",\n        \"view\",\n        \"svg\"\n    ], svgInvalidAncestors = [\n        \"pattern\",\n        \"defs\",\n        \"symbol\",\n        \"metadata\",\n        \"clipPath\",\n        \"mask\",\n        \"desc\"\n    ], svgValidParents = [\n        \"symbol\",\n        \"g\",\n        \"a\",\n        \"svg\",\n        \"clipPath\",\n        \"defs\"\n    ], attributesMap = {\n        cx: \"left\",\n        x: \"left\",\n        r: \"radius\",\n        cy: \"top\",\n        y: \"top\",\n        display: \"visible\",\n        visibility: \"visible\",\n        transform: \"transformMatrix\",\n        \"fill-opacity\": \"fillOpacity\",\n        \"fill-rule\": \"fillRule\",\n        \"font-family\": \"fontFamily\",\n        \"font-size\": \"fontSize\",\n        \"font-style\": \"fontStyle\",\n        \"font-weight\": \"fontWeight\",\n        \"letter-spacing\": \"charSpacing\",\n        \"paint-order\": \"paintFirst\",\n        \"stroke-dasharray\": \"strokeDashArray\",\n        \"stroke-dashoffset\": \"strokeDashOffset\",\n        \"stroke-linecap\": \"strokeLineCap\",\n        \"stroke-linejoin\": \"strokeLineJoin\",\n        \"stroke-miterlimit\": \"strokeMiterLimit\",\n        \"stroke-opacity\": \"strokeOpacity\",\n        \"stroke-width\": \"strokeWidth\",\n        \"text-decoration\": \"textDecoration\",\n        \"text-anchor\": \"textAnchor\",\n        opacity: \"opacity\",\n        \"clip-path\": \"clipPath\",\n        \"clip-rule\": \"clipRule\",\n        \"vector-effect\": \"strokeUniform\",\n        \"image-rendering\": \"imageSmoothing\"\n    }, colorAttributes = {\n        stroke: \"strokeOpacity\",\n        fill: \"fillOpacity\"\n    }, fSize = \"font-size\", cPath = \"clip-path\";\n    fabric.svgValidTagNamesRegEx = getSvgRegex(svgValidTagNames);\n    fabric.svgViewBoxElementsRegEx = getSvgRegex(svgViewBoxElements);\n    fabric.svgInvalidAncestorsRegEx = getSvgRegex(svgInvalidAncestors);\n    fabric.svgValidParentsRegEx = getSvgRegex(svgValidParents);\n    fabric.cssRules = {};\n    fabric.gradientDefs = {};\n    fabric.clipPaths = {};\n    function normalizeAttr(attr) {\n        // transform attribute names\n        if (attr in attributesMap) {\n            return attributesMap[attr];\n        }\n        return attr;\n    }\n    function normalizeValue(attr, value, parentAttributes, fontSize) {\n        var isArray = Array.isArray(value), parsed;\n        if ((attr === \"fill\" || attr === \"stroke\") && value === \"none\") {\n            value = \"\";\n        } else if (attr === \"strokeUniform\") {\n            return value === \"non-scaling-stroke\";\n        } else if (attr === \"strokeDashArray\") {\n            if (value === \"none\") {\n                value = null;\n            } else {\n                value = value.replace(/,/g, \" \").split(/\\s+/).map(parseFloat);\n            }\n        } else if (attr === \"transformMatrix\") {\n            if (parentAttributes && parentAttributes.transformMatrix) {\n                value = multiplyTransformMatrices(parentAttributes.transformMatrix, fabric.parseTransformAttribute(value));\n            } else {\n                value = fabric.parseTransformAttribute(value);\n            }\n        } else if (attr === \"visible\") {\n            value = value !== \"none\" && value !== \"hidden\";\n            // display=none on parent element always takes precedence over child element\n            if (parentAttributes && parentAttributes.visible === false) {\n                value = false;\n            }\n        } else if (attr === \"opacity\") {\n            value = parseFloat(value);\n            if (parentAttributes && typeof parentAttributes.opacity !== \"undefined\") {\n                value *= parentAttributes.opacity;\n            }\n        } else if (attr === \"textAnchor\" /* text-anchor */ ) {\n            value = value === \"start\" ? \"left\" : value === \"end\" ? \"right\" : \"center\";\n        } else if (attr === \"charSpacing\") {\n            // parseUnit returns px and we convert it to em\n            parsed = parseUnit(value, fontSize) / fontSize * 1000;\n        } else if (attr === \"paintFirst\") {\n            var fillIndex = value.indexOf(\"fill\");\n            var strokeIndex = value.indexOf(\"stroke\");\n            var value = \"fill\";\n            if (fillIndex > -1 && strokeIndex > -1 && strokeIndex < fillIndex) {\n                value = \"stroke\";\n            } else if (fillIndex === -1 && strokeIndex > -1) {\n                value = \"stroke\";\n            }\n        } else if (attr === \"href\" || attr === \"xlink:href\" || attr === \"font\") {\n            return value;\n        } else if (attr === \"imageSmoothing\") {\n            return value === \"optimizeQuality\";\n        } else {\n            parsed = isArray ? value.map(parseUnit) : parseUnit(value, fontSize);\n        }\n        return !isArray && isNaN(parsed) ? value : parsed;\n    }\n    /**\n    * @private\n    */ function getSvgRegex(arr) {\n        return new RegExp(\"^(\" + arr.join(\"|\") + \")\\\\b\", \"i\");\n    }\n    /**\n   * @private\n   * @param {Object} attributes Array of attributes to parse\n   */ function _setStrokeFillOpacity(attributes) {\n        for(var attr in colorAttributes){\n            if (typeof attributes[colorAttributes[attr]] === \"undefined\" || attributes[attr] === \"\") {\n                continue;\n            }\n            if (typeof attributes[attr] === \"undefined\") {\n                if (!fabric.Object.prototype[attr]) {\n                    continue;\n                }\n                attributes[attr] = fabric.Object.prototype[attr];\n            }\n            if (attributes[attr].indexOf(\"url(\") === 0) {\n                continue;\n            }\n            var color = new fabric.Color(attributes[attr]);\n            attributes[attr] = color.setAlpha(toFixed(color.getAlpha() * attributes[colorAttributes[attr]], 2)).toRgba();\n        }\n        return attributes;\n    }\n    /**\n   * @private\n   */ function _getMultipleNodes(doc, nodeNames) {\n        var nodeName, nodeArray = [], nodeList, i, len;\n        for(i = 0, len = nodeNames.length; i < len; i++){\n            nodeName = nodeNames[i];\n            nodeList = doc.getElementsByTagName(nodeName);\n            nodeArray = nodeArray.concat(Array.prototype.slice.call(nodeList));\n        }\n        return nodeArray;\n    }\n    /**\n   * Parses \"transform\" attribute, returning an array of values\n   * @static\n   * @function\n   * @memberOf fabric\n   * @param {String} attributeValue String containing attribute value\n   * @return {Array} Array of 6 elements representing transformation matrix\n   */ fabric.parseTransformAttribute = function() {\n        function rotateMatrix(matrix, args) {\n            var cos = fabric.util.cos(args[0]), sin = fabric.util.sin(args[0]), x = 0, y = 0;\n            if (args.length === 3) {\n                x = args[1];\n                y = args[2];\n            }\n            matrix[0] = cos;\n            matrix[1] = sin;\n            matrix[2] = -sin;\n            matrix[3] = cos;\n            matrix[4] = x - (cos * x - sin * y);\n            matrix[5] = y - (sin * x + cos * y);\n        }\n        function scaleMatrix(matrix, args) {\n            var multiplierX = args[0], multiplierY = args.length === 2 ? args[1] : args[0];\n            matrix[0] = multiplierX;\n            matrix[3] = multiplierY;\n        }\n        function skewMatrix(matrix, args, pos) {\n            matrix[pos] = Math.tan(fabric.util.degreesToRadians(args[0]));\n        }\n        function translateMatrix(matrix, args) {\n            matrix[4] = args[0];\n            if (args.length === 2) {\n                matrix[5] = args[1];\n            }\n        }\n        // identity matrix\n        var iMatrix = fabric.iMatrix, // == begin transform regexp\n        number = fabric.reNum, commaWsp = fabric.commaWsp, skewX = \"(?:(skewX)\\\\s*\\\\(\\\\s*(\" + number + \")\\\\s*\\\\))\", skewY = \"(?:(skewY)\\\\s*\\\\(\\\\s*(\" + number + \")\\\\s*\\\\))\", rotate = \"(?:(rotate)\\\\s*\\\\(\\\\s*(\" + number + \")(?:\" + commaWsp + \"(\" + number + \")\" + commaWsp + \"(\" + number + \"))?\\\\s*\\\\))\", scale = \"(?:(scale)\\\\s*\\\\(\\\\s*(\" + number + \")(?:\" + commaWsp + \"(\" + number + \"))?\\\\s*\\\\))\", translate = \"(?:(translate)\\\\s*\\\\(\\\\s*(\" + number + \")(?:\" + commaWsp + \"(\" + number + \"))?\\\\s*\\\\))\", matrix = \"(?:(matrix)\\\\s*\\\\(\\\\s*\" + \"(\" + number + \")\" + commaWsp + \"(\" + number + \")\" + commaWsp + \"(\" + number + \")\" + commaWsp + \"(\" + number + \")\" + commaWsp + \"(\" + number + \")\" + commaWsp + \"(\" + number + \")\" + \"\\\\s*\\\\))\", transform = \"(?:\" + matrix + \"|\" + translate + \"|\" + scale + \"|\" + rotate + \"|\" + skewX + \"|\" + skewY + \")\", transforms = \"(?:\" + transform + \"(?:\" + commaWsp + \"*\" + transform + \")*\" + \")\", transformList = \"^\\\\s*(?:\" + transforms + \"?)\\\\s*$\", // http://www.w3.org/TR/SVG/coords.html#TransformAttribute\n        reTransformList = new RegExp(transformList), // == end transform regexp\n        reTransform = new RegExp(transform, \"g\");\n        return function(attributeValue) {\n            // start with identity matrix\n            var matrix = iMatrix.concat(), matrices = [];\n            // return if no argument was given or\n            // an argument does not match transform attribute regexp\n            if (!attributeValue || attributeValue && !reTransformList.test(attributeValue)) {\n                return matrix;\n            }\n            attributeValue.replace(reTransform, function(match) {\n                var m = new RegExp(transform).exec(match).filter(function(match) {\n                    // match !== '' && match != null\n                    return !!match;\n                }), operation = m[1], args = m.slice(2).map(parseFloat);\n                switch(operation){\n                    case \"translate\":\n                        translateMatrix(matrix, args);\n                        break;\n                    case \"rotate\":\n                        args[0] = fabric.util.degreesToRadians(args[0]);\n                        rotateMatrix(matrix, args);\n                        break;\n                    case \"scale\":\n                        scaleMatrix(matrix, args);\n                        break;\n                    case \"skewX\":\n                        skewMatrix(matrix, args, 2);\n                        break;\n                    case \"skewY\":\n                        skewMatrix(matrix, args, 1);\n                        break;\n                    case \"matrix\":\n                        matrix = args;\n                        break;\n                }\n                // snapshot current matrix into matrices array\n                matrices.push(matrix.concat());\n                // reset\n                matrix = iMatrix.concat();\n            });\n            var combinedMatrix = matrices[0];\n            while(matrices.length > 1){\n                matrices.shift();\n                combinedMatrix = fabric.util.multiplyTransformMatrices(combinedMatrix, matrices[0]);\n            }\n            return combinedMatrix;\n        };\n    }();\n    /**\n   * @private\n   */ function parseStyleString(style, oStyle) {\n        var attr, value;\n        style.replace(/;\\s*$/, \"\").split(\";\").forEach(function(chunk) {\n            var pair = chunk.split(\":\");\n            attr = pair[0].trim().toLowerCase();\n            value = pair[1].trim();\n            oStyle[attr] = value;\n        });\n    }\n    /**\n   * @private\n   */ function parseStyleObject(style, oStyle) {\n        var attr, value;\n        for(var prop in style){\n            if (typeof style[prop] === \"undefined\") {\n                continue;\n            }\n            attr = prop.toLowerCase();\n            value = style[prop];\n            oStyle[attr] = value;\n        }\n    }\n    /**\n   * @private\n   */ function getGlobalStylesForElement(element, svgUid) {\n        var styles = {};\n        for(var rule in fabric.cssRules[svgUid]){\n            if (elementMatchesRule(element, rule.split(\" \"))) {\n                for(var property in fabric.cssRules[svgUid][rule]){\n                    styles[property] = fabric.cssRules[svgUid][rule][property];\n                }\n            }\n        }\n        return styles;\n    }\n    /**\n   * @private\n   */ function elementMatchesRule(element, selectors) {\n        var firstMatching, parentMatching = true;\n        //start from rightmost selector.\n        firstMatching = selectorMatches(element, selectors.pop());\n        if (firstMatching && selectors.length) {\n            parentMatching = doesSomeParentMatch(element, selectors);\n        }\n        return firstMatching && parentMatching && selectors.length === 0;\n    }\n    function doesSomeParentMatch(element, selectors) {\n        var selector, parentMatching = true;\n        while(element.parentNode && element.parentNode.nodeType === 1 && selectors.length){\n            if (parentMatching) {\n                selector = selectors.pop();\n            }\n            element = element.parentNode;\n            parentMatching = selectorMatches(element, selector);\n        }\n        return selectors.length === 0;\n    }\n    /**\n   * @private\n   */ function selectorMatches(element, selector) {\n        var nodeName = element.nodeName, classNames = element.getAttribute(\"class\"), id = element.getAttribute(\"id\"), matcher, i;\n        // i check if a selector matches slicing away part from it.\n        // if i get empty string i should match\n        matcher = new RegExp(\"^\" + nodeName, \"i\");\n        selector = selector.replace(matcher, \"\");\n        if (id && selector.length) {\n            matcher = new RegExp(\"#\" + id + \"(?![a-zA-Z\\\\-]+)\", \"i\");\n            selector = selector.replace(matcher, \"\");\n        }\n        if (classNames && selector.length) {\n            classNames = classNames.split(\" \");\n            for(i = classNames.length; i--;){\n                matcher = new RegExp(\"\\\\.\" + classNames[i] + \"(?![a-zA-Z\\\\-]+)\", \"i\");\n                selector = selector.replace(matcher, \"\");\n            }\n        }\n        return selector.length === 0;\n    }\n    /**\n   * @private\n   * to support IE8 missing getElementById on SVGdocument and on node xmlDOM\n   */ function elementById(doc, id) {\n        var el;\n        doc.getElementById && (el = doc.getElementById(id));\n        if (el) {\n            return el;\n        }\n        var node, i, len, nodelist = doc.getElementsByTagName(\"*\");\n        for(i = 0, len = nodelist.length; i < len; i++){\n            node = nodelist[i];\n            if (id === node.getAttribute(\"id\")) {\n                return node;\n            }\n        }\n    }\n    /**\n   * @private\n   */ function parseUseDirectives(doc) {\n        var nodelist = _getMultipleNodes(doc, [\n            \"use\",\n            \"svg:use\"\n        ]), i = 0;\n        while(nodelist.length && i < nodelist.length){\n            var el = nodelist[i], xlinkAttribute = el.getAttribute(\"xlink:href\") || el.getAttribute(\"href\");\n            if (xlinkAttribute === null) {\n                return;\n            }\n            var xlink = xlinkAttribute.slice(1), x = el.getAttribute(\"x\") || 0, y = el.getAttribute(\"y\") || 0, el2 = elementById(doc, xlink).cloneNode(true), currentTrans = (el2.getAttribute(\"transform\") || \"\") + \" translate(\" + x + \", \" + y + \")\", parentNode, oldLength = nodelist.length, attr, j, attrs, len, namespace = fabric.svgNS;\n            applyViewboxTransform(el2);\n            if (/^svg$/i.test(el2.nodeName)) {\n                var el3 = el2.ownerDocument.createElementNS(namespace, \"g\");\n                for(j = 0, attrs = el2.attributes, len = attrs.length; j < len; j++){\n                    attr = attrs.item(j);\n                    el3.setAttributeNS(namespace, attr.nodeName, attr.nodeValue);\n                }\n                // el2.firstChild != null\n                while(el2.firstChild){\n                    el3.appendChild(el2.firstChild);\n                }\n                el2 = el3;\n            }\n            for(j = 0, attrs = el.attributes, len = attrs.length; j < len; j++){\n                attr = attrs.item(j);\n                if (attr.nodeName === \"x\" || attr.nodeName === \"y\" || attr.nodeName === \"xlink:href\" || attr.nodeName === \"href\") {\n                    continue;\n                }\n                if (attr.nodeName === \"transform\") {\n                    currentTrans = attr.nodeValue + \" \" + currentTrans;\n                } else {\n                    el2.setAttribute(attr.nodeName, attr.nodeValue);\n                }\n            }\n            el2.setAttribute(\"transform\", currentTrans);\n            el2.setAttribute(\"instantiated_by_use\", \"1\");\n            el2.removeAttribute(\"id\");\n            parentNode = el.parentNode;\n            parentNode.replaceChild(el2, el);\n            // some browsers do not shorten nodelist after replaceChild (IE8)\n            if (nodelist.length === oldLength) {\n                i++;\n            }\n        }\n    }\n    // http://www.w3.org/TR/SVG/coords.html#ViewBoxAttribute\n    // matches, e.g.: +14.56e-12, etc.\n    var reViewBoxAttrValue = new RegExp(\"^\" + \"\\\\s*(\" + fabric.reNum + \"+)\\\\s*,?\" + \"\\\\s*(\" + fabric.reNum + \"+)\\\\s*,?\" + \"\\\\s*(\" + fabric.reNum + \"+)\\\\s*,?\" + \"\\\\s*(\" + fabric.reNum + \"+)\\\\s*\" + \"$\");\n    /**\n   * Add a <g> element that envelop all child elements and makes the viewbox transformMatrix descend on all elements\n   */ function applyViewboxTransform(element) {\n        if (!fabric.svgViewBoxElementsRegEx.test(element.nodeName)) {\n            return {};\n        }\n        var viewBoxAttr = element.getAttribute(\"viewBox\"), scaleX = 1, scaleY = 1, minX = 0, minY = 0, viewBoxWidth, viewBoxHeight, matrix, el, widthAttr = element.getAttribute(\"width\"), heightAttr = element.getAttribute(\"height\"), x = element.getAttribute(\"x\") || 0, y = element.getAttribute(\"y\") || 0, preserveAspectRatio = element.getAttribute(\"preserveAspectRatio\") || \"\", missingViewBox = !viewBoxAttr || !(viewBoxAttr = viewBoxAttr.match(reViewBoxAttrValue)), missingDimAttr = !widthAttr || !heightAttr || widthAttr === \"100%\" || heightAttr === \"100%\", toBeParsed = missingViewBox && missingDimAttr, parsedDim = {}, translateMatrix = \"\", widthDiff = 0, heightDiff = 0;\n        parsedDim.width = 0;\n        parsedDim.height = 0;\n        parsedDim.toBeParsed = toBeParsed;\n        if (missingViewBox) {\n            if ((x || y) && element.parentNode && element.parentNode.nodeName !== \"#document\") {\n                translateMatrix = \" translate(\" + parseUnit(x) + \" \" + parseUnit(y) + \") \";\n                matrix = (element.getAttribute(\"transform\") || \"\") + translateMatrix;\n                element.setAttribute(\"transform\", matrix);\n                element.removeAttribute(\"x\");\n                element.removeAttribute(\"y\");\n            }\n        }\n        if (toBeParsed) {\n            return parsedDim;\n        }\n        if (missingViewBox) {\n            parsedDim.width = parseUnit(widthAttr);\n            parsedDim.height = parseUnit(heightAttr);\n            // set a transform for elements that have x y and are inner(only) SVGs\n            return parsedDim;\n        }\n        minX = -parseFloat(viewBoxAttr[1]);\n        minY = -parseFloat(viewBoxAttr[2]);\n        viewBoxWidth = parseFloat(viewBoxAttr[3]);\n        viewBoxHeight = parseFloat(viewBoxAttr[4]);\n        parsedDim.minX = minX;\n        parsedDim.minY = minY;\n        parsedDim.viewBoxWidth = viewBoxWidth;\n        parsedDim.viewBoxHeight = viewBoxHeight;\n        if (!missingDimAttr) {\n            parsedDim.width = parseUnit(widthAttr);\n            parsedDim.height = parseUnit(heightAttr);\n            scaleX = parsedDim.width / viewBoxWidth;\n            scaleY = parsedDim.height / viewBoxHeight;\n        } else {\n            parsedDim.width = viewBoxWidth;\n            parsedDim.height = viewBoxHeight;\n        }\n        // default is to preserve aspect ratio\n        preserveAspectRatio = fabric.util.parsePreserveAspectRatioAttribute(preserveAspectRatio);\n        if (preserveAspectRatio.alignX !== \"none\") {\n            //translate all container for the effect of Mid, Min, Max\n            if (preserveAspectRatio.meetOrSlice === \"meet\") {\n                scaleY = scaleX = scaleX > scaleY ? scaleY : scaleX;\n            // calculate additional translation to move the viewbox\n            }\n            if (preserveAspectRatio.meetOrSlice === \"slice\") {\n                scaleY = scaleX = scaleX > scaleY ? scaleX : scaleY;\n            // calculate additional translation to move the viewbox\n            }\n            widthDiff = parsedDim.width - viewBoxWidth * scaleX;\n            heightDiff = parsedDim.height - viewBoxHeight * scaleX;\n            if (preserveAspectRatio.alignX === \"Mid\") {\n                widthDiff /= 2;\n            }\n            if (preserveAspectRatio.alignY === \"Mid\") {\n                heightDiff /= 2;\n            }\n            if (preserveAspectRatio.alignX === \"Min\") {\n                widthDiff = 0;\n            }\n            if (preserveAspectRatio.alignY === \"Min\") {\n                heightDiff = 0;\n            }\n        }\n        if (scaleX === 1 && scaleY === 1 && minX === 0 && minY === 0 && x === 0 && y === 0) {\n            return parsedDim;\n        }\n        if ((x || y) && element.parentNode.nodeName !== \"#document\") {\n            translateMatrix = \" translate(\" + parseUnit(x) + \" \" + parseUnit(y) + \") \";\n        }\n        matrix = translateMatrix + \" matrix(\" + scaleX + \" 0\" + \" 0 \" + scaleY + \" \" + (minX * scaleX + widthDiff) + \" \" + (minY * scaleY + heightDiff) + \") \";\n        // seems unused.\n        // parsedDim.viewboxTransform = fabric.parseTransformAttribute(matrix);\n        if (element.nodeName === \"svg\") {\n            el = element.ownerDocument.createElementNS(fabric.svgNS, \"g\");\n            // element.firstChild != null\n            while(element.firstChild){\n                el.appendChild(element.firstChild);\n            }\n            element.appendChild(el);\n        } else {\n            el = element;\n            el.removeAttribute(\"x\");\n            el.removeAttribute(\"y\");\n            matrix = el.getAttribute(\"transform\") + matrix;\n        }\n        el.setAttribute(\"transform\", matrix);\n        return parsedDim;\n    }\n    function hasAncestorWithNodeName(element, nodeName) {\n        while(element && (element = element.parentNode)){\n            if (element.nodeName && nodeName.test(element.nodeName.replace(\"svg:\", \"\")) && !element.getAttribute(\"instantiated_by_use\")) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n   * Parses an SVG document, converts it to an array of corresponding fabric.* instances and passes them to a callback\n   * @static\n   * @function\n   * @memberOf fabric\n   * @param {SVGDocument} doc SVG document to parse\n   * @param {Function} callback Callback to call when parsing is finished;\n   * It's being passed an array of elements (parsed from a document).\n   * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\n   * @param {Object} [parsingOptions] options for parsing document\n   * @param {String} [parsingOptions.crossOrigin] crossOrigin settings\n   */ fabric.parseSVGDocument = function(doc, callback, reviver, parsingOptions) {\n        if (!doc) {\n            return;\n        }\n        parseUseDirectives(doc);\n        var svgUid = fabric.Object.__uid++, i, len, options = applyViewboxTransform(doc), descendants = fabric.util.toArray(doc.getElementsByTagName(\"*\"));\n        options.crossOrigin = parsingOptions && parsingOptions.crossOrigin;\n        options.svgUid = svgUid;\n        if (descendants.length === 0 && fabric.isLikelyNode) {\n            // we're likely in node, where \"o3-xml\" library fails to gEBTN(\"*\")\n            // https://github.com/ajaxorg/node-o3-xml/issues/21\n            descendants = doc.selectNodes('//*[name(.)!=\"svg\"]');\n            var arr = [];\n            for(i = 0, len = descendants.length; i < len; i++){\n                arr[i] = descendants[i];\n            }\n            descendants = arr;\n        }\n        var elements = descendants.filter(function(el) {\n            applyViewboxTransform(el);\n            return fabric.svgValidTagNamesRegEx.test(el.nodeName.replace(\"svg:\", \"\")) && !hasAncestorWithNodeName(el, fabric.svgInvalidAncestorsRegEx); // http://www.w3.org/TR/SVG/struct.html#DefsElement\n        });\n        if (!elements || elements && !elements.length) {\n            callback && callback([], {});\n            return;\n        }\n        var clipPaths = {};\n        descendants.filter(function(el) {\n            return el.nodeName.replace(\"svg:\", \"\") === \"clipPath\";\n        }).forEach(function(el) {\n            var id = el.getAttribute(\"id\");\n            clipPaths[id] = fabric.util.toArray(el.getElementsByTagName(\"*\")).filter(function(el) {\n                return fabric.svgValidTagNamesRegEx.test(el.nodeName.replace(\"svg:\", \"\"));\n            });\n        });\n        fabric.gradientDefs[svgUid] = fabric.getGradientDefs(doc);\n        fabric.cssRules[svgUid] = fabric.getCSSRules(doc);\n        fabric.clipPaths[svgUid] = clipPaths;\n        // Precedence of rules:   style > class > attribute\n        fabric.parseElements(elements, function(instances, elements) {\n            if (callback) {\n                callback(instances, options, elements, descendants);\n                delete fabric.gradientDefs[svgUid];\n                delete fabric.cssRules[svgUid];\n                delete fabric.clipPaths[svgUid];\n            }\n        }, clone(options), reviver, parsingOptions);\n    };\n    function recursivelyParseGradientsXlink(doc, gradient) {\n        var gradientsAttrs = [\n            \"gradientTransform\",\n            \"x1\",\n            \"x2\",\n            \"y1\",\n            \"y2\",\n            \"gradientUnits\",\n            \"cx\",\n            \"cy\",\n            \"r\",\n            \"fx\",\n            \"fy\"\n        ], xlinkAttr = \"xlink:href\", xLink = gradient.getAttribute(xlinkAttr).slice(1), referencedGradient = elementById(doc, xLink);\n        if (referencedGradient && referencedGradient.getAttribute(xlinkAttr)) {\n            recursivelyParseGradientsXlink(doc, referencedGradient);\n        }\n        gradientsAttrs.forEach(function(attr) {\n            if (referencedGradient && !gradient.hasAttribute(attr) && referencedGradient.hasAttribute(attr)) {\n                gradient.setAttribute(attr, referencedGradient.getAttribute(attr));\n            }\n        });\n        if (!gradient.children.length) {\n            var referenceClone = referencedGradient.cloneNode(true);\n            while(referenceClone.firstChild){\n                gradient.appendChild(referenceClone.firstChild);\n            }\n        }\n        gradient.removeAttribute(xlinkAttr);\n    }\n    var reFontDeclaration = new RegExp(\"(normal|italic)?\\\\s*(normal|small-caps)?\\\\s*\" + \"(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\\\s*(\" + fabric.reNum + \"(?:px|cm|mm|em|pt|pc|in)*)(?:\\\\/(normal|\" + fabric.reNum + \"))?\\\\s+(.*)\");\n    extend(fabric, {\n        /**\n     * Parses a short font declaration, building adding its properties to a style object\n     * @static\n     * @function\n     * @memberOf fabric\n     * @param {String} value font declaration\n     * @param {Object} oStyle definition\n     */ parseFontDeclaration: function(value, oStyle) {\n            var match = value.match(reFontDeclaration);\n            if (!match) {\n                return;\n            }\n            var fontStyle = match[1], // font variant is not used\n            // fontVariant = match[2],\n            fontWeight = match[3], fontSize = match[4], lineHeight = match[5], fontFamily = match[6];\n            if (fontStyle) {\n                oStyle.fontStyle = fontStyle;\n            }\n            if (fontWeight) {\n                oStyle.fontWeight = isNaN(parseFloat(fontWeight)) ? fontWeight : parseFloat(fontWeight);\n            }\n            if (fontSize) {\n                oStyle.fontSize = parseUnit(fontSize);\n            }\n            if (fontFamily) {\n                oStyle.fontFamily = fontFamily;\n            }\n            if (lineHeight) {\n                oStyle.lineHeight = lineHeight === \"normal\" ? 1 : lineHeight;\n            }\n        },\n        /**\n     * Parses an SVG document, returning all of the gradient declarations found in it\n     * @static\n     * @function\n     * @memberOf fabric\n     * @param {SVGDocument} doc SVG document to parse\n     * @return {Object} Gradient definitions; key corresponds to element id, value -- to gradient definition element\n     */ getGradientDefs: function(doc) {\n            var tagArray = [\n                \"linearGradient\",\n                \"radialGradient\",\n                \"svg:linearGradient\",\n                \"svg:radialGradient\"\n            ], elList = _getMultipleNodes(doc, tagArray), el, j = 0, gradientDefs = {};\n            j = elList.length;\n            while(j--){\n                el = elList[j];\n                if (el.getAttribute(\"xlink:href\")) {\n                    recursivelyParseGradientsXlink(doc, el);\n                }\n                gradientDefs[el.getAttribute(\"id\")] = el;\n            }\n            return gradientDefs;\n        },\n        /**\n     * Returns an object of attributes' name/value, given element and an array of attribute names;\n     * Parses parent \"g\" nodes recursively upwards.\n     * @static\n     * @memberOf fabric\n     * @param {DOMElement} element Element to parse\n     * @param {Array} attributes Array of attributes to parse\n     * @return {Object} object containing parsed attributes' names/values\n     */ parseAttributes: function(element, attributes, svgUid) {\n            if (!element) {\n                return;\n            }\n            var value, parentAttributes = {}, fontSize, parentFontSize;\n            if (typeof svgUid === \"undefined\") {\n                svgUid = element.getAttribute(\"svgUid\");\n            }\n            // if there's a parent container (`g` or `a` or `symbol` node), parse its attributes recursively upwards\n            if (element.parentNode && fabric.svgValidParentsRegEx.test(element.parentNode.nodeName)) {\n                parentAttributes = fabric.parseAttributes(element.parentNode, attributes, svgUid);\n            }\n            var ownAttributes = attributes.reduce(function(memo, attr) {\n                value = element.getAttribute(attr);\n                if (value) {\n                    memo[attr] = value;\n                }\n                return memo;\n            }, {});\n            // add values parsed from style, which take precedence over attributes\n            // (see: http://www.w3.org/TR/SVG/styling.html#UsingPresentationAttributes)\n            var cssAttrs = extend(getGlobalStylesForElement(element, svgUid), fabric.parseStyleAttribute(element));\n            ownAttributes = extend(ownAttributes, cssAttrs);\n            if (cssAttrs[cPath]) {\n                element.setAttribute(cPath, cssAttrs[cPath]);\n            }\n            fontSize = parentFontSize = parentAttributes.fontSize || fabric.Text.DEFAULT_SVG_FONT_SIZE;\n            if (ownAttributes[fSize]) {\n                // looks like the minimum should be 9px when dealing with ems. this is what looks like in browsers.\n                ownAttributes[fSize] = fontSize = parseUnit(ownAttributes[fSize], parentFontSize);\n            }\n            var normalizedAttr, normalizedValue, normalizedStyle = {};\n            for(var attr in ownAttributes){\n                normalizedAttr = normalizeAttr(attr);\n                normalizedValue = normalizeValue(normalizedAttr, ownAttributes[attr], parentAttributes, fontSize);\n                normalizedStyle[normalizedAttr] = normalizedValue;\n            }\n            if (normalizedStyle && normalizedStyle.font) {\n                fabric.parseFontDeclaration(normalizedStyle.font, normalizedStyle);\n            }\n            var mergedAttrs = extend(parentAttributes, normalizedStyle);\n            return fabric.svgValidParentsRegEx.test(element.nodeName) ? mergedAttrs : _setStrokeFillOpacity(mergedAttrs);\n        },\n        /**\n     * Transforms an array of svg elements to corresponding fabric.* instances\n     * @static\n     * @memberOf fabric\n     * @param {Array} elements Array of elements to parse\n     * @param {Function} callback Being passed an array of fabric instances (transformed from SVG elements)\n     * @param {Object} [options] Options object\n     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\n     */ parseElements: function(elements, callback, options, reviver, parsingOptions) {\n            new fabric.ElementsParser(elements, callback, options, reviver, parsingOptions).parse();\n        },\n        /**\n     * Parses \"style\" attribute, retuning an object with values\n     * @static\n     * @memberOf fabric\n     * @param {SVGElement} element Element to parse\n     * @return {Object} Objects with values parsed from style attribute of an element\n     */ parseStyleAttribute: function(element) {\n            var oStyle = {}, style = element.getAttribute(\"style\");\n            if (!style) {\n                return oStyle;\n            }\n            if (typeof style === \"string\") {\n                parseStyleString(style, oStyle);\n            } else {\n                parseStyleObject(style, oStyle);\n            }\n            return oStyle;\n        },\n        /**\n     * Parses \"points\" attribute, returning an array of values\n     * @static\n     * @memberOf fabric\n     * @param {String} points points attribute string\n     * @return {Array} array of points\n     */ parsePointsAttribute: function(points) {\n            // points attribute is required and must not be empty\n            if (!points) {\n                return null;\n            }\n            // replace commas with whitespace and remove bookending whitespace\n            points = points.replace(/,/g, \" \").trim();\n            points = points.split(/\\s+/);\n            var parsedPoints = [], i, len;\n            for(i = 0, len = points.length; i < len; i += 2){\n                parsedPoints.push({\n                    x: parseFloat(points[i]),\n                    y: parseFloat(points[i + 1])\n                });\n            }\n            // odd number of points is an error\n            // if (parsedPoints.length % 2 !== 0) {\n            //   return null;\n            // }\n            return parsedPoints;\n        },\n        /**\n     * Returns CSS rules for a given SVG document\n     * @static\n     * @function\n     * @memberOf fabric\n     * @param {SVGDocument} doc SVG document to parse\n     * @return {Object} CSS rules of this document\n     */ getCSSRules: function(doc) {\n            var styles = doc.getElementsByTagName(\"style\"), i, len, allRules = {}, rules;\n            // very crude parsing of style contents\n            for(i = 0, len = styles.length; i < len; i++){\n                var styleContents = styles[i].textContent;\n                // remove comments\n                styleContents = styleContents.replace(/\\/\\*[\\s\\S]*?\\*\\//g, \"\");\n                if (styleContents.trim() === \"\") {\n                    continue;\n                }\n                // recovers all the rule in this form `body { style code... }`\n                // rules = styleContents.match(/[^{]*\\{[\\s\\S]*?\\}/g);\n                rules = styleContents.split(\"}\");\n                // remove empty rules.\n                rules = rules.filter(function(rule) {\n                    return rule.trim();\n                });\n                // at this point we have hopefully an array of rules `body { style code... `\n                // eslint-disable-next-line no-loop-func\n                rules.forEach(function(rule) {\n                    var match = rule.split(\"{\"), ruleObj = {}, declaration = match[1].trim(), propertyValuePairs = declaration.split(\";\").filter(function(pair) {\n                        return pair.trim();\n                    });\n                    for(i = 0, len = propertyValuePairs.length; i < len; i++){\n                        var pair = propertyValuePairs[i].split(\":\"), property = pair[0].trim(), value = pair[1].trim();\n                        ruleObj[property] = value;\n                    }\n                    rule = match[0].trim();\n                    rule.split(\",\").forEach(function(_rule) {\n                        _rule = _rule.replace(/^svg/i, \"\").trim();\n                        if (_rule === \"\") {\n                            return;\n                        }\n                        if (allRules[_rule]) {\n                            fabric.util.object.extend(allRules[_rule], ruleObj);\n                        } else {\n                            allRules[_rule] = fabric.util.object.clone(ruleObj);\n                        }\n                    });\n                });\n            }\n            return allRules;\n        },\n        /**\n     * Takes url corresponding to an SVG document, and parses it into a set of fabric objects.\n     * Note that SVG is fetched via XMLHttpRequest, so it needs to conform to SOP (Same Origin Policy)\n     * @memberOf fabric\n     * @param {String} url\n     * @param {Function} callback\n     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\n     * @param {Object} [options] Object containing options for parsing\n     * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources\n     */ loadSVGFromURL: function(url, callback, reviver, options) {\n            url = url.replace(/^\\n\\s*/, \"\").trim();\n            new fabric.util.request(url, {\n                method: \"get\",\n                onComplete: onComplete\n            });\n            function onComplete(r) {\n                var xml = r.responseXML;\n                if (!xml || !xml.documentElement) {\n                    callback && callback(null);\n                    return false;\n                }\n                fabric.parseSVGDocument(xml.documentElement, function(results, _options, elements, allElements) {\n                    callback && callback(results, _options, elements, allElements);\n                }, reviver, options);\n            }\n        },\n        /**\n     * Takes string corresponding to an SVG document, and parses it into a set of fabric objects\n     * @memberOf fabric\n     * @param {String} string\n     * @param {Function} callback\n     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\n     * @param {Object} [options] Object containing options for parsing\n     * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources\n     */ loadSVGFromString: function(string, callback, reviver, options) {\n            var parser = new fabric.window.DOMParser(), doc = parser.parseFromString(string.trim(), \"text/xml\");\n            fabric.parseSVGDocument(doc.documentElement, function(results, _options, elements, allElements) {\n                callback(results, _options, elements, allElements);\n            }, reviver, options);\n        }\n    });\n})( true ? exports : 0);\nfabric.ElementsParser = function(elements, callback, options, reviver, parsingOptions, doc) {\n    this.elements = elements;\n    this.callback = callback;\n    this.options = options;\n    this.reviver = reviver;\n    this.svgUid = options && options.svgUid || 0;\n    this.parsingOptions = parsingOptions;\n    this.regexUrl = /^url\\(['\"]?#([^'\"]+)['\"]?\\)/g;\n    this.doc = doc;\n};\n(function(proto) {\n    proto.parse = function() {\n        this.instances = new Array(this.elements.length);\n        this.numElements = this.elements.length;\n        this.createObjects();\n    };\n    proto.createObjects = function() {\n        var _this = this;\n        this.elements.forEach(function(element, i) {\n            element.setAttribute(\"svgUid\", _this.svgUid);\n            _this.createObject(element, i);\n        });\n    };\n    proto.findTag = function(el) {\n        return fabric[fabric.util.string.capitalize(el.tagName.replace(\"svg:\", \"\"))];\n    };\n    proto.createObject = function(el, index) {\n        var klass = this.findTag(el);\n        if (klass && klass.fromElement) {\n            try {\n                klass.fromElement(el, this.createCallback(index, el), this.options);\n            } catch (err) {\n                fabric.log(err);\n            }\n        } else {\n            this.checkIfDone();\n        }\n    };\n    proto.createCallback = function(index, el) {\n        var _this = this;\n        return function(obj) {\n            var _options;\n            _this.resolveGradient(obj, el, \"fill\");\n            _this.resolveGradient(obj, el, \"stroke\");\n            if (obj instanceof fabric.Image && obj._originalElement) {\n                _options = obj.parsePreserveAspectRatioAttribute(el);\n            }\n            obj._removeTransformMatrix(_options);\n            _this.resolveClipPath(obj, el);\n            _this.reviver && _this.reviver(el, obj);\n            _this.instances[index] = obj;\n            _this.checkIfDone();\n        };\n    };\n    proto.extractPropertyDefinition = function(obj, property, storage) {\n        var value = obj[property], regex = this.regexUrl;\n        if (!regex.test(value)) {\n            return;\n        }\n        regex.lastIndex = 0;\n        var id = regex.exec(value)[1];\n        regex.lastIndex = 0;\n        return fabric[storage][this.svgUid][id];\n    };\n    proto.resolveGradient = function(obj, el, property) {\n        var gradientDef = this.extractPropertyDefinition(obj, property, \"gradientDefs\");\n        if (gradientDef) {\n            var opacityAttr = el.getAttribute(property + \"-opacity\");\n            var gradient = fabric.Gradient.fromElement(gradientDef, obj, opacityAttr, this.options);\n            obj.set(property, gradient);\n        }\n    };\n    proto.createClipPathCallback = function(obj, container) {\n        return function(_newObj) {\n            _newObj._removeTransformMatrix();\n            _newObj.fillRule = _newObj.clipRule;\n            container.push(_newObj);\n        };\n    };\n    proto.resolveClipPath = function(obj, usingElement) {\n        var clipPath = this.extractPropertyDefinition(obj, \"clipPath\", \"clipPaths\"), element, klass, objTransformInv, container, gTransform, options;\n        if (clipPath) {\n            container = [];\n            objTransformInv = fabric.util.invertTransform(obj.calcTransformMatrix());\n            // move the clipPath tag as sibling to the real element that is using it\n            var clipPathTag = clipPath[0].parentNode;\n            var clipPathOwner = usingElement;\n            while(clipPathOwner.parentNode && clipPathOwner.getAttribute(\"clip-path\") !== obj.clipPath){\n                clipPathOwner = clipPathOwner.parentNode;\n            }\n            clipPathOwner.parentNode.appendChild(clipPathTag);\n            for(var i = 0; i < clipPath.length; i++){\n                element = clipPath[i];\n                klass = this.findTag(element);\n                klass.fromElement(element, this.createClipPathCallback(obj, container), this.options);\n            }\n            if (container.length === 1) {\n                clipPath = container[0];\n            } else {\n                clipPath = new fabric.Group(container);\n            }\n            gTransform = fabric.util.multiplyTransformMatrices(objTransformInv, clipPath.calcTransformMatrix());\n            if (clipPath.clipPath) {\n                this.resolveClipPath(clipPath, clipPathOwner);\n            }\n            var options = fabric.util.qrDecompose(gTransform);\n            clipPath.flipX = false;\n            clipPath.flipY = false;\n            clipPath.set(\"scaleX\", options.scaleX);\n            clipPath.set(\"scaleY\", options.scaleY);\n            clipPath.angle = options.angle;\n            clipPath.skewX = options.skewX;\n            clipPath.skewY = 0;\n            clipPath.setPositionByOrigin({\n                x: options.translateX,\n                y: options.translateY\n            }, \"center\", \"center\");\n            obj.clipPath = clipPath;\n        } else {\n            // if clip-path does not resolve to any element, delete the property.\n            delete obj.clipPath;\n        }\n    };\n    proto.checkIfDone = function() {\n        if (--this.numElements === 0) {\n            this.instances = this.instances.filter(function(el) {\n                // eslint-disable-next-line no-eq-null, eqeqeq\n                return el != null;\n            });\n            this.callback(this.instances, this.elements);\n        }\n    };\n})(fabric.ElementsParser.prototype);\n(function(global) {\n    \"use strict\";\n    /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */ var fabric = global.fabric || (global.fabric = {});\n    if (fabric.Point) {\n        fabric.warn(\"fabric.Point is already defined\");\n        return;\n    }\n    fabric.Point = Point;\n    /**\n   * Point class\n   * @class fabric.Point\n   * @memberOf fabric\n   * @constructor\n   * @param {Number} x\n   * @param {Number} y\n   * @return {fabric.Point} thisArg\n   */ function Point(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    Point.prototype = /** @lends fabric.Point.prototype */ {\n        type: \"point\",\n        constructor: Point,\n        /**\n     * Adds another point to this one and returns another one\n     * @param {fabric.Point} that\n     * @return {fabric.Point} new Point instance with added values\n     */ add: function(that) {\n            return new Point(this.x + that.x, this.y + that.y);\n        },\n        /**\n     * Adds another point to this one\n     * @param {fabric.Point} that\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */ addEquals: function(that) {\n            this.x += that.x;\n            this.y += that.y;\n            return this;\n        },\n        /**\n     * Adds value to this point and returns a new one\n     * @param {Number} scalar\n     * @return {fabric.Point} new Point with added value\n     */ scalarAdd: function(scalar) {\n            return new Point(this.x + scalar, this.y + scalar);\n        },\n        /**\n     * Adds value to this point\n     * @param {Number} scalar\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */ scalarAddEquals: function(scalar) {\n            this.x += scalar;\n            this.y += scalar;\n            return this;\n        },\n        /**\n     * Subtracts another point from this point and returns a new one\n     * @param {fabric.Point} that\n     * @return {fabric.Point} new Point object with subtracted values\n     */ subtract: function(that) {\n            return new Point(this.x - that.x, this.y - that.y);\n        },\n        /**\n     * Subtracts another point from this point\n     * @param {fabric.Point} that\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */ subtractEquals: function(that) {\n            this.x -= that.x;\n            this.y -= that.y;\n            return this;\n        },\n        /**\n     * Subtracts value from this point and returns a new one\n     * @param {Number} scalar\n     * @return {fabric.Point}\n     */ scalarSubtract: function(scalar) {\n            return new Point(this.x - scalar, this.y - scalar);\n        },\n        /**\n     * Subtracts value from this point\n     * @param {Number} scalar\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */ scalarSubtractEquals: function(scalar) {\n            this.x -= scalar;\n            this.y -= scalar;\n            return this;\n        },\n        /**\n     * Multiplies this point by a value and returns a new one\n     * TODO: rename in scalarMultiply in 2.0\n     * @param {Number} scalar\n     * @return {fabric.Point}\n     */ multiply: function(scalar) {\n            return new Point(this.x * scalar, this.y * scalar);\n        },\n        /**\n     * Multiplies this point by a value\n     * TODO: rename in scalarMultiplyEquals in 2.0\n     * @param {Number} scalar\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */ multiplyEquals: function(scalar) {\n            this.x *= scalar;\n            this.y *= scalar;\n            return this;\n        },\n        /**\n     * Divides this point by a value and returns a new one\n     * TODO: rename in scalarDivide in 2.0\n     * @param {Number} scalar\n     * @return {fabric.Point}\n     */ divide: function(scalar) {\n            return new Point(this.x / scalar, this.y / scalar);\n        },\n        /**\n     * Divides this point by a value\n     * TODO: rename in scalarDivideEquals in 2.0\n     * @param {Number} scalar\n     * @return {fabric.Point} thisArg\n     * @chainable\n     */ divideEquals: function(scalar) {\n            this.x /= scalar;\n            this.y /= scalar;\n            return this;\n        },\n        /**\n     * Returns true if this point is equal to another one\n     * @param {fabric.Point} that\n     * @return {Boolean}\n     */ eq: function(that) {\n            return this.x === that.x && this.y === that.y;\n        },\n        /**\n     * Returns true if this point is less than another one\n     * @param {fabric.Point} that\n     * @return {Boolean}\n     */ lt: function(that) {\n            return this.x < that.x && this.y < that.y;\n        },\n        /**\n     * Returns true if this point is less than or equal to another one\n     * @param {fabric.Point} that\n     * @return {Boolean}\n     */ lte: function(that) {\n            return this.x <= that.x && this.y <= that.y;\n        },\n        /**\n\n     * Returns true if this point is greater another one\n     * @param {fabric.Point} that\n     * @return {Boolean}\n     */ gt: function(that) {\n            return this.x > that.x && this.y > that.y;\n        },\n        /**\n     * Returns true if this point is greater than or equal to another one\n     * @param {fabric.Point} that\n     * @return {Boolean}\n     */ gte: function(that) {\n            return this.x >= that.x && this.y >= that.y;\n        },\n        /**\n     * Returns new point which is the result of linear interpolation with this one and another one\n     * @param {fabric.Point} that\n     * @param {Number} t , position of interpolation, between 0 and 1 default 0.5\n     * @return {fabric.Point}\n     */ lerp: function(that, t) {\n            if (typeof t === \"undefined\") {\n                t = 0.5;\n            }\n            t = Math.max(Math.min(1, t), 0);\n            return new Point(this.x + (that.x - this.x) * t, this.y + (that.y - this.y) * t);\n        },\n        /**\n     * Returns distance from this point and another one\n     * @param {fabric.Point} that\n     * @return {Number}\n     */ distanceFrom: function(that) {\n            var dx = this.x - that.x, dy = this.y - that.y;\n            return Math.sqrt(dx * dx + dy * dy);\n        },\n        /**\n     * Returns the point between this point and another one\n     * @param {fabric.Point} that\n     * @return {fabric.Point}\n     */ midPointFrom: function(that) {\n            return this.lerp(that);\n        },\n        /**\n     * Returns a new point which is the min of this and another one\n     * @param {fabric.Point} that\n     * @return {fabric.Point}\n     */ min: function(that) {\n            return new Point(Math.min(this.x, that.x), Math.min(this.y, that.y));\n        },\n        /**\n     * Returns a new point which is the max of this and another one\n     * @param {fabric.Point} that\n     * @return {fabric.Point}\n     */ max: function(that) {\n            return new Point(Math.max(this.x, that.x), Math.max(this.y, that.y));\n        },\n        /**\n     * Returns string representation of this point\n     * @return {String}\n     */ toString: function() {\n            return this.x + \",\" + this.y;\n        },\n        /**\n     * Sets x/y of this point\n     * @param {Number} x\n     * @param {Number} y\n     * @chainable\n     */ setXY: function(x, y) {\n            this.x = x;\n            this.y = y;\n            return this;\n        },\n        /**\n     * Sets x of this point\n     * @param {Number} x\n     * @chainable\n     */ setX: function(x) {\n            this.x = x;\n            return this;\n        },\n        /**\n     * Sets y of this point\n     * @param {Number} y\n     * @chainable\n     */ setY: function(y) {\n            this.y = y;\n            return this;\n        },\n        /**\n     * Sets x/y of this point from another point\n     * @param {fabric.Point} that\n     * @chainable\n     */ setFromPoint: function(that) {\n            this.x = that.x;\n            this.y = that.y;\n            return this;\n        },\n        /**\n     * Swaps x/y of this point and another point\n     * @param {fabric.Point} that\n     */ swap: function(that) {\n            var x = this.x, y = this.y;\n            this.x = that.x;\n            this.y = that.y;\n            that.x = x;\n            that.y = y;\n        },\n        /**\n     * return a cloned instance of the point\n     * @return {fabric.Point}\n     */ clone: function() {\n            return new Point(this.x, this.y);\n        }\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */ var fabric = global.fabric || (global.fabric = {});\n    if (fabric.Intersection) {\n        fabric.warn(\"fabric.Intersection is already defined\");\n        return;\n    }\n    /**\n   * Intersection class\n   * @class fabric.Intersection\n   * @memberOf fabric\n   * @constructor\n   */ function Intersection(status) {\n        this.status = status;\n        this.points = [];\n    }\n    fabric.Intersection = Intersection;\n    fabric.Intersection.prototype = /** @lends fabric.Intersection.prototype */ {\n        constructor: Intersection,\n        /**\n     * Appends a point to intersection\n     * @param {fabric.Point} point\n     * @return {fabric.Intersection} thisArg\n     * @chainable\n     */ appendPoint: function(point) {\n            this.points.push(point);\n            return this;\n        },\n        /**\n     * Appends points to intersection\n     * @param {Array} points\n     * @return {fabric.Intersection} thisArg\n     * @chainable\n     */ appendPoints: function(points) {\n            this.points = this.points.concat(points);\n            return this;\n        }\n    };\n    /**\n   * Checks if one line intersects another\n   * TODO: rename in intersectSegmentSegment\n   * @static\n   * @param {fabric.Point} a1\n   * @param {fabric.Point} a2\n   * @param {fabric.Point} b1\n   * @param {fabric.Point} b2\n   * @return {fabric.Intersection}\n   */ fabric.Intersection.intersectLineLine = function(a1, a2, b1, b2) {\n        var result, uaT = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x), ubT = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x), uB = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);\n        if (uB !== 0) {\n            var ua = uaT / uB, ub = ubT / uB;\n            if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\n                result = new Intersection(\"Intersection\");\n                result.appendPoint(new fabric.Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)));\n            } else {\n                result = new Intersection();\n            }\n        } else {\n            if (uaT === 0 || ubT === 0) {\n                result = new Intersection(\"Coincident\");\n            } else {\n                result = new Intersection(\"Parallel\");\n            }\n        }\n        return result;\n    };\n    /**\n   * Checks if line intersects polygon\n   * TODO: rename in intersectSegmentPolygon\n   * fix detection of coincident\n   * @static\n   * @param {fabric.Point} a1\n   * @param {fabric.Point} a2\n   * @param {Array} points\n   * @return {fabric.Intersection}\n   */ fabric.Intersection.intersectLinePolygon = function(a1, a2, points) {\n        var result = new Intersection(), length = points.length, b1, b2, inter, i;\n        for(i = 0; i < length; i++){\n            b1 = points[i];\n            b2 = points[(i + 1) % length];\n            inter = Intersection.intersectLineLine(a1, a2, b1, b2);\n            result.appendPoints(inter.points);\n        }\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n        return result;\n    };\n    /**\n   * Checks if polygon intersects another polygon\n   * @static\n   * @param {Array} points1\n   * @param {Array} points2\n   * @return {fabric.Intersection}\n   */ fabric.Intersection.intersectPolygonPolygon = function(points1, points2) {\n        var result = new Intersection(), length = points1.length, i;\n        for(i = 0; i < length; i++){\n            var a1 = points1[i], a2 = points1[(i + 1) % length], inter = Intersection.intersectLinePolygon(a1, a2, points2);\n            result.appendPoints(inter.points);\n        }\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n        return result;\n    };\n    /**\n   * Checks if polygon intersects rectangle\n   * @static\n   * @param {Array} points\n   * @param {fabric.Point} r1\n   * @param {fabric.Point} r2\n   * @return {fabric.Intersection}\n   */ fabric.Intersection.intersectPolygonRectangle = function(points, r1, r2) {\n        var min = r1.min(r2), max = r1.max(r2), topRight = new fabric.Point(max.x, min.y), bottomLeft = new fabric.Point(min.x, max.y), inter1 = Intersection.intersectLinePolygon(min, topRight, points), inter2 = Intersection.intersectLinePolygon(topRight, max, points), inter3 = Intersection.intersectLinePolygon(max, bottomLeft, points), inter4 = Intersection.intersectLinePolygon(bottomLeft, min, points), result = new Intersection();\n        result.appendPoints(inter1.points);\n        result.appendPoints(inter2.points);\n        result.appendPoints(inter3.points);\n        result.appendPoints(inter4.points);\n        if (result.points.length > 0) {\n            result.status = \"Intersection\";\n        }\n        return result;\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {});\n    if (fabric.Color) {\n        fabric.warn(\"fabric.Color is already defined.\");\n        return;\n    }\n    /**\n   * Color class\n   * The purpose of {@link fabric.Color} is to abstract and encapsulate common color operations;\n   * {@link fabric.Color} is a constructor and creates instances of {@link fabric.Color} objects.\n   *\n   * @class fabric.Color\n   * @param {String} color optional in hex or rgb(a) or hsl format or from known color list\n   * @return {fabric.Color} thisArg\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#colors}\n   */ function Color(color) {\n        if (!color) {\n            this.setSource([\n                0,\n                0,\n                0,\n                1\n            ]);\n        } else {\n            this._tryParsingColor(color);\n        }\n    }\n    fabric.Color = Color;\n    fabric.Color.prototype = /** @lends fabric.Color.prototype */ {\n        /**\n     * @private\n     * @param {String|Array} color Color value to parse\n     */ _tryParsingColor: function(color) {\n            var source;\n            if (color in Color.colorNameMap) {\n                color = Color.colorNameMap[color];\n            }\n            if (color === \"transparent\") {\n                source = [\n                    255,\n                    255,\n                    255,\n                    0\n                ];\n            }\n            if (!source) {\n                source = Color.sourceFromHex(color);\n            }\n            if (!source) {\n                source = Color.sourceFromRgb(color);\n            }\n            if (!source) {\n                source = Color.sourceFromHsl(color);\n            }\n            if (!source) {\n                //if color is not recognize let's make black as canvas does\n                source = [\n                    0,\n                    0,\n                    0,\n                    1\n                ];\n            }\n            if (source) {\n                this.setSource(source);\n            }\n        },\n        /**\n     * Adapted from <a href=\"https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html\">https://github.com/mjijackson</a>\n     * @private\n     * @param {Number} r Red color value\n     * @param {Number} g Green color value\n     * @param {Number} b Blue color value\n     * @return {Array} Hsl color\n     */ _rgbToHsl: function(r, g, b) {\n            r /= 255;\n            g /= 255;\n            b /= 255;\n            var h, s, l, max = fabric.util.array.max([\n                r,\n                g,\n                b\n            ]), min = fabric.util.array.min([\n                r,\n                g,\n                b\n            ]);\n            l = (max + min) / 2;\n            if (max === min) {\n                h = s = 0; // achromatic\n            } else {\n                var d = max - min;\n                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n                switch(max){\n                    case r:\n                        h = (g - b) / d + (g < b ? 6 : 0);\n                        break;\n                    case g:\n                        h = (b - r) / d + 2;\n                        break;\n                    case b:\n                        h = (r - g) / d + 4;\n                        break;\n                }\n                h /= 6;\n            }\n            return [\n                Math.round(h * 360),\n                Math.round(s * 100),\n                Math.round(l * 100)\n            ];\n        },\n        /**\n     * Returns source of this color (where source is an array representation; ex: [200, 200, 100, 1])\n     * @return {Array}\n     */ getSource: function() {\n            return this._source;\n        },\n        /**\n     * Sets source of this color (where source is an array representation; ex: [200, 200, 100, 1])\n     * @param {Array} source\n     */ setSource: function(source) {\n            this._source = source;\n        },\n        /**\n     * Returns color representation in RGB format\n     * @return {String} ex: rgb(0-255,0-255,0-255)\n     */ toRgb: function() {\n            var source = this.getSource();\n            return \"rgb(\" + source[0] + \",\" + source[1] + \",\" + source[2] + \")\";\n        },\n        /**\n     * Returns color representation in RGBA format\n     * @return {String} ex: rgba(0-255,0-255,0-255,0-1)\n     */ toRgba: function() {\n            var source = this.getSource();\n            return \"rgba(\" + source[0] + \",\" + source[1] + \",\" + source[2] + \",\" + source[3] + \")\";\n        },\n        /**\n     * Returns color representation in HSL format\n     * @return {String} ex: hsl(0-360,0%-100%,0%-100%)\n     */ toHsl: function() {\n            var source = this.getSource(), hsl = this._rgbToHsl(source[0], source[1], source[2]);\n            return \"hsl(\" + hsl[0] + \",\" + hsl[1] + \"%,\" + hsl[2] + \"%)\";\n        },\n        /**\n     * Returns color representation in HSLA format\n     * @return {String} ex: hsla(0-360,0%-100%,0%-100%,0-1)\n     */ toHsla: function() {\n            var source = this.getSource(), hsl = this._rgbToHsl(source[0], source[1], source[2]);\n            return \"hsla(\" + hsl[0] + \",\" + hsl[1] + \"%,\" + hsl[2] + \"%,\" + source[3] + \")\";\n        },\n        /**\n     * Returns color representation in HEX format\n     * @return {String} ex: FF5555\n     */ toHex: function() {\n            var source = this.getSource(), r, g, b;\n            r = source[0].toString(16);\n            r = r.length === 1 ? \"0\" + r : r;\n            g = source[1].toString(16);\n            g = g.length === 1 ? \"0\" + g : g;\n            b = source[2].toString(16);\n            b = b.length === 1 ? \"0\" + b : b;\n            return r.toUpperCase() + g.toUpperCase() + b.toUpperCase();\n        },\n        /**\n     * Returns color representation in HEXA format\n     * @return {String} ex: FF5555CC\n     */ toHexa: function() {\n            var source = this.getSource(), a;\n            a = Math.round(source[3] * 255);\n            a = a.toString(16);\n            a = a.length === 1 ? \"0\" + a : a;\n            return this.toHex() + a.toUpperCase();\n        },\n        /**\n     * Gets value of alpha channel for this color\n     * @return {Number} 0-1\n     */ getAlpha: function() {\n            return this.getSource()[3];\n        },\n        /**\n     * Sets value of alpha channel for this color\n     * @param {Number} alpha Alpha value 0-1\n     * @return {fabric.Color} thisArg\n     */ setAlpha: function(alpha) {\n            var source = this.getSource();\n            source[3] = alpha;\n            this.setSource(source);\n            return this;\n        },\n        /**\n     * Transforms color to its grayscale representation\n     * @return {fabric.Color} thisArg\n     */ toGrayscale: function() {\n            var source = this.getSource(), average = parseInt((source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0), 10), currentAlpha = source[3];\n            this.setSource([\n                average,\n                average,\n                average,\n                currentAlpha\n            ]);\n            return this;\n        },\n        /**\n     * Transforms color to its black and white representation\n     * @param {Number} threshold\n     * @return {fabric.Color} thisArg\n     */ toBlackWhite: function(threshold) {\n            var source = this.getSource(), average = (source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0), currentAlpha = source[3];\n            threshold = threshold || 127;\n            average = Number(average) < Number(threshold) ? 0 : 255;\n            this.setSource([\n                average,\n                average,\n                average,\n                currentAlpha\n            ]);\n            return this;\n        },\n        /**\n     * Overlays color with another color\n     * @param {String|fabric.Color} otherColor\n     * @return {fabric.Color} thisArg\n     */ overlayWith: function(otherColor) {\n            if (!(otherColor instanceof Color)) {\n                otherColor = new Color(otherColor);\n            }\n            var result = [], alpha = this.getAlpha(), otherAlpha = 0.5, source = this.getSource(), otherSource = otherColor.getSource(), i;\n            for(i = 0; i < 3; i++){\n                result.push(Math.round(source[i] * (1 - otherAlpha) + otherSource[i] * otherAlpha));\n            }\n            result[3] = alpha;\n            this.setSource(result);\n            return this;\n        }\n    };\n    /**\n   * Regex matching color in RGB or RGBA formats (ex: rgb(0, 0, 0), rgba(255, 100, 10, 0.5), rgba( 255 , 100 , 10 , 0.5 ), rgb(1,1,1), rgba(100%, 60%, 10%, 0.5))\n   * @static\n   * @field\n   * @memberOf fabric.Color\n   */ // eslint-disable-next-line max-len\n    fabric.Color.reRGBa = /^rgba?\\(\\s*(\\d{1,3}(?:\\.\\d+)?\\%?)\\s*,\\s*(\\d{1,3}(?:\\.\\d+)?\\%?)\\s*,\\s*(\\d{1,3}(?:\\.\\d+)?\\%?)\\s*(?:\\s*,\\s*((?:\\d*\\.?\\d+)?)\\s*)?\\)$/i;\n    /**\n   * Regex matching color in HSL or HSLA formats (ex: hsl(200, 80%, 10%), hsla(300, 50%, 80%, 0.5), hsla( 300 , 50% , 80% , 0.5 ))\n   * @static\n   * @field\n   * @memberOf fabric.Color\n   */ fabric.Color.reHSLa = /^hsla?\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3}\\%)\\s*,\\s*(\\d{1,3}\\%)\\s*(?:\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*)?\\)$/i;\n    /**\n   * Regex matching color in HEX format (ex: #FF5544CC, #FF5555, 010155, aff)\n   * @static\n   * @field\n   * @memberOf fabric.Color\n   */ fabric.Color.reHex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;\n    /**\n   * Map of the 148 color names with HEX code\n   * @static\n   * @field\n   * @memberOf fabric.Color\n   * @see: https://www.w3.org/TR/css3-color/#svg-color\n   */ fabric.Color.colorNameMap = {\n        aliceblue: \"#F0F8FF\",\n        antiquewhite: \"#FAEBD7\",\n        aqua: \"#00FFFF\",\n        aquamarine: \"#7FFFD4\",\n        azure: \"#F0FFFF\",\n        beige: \"#F5F5DC\",\n        bisque: \"#FFE4C4\",\n        black: \"#000000\",\n        blanchedalmond: \"#FFEBCD\",\n        blue: \"#0000FF\",\n        blueviolet: \"#8A2BE2\",\n        brown: \"#A52A2A\",\n        burlywood: \"#DEB887\",\n        cadetblue: \"#5F9EA0\",\n        chartreuse: \"#7FFF00\",\n        chocolate: \"#D2691E\",\n        coral: \"#FF7F50\",\n        cornflowerblue: \"#6495ED\",\n        cornsilk: \"#FFF8DC\",\n        crimson: \"#DC143C\",\n        cyan: \"#00FFFF\",\n        darkblue: \"#00008B\",\n        darkcyan: \"#008B8B\",\n        darkgoldenrod: \"#B8860B\",\n        darkgray: \"#A9A9A9\",\n        darkgrey: \"#A9A9A9\",\n        darkgreen: \"#006400\",\n        darkkhaki: \"#BDB76B\",\n        darkmagenta: \"#8B008B\",\n        darkolivegreen: \"#556B2F\",\n        darkorange: \"#FF8C00\",\n        darkorchid: \"#9932CC\",\n        darkred: \"#8B0000\",\n        darksalmon: \"#E9967A\",\n        darkseagreen: \"#8FBC8F\",\n        darkslateblue: \"#483D8B\",\n        darkslategray: \"#2F4F4F\",\n        darkslategrey: \"#2F4F4F\",\n        darkturquoise: \"#00CED1\",\n        darkviolet: \"#9400D3\",\n        deeppink: \"#FF1493\",\n        deepskyblue: \"#00BFFF\",\n        dimgray: \"#696969\",\n        dimgrey: \"#696969\",\n        dodgerblue: \"#1E90FF\",\n        firebrick: \"#B22222\",\n        floralwhite: \"#FFFAF0\",\n        forestgreen: \"#228B22\",\n        fuchsia: \"#FF00FF\",\n        gainsboro: \"#DCDCDC\",\n        ghostwhite: \"#F8F8FF\",\n        gold: \"#FFD700\",\n        goldenrod: \"#DAA520\",\n        gray: \"#808080\",\n        grey: \"#808080\",\n        green: \"#008000\",\n        greenyellow: \"#ADFF2F\",\n        honeydew: \"#F0FFF0\",\n        hotpink: \"#FF69B4\",\n        indianred: \"#CD5C5C\",\n        indigo: \"#4B0082\",\n        ivory: \"#FFFFF0\",\n        khaki: \"#F0E68C\",\n        lavender: \"#E6E6FA\",\n        lavenderblush: \"#FFF0F5\",\n        lawngreen: \"#7CFC00\",\n        lemonchiffon: \"#FFFACD\",\n        lightblue: \"#ADD8E6\",\n        lightcoral: \"#F08080\",\n        lightcyan: \"#E0FFFF\",\n        lightgoldenrodyellow: \"#FAFAD2\",\n        lightgray: \"#D3D3D3\",\n        lightgrey: \"#D3D3D3\",\n        lightgreen: \"#90EE90\",\n        lightpink: \"#FFB6C1\",\n        lightsalmon: \"#FFA07A\",\n        lightseagreen: \"#20B2AA\",\n        lightskyblue: \"#87CEFA\",\n        lightslategray: \"#778899\",\n        lightslategrey: \"#778899\",\n        lightsteelblue: \"#B0C4DE\",\n        lightyellow: \"#FFFFE0\",\n        lime: \"#00FF00\",\n        limegreen: \"#32CD32\",\n        linen: \"#FAF0E6\",\n        magenta: \"#FF00FF\",\n        maroon: \"#800000\",\n        mediumaquamarine: \"#66CDAA\",\n        mediumblue: \"#0000CD\",\n        mediumorchid: \"#BA55D3\",\n        mediumpurple: \"#9370DB\",\n        mediumseagreen: \"#3CB371\",\n        mediumslateblue: \"#7B68EE\",\n        mediumspringgreen: \"#00FA9A\",\n        mediumturquoise: \"#48D1CC\",\n        mediumvioletred: \"#C71585\",\n        midnightblue: \"#191970\",\n        mintcream: \"#F5FFFA\",\n        mistyrose: \"#FFE4E1\",\n        moccasin: \"#FFE4B5\",\n        navajowhite: \"#FFDEAD\",\n        navy: \"#000080\",\n        oldlace: \"#FDF5E6\",\n        olive: \"#808000\",\n        olivedrab: \"#6B8E23\",\n        orange: \"#FFA500\",\n        orangered: \"#FF4500\",\n        orchid: \"#DA70D6\",\n        palegoldenrod: \"#EEE8AA\",\n        palegreen: \"#98FB98\",\n        paleturquoise: \"#AFEEEE\",\n        palevioletred: \"#DB7093\",\n        papayawhip: \"#FFEFD5\",\n        peachpuff: \"#FFDAB9\",\n        peru: \"#CD853F\",\n        pink: \"#FFC0CB\",\n        plum: \"#DDA0DD\",\n        powderblue: \"#B0E0E6\",\n        purple: \"#800080\",\n        rebeccapurple: \"#663399\",\n        red: \"#FF0000\",\n        rosybrown: \"#BC8F8F\",\n        royalblue: \"#4169E1\",\n        saddlebrown: \"#8B4513\",\n        salmon: \"#FA8072\",\n        sandybrown: \"#F4A460\",\n        seagreen: \"#2E8B57\",\n        seashell: \"#FFF5EE\",\n        sienna: \"#A0522D\",\n        silver: \"#C0C0C0\",\n        skyblue: \"#87CEEB\",\n        slateblue: \"#6A5ACD\",\n        slategray: \"#708090\",\n        slategrey: \"#708090\",\n        snow: \"#FFFAFA\",\n        springgreen: \"#00FF7F\",\n        steelblue: \"#4682B4\",\n        tan: \"#D2B48C\",\n        teal: \"#008080\",\n        thistle: \"#D8BFD8\",\n        tomato: \"#FF6347\",\n        turquoise: \"#40E0D0\",\n        violet: \"#EE82EE\",\n        wheat: \"#F5DEB3\",\n        white: \"#FFFFFF\",\n        whitesmoke: \"#F5F5F5\",\n        yellow: \"#FFFF00\",\n        yellowgreen: \"#9ACD32\"\n    };\n    /**\n   * @private\n   * @param {Number} p\n   * @param {Number} q\n   * @param {Number} t\n   * @return {Number}\n   */ function hue2rgb(p, q, t) {\n        if (t < 0) {\n            t += 1;\n        }\n        if (t > 1) {\n            t -= 1;\n        }\n        if (t < 1 / 6) {\n            return p + (q - p) * 6 * t;\n        }\n        if (t < 1 / 2) {\n            return q;\n        }\n        if (t < 2 / 3) {\n            return p + (q - p) * (2 / 3 - t) * 6;\n        }\n        return p;\n    }\n    /**\n   * Returns new color object, when given a color in RGB format\n   * @memberOf fabric.Color\n   * @param {String} color Color value ex: rgb(0-255,0-255,0-255)\n   * @return {fabric.Color}\n   */ fabric.Color.fromRgb = function(color) {\n        return Color.fromSource(Color.sourceFromRgb(color));\n    };\n    /**\n   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in RGB or RGBA format\n   * @memberOf fabric.Color\n   * @param {String} color Color value ex: rgb(0-255,0-255,0-255), rgb(0%-100%,0%-100%,0%-100%)\n   * @return {Array} source\n   */ fabric.Color.sourceFromRgb = function(color) {\n        var match = color.match(Color.reRGBa);\n        if (match) {\n            var r = parseInt(match[1], 10) / (/%$/.test(match[1]) ? 100 : 1) * (/%$/.test(match[1]) ? 255 : 1), g = parseInt(match[2], 10) / (/%$/.test(match[2]) ? 100 : 1) * (/%$/.test(match[2]) ? 255 : 1), b = parseInt(match[3], 10) / (/%$/.test(match[3]) ? 100 : 1) * (/%$/.test(match[3]) ? 255 : 1);\n            return [\n                parseInt(r, 10),\n                parseInt(g, 10),\n                parseInt(b, 10),\n                match[4] ? parseFloat(match[4]) : 1\n            ];\n        }\n    };\n    /**\n   * Returns new color object, when given a color in RGBA format\n   * @static\n   * @function\n   * @memberOf fabric.Color\n   * @param {String} color\n   * @return {fabric.Color}\n   */ fabric.Color.fromRgba = Color.fromRgb;\n    /**\n   * Returns new color object, when given a color in HSL format\n   * @param {String} color Color value ex: hsl(0-260,0%-100%,0%-100%)\n   * @memberOf fabric.Color\n   * @return {fabric.Color}\n   */ fabric.Color.fromHsl = function(color) {\n        return Color.fromSource(Color.sourceFromHsl(color));\n    };\n    /**\n   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HSL or HSLA format.\n   * Adapted from <a href=\"https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html\">https://github.com/mjijackson</a>\n   * @memberOf fabric.Color\n   * @param {String} color Color value ex: hsl(0-360,0%-100%,0%-100%) or hsla(0-360,0%-100%,0%-100%, 0-1)\n   * @return {Array} source\n   * @see http://http://www.w3.org/TR/css3-color/#hsl-color\n   */ fabric.Color.sourceFromHsl = function(color) {\n        var match = color.match(Color.reHSLa);\n        if (!match) {\n            return;\n        }\n        var h = (parseFloat(match[1]) % 360 + 360) % 360 / 360, s = parseFloat(match[2]) / (/%$/.test(match[2]) ? 100 : 1), l = parseFloat(match[3]) / (/%$/.test(match[3]) ? 100 : 1), r, g, b;\n        if (s === 0) {\n            r = g = b = l;\n        } else {\n            var q = l <= 0.5 ? l * (s + 1) : l + s - l * s, p = l * 2 - q;\n            r = hue2rgb(p, q, h + 1 / 3);\n            g = hue2rgb(p, q, h);\n            b = hue2rgb(p, q, h - 1 / 3);\n        }\n        return [\n            Math.round(r * 255),\n            Math.round(g * 255),\n            Math.round(b * 255),\n            match[4] ? parseFloat(match[4]) : 1\n        ];\n    };\n    /**\n   * Returns new color object, when given a color in HSLA format\n   * @static\n   * @function\n   * @memberOf fabric.Color\n   * @param {String} color\n   * @return {fabric.Color}\n   */ fabric.Color.fromHsla = Color.fromHsl;\n    /**\n   * Returns new color object, when given a color in HEX format\n   * @static\n   * @memberOf fabric.Color\n   * @param {String} color Color value ex: FF5555\n   * @return {fabric.Color}\n   */ fabric.Color.fromHex = function(color) {\n        return Color.fromSource(Color.sourceFromHex(color));\n    };\n    /**\n   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HEX format\n   * @static\n   * @memberOf fabric.Color\n   * @param {String} color ex: FF5555 or FF5544CC (RGBa)\n   * @return {Array} source\n   */ fabric.Color.sourceFromHex = function(color) {\n        if (color.match(Color.reHex)) {\n            var value = color.slice(color.indexOf(\"#\") + 1), isShortNotation = value.length === 3 || value.length === 4, isRGBa = value.length === 8 || value.length === 4, r = isShortNotation ? value.charAt(0) + value.charAt(0) : value.substring(0, 2), g = isShortNotation ? value.charAt(1) + value.charAt(1) : value.substring(2, 4), b = isShortNotation ? value.charAt(2) + value.charAt(2) : value.substring(4, 6), a = isRGBa ? isShortNotation ? value.charAt(3) + value.charAt(3) : value.substring(6, 8) : \"FF\";\n            return [\n                parseInt(r, 16),\n                parseInt(g, 16),\n                parseInt(b, 16),\n                parseFloat((parseInt(a, 16) / 255).toFixed(2))\n            ];\n        }\n    };\n    /**\n   * Returns new color object, when given color in array representation (ex: [200, 100, 100, 0.5])\n   * @static\n   * @memberOf fabric.Color\n   * @param {Array} source\n   * @return {fabric.Color}\n   */ fabric.Color.fromSource = function(source) {\n        var oColor = new Color();\n        oColor.setSource(source);\n        return oColor;\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), scaleMap = [\n        \"e\",\n        \"se\",\n        \"s\",\n        \"sw\",\n        \"w\",\n        \"nw\",\n        \"n\",\n        \"ne\",\n        \"e\"\n    ], skewMap = [\n        \"ns\",\n        \"nesw\",\n        \"ew\",\n        \"nwse\"\n    ], controls = {}, LEFT = \"left\", TOP = \"top\", RIGHT = \"right\", BOTTOM = \"bottom\", CENTER = \"center\", opposite = {\n        top: BOTTOM,\n        bottom: TOP,\n        left: RIGHT,\n        right: LEFT,\n        center: CENTER\n    }, radiansToDegrees = fabric.util.radiansToDegrees, sign = Math.sign || function(x) {\n        return (x > 0) - (x < 0) || +x;\n    };\n    /**\n   * Combine control position and object angle to find the control direction compared\n   * to the object center.\n   * @param {fabric.Object} fabricObject the fabric object for which we are rendering controls\n   * @param {fabric.Control} control the control class\n   * @return {Number} 0 - 7 a quadrant number\n   */ function findCornerQuadrant(fabricObject, control) {\n        var cornerAngle = fabricObject.angle + radiansToDegrees(Math.atan2(control.y, control.x)) + 360;\n        return Math.round(cornerAngle % 360 / 45);\n    }\n    function fireEvent(eventName, options) {\n        var target = options.transform.target, canvas = target.canvas, canvasOptions = fabric.util.object.clone(options);\n        canvasOptions.target = target;\n        canvas && canvas.fire(\"object:\" + eventName, canvasOptions);\n        target.fire(eventName, options);\n    }\n    /**\n   * Inspect event and fabricObject properties to understand if the scaling action\n   * @param {Event} eventData from the user action\n   * @param {fabric.Object} fabricObject the fabric object about to scale\n   * @return {Boolean} true if scale is proportional\n   */ function scaleIsProportional(eventData, fabricObject) {\n        var canvas = fabricObject.canvas, uniScaleKey = canvas.uniScaleKey, uniformIsToggled = eventData[uniScaleKey];\n        return canvas.uniformScaling && !uniformIsToggled || !canvas.uniformScaling && uniformIsToggled;\n    }\n    /**\n   * Checks if transform is centered\n   * @param {Object} transform transform data\n   * @return {Boolean} true if transform is centered\n   */ function isTransformCentered(transform) {\n        return transform.originX === CENTER && transform.originY === CENTER;\n    }\n    /**\n   * Inspect fabricObject to understand if the current scaling action is allowed\n   * @param {fabric.Object} fabricObject the fabric object about to scale\n   * @param {String} by 'x' or 'y' or ''\n   * @param {Boolean} scaleProportionally true if we are trying to scale proportionally\n   * @return {Boolean} true if scaling is not allowed at current conditions\n   */ function scalingIsForbidden(fabricObject, by, scaleProportionally) {\n        var lockX = fabricObject.lockScalingX, lockY = fabricObject.lockScalingY;\n        if (lockX && lockY) {\n            return true;\n        }\n        if (!by && (lockX || lockY) && scaleProportionally) {\n            return true;\n        }\n        if (lockX && by === \"x\") {\n            return true;\n        }\n        if (lockY && by === \"y\") {\n            return true;\n        }\n        return false;\n    }\n    /**\n   * return the correct cursor style for the scale action\n   * @param {Event} eventData the javascript event that is causing the scale\n   * @param {fabric.Control} control the control that is interested in the action\n   * @param {fabric.Object} fabricObject the fabric object that is interested in the action\n   * @return {String} a valid css string for the cursor\n   */ function scaleCursorStyleHandler(eventData, control, fabricObject) {\n        var notAllowed = \"not-allowed\", scaleProportionally = scaleIsProportional(eventData, fabricObject), by = \"\";\n        if (control.x !== 0 && control.y === 0) {\n            by = \"x\";\n        } else if (control.x === 0 && control.y !== 0) {\n            by = \"y\";\n        }\n        if (scalingIsForbidden(fabricObject, by, scaleProportionally)) {\n            return notAllowed;\n        }\n        var n = findCornerQuadrant(fabricObject, control);\n        return scaleMap[n] + \"-resize\";\n    }\n    /**\n   * return the correct cursor style for the skew action\n   * @param {Event} eventData the javascript event that is causing the scale\n   * @param {fabric.Control} control the control that is interested in the action\n   * @param {fabric.Object} fabricObject the fabric object that is interested in the action\n   * @return {String} a valid css string for the cursor\n   */ function skewCursorStyleHandler(eventData, control, fabricObject) {\n        var notAllowed = \"not-allowed\";\n        if (control.x !== 0 && fabricObject.lockSkewingY) {\n            return notAllowed;\n        }\n        if (control.y !== 0 && fabricObject.lockSkewingX) {\n            return notAllowed;\n        }\n        var n = findCornerQuadrant(fabricObject, control) % 4;\n        return skewMap[n] + \"-resize\";\n    }\n    /**\n   * Combine skew and scale style handlers to cover fabric standard use case\n   * @param {Event} eventData the javascript event that is causing the scale\n   * @param {fabric.Control} control the control that is interested in the action\n   * @param {fabric.Object} fabricObject the fabric object that is interested in the action\n   * @return {String} a valid css string for the cursor\n   */ function scaleSkewCursorStyleHandler(eventData, control, fabricObject) {\n        if (eventData[fabricObject.canvas.altActionKey]) {\n            return controls.skewCursorStyleHandler(eventData, control, fabricObject);\n        }\n        return controls.scaleCursorStyleHandler(eventData, control, fabricObject);\n    }\n    /**\n   * Inspect event, control and fabricObject to return the correct action name\n   * @param {Event} eventData the javascript event that is causing the scale\n   * @param {fabric.Control} control the control that is interested in the action\n   * @param {fabric.Object} fabricObject the fabric object that is interested in the action\n   * @return {String} an action name\n   */ function scaleOrSkewActionName(eventData, control, fabricObject) {\n        var isAlternative = eventData[fabricObject.canvas.altActionKey];\n        if (control.x === 0) {\n            // then is scaleY or skewX\n            return isAlternative ? \"skewX\" : \"scaleY\";\n        }\n        if (control.y === 0) {\n            // then is scaleY or skewX\n            return isAlternative ? \"skewY\" : \"scaleX\";\n        }\n    }\n    /**\n   * Find the correct style for the control that is used for rotation.\n   * this function is very simple and it just take care of not-allowed or standard cursor\n   * @param {Event} eventData the javascript event that is causing the scale\n   * @param {fabric.Control} control the control that is interested in the action\n   * @param {fabric.Object} fabricObject the fabric object that is interested in the action\n   * @return {String} a valid css string for the cursor\n   */ function rotationStyleHandler(eventData, control, fabricObject) {\n        if (fabricObject.lockRotation) {\n            return \"not-allowed\";\n        }\n        return control.cursorStyle;\n    }\n    function commonEventInfo(eventData, transform, x, y) {\n        return {\n            e: eventData,\n            transform: transform,\n            pointer: {\n                x: x,\n                y: y\n            }\n        };\n    }\n    /**\n   * Wrap an action handler with saving/restoring object position on the transform.\n   * this is the code that permits to objects to keep their position while transforming.\n   * @param {Function} actionHandler the function to wrap\n   * @return {Function} a function with an action handler signature\n   */ function wrapWithFixedAnchor(actionHandler) {\n        return function(eventData, transform, x, y) {\n            var target = transform.target, centerPoint = target.getCenterPoint(), constraint = target.translateToOriginPoint(centerPoint, transform.originX, transform.originY), actionPerformed = actionHandler(eventData, transform, x, y);\n            target.setPositionByOrigin(constraint, transform.originX, transform.originY);\n            return actionPerformed;\n        };\n    }\n    /**\n   * Wrap an action handler with firing an event if the action is performed\n   * @param {Function} actionHandler the function to wrap\n   * @return {Function} a function with an action handler signature\n   */ function wrapWithFireEvent(eventName, actionHandler) {\n        return function(eventData, transform, x, y) {\n            var actionPerformed = actionHandler(eventData, transform, x, y);\n            if (actionPerformed) {\n                fireEvent(eventName, commonEventInfo(eventData, transform, x, y));\n            }\n            return actionPerformed;\n        };\n    }\n    /**\n   * Transforms a point described by x and y in a distance from the top left corner of the object\n   * bounding box.\n   * @param {Object} transform\n   * @param {String} originX\n   * @param {String} originY\n   * @param {number} x\n   * @param {number} y\n   * @return {Fabric.Point} the normalized point\n   */ function getLocalPoint(transform, originX, originY, x, y) {\n        var target = transform.target, control = target.controls[transform.corner], zoom = target.canvas.getZoom(), padding = target.padding / zoom, localPoint = target.toLocalPoint(new fabric.Point(x, y), originX, originY);\n        if (localPoint.x >= padding) {\n            localPoint.x -= padding;\n        }\n        if (localPoint.x <= -padding) {\n            localPoint.x += padding;\n        }\n        if (localPoint.y >= padding) {\n            localPoint.y -= padding;\n        }\n        if (localPoint.y <= padding) {\n            localPoint.y += padding;\n        }\n        localPoint.x -= control.offsetX;\n        localPoint.y -= control.offsetY;\n        return localPoint;\n    }\n    /**\n   * Detect if the fabric object is flipped on one side.\n   * @param {fabric.Object} target\n   * @return {Boolean} true if one flip, but not two.\n   */ function targetHasOneFlip(target) {\n        return target.flipX !== target.flipY;\n    }\n    /**\n   * Utility function to compensate the scale factor when skew is applied on both axes\n   * @private\n   */ function compensateScaleForSkew(target, oppositeSkew, scaleToCompensate, axis, reference) {\n        if (target[oppositeSkew] !== 0) {\n            var newDim = target._getTransformedDimensions()[axis];\n            var newValue = reference / newDim * target[scaleToCompensate];\n            target.set(scaleToCompensate, newValue);\n        }\n    }\n    /**\n   * Action handler for skewing on the X axis\n   * @private\n   */ function skewObjectX(eventData, transform, x, y) {\n        var target = transform.target, // find how big the object would be, if there was no skewX. takes in account scaling\n        dimNoSkew = target._getTransformedDimensions(0, target.skewY), localPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y), // the mouse is in the center of the object, and we want it to stay there.\n        // so the object will grow twice as much as the mouse.\n        // this makes the skew growth to localPoint * 2 - dimNoSkew.\n        totalSkewSize = Math.abs(localPoint.x * 2) - dimNoSkew.x, currentSkew = target.skewX, newSkew;\n        if (totalSkewSize < 2) {\n            // let's make it easy to go back to position 0.\n            newSkew = 0;\n        } else {\n            newSkew = radiansToDegrees(Math.atan2(totalSkewSize / target.scaleX, dimNoSkew.y / target.scaleY));\n            // now we have to find the sign of the skew.\n            // it mostly depend on the origin of transformation.\n            if (transform.originX === LEFT && transform.originY === BOTTOM) {\n                newSkew = -newSkew;\n            }\n            if (transform.originX === RIGHT && transform.originY === TOP) {\n                newSkew = -newSkew;\n            }\n            if (targetHasOneFlip(target)) {\n                newSkew = -newSkew;\n            }\n        }\n        var hasSkewed = currentSkew !== newSkew;\n        if (hasSkewed) {\n            var dimBeforeSkewing = target._getTransformedDimensions().y;\n            target.set(\"skewX\", newSkew);\n            compensateScaleForSkew(target, \"skewY\", \"scaleY\", \"y\", dimBeforeSkewing);\n        }\n        return hasSkewed;\n    }\n    /**\n   * Action handler for skewing on the Y axis\n   * @private\n   */ function skewObjectY(eventData, transform, x, y) {\n        var target = transform.target, // find how big the object would be, if there was no skewX. takes in account scaling\n        dimNoSkew = target._getTransformedDimensions(target.skewX, 0), localPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y), // the mouse is in the center of the object, and we want it to stay there.\n        // so the object will grow twice as much as the mouse.\n        // this makes the skew growth to localPoint * 2 - dimNoSkew.\n        totalSkewSize = Math.abs(localPoint.y * 2) - dimNoSkew.y, currentSkew = target.skewY, newSkew;\n        if (totalSkewSize < 2) {\n            // let's make it easy to go back to position 0.\n            newSkew = 0;\n        } else {\n            newSkew = radiansToDegrees(Math.atan2(totalSkewSize / target.scaleY, dimNoSkew.x / target.scaleX));\n            // now we have to find the sign of the skew.\n            // it mostly depend on the origin of transformation.\n            if (transform.originX === LEFT && transform.originY === BOTTOM) {\n                newSkew = -newSkew;\n            }\n            if (transform.originX === RIGHT && transform.originY === TOP) {\n                newSkew = -newSkew;\n            }\n            if (targetHasOneFlip(target)) {\n                newSkew = -newSkew;\n            }\n        }\n        var hasSkewed = currentSkew !== newSkew;\n        if (hasSkewed) {\n            var dimBeforeSkewing = target._getTransformedDimensions().x;\n            target.set(\"skewY\", newSkew);\n            compensateScaleForSkew(target, \"skewX\", \"scaleX\", \"x\", dimBeforeSkewing);\n        }\n        return hasSkewed;\n    }\n    /**\n   * Wrapped Action handler for skewing on the Y axis, takes care of the\n   * skew direction and determine the correct transform origin for the anchor point\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function skewHandlerX(eventData, transform, x, y) {\n        // step1 figure out and change transform origin.\n        // if skewX > 0 and originY bottom we anchor on right\n        // if skewX > 0 and originY top we anchor on left\n        // if skewX < 0 and originY bottom we anchor on left\n        // if skewX < 0 and originY top we anchor on right\n        // if skewX is 0, we look for mouse position to understand where are we going.\n        var target = transform.target, currentSkew = target.skewX, originX, originY = transform.originY;\n        if (target.lockSkewingX) {\n            return false;\n        }\n        if (currentSkew === 0) {\n            var localPointFromCenter = getLocalPoint(transform, CENTER, CENTER, x, y);\n            if (localPointFromCenter.x > 0) {\n                // we are pulling right, anchor left;\n                originX = LEFT;\n            } else {\n                // we are pulling right, anchor right\n                originX = RIGHT;\n            }\n        } else {\n            if (currentSkew > 0) {\n                originX = originY === TOP ? LEFT : RIGHT;\n            }\n            if (currentSkew < 0) {\n                originX = originY === TOP ? RIGHT : LEFT;\n            }\n            // is the object flipped on one side only? swap the origin.\n            if (targetHasOneFlip(target)) {\n                originX = originX === LEFT ? RIGHT : LEFT;\n            }\n        }\n        // once we have the origin, we find the anchor point\n        transform.originX = originX;\n        var finalHandler = wrapWithFireEvent(\"skewing\", wrapWithFixedAnchor(skewObjectX));\n        return finalHandler(eventData, transform, x, y);\n    }\n    /**\n   * Wrapped Action handler for skewing on the Y axis, takes care of the\n   * skew direction and determine the correct transform origin for the anchor point\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function skewHandlerY(eventData, transform, x, y) {\n        // step1 figure out and change transform origin.\n        // if skewY > 0 and originX left we anchor on top\n        // if skewY > 0 and originX right we anchor on bottom\n        // if skewY < 0 and originX left we anchor on bottom\n        // if skewY < 0 and originX right we anchor on top\n        // if skewY is 0, we look for mouse position to understand where are we going.\n        var target = transform.target, currentSkew = target.skewY, originY, originX = transform.originX;\n        if (target.lockSkewingY) {\n            return false;\n        }\n        if (currentSkew === 0) {\n            var localPointFromCenter = getLocalPoint(transform, CENTER, CENTER, x, y);\n            if (localPointFromCenter.y > 0) {\n                // we are pulling down, anchor up;\n                originY = TOP;\n            } else {\n                // we are pulling up, anchor down\n                originY = BOTTOM;\n            }\n        } else {\n            if (currentSkew > 0) {\n                originY = originX === LEFT ? TOP : BOTTOM;\n            }\n            if (currentSkew < 0) {\n                originY = originX === LEFT ? BOTTOM : TOP;\n            }\n            // is the object flipped on one side only? swap the origin.\n            if (targetHasOneFlip(target)) {\n                originY = originY === TOP ? BOTTOM : TOP;\n            }\n        }\n        // once we have the origin, we find the anchor point\n        transform.originY = originY;\n        var finalHandler = wrapWithFireEvent(\"skewing\", wrapWithFixedAnchor(skewObjectY));\n        return finalHandler(eventData, transform, x, y);\n    }\n    /**\n   * Action handler for rotation and snapping, without anchor point.\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   * @private\n   */ function rotationWithSnapping(eventData, transform, x, y) {\n        var t = transform, target = t.target, pivotPoint = target.translateToOriginPoint(target.getCenterPoint(), t.originX, t.originY);\n        if (target.lockRotation) {\n            return false;\n        }\n        var lastAngle = Math.atan2(t.ey - pivotPoint.y, t.ex - pivotPoint.x), curAngle = Math.atan2(y - pivotPoint.y, x - pivotPoint.x), angle = radiansToDegrees(curAngle - lastAngle + t.theta), hasRotated = true;\n        if (target.snapAngle > 0) {\n            var snapAngle = target.snapAngle, snapThreshold = target.snapThreshold || snapAngle, rightAngleLocked = Math.ceil(angle / snapAngle) * snapAngle, leftAngleLocked = Math.floor(angle / snapAngle) * snapAngle;\n            if (Math.abs(angle - leftAngleLocked) < snapThreshold) {\n                angle = leftAngleLocked;\n            } else if (Math.abs(angle - rightAngleLocked) < snapThreshold) {\n                angle = rightAngleLocked;\n            }\n        }\n        // normalize angle to positive value\n        if (angle < 0) {\n            angle = 360 + angle;\n        }\n        angle %= 360;\n        hasRotated = target.angle !== angle;\n        target.angle = angle;\n        return hasRotated;\n    }\n    /**\n   * Basic scaling logic, reused with different constrain for scaling X,Y, freely or equally.\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @param {Object} options additional information for scaling\n   * @param {String} options.by 'x', 'y', 'equally' or '' to indicate type of scaling\n   * @return {Boolean} true if some change happened\n   * @private\n   */ function scaleObject(eventData, transform, x, y, options) {\n        options = options || {};\n        var target = transform.target, lockScalingX = target.lockScalingX, lockScalingY = target.lockScalingY, by = options.by, newPoint, scaleX, scaleY, dim, scaleProportionally = scaleIsProportional(eventData, target), forbidScaling = scalingIsForbidden(target, by, scaleProportionally), signX, signY, gestureScale = transform.gestureScale;\n        if (forbidScaling) {\n            return false;\n        }\n        if (gestureScale) {\n            scaleX = transform.scaleX * gestureScale;\n            scaleY = transform.scaleY * gestureScale;\n        } else {\n            newPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y);\n            // use of sign: We use sign to detect change of direction of an action. sign usually change when\n            // we cross the origin point with the mouse. So a scale flip for example. There is an issue when scaling\n            // by center and scaling using one middle control ( default: mr, mt, ml, mb), the mouse movement can easily\n            // cross many time the origin point and flip the object. so we need a way to filter out the noise.\n            // This ternary here should be ok to filter out X scaling when we want Y only and vice versa.\n            signX = by !== \"y\" ? sign(newPoint.x) : 1;\n            signY = by !== \"x\" ? sign(newPoint.y) : 1;\n            if (!transform.signX) {\n                transform.signX = signX;\n            }\n            if (!transform.signY) {\n                transform.signY = signY;\n            }\n            if (target.lockScalingFlip && (transform.signX !== signX || transform.signY !== signY)) {\n                return false;\n            }\n            dim = target._getTransformedDimensions();\n            // missing detection of flip and logic to switch the origin\n            if (scaleProportionally && !by) {\n                // uniform scaling\n                var distance = Math.abs(newPoint.x) + Math.abs(newPoint.y), original = transform.original, originalDistance = Math.abs(dim.x * original.scaleX / target.scaleX) + Math.abs(dim.y * original.scaleY / target.scaleY), scale = distance / originalDistance;\n                scaleX = original.scaleX * scale;\n                scaleY = original.scaleY * scale;\n            } else {\n                scaleX = Math.abs(newPoint.x * target.scaleX / dim.x);\n                scaleY = Math.abs(newPoint.y * target.scaleY / dim.y);\n            }\n            // if we are scaling by center, we need to double the scale\n            if (isTransformCentered(transform)) {\n                scaleX *= 2;\n                scaleY *= 2;\n            }\n            if (transform.signX !== signX && by !== \"y\") {\n                transform.originX = opposite[transform.originX];\n                scaleX *= -1;\n                transform.signX = signX;\n            }\n            if (transform.signY !== signY && by !== \"x\") {\n                transform.originY = opposite[transform.originY];\n                scaleY *= -1;\n                transform.signY = signY;\n            }\n        }\n        // minScale is taken are in the setter.\n        var oldScaleX = target.scaleX, oldScaleY = target.scaleY;\n        if (!by) {\n            !lockScalingX && target.set(\"scaleX\", scaleX);\n            !lockScalingY && target.set(\"scaleY\", scaleY);\n        } else {\n            // forbidden cases already handled on top here.\n            by === \"x\" && target.set(\"scaleX\", scaleX);\n            by === \"y\" && target.set(\"scaleY\", scaleY);\n        }\n        return oldScaleX !== target.scaleX || oldScaleY !== target.scaleY;\n    }\n    /**\n   * Generic scaling logic, to scale from corners either equally or freely.\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function scaleObjectFromCorner(eventData, transform, x, y) {\n        return scaleObject(eventData, transform, x, y);\n    }\n    /**\n   * Scaling logic for the X axis.\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function scaleObjectX(eventData, transform, x, y) {\n        return scaleObject(eventData, transform, x, y, {\n            by: \"x\"\n        });\n    }\n    /**\n   * Scaling logic for the Y axis.\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function scaleObjectY(eventData, transform, x, y) {\n        return scaleObject(eventData, transform, x, y, {\n            by: \"y\"\n        });\n    }\n    /**\n   * Composed action handler to either scale Y or skew X\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function scalingYOrSkewingX(eventData, transform, x, y) {\n        // ok some safety needed here.\n        if (eventData[transform.target.canvas.altActionKey]) {\n            return controls.skewHandlerX(eventData, transform, x, y);\n        }\n        return controls.scalingY(eventData, transform, x, y);\n    }\n    /**\n   * Composed action handler to either scale X or skew Y\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function scalingXOrSkewingY(eventData, transform, x, y) {\n        // ok some safety needed here.\n        if (eventData[transform.target.canvas.altActionKey]) {\n            return controls.skewHandlerY(eventData, transform, x, y);\n        }\n        return controls.scalingX(eventData, transform, x, y);\n    }\n    /**\n   * Action handler to change textbox width\n   * Needs to be wrapped with `wrapWithFixedAnchor` to be effective\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if some change happened\n   */ function changeWidth(eventData, transform, x, y) {\n        var target = transform.target, localPoint = getLocalPoint(transform, transform.originX, transform.originY, x, y), strokePadding = target.strokeWidth / (target.strokeUniform ? target.scaleX : 1), multiplier = isTransformCentered(transform) ? 2 : 1, oldWidth = target.width, newWidth = Math.abs(localPoint.x * multiplier / target.scaleX) - strokePadding;\n        target.set(\"width\", Math.max(newWidth, 0));\n        return oldWidth !== newWidth;\n    }\n    /**\n   * Action handler\n   * @private\n   * @param {Event} eventData javascript event that is doing the transform\n   * @param {Object} transform javascript object containing a series of information around the current transform\n   * @param {number} x current mouse x position, canvas normalized\n   * @param {number} y current mouse y position, canvas normalized\n   * @return {Boolean} true if the translation occurred\n   */ function dragHandler(eventData, transform, x, y) {\n        var target = transform.target, newLeft = x - transform.offsetX, newTop = y - transform.offsetY, moveX = !target.get(\"lockMovementX\") && target.left !== newLeft, moveY = !target.get(\"lockMovementY\") && target.top !== newTop;\n        moveX && target.set(\"left\", newLeft);\n        moveY && target.set(\"top\", newTop);\n        if (moveX || moveY) {\n            fireEvent(\"moving\", commonEventInfo(eventData, transform, x, y));\n        }\n        return moveX || moveY;\n    }\n    controls.scaleCursorStyleHandler = scaleCursorStyleHandler;\n    controls.skewCursorStyleHandler = skewCursorStyleHandler;\n    controls.scaleSkewCursorStyleHandler = scaleSkewCursorStyleHandler;\n    controls.rotationWithSnapping = wrapWithFireEvent(\"rotating\", wrapWithFixedAnchor(rotationWithSnapping));\n    controls.scalingEqually = wrapWithFireEvent(\"scaling\", wrapWithFixedAnchor(scaleObjectFromCorner));\n    controls.scalingX = wrapWithFireEvent(\"scaling\", wrapWithFixedAnchor(scaleObjectX));\n    controls.scalingY = wrapWithFireEvent(\"scaling\", wrapWithFixedAnchor(scaleObjectY));\n    controls.scalingYOrSkewingX = scalingYOrSkewingX;\n    controls.scalingXOrSkewingY = scalingXOrSkewingY;\n    controls.changeWidth = wrapWithFireEvent(\"resizing\", wrapWithFixedAnchor(changeWidth));\n    controls.skewHandlerX = skewHandlerX;\n    controls.skewHandlerY = skewHandlerY;\n    controls.dragHandler = dragHandler;\n    controls.scaleOrSkewActionName = scaleOrSkewActionName;\n    controls.rotationStyleHandler = rotationStyleHandler;\n    controls.fireEvent = fireEvent;\n    controls.wrapWithFixedAnchor = wrapWithFixedAnchor;\n    controls.wrapWithFireEvent = wrapWithFireEvent;\n    controls.getLocalPoint = getLocalPoint;\n    fabric.controlsUtils = controls;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), degreesToRadians = fabric.util.degreesToRadians, controls = fabric.controlsUtils;\n    /**\n   * Render a round control, as per fabric features.\n   * This function is written to respect object properties like transparentCorners, cornerSize\n   * cornerColor, cornerStrokeColor\n   * plus the addition of offsetY and offsetX.\n   * @param {CanvasRenderingContext2D} ctx context to render on\n   * @param {Number} left x coordinate where the control center should be\n   * @param {Number} top y coordinate where the control center should be\n   * @param {Object} styleOverride override for fabric.Object controls style\n   * @param {fabric.Object} fabricObject the fabric object for which we are rendering controls\n   */ function renderCircleControl(ctx, left, top, styleOverride, fabricObject) {\n        styleOverride = styleOverride || {};\n        var xSize = this.sizeX || styleOverride.cornerSize || fabricObject.cornerSize, ySize = this.sizeY || styleOverride.cornerSize || fabricObject.cornerSize, transparentCorners = typeof styleOverride.transparentCorners !== \"undefined\" ? styleOverride.transparentCorners : fabricObject.transparentCorners, methodName = transparentCorners ? \"stroke\" : \"fill\", stroke = !transparentCorners && (styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor), myLeft = left, myTop = top, size;\n        ctx.save();\n        ctx.fillStyle = styleOverride.cornerColor || fabricObject.cornerColor;\n        ctx.strokeStyle = styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor;\n        // as soon as fabric react v5, remove ie11, use proper ellipse code.\n        if (xSize > ySize) {\n            size = xSize;\n            ctx.scale(1.0, ySize / xSize);\n            myTop = top * xSize / ySize;\n        } else if (ySize > xSize) {\n            size = ySize;\n            ctx.scale(xSize / ySize, 1.0);\n            myLeft = left * ySize / xSize;\n        } else {\n            size = xSize;\n        }\n        // this is still wrong\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n        ctx.arc(myLeft, myTop, size / 2, 0, 2 * Math.PI, false);\n        ctx[methodName]();\n        if (stroke) {\n            ctx.stroke();\n        }\n        ctx.restore();\n    }\n    /**\n   * Render a square control, as per fabric features.\n   * This function is written to respect object properties like transparentCorners, cornerSize\n   * cornerColor, cornerStrokeColor\n   * plus the addition of offsetY and offsetX.\n   * @param {CanvasRenderingContext2D} ctx context to render on\n   * @param {Number} left x coordinate where the control center should be\n   * @param {Number} top y coordinate where the control center should be\n   * @param {Object} styleOverride override for fabric.Object controls style\n   * @param {fabric.Object} fabricObject the fabric object for which we are rendering controls\n   */ function renderSquareControl(ctx, left, top, styleOverride, fabricObject) {\n        styleOverride = styleOverride || {};\n        var xSize = this.sizeX || styleOverride.cornerSize || fabricObject.cornerSize, ySize = this.sizeY || styleOverride.cornerSize || fabricObject.cornerSize, transparentCorners = typeof styleOverride.transparentCorners !== \"undefined\" ? styleOverride.transparentCorners : fabricObject.transparentCorners, methodName = transparentCorners ? \"stroke\" : \"fill\", stroke = !transparentCorners && (styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor), xSizeBy2 = xSize / 2, ySizeBy2 = ySize / 2;\n        ctx.save();\n        ctx.fillStyle = styleOverride.cornerColor || fabricObject.cornerColor;\n        ctx.strokeStyle = styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor;\n        // this is still wrong\n        ctx.lineWidth = 1;\n        ctx.translate(left, top);\n        ctx.rotate(degreesToRadians(fabricObject.angle));\n        // this does not work, and fixed with ( && ) does not make sense.\n        // to have real transparent corners we need the controls on upperCanvas\n        // transparentCorners || ctx.clearRect(-xSizeBy2, -ySizeBy2, xSize, ySize);\n        ctx[methodName + \"Rect\"](-xSizeBy2, -ySizeBy2, xSize, ySize);\n        if (stroke) {\n            ctx.strokeRect(-xSizeBy2, -ySizeBy2, xSize, ySize);\n        }\n        ctx.restore();\n    }\n    controls.renderCircleControl = renderCircleControl;\n    controls.renderSquareControl = renderSquareControl;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {});\n    function Control(options) {\n        for(var i in options){\n            this[i] = options[i];\n        }\n    }\n    fabric.Control = Control;\n    fabric.Control.prototype = /** @lends fabric.Control.prototype */ {\n        /**\n     * keep track of control visibility.\n     * mainly for backward compatibility.\n     * if you do not want to see a control, you can remove it\n     * from the controlset.\n     * @type {Boolean}\n     * @default true\n     */ visible: true,\n        /**\n     * Name of the action that the control will likely execute.\n     * This is optional. FabricJS uses to identify what the user is doing for some\n     * extra optimizations. If you are writing a custom control and you want to know\n     * somewhere else in the code what is going on, you can use this string here.\n     * you can also provide a custom getActionName if your control run multiple actions\n     * depending on some external state.\n     * default to scale since is the most common, used on 4 corners by default\n     * @type {String}\n     * @default 'scale'\n     */ actionName: \"scale\",\n        /**\n     * Drawing angle of the control.\n     * NOT used for now, but name marked as needed for internal logic\n     * example: to reuse the same drawing function for different rotated controls\n     * @type {Number}\n     * @default 0\n     */ angle: 0,\n        /**\n     * Relative position of the control. X\n     * 0,0 is the center of the Object, while -0.5 (left) or 0.5 (right) are the extremities\n     * of the bounding box.\n     * @type {Number}\n     * @default 0\n     */ x: 0,\n        /**\n     * Relative position of the control. Y\n     * 0,0 is the center of the Object, while -0.5 (top) or 0.5 (bottom) are the extremities\n     * of the bounding box.\n     * @type {Number}\n     * @default 0\n     */ y: 0,\n        /**\n     * Horizontal offset of the control from the defined position. In pixels\n     * Positive offset moves the control to the right, negative to the left.\n     * It used when you want to have position of control that does not scale with\n     * the bounding box. Example: rotation control is placed at x:0, y: 0.5 on\n     * the boundindbox, with an offset of 30 pixels vertically. Those 30 pixels will\n     * stay 30 pixels no matter how the object is big. Another example is having 2\n     * controls in the corner, that stay in the same position when the object scale.\n     * of the bounding box.\n     * @type {Number}\n     * @default 0\n     */ offsetX: 0,\n        /**\n     * Vertical offset of the control from the defined position. In pixels\n     * Positive offset moves the control to the bottom, negative to the top.\n     * @type {Number}\n     * @default 0\n     */ offsetY: 0,\n        /**\n     * Sets the length of the control. If null, defaults to object's cornerSize.\n     * Expects both sizeX and sizeY to be set when set.\n     * @type {?Number}\n     * @default null\n     */ sizeX: null,\n        /**\n     * Sets the height of the control. If null, defaults to object's cornerSize.\n     * Expects both sizeX and sizeY to be set when set.\n     * @type {?Number}\n     * @default null\n     */ sizeY: null,\n        /**\n     * Sets the length of the touch area of the control. If null, defaults to object's touchCornerSize.\n     * Expects both touchSizeX and touchSizeY to be set when set.\n     * @type {?Number}\n     * @default null\n     */ touchSizeX: null,\n        /**\n     * Sets the height of the touch area of the control. If null, defaults to object's touchCornerSize.\n     * Expects both touchSizeX and touchSizeY to be set when set.\n     * @type {?Number}\n     * @default null\n     */ touchSizeY: null,\n        /**\n     * Css cursor style to display when the control is hovered.\n     * if the method `cursorStyleHandler` is provided, this property is ignored.\n     * @type {String}\n     * @default 'crosshair'\n     */ cursorStyle: \"crosshair\",\n        /**\n     * If controls has an offsetY or offsetX, draw a line that connects\n     * the control to the bounding box\n     * @type {Boolean}\n     * @default false\n     */ withConnection: false,\n        /**\n     * The control actionHandler, provide one to handle action ( control being moved )\n     * @param {Event} eventData the native mouse event\n     * @param {Object} transformData properties of the current transform\n     * @param {Number} x x position of the cursor\n     * @param {Number} y y position of the cursor\n     * @return {Boolean} true if the action/event modified the object\n     */ actionHandler: function() {},\n        /**\n     * The control handler for mouse down, provide one to handle mouse down on control\n     * @param {Event} eventData the native mouse event\n     * @param {Object} transformData properties of the current transform\n     * @param {Number} x x position of the cursor\n     * @param {Number} y y position of the cursor\n     * @return {Boolean} true if the action/event modified the object\n     */ mouseDownHandler: function() {},\n        /**\n     * The control mouseUpHandler, provide one to handle an effect on mouse up.\n     * @param {Event} eventData the native mouse event\n     * @param {Object} transformData properties of the current transform\n     * @param {Number} x x position of the cursor\n     * @param {Number} y y position of the cursor\n     * @return {Boolean} true if the action/event modified the object\n     */ mouseUpHandler: function() {},\n        /**\n     * Returns control actionHandler\n     * @param {Event} eventData the native mouse event\n     * @param {fabric.Object} fabricObject on which the control is displayed\n     * @param {fabric.Control} control control for which the action handler is being asked\n     * @return {Function} the action handler\n     */ getActionHandler: function() {\n            return this.actionHandler;\n        },\n        /**\n     * Returns control mouseDown handler\n     * @param {Event} eventData the native mouse event\n     * @param {fabric.Object} fabricObject on which the control is displayed\n     * @param {fabric.Control} control control for which the action handler is being asked\n     * @return {Function} the action handler\n     */ getMouseDownHandler: function() {\n            return this.mouseDownHandler;\n        },\n        /**\n     * Returns control mouseUp handler\n     * @param {Event} eventData the native mouse event\n     * @param {fabric.Object} fabricObject on which the control is displayed\n     * @param {fabric.Control} control control for which the action handler is being asked\n     * @return {Function} the action handler\n     */ getMouseUpHandler: function() {\n            return this.mouseUpHandler;\n        },\n        /**\n     * Returns control cursorStyle for css using cursorStyle. If you need a more elaborate\n     * function you can pass one in the constructor\n     * the cursorStyle property\n     * @param {Event} eventData the native mouse event\n     * @param {fabric.Control} control the current control ( likely this)\n     * @param {fabric.Object} object on which the control is displayed\n     * @return {String}\n     */ cursorStyleHandler: function(eventData, control /* fabricObject */ ) {\n            return control.cursorStyle;\n        },\n        /**\n     * Returns the action name. The basic implementation just return the actionName property.\n     * @param {Event} eventData the native mouse event\n     * @param {fabric.Control} control the current control ( likely this)\n     * @param {fabric.Object} object on which the control is displayed\n     * @return {String}\n     */ getActionName: function(eventData, control /* fabricObject */ ) {\n            return control.actionName;\n        },\n        /**\n     * Returns controls visibility\n     * @param {fabric.Object} object on which the control is displayed\n     * @param {String} controlKey key where the control is memorized on the\n     * @return {Boolean}\n     */ getVisibility: function(fabricObject, controlKey) {\n            var objectVisibility = fabricObject._controlsVisibility;\n            if (objectVisibility && typeof objectVisibility[controlKey] !== \"undefined\") {\n                return objectVisibility[controlKey];\n            }\n            return this.visible;\n        },\n        /**\n     * Sets controls visibility\n     * @param {Boolean} visibility for the object\n     * @return {Void}\n     */ setVisibility: function(visibility /* name, fabricObject */ ) {\n            this.visible = visibility;\n        },\n        positionHandler: function(dim, finalMatrix /*, fabricObject, currentControl */ ) {\n            var point = fabric.util.transformPoint({\n                x: this.x * dim.x + this.offsetX,\n                y: this.y * dim.y + this.offsetY\n            }, finalMatrix);\n            return point;\n        },\n        /**\n     * Returns the coords for this control based on object values.\n     * @param {Number} objectAngle angle from the fabric object holding the control\n     * @param {Number} objectCornerSize cornerSize from the fabric object holding the control (or touchCornerSize if\n     *   isTouch is true)\n     * @param {Number} centerX x coordinate where the control center should be\n     * @param {Number} centerY y coordinate where the control center should be\n     * @param {boolean} isTouch true if touch corner, false if normal corner\n     */ calcCornerCoords: function(objectAngle, objectCornerSize, centerX, centerY, isTouch) {\n            var cosHalfOffset, sinHalfOffset, cosHalfOffsetComp, sinHalfOffsetComp, xSize = isTouch ? this.touchSizeX : this.sizeX, ySize = isTouch ? this.touchSizeY : this.sizeY;\n            if (xSize && ySize && xSize !== ySize) {\n                // handle rectangular corners\n                var controlTriangleAngle = Math.atan2(ySize, xSize);\n                var cornerHypotenuse = Math.sqrt(xSize * xSize + ySize * ySize) / 2;\n                var newTheta = controlTriangleAngle - fabric.util.degreesToRadians(objectAngle);\n                var newThetaComp = Math.PI / 2 - controlTriangleAngle - fabric.util.degreesToRadians(objectAngle);\n                cosHalfOffset = cornerHypotenuse * fabric.util.cos(newTheta);\n                sinHalfOffset = cornerHypotenuse * fabric.util.sin(newTheta);\n                // use complementary angle for two corners\n                cosHalfOffsetComp = cornerHypotenuse * fabric.util.cos(newThetaComp);\n                sinHalfOffsetComp = cornerHypotenuse * fabric.util.sin(newThetaComp);\n            } else {\n                // handle square corners\n                // use default object corner size unless size is defined\n                var cornerSize = xSize && ySize ? xSize : objectCornerSize;\n                /* 0.7071067812 stands for sqrt(2)/2 */ cornerHypotenuse = cornerSize * 0.7071067812;\n                // complementary angles are equal since they're both 45 degrees\n                var newTheta = fabric.util.degreesToRadians(45 - objectAngle);\n                cosHalfOffset = cosHalfOffsetComp = cornerHypotenuse * fabric.util.cos(newTheta);\n                sinHalfOffset = sinHalfOffsetComp = cornerHypotenuse * fabric.util.sin(newTheta);\n            }\n            return {\n                tl: {\n                    x: centerX - sinHalfOffsetComp,\n                    y: centerY - cosHalfOffsetComp\n                },\n                tr: {\n                    x: centerX + cosHalfOffset,\n                    y: centerY - sinHalfOffset\n                },\n                bl: {\n                    x: centerX - cosHalfOffset,\n                    y: centerY + sinHalfOffset\n                },\n                br: {\n                    x: centerX + sinHalfOffsetComp,\n                    y: centerY + cosHalfOffsetComp\n                }\n            };\n        },\n        /**\n    * Render function for the control.\n    * When this function runs the context is unscaled. unrotate. Just retina scaled.\n    * all the functions will have to translate to the point left,top before starting Drawing\n    * if they want to draw a control where the position is detected.\n    * left and top are the result of the positionHandler function\n    * @param {RenderingContext2D} ctx the context where the control will be drawn\n    * @param {Number} left position of the canvas where we are about to render the control.\n    * @param {Number} top position of the canvas where we are about to render the control.\n    * @param {Object} styleOverride\n    * @param {fabric.Object} fabricObject the object where the control is about to be rendered\n    */ render: function(ctx, left, top, styleOverride, fabricObject) {\n            styleOverride = styleOverride || {};\n            switch(styleOverride.cornerStyle || fabricObject.cornerStyle){\n                case \"circle\":\n                    fabric.controlsUtils.renderCircleControl.call(this, ctx, left, top, styleOverride, fabricObject);\n                    break;\n                default:\n                    fabric.controlsUtils.renderSquareControl.call(this, ctx, left, top, styleOverride, fabricObject);\n            }\n        }\n    };\n})( true ? exports : 0);\n(function() {\n    /* _FROM_SVG_START_ */ function getColorStop(el, multiplier) {\n        var style = el.getAttribute(\"style\"), offset = el.getAttribute(\"offset\") || 0, color, colorAlpha, opacity, i;\n        // convert percents to absolute values\n        offset = parseFloat(offset) / (/%$/.test(offset) ? 100 : 1);\n        offset = offset < 0 ? 0 : offset > 1 ? 1 : offset;\n        if (style) {\n            var keyValuePairs = style.split(/\\s*;\\s*/);\n            if (keyValuePairs[keyValuePairs.length - 1] === \"\") {\n                keyValuePairs.pop();\n            }\n            for(i = keyValuePairs.length; i--;){\n                var split = keyValuePairs[i].split(/\\s*:\\s*/), key = split[0].trim(), value = split[1].trim();\n                if (key === \"stop-color\") {\n                    color = value;\n                } else if (key === \"stop-opacity\") {\n                    opacity = value;\n                }\n            }\n        }\n        if (!color) {\n            color = el.getAttribute(\"stop-color\") || \"rgb(0,0,0)\";\n        }\n        if (!opacity) {\n            opacity = el.getAttribute(\"stop-opacity\");\n        }\n        color = new fabric.Color(color);\n        colorAlpha = color.getAlpha();\n        opacity = isNaN(parseFloat(opacity)) ? 1 : parseFloat(opacity);\n        opacity *= colorAlpha * multiplier;\n        return {\n            offset: offset,\n            color: color.toRgb(),\n            opacity: opacity\n        };\n    }\n    function getLinearCoords(el) {\n        return {\n            x1: el.getAttribute(\"x1\") || 0,\n            y1: el.getAttribute(\"y1\") || 0,\n            x2: el.getAttribute(\"x2\") || \"100%\",\n            y2: el.getAttribute(\"y2\") || 0\n        };\n    }\n    function getRadialCoords(el) {\n        return {\n            x1: el.getAttribute(\"fx\") || el.getAttribute(\"cx\") || \"50%\",\n            y1: el.getAttribute(\"fy\") || el.getAttribute(\"cy\") || \"50%\",\n            r1: 0,\n            x2: el.getAttribute(\"cx\") || \"50%\",\n            y2: el.getAttribute(\"cy\") || \"50%\",\n            r2: el.getAttribute(\"r\") || \"50%\"\n        };\n    }\n    /* _FROM_SVG_END_ */ var clone = fabric.util.object.clone;\n    /**\n   * Gradient class\n   * @class fabric.Gradient\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#gradients}\n   * @see {@link fabric.Gradient#initialize} for constructor definition\n   */ fabric.Gradient = fabric.util.createClass(/** @lends fabric.Gradient.prototype */ {\n        /**\n     * Horizontal offset for aligning gradients coming from SVG when outside pathgroups\n     * @type Number\n     * @default 0\n     */ offsetX: 0,\n        /**\n     * Vertical offset for aligning gradients coming from SVG when outside pathgroups\n     * @type Number\n     * @default 0\n     */ offsetY: 0,\n        /**\n     * A transform matrix to apply to the gradient before painting.\n     * Imported from svg gradients, is not applied with the current transform in the center.\n     * Before this transform is applied, the origin point is at the top left corner of the object\n     * plus the addition of offsetY and offsetX.\n     * @type Number[]\n     * @default null\n     */ gradientTransform: null,\n        /**\n     * coordinates units for coords.\n     * If `pixels`, the number of coords are in the same unit of width / height.\n     * If set as `percentage` the coords are still a number, but 1 means 100% of width\n     * for the X and 100% of the height for the y. It can be bigger than 1 and negative.\n     * allowed values pixels or percentage.\n     * @type String\n     * @default 'pixels'\n     */ gradientUnits: \"pixels\",\n        /**\n     * Gradient type linear or radial\n     * @type String\n     * @default 'pixels'\n     */ type: \"linear\",\n        /**\n     * Constructor\n     * @param {Object} options Options object with type, coords, gradientUnits and colorStops\n     * @param {Object} [options.type] gradient type linear or radial\n     * @param {Object} [options.gradientUnits] gradient units\n     * @param {Object} [options.offsetX] SVG import compatibility\n     * @param {Object} [options.offsetY] SVG import compatibility\n     * @param {Object[]} options.colorStops contains the colorstops.\n     * @param {Object} options.coords contains the coords of the gradient\n     * @param {Number} [options.coords.x1] X coordiante of the first point for linear or of the focal point for radial\n     * @param {Number} [options.coords.y1] Y coordiante of the first point for linear or of the focal point for radial\n     * @param {Number} [options.coords.x2] X coordiante of the second point for linear or of the center point for radial\n     * @param {Number} [options.coords.y2] Y coordiante of the second point for linear or of the center point for radial\n     * @param {Number} [options.coords.r1] only for radial gradient, radius of the inner circle\n     * @param {Number} [options.coords.r2] only for radial gradient, radius of the external circle\n     * @return {fabric.Gradient} thisArg\n     */ initialize: function(options) {\n            options || (options = {});\n            options.coords || (options.coords = {});\n            var coords, _this = this;\n            // sets everything, then coords and colorstops get sets again\n            Object.keys(options).forEach(function(option) {\n                _this[option] = options[option];\n            });\n            if (this.id) {\n                this.id += \"_\" + fabric.Object.__uid++;\n            } else {\n                this.id = fabric.Object.__uid++;\n            }\n            coords = {\n                x1: options.coords.x1 || 0,\n                y1: options.coords.y1 || 0,\n                x2: options.coords.x2 || 0,\n                y2: options.coords.y2 || 0\n            };\n            if (this.type === \"radial\") {\n                coords.r1 = options.coords.r1 || 0;\n                coords.r2 = options.coords.r2 || 0;\n            }\n            this.coords = coords;\n            this.colorStops = options.colorStops.slice();\n        },\n        /**\n     * Adds another colorStop\n     * @param {Object} colorStop Object with offset and color\n     * @return {fabric.Gradient} thisArg\n     */ addColorStop: function(colorStops) {\n            for(var position in colorStops){\n                var color = new fabric.Color(colorStops[position]);\n                this.colorStops.push({\n                    offset: parseFloat(position),\n                    color: color.toRgb(),\n                    opacity: color.getAlpha()\n                });\n            }\n            return this;\n        },\n        /**\n     * Returns object representation of a gradient\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object}\n     */ toObject: function(propertiesToInclude) {\n            var object = {\n                type: this.type,\n                coords: this.coords,\n                colorStops: this.colorStops,\n                offsetX: this.offsetX,\n                offsetY: this.offsetY,\n                gradientUnits: this.gradientUnits,\n                gradientTransform: this.gradientTransform ? this.gradientTransform.concat() : this.gradientTransform\n            };\n            fabric.util.populateWithProperties(this, object, propertiesToInclude);\n            return object;\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns SVG representation of an gradient\n     * @param {Object} object Object to create a gradient for\n     * @return {String} SVG representation of an gradient (linear/radial)\n     */ toSVG: function(object, options) {\n            var coords = clone(this.coords, true), i, len, options = options || {}, markup, commonAttributes, colorStops = clone(this.colorStops, true), needsSwap = coords.r1 > coords.r2, transform = this.gradientTransform ? this.gradientTransform.concat() : fabric.iMatrix.concat(), offsetX = -this.offsetX, offsetY = -this.offsetY, withViewport = !!options.additionalTransform, gradientUnits = this.gradientUnits === \"pixels\" ? \"userSpaceOnUse\" : \"objectBoundingBox\";\n            // colorStops must be sorted ascending\n            colorStops.sort(function(a, b) {\n                return a.offset - b.offset;\n            });\n            if (gradientUnits === \"objectBoundingBox\") {\n                offsetX /= object.width;\n                offsetY /= object.height;\n            } else {\n                offsetX += object.width / 2;\n                offsetY += object.height / 2;\n            }\n            if (object.type === \"path\" && this.gradientUnits !== \"percentage\") {\n                offsetX -= object.pathOffset.x;\n                offsetY -= object.pathOffset.y;\n            }\n            transform[4] -= offsetX;\n            transform[5] -= offsetY;\n            commonAttributes = 'id=\"SVGID_' + this.id + '\" gradientUnits=\"' + gradientUnits + '\"';\n            commonAttributes += ' gradientTransform=\"' + (withViewport ? options.additionalTransform + \" \" : \"\") + fabric.util.matrixToSVG(transform) + '\" ';\n            if (this.type === \"linear\") {\n                markup = [\n                    \"<linearGradient \",\n                    commonAttributes,\n                    ' x1=\"',\n                    coords.x1,\n                    '\" y1=\"',\n                    coords.y1,\n                    '\" x2=\"',\n                    coords.x2,\n                    '\" y2=\"',\n                    coords.y2,\n                    '\">\\n'\n                ];\n            } else if (this.type === \"radial\") {\n                // svg radial gradient has just 1 radius. the biggest.\n                markup = [\n                    \"<radialGradient \",\n                    commonAttributes,\n                    ' cx=\"',\n                    needsSwap ? coords.x1 : coords.x2,\n                    '\" cy=\"',\n                    needsSwap ? coords.y1 : coords.y2,\n                    '\" r=\"',\n                    needsSwap ? coords.r1 : coords.r2,\n                    '\" fx=\"',\n                    needsSwap ? coords.x2 : coords.x1,\n                    '\" fy=\"',\n                    needsSwap ? coords.y2 : coords.y1,\n                    '\">\\n'\n                ];\n            }\n            if (this.type === \"radial\") {\n                if (needsSwap) {\n                    // svg goes from internal to external radius. if radius are inverted, swap color stops.\n                    colorStops = colorStops.concat();\n                    colorStops.reverse();\n                    for(i = 0, len = colorStops.length; i < len; i++){\n                        colorStops[i].offset = 1 - colorStops[i].offset;\n                    }\n                }\n                var minRadius = Math.min(coords.r1, coords.r2);\n                if (minRadius > 0) {\n                    // i have to shift all colorStops and add new one in 0.\n                    var maxRadius = Math.max(coords.r1, coords.r2), percentageShift = minRadius / maxRadius;\n                    for(i = 0, len = colorStops.length; i < len; i++){\n                        colorStops[i].offset += percentageShift * (1 - colorStops[i].offset);\n                    }\n                }\n            }\n            for(i = 0, len = colorStops.length; i < len; i++){\n                var colorStop = colorStops[i];\n                markup.push(\"<stop \", 'offset=\"', colorStop.offset * 100 + \"%\", '\" style=\"stop-color:', colorStop.color, typeof colorStop.opacity !== \"undefined\" ? \";stop-opacity: \" + colorStop.opacity : \";\", '\"/>\\n');\n            }\n            markup.push(this.type === \"linear\" ? \"</linearGradient>\\n\" : \"</radialGradient>\\n\");\n            return markup.join(\"\");\n        },\n        /* _TO_SVG_END_ */ /**\n     * Returns an instance of CanvasGradient\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @return {CanvasGradient}\n     */ toLive: function(ctx) {\n            var gradient, coords = fabric.util.object.clone(this.coords), i, len;\n            if (!this.type) {\n                return;\n            }\n            if (this.type === \"linear\") {\n                gradient = ctx.createLinearGradient(coords.x1, coords.y1, coords.x2, coords.y2);\n            } else if (this.type === \"radial\") {\n                gradient = ctx.createRadialGradient(coords.x1, coords.y1, coords.r1, coords.x2, coords.y2, coords.r2);\n            }\n            for(i = 0, len = this.colorStops.length; i < len; i++){\n                var color = this.colorStops[i].color, opacity = this.colorStops[i].opacity, offset = this.colorStops[i].offset;\n                if (typeof opacity !== \"undefined\") {\n                    color = new fabric.Color(color).setAlpha(opacity).toRgba();\n                }\n                gradient.addColorStop(offset, color);\n            }\n            return gradient;\n        }\n    });\n    fabric.util.object.extend(fabric.Gradient, {\n        /* _FROM_SVG_START_ */ /**\n     * Returns {@link fabric.Gradient} instance from an SVG element\n     * @static\n     * @memberOf fabric.Gradient\n     * @param {SVGGradientElement} el SVG gradient element\n     * @param {fabric.Object} instance\n     * @param {String} opacityAttr A fill-opacity or stroke-opacity attribute to multiply to each stop's opacity.\n     * @param {Object} svgOptions an object containing the size of the SVG in order to parse correctly gradients\n     * that uses gradientUnits as 'userSpaceOnUse' and percentages.\n     * @param {Object.number} viewBoxWidth width part of the viewBox attribute on svg\n     * @param {Object.number} viewBoxHeight height part of the viewBox attribute on svg\n     * @param {Object.number} width width part of the svg tag if viewBox is not specified\n     * @param {Object.number} height height part of the svg tag if viewBox is not specified\n     * @return {fabric.Gradient} Gradient instance\n     * @see http://www.w3.org/TR/SVG/pservers.html#LinearGradientElement\n     * @see http://www.w3.org/TR/SVG/pservers.html#RadialGradientElement\n     */ fromElement: function(el, instance, opacityAttr, svgOptions) {\n            /**\n       *  @example:\n       *\n       *  <linearGradient id=\"linearGrad1\">\n       *    <stop offset=\"0%\" stop-color=\"white\"/>\n       *    <stop offset=\"100%\" stop-color=\"black\"/>\n       *  </linearGradient>\n       *\n       *  OR\n       *\n       *  <linearGradient id=\"linearGrad2\">\n       *    <stop offset=\"0\" style=\"stop-color:rgb(255,255,255)\"/>\n       *    <stop offset=\"1\" style=\"stop-color:rgb(0,0,0)\"/>\n       *  </linearGradient>\n       *\n       *  OR\n       *\n       *  <radialGradient id=\"radialGrad1\">\n       *    <stop offset=\"0%\" stop-color=\"white\" stop-opacity=\"1\" />\n       *    <stop offset=\"50%\" stop-color=\"black\" stop-opacity=\"0.5\" />\n       *    <stop offset=\"100%\" stop-color=\"white\" stop-opacity=\"1\" />\n       *  </radialGradient>\n       *\n       *  OR\n       *\n       *  <radialGradient id=\"radialGrad2\">\n       *    <stop offset=\"0\" stop-color=\"rgb(255,255,255)\" />\n       *    <stop offset=\"0.5\" stop-color=\"rgb(0,0,0)\" />\n       *    <stop offset=\"1\" stop-color=\"rgb(255,255,255)\" />\n       *  </radialGradient>\n       *\n       */ var multiplier = parseFloat(opacityAttr) / (/%$/.test(opacityAttr) ? 100 : 1);\n            multiplier = multiplier < 0 ? 0 : multiplier > 1 ? 1 : multiplier;\n            if (isNaN(multiplier)) {\n                multiplier = 1;\n            }\n            var colorStopEls = el.getElementsByTagName(\"stop\"), type, gradientUnits = el.getAttribute(\"gradientUnits\") === \"userSpaceOnUse\" ? \"pixels\" : \"percentage\", gradientTransform = el.getAttribute(\"gradientTransform\") || \"\", colorStops = [], coords, i, offsetX = 0, offsetY = 0, transformMatrix;\n            if (el.nodeName === \"linearGradient\" || el.nodeName === \"LINEARGRADIENT\") {\n                type = \"linear\";\n                coords = getLinearCoords(el);\n            } else {\n                type = \"radial\";\n                coords = getRadialCoords(el);\n            }\n            for(i = colorStopEls.length; i--;){\n                colorStops.push(getColorStop(colorStopEls[i], multiplier));\n            }\n            transformMatrix = fabric.parseTransformAttribute(gradientTransform);\n            __convertPercentUnitsToValues(instance, coords, svgOptions, gradientUnits);\n            if (gradientUnits === \"pixels\") {\n                offsetX = -instance.left;\n                offsetY = -instance.top;\n            }\n            var gradient = new fabric.Gradient({\n                id: el.getAttribute(\"id\"),\n                type: type,\n                coords: coords,\n                colorStops: colorStops,\n                gradientUnits: gradientUnits,\n                gradientTransform: transformMatrix,\n                offsetX: offsetX,\n                offsetY: offsetY\n            });\n            return gradient;\n        }\n    });\n    /**\n   * @private\n   */ function __convertPercentUnitsToValues(instance, options, svgOptions, gradientUnits) {\n        var propValue, finalValue;\n        Object.keys(options).forEach(function(prop) {\n            propValue = options[prop];\n            if (propValue === \"Infinity\") {\n                finalValue = 1;\n            } else if (propValue === \"-Infinity\") {\n                finalValue = 0;\n            } else {\n                finalValue = parseFloat(options[prop], 10);\n                if (typeof propValue === \"string\" && /^(\\d+\\.\\d+)%|(\\d+)%$/.test(propValue)) {\n                    finalValue *= 0.01;\n                    if (gradientUnits === \"pixels\") {\n                        // then we need to fix those percentages here in svg parsing\n                        if (prop === \"x1\" || prop === \"x2\" || prop === \"r2\") {\n                            finalValue *= svgOptions.viewBoxWidth || svgOptions.width;\n                        }\n                        if (prop === \"y1\" || prop === \"y2\") {\n                            finalValue *= svgOptions.viewBoxHeight || svgOptions.height;\n                        }\n                    }\n                }\n            }\n            options[prop] = finalValue;\n        });\n    }\n})();\n(function() {\n    \"use strict\";\n    var toFixed = fabric.util.toFixed;\n    /**\n   * Pattern class\n   * @class fabric.Pattern\n   * @see {@link http://fabricjs.com/patterns|Pattern demo}\n   * @see {@link http://fabricjs.com/dynamic-patterns|DynamicPattern demo}\n   * @see {@link fabric.Pattern#initialize} for constructor definition\n   */ fabric.Pattern = fabric.util.createClass(/** @lends fabric.Pattern.prototype */ {\n        /**\n     * Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)\n     * @type String\n     * @default\n     */ repeat: \"repeat\",\n        /**\n     * Pattern horizontal offset from object's left/top corner\n     * @type Number\n     * @default\n     */ offsetX: 0,\n        /**\n     * Pattern vertical offset from object's left/top corner\n     * @type Number\n     * @default\n     */ offsetY: 0,\n        /**\n     * crossOrigin value (one of \"\", \"anonymous\", \"use-credentials\")\n     * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes\n     * @type String\n     * @default\n     */ crossOrigin: \"\",\n        /**\n     * transform matrix to change the pattern, imported from svgs.\n     * @type Array\n     * @default\n     */ patternTransform: null,\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     * @param {Function} [callback] function to invoke after callback init.\n     * @return {fabric.Pattern} thisArg\n     */ initialize: function(options, callback) {\n            options || (options = {});\n            this.id = fabric.Object.__uid++;\n            this.setOptions(options);\n            if (!options.source || options.source && typeof options.source !== \"string\") {\n                callback && callback(this);\n                return;\n            } else {\n                // img src string\n                var _this = this;\n                this.source = fabric.util.createImage();\n                fabric.util.loadImage(options.source, function(img, isError) {\n                    _this.source = img;\n                    callback && callback(_this, isError);\n                }, null, this.crossOrigin);\n            }\n        },\n        /**\n     * Returns object representation of a pattern\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of a pattern instance\n     */ toObject: function(propertiesToInclude) {\n            var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS, source, object;\n            // <img> element\n            if (typeof this.source.src === \"string\") {\n                source = this.source.src;\n            } else if (typeof this.source === \"object\" && this.source.toDataURL) {\n                source = this.source.toDataURL();\n            }\n            object = {\n                type: \"pattern\",\n                source: source,\n                repeat: this.repeat,\n                crossOrigin: this.crossOrigin,\n                offsetX: toFixed(this.offsetX, NUM_FRACTION_DIGITS),\n                offsetY: toFixed(this.offsetY, NUM_FRACTION_DIGITS),\n                patternTransform: this.patternTransform ? this.patternTransform.concat() : null\n            };\n            fabric.util.populateWithProperties(this, object, propertiesToInclude);\n            return object;\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns SVG representation of a pattern\n     * @param {fabric.Object} object\n     * @return {String} SVG representation of a pattern\n     */ toSVG: function(object) {\n            var patternSource = typeof this.source === \"function\" ? this.source() : this.source, patternWidth = patternSource.width / object.width, patternHeight = patternSource.height / object.height, patternOffsetX = this.offsetX / object.width, patternOffsetY = this.offsetY / object.height, patternImgSrc = \"\";\n            if (this.repeat === \"repeat-x\" || this.repeat === \"no-repeat\") {\n                patternHeight = 1;\n                if (patternOffsetY) {\n                    patternHeight += Math.abs(patternOffsetY);\n                }\n            }\n            if (this.repeat === \"repeat-y\" || this.repeat === \"no-repeat\") {\n                patternWidth = 1;\n                if (patternOffsetX) {\n                    patternWidth += Math.abs(patternOffsetX);\n                }\n            }\n            if (patternSource.src) {\n                patternImgSrc = patternSource.src;\n            } else if (patternSource.toDataURL) {\n                patternImgSrc = patternSource.toDataURL();\n            }\n            return '<pattern id=\"SVGID_' + this.id + '\" x=\"' + patternOffsetX + '\" y=\"' + patternOffsetY + '\" width=\"' + patternWidth + '\" height=\"' + patternHeight + '\">\\n' + '<image x=\"0\" y=\"0\"' + ' width=\"' + patternSource.width + '\" height=\"' + patternSource.height + '\" xlink:href=\"' + patternImgSrc + '\"></image>\\n' + \"</pattern>\\n\";\n        },\n        /* _TO_SVG_END_ */ setOptions: function(options) {\n            for(var prop in options){\n                this[prop] = options[prop];\n            }\n        },\n        /**\n     * Returns an instance of CanvasPattern\n     * @param {CanvasRenderingContext2D} ctx Context to create pattern\n     * @return {CanvasPattern}\n     */ toLive: function(ctx) {\n            var source = this.source;\n            // if the image failed to load, return, and allow rest to continue loading\n            if (!source) {\n                return \"\";\n            }\n            // if an image\n            if (typeof source.src !== \"undefined\") {\n                if (!source.complete) {\n                    return \"\";\n                }\n                if (source.naturalWidth === 0 || source.naturalHeight === 0) {\n                    return \"\";\n                }\n            }\n            return ctx.createPattern(source, this.repeat);\n        }\n    });\n})();\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), toFixed = fabric.util.toFixed;\n    if (fabric.Shadow) {\n        fabric.warn(\"fabric.Shadow is already defined.\");\n        return;\n    }\n    /**\n   * Shadow class\n   * @class fabric.Shadow\n   * @see {@link http://fabricjs.com/shadows|Shadow demo}\n   * @see {@link fabric.Shadow#initialize} for constructor definition\n   */ fabric.Shadow = fabric.util.createClass(/** @lends fabric.Shadow.prototype */ {\n        /**\n     * Shadow color\n     * @type String\n     * @default\n     */ color: \"rgb(0,0,0)\",\n        /**\n     * Shadow blur\n     * @type Number\n     */ blur: 0,\n        /**\n     * Shadow horizontal offset\n     * @type Number\n     * @default\n     */ offsetX: 0,\n        /**\n     * Shadow vertical offset\n     * @type Number\n     * @default\n     */ offsetY: 0,\n        /**\n     * Whether the shadow should affect stroke operations\n     * @type Boolean\n     * @default\n     */ affectStroke: false,\n        /**\n     * Indicates whether toObject should include default values\n     * @type Boolean\n     * @default\n     */ includeDefaultValues: true,\n        /**\n     * When `false`, the shadow will scale with the object.\n     * When `true`, the shadow's offsetX, offsetY, and blur will not be affected by the object's scale.\n     * default to false\n     * @type Boolean\n     * @default\n     */ nonScaling: false,\n        /**\n     * Constructor\n     * @param {Object|String} [options] Options object with any of color, blur, offsetX, offsetY properties or string (e.g. \"rgba(0,0,0,0.2) 2px 2px 10px\")\n     * @return {fabric.Shadow} thisArg\n     */ initialize: function(options) {\n            if (typeof options === \"string\") {\n                options = this._parseShadow(options);\n            }\n            for(var prop in options){\n                this[prop] = options[prop];\n            }\n            this.id = fabric.Object.__uid++;\n        },\n        /**\n     * @private\n     * @param {String} shadow Shadow value to parse\n     * @return {Object} Shadow object with color, offsetX, offsetY and blur\n     */ _parseShadow: function(shadow) {\n            var shadowStr = shadow.trim(), offsetsAndBlur = fabric.Shadow.reOffsetsAndBlur.exec(shadowStr) || [], color = shadowStr.replace(fabric.Shadow.reOffsetsAndBlur, \"\") || \"rgb(0,0,0)\";\n            return {\n                color: color.trim(),\n                offsetX: parseFloat(offsetsAndBlur[1], 10) || 0,\n                offsetY: parseFloat(offsetsAndBlur[2], 10) || 0,\n                blur: parseFloat(offsetsAndBlur[3], 10) || 0\n            };\n        },\n        /**\n     * Returns a string representation of an instance\n     * @see http://www.w3.org/TR/css-text-decor-3/#text-shadow\n     * @return {String} Returns CSS3 text-shadow declaration\n     */ toString: function() {\n            return [\n                this.offsetX,\n                this.offsetY,\n                this.blur,\n                this.color\n            ].join(\"px \");\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns SVG representation of a shadow\n     * @param {fabric.Object} object\n     * @return {String} SVG representation of a shadow\n     */ toSVG: function(object) {\n            var fBoxX = 40, fBoxY = 40, NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS, offset = fabric.util.rotateVector({\n                x: this.offsetX,\n                y: this.offsetY\n            }, fabric.util.degreesToRadians(-object.angle)), BLUR_BOX = 20, color = new fabric.Color(this.color);\n            if (object.width && object.height) {\n                //http://www.w3.org/TR/SVG/filters.html#FilterEffectsRegion\n                // we add some extra space to filter box to contain the blur ( 20 )\n                fBoxX = toFixed((Math.abs(offset.x) + this.blur) / object.width, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;\n                fBoxY = toFixed((Math.abs(offset.y) + this.blur) / object.height, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;\n            }\n            if (object.flipX) {\n                offset.x *= -1;\n            }\n            if (object.flipY) {\n                offset.y *= -1;\n            }\n            return '<filter id=\"SVGID_' + this.id + '\" y=\"-' + fBoxY + '%\" height=\"' + (100 + 2 * fBoxY) + '%\" ' + 'x=\"-' + fBoxX + '%\" width=\"' + (100 + 2 * fBoxX) + '%\" ' + \">\\n\" + '\t<feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"' + toFixed(this.blur ? this.blur / 2 : 0, NUM_FRACTION_DIGITS) + '\"></feGaussianBlur>\\n' + '\t<feOffset dx=\"' + toFixed(offset.x, NUM_FRACTION_DIGITS) + '\" dy=\"' + toFixed(offset.y, NUM_FRACTION_DIGITS) + '\" result=\"oBlur\" ></feOffset>\\n' + '\t<feFlood flood-color=\"' + color.toRgb() + '\" flood-opacity=\"' + color.getAlpha() + '\"/>\\n' + '\t<feComposite in2=\"oBlur\" operator=\"in\" />\\n' + \"\t<feMerge>\\n\" + \"\t\t<feMergeNode></feMergeNode>\\n\" + '\t\t<feMergeNode in=\"SourceGraphic\"></feMergeNode>\\n' + \"\t</feMerge>\\n\" + \"</filter>\\n\";\n        },\n        /* _TO_SVG_END_ */ /**\n     * Returns object representation of a shadow\n     * @return {Object} Object representation of a shadow instance\n     */ toObject: function() {\n            if (this.includeDefaultValues) {\n                return {\n                    color: this.color,\n                    blur: this.blur,\n                    offsetX: this.offsetX,\n                    offsetY: this.offsetY,\n                    affectStroke: this.affectStroke,\n                    nonScaling: this.nonScaling\n                };\n            }\n            var obj = {}, proto = fabric.Shadow.prototype;\n            [\n                \"color\",\n                \"blur\",\n                \"offsetX\",\n                \"offsetY\",\n                \"affectStroke\",\n                \"nonScaling\"\n            ].forEach(function(prop) {\n                if (this[prop] !== proto[prop]) {\n                    obj[prop] = this[prop];\n                }\n            }, this);\n            return obj;\n        }\n    });\n    /**\n   * Regex matching shadow offsetX, offsetY and blur (ex: \"2px 2px 10px rgba(0,0,0,0.2)\", \"rgb(0,255,0) 2px 2px\")\n   * @static\n   * @field\n   * @memberOf fabric.Shadow\n   */ // eslint-disable-next-line max-len\n    fabric.Shadow.reOffsetsAndBlur = /(?:\\s|^)(-?\\d+(?:\\.\\d*)?(?:px)?(?:\\s?|$))?(-?\\d+(?:\\.\\d*)?(?:px)?(?:\\s?|$))?(\\d+(?:\\.\\d*)?(?:px)?)?(?:\\s?|$)(?:$|\\s)/;\n})( true ? exports : 0);\n(function() {\n    \"use strict\";\n    if (fabric.StaticCanvas) {\n        fabric.warn(\"fabric.StaticCanvas is already defined.\");\n        return;\n    }\n    // aliases for faster resolution\n    var extend = fabric.util.object.extend, getElementOffset = fabric.util.getElementOffset, removeFromArray = fabric.util.removeFromArray, toFixed = fabric.util.toFixed, transformPoint = fabric.util.transformPoint, invertTransform = fabric.util.invertTransform, getNodeCanvas = fabric.util.getNodeCanvas, createCanvasElement = fabric.util.createCanvasElement, CANVAS_INIT_ERROR = new Error(\"Could not initialize `canvas` element\");\n    /**\n   * Static canvas class\n   * @class fabric.StaticCanvas\n   * @mixes fabric.Collection\n   * @mixes fabric.Observable\n   * @see {@link http://fabricjs.com/static_canvas|StaticCanvas demo}\n   * @see {@link fabric.StaticCanvas#initialize} for constructor definition\n   * @fires before:render\n   * @fires after:render\n   * @fires canvas:cleared\n   * @fires object:added\n   * @fires object:removed\n   */ fabric.StaticCanvas = fabric.util.createClass(fabric.CommonMethods, /** @lends fabric.StaticCanvas.prototype */ {\n        /**\n     * Constructor\n     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on\n     * @param {Object} [options] Options object\n     * @return {Object} thisArg\n     */ initialize: function(el, options) {\n            options || (options = {});\n            this.renderAndResetBound = this.renderAndReset.bind(this);\n            this.requestRenderAllBound = this.requestRenderAll.bind(this);\n            this._initStatic(el, options);\n        },\n        /**\n     * Background color of canvas instance.\n     * Should be set via {@link fabric.StaticCanvas#setBackgroundColor}.\n     * @type {(String|fabric.Pattern)}\n     * @default\n     */ backgroundColor: \"\",\n        /**\n     * Background image of canvas instance.\n     * since 2.4.0 image caching is active, please when putting an image as background, add to the\n     * canvas property a reference to the canvas it is on. Otherwise the image cannot detect the zoom\n     * vale. As an alternative you can disable image objectCaching\n     * @type fabric.Image\n     * @default\n     */ backgroundImage: null,\n        /**\n     * Overlay color of canvas instance.\n     * Should be set via {@link fabric.StaticCanvas#setOverlayColor}\n     * @since 1.3.9\n     * @type {(String|fabric.Pattern)}\n     * @default\n     */ overlayColor: \"\",\n        /**\n     * Overlay image of canvas instance.\n     * since 2.4.0 image caching is active, please when putting an image as overlay, add to the\n     * canvas property a reference to the canvas it is on. Otherwise the image cannot detect the zoom\n     * vale. As an alternative you can disable image objectCaching\n     * @type fabric.Image\n     * @default\n     */ overlayImage: null,\n        /**\n     * Indicates whether toObject/toDatalessObject should include default values\n     * if set to false, takes precedence over the object value.\n     * @type Boolean\n     * @default\n     */ includeDefaultValues: true,\n        /**\n     * Indicates whether objects' state should be saved\n     * @type Boolean\n     * @default\n     */ stateful: false,\n        /**\n     * Indicates whether {@link fabric.Collection.add}, {@link fabric.Collection.insertAt} and {@link fabric.Collection.remove},\n     * {@link fabric.StaticCanvas.moveTo}, {@link fabric.StaticCanvas.clear} and many more, should also re-render canvas.\n     * Disabling this option will not give a performance boost when adding/removing a lot of objects to/from canvas at once\n     * since the renders are quequed and executed one per frame.\n     * Disabling is suggested anyway and managing the renders of the app manually is not a big effort ( canvas.requestRenderAll() )\n     * Left default to true to do not break documentation and old app, fiddles.\n     * @type Boolean\n     * @default\n     */ renderOnAddRemove: true,\n        /**\n     * Indicates whether object controls (borders/controls) are rendered above overlay image\n     * @type Boolean\n     * @default\n     */ controlsAboveOverlay: false,\n        /**\n     * Indicates whether the browser can be scrolled when using a touchscreen and dragging on the canvas\n     * @type Boolean\n     * @default\n     */ allowTouchScrolling: false,\n        /**\n     * Indicates whether this canvas will use image smoothing, this is on by default in browsers\n     * @type Boolean\n     * @default\n     */ imageSmoothingEnabled: true,\n        /**\n     * The transformation (a Canvas 2D API transform matrix) which focuses the viewport\n     * @type Array\n     * @example <caption>Default transform</caption>\n     * canvas.viewportTransform = [1, 0, 0, 1, 0, 0];\n     * @example <caption>Scale by 70% and translate toward bottom-right by 50, without skewing</caption>\n     * canvas.viewportTransform = [0.7, 0, 0, 0.7, 50, 50];\n     * @default\n     */ viewportTransform: fabric.iMatrix.concat(),\n        /**\n     * if set to false background image is not affected by viewport transform\n     * @since 1.6.3\n     * @type Boolean\n     * @default\n     */ backgroundVpt: true,\n        /**\n     * if set to false overlya image is not affected by viewport transform\n     * @since 1.6.3\n     * @type Boolean\n     * @default\n     */ overlayVpt: true,\n        /**\n     * When true, canvas is scaled by devicePixelRatio for better rendering on retina screens\n     * @type Boolean\n     * @default\n     */ enableRetinaScaling: true,\n        /**\n     * Describe canvas element extension over design\n     * properties are tl,tr,bl,br.\n     * if canvas is not zoomed/panned those points are the four corner of canvas\n     * if canvas is viewportTransformed you those points indicate the extension\n     * of canvas element in plain untrasformed coordinates\n     * The coordinates get updated with @method calcViewportBoundaries.\n     * @memberOf fabric.StaticCanvas.prototype\n     */ vptCoords: {},\n        /**\n     * Based on vptCoords and object.aCoords, skip rendering of objects that\n     * are not included in current viewport.\n     * May greatly help in applications with crowded canvas and use of zoom/pan\n     * If One of the corner of the bounding box of the object is on the canvas\n     * the objects get rendered.\n     * @memberOf fabric.StaticCanvas.prototype\n     * @type Boolean\n     * @default\n     */ skipOffscreen: true,\n        /**\n     * a fabricObject that, without stroke define a clipping area with their shape. filled in black\n     * the clipPath object gets used when the canvas has rendered, and the context is placed in the\n     * top left corner of the canvas.\n     * clipPath will clip away controls, if you do not want this to happen use controlsAboveOverlay = true\n     * @type fabric.Object\n     */ clipPath: undefined,\n        /**\n     * @private\n     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on\n     * @param {Object} [options] Options object\n     */ _initStatic: function(el, options) {\n            var cb = this.requestRenderAllBound;\n            this._objects = [];\n            this._createLowerCanvas(el);\n            this._initOptions(options);\n            // only initialize retina scaling once\n            if (!this.interactive) {\n                this._initRetinaScaling();\n            }\n            if (options.overlayImage) {\n                this.setOverlayImage(options.overlayImage, cb);\n            }\n            if (options.backgroundImage) {\n                this.setBackgroundImage(options.backgroundImage, cb);\n            }\n            if (options.backgroundColor) {\n                this.setBackgroundColor(options.backgroundColor, cb);\n            }\n            if (options.overlayColor) {\n                this.setOverlayColor(options.overlayColor, cb);\n            }\n            this.calcOffset();\n        },\n        /**\n     * @private\n     */ _isRetinaScaling: function() {\n            return fabric.devicePixelRatio > 1 && this.enableRetinaScaling;\n        },\n        /**\n     * @private\n     * @return {Number} retinaScaling if applied, otherwise 1;\n     */ getRetinaScaling: function() {\n            return this._isRetinaScaling() ? Math.max(1, fabric.devicePixelRatio) : 1;\n        },\n        /**\n     * @private\n     */ _initRetinaScaling: function() {\n            if (!this._isRetinaScaling()) {\n                return;\n            }\n            var scaleRatio = fabric.devicePixelRatio;\n            this.__initRetinaScaling(scaleRatio, this.lowerCanvasEl, this.contextContainer);\n            if (this.upperCanvasEl) {\n                this.__initRetinaScaling(scaleRatio, this.upperCanvasEl, this.contextTop);\n            }\n        },\n        __initRetinaScaling: function(scaleRatio, canvas, context) {\n            canvas.setAttribute(\"width\", this.width * scaleRatio);\n            canvas.setAttribute(\"height\", this.height * scaleRatio);\n            context.scale(scaleRatio, scaleRatio);\n        },\n        /**\n     * Calculates canvas element offset relative to the document\n     * This method is also attached as \"resize\" event handler of window\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */ calcOffset: function() {\n            this._offset = getElementOffset(this.lowerCanvasEl);\n            return this;\n        },\n        /**\n     * Sets {@link fabric.StaticCanvas#overlayImage|overlay image} for this canvas\n     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set overlay to\n     * @param {Function} callback callback to invoke when image is loaded and set as an overlay\n     * @param {Object} [options] Optional options to set for the {@link fabric.Image|overlay image}.\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     * @see {@link http://jsfiddle.net/fabricjs/MnzHT/|jsFiddle demo}\n     * @example <caption>Normal overlayImage with left/top = 0</caption>\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\n     *   // Needed to position overlayImage at 0/0\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>overlayImage with different properties</caption>\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\n     *   opacity: 0.5,\n     *   angle: 45,\n     *   left: 400,\n     *   top: 400,\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>Stretched overlayImage #1 - width/height correspond to canvas width/height</caption>\n     * fabric.Image.fromURL('http://fabricjs.com/assets/jail_cell_bars.png', function(img, isError) {\n     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});\n     *    canvas.setOverlayImage(img, canvas.renderAll.bind(canvas));\n     * });\n     * @example <caption>Stretched overlayImage #2 - width/height correspond to canvas width/height</caption>\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\n     *   width: canvas.width,\n     *   height: canvas.height,\n     *   // Needed to position overlayImage at 0/0\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>overlayImage loaded from cross-origin</caption>\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\n     *   opacity: 0.5,\n     *   angle: 45,\n     *   left: 400,\n     *   top: 400,\n     *   originX: 'left',\n     *   originY: 'top',\n     *   crossOrigin: 'anonymous'\n     * });\n     */ setOverlayImage: function(image, callback, options) {\n            return this.__setBgOverlayImage(\"overlayImage\", image, callback, options);\n        },\n        /**\n     * Sets {@link fabric.StaticCanvas#backgroundImage|background image} for this canvas\n     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set background to\n     * @param {Function} callback Callback to invoke when image is loaded and set as background\n     * @param {Object} [options] Optional options to set for the {@link fabric.Image|background image}.\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     * @see {@link http://jsfiddle.net/djnr8o7a/28/|jsFiddle demo}\n     * @example <caption>Normal backgroundImage with left/top = 0</caption>\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\n     *   // Needed to position backgroundImage at 0/0\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>backgroundImage with different properties</caption>\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\n     *   opacity: 0.5,\n     *   angle: 45,\n     *   left: 400,\n     *   top: 400,\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>Stretched backgroundImage #1 - width/height correspond to canvas width/height</caption>\n     * fabric.Image.fromURL('http://fabricjs.com/assets/honey_im_subtle.png', function(img, isError) {\n     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});\n     *    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));\n     * });\n     * @example <caption>Stretched backgroundImage #2 - width/height correspond to canvas width/height</caption>\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\n     *   width: canvas.width,\n     *   height: canvas.height,\n     *   // Needed to position backgroundImage at 0/0\n     *   originX: 'left',\n     *   originY: 'top'\n     * });\n     * @example <caption>backgroundImage loaded from cross-origin</caption>\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\n     *   opacity: 0.5,\n     *   angle: 45,\n     *   left: 400,\n     *   top: 400,\n     *   originX: 'left',\n     *   originY: 'top',\n     *   crossOrigin: 'anonymous'\n     * });\n     */ // TODO: fix stretched examples\n        setBackgroundImage: function(image, callback, options) {\n            return this.__setBgOverlayImage(\"backgroundImage\", image, callback, options);\n        },\n        /**\n     * Sets {@link fabric.StaticCanvas#overlayColor|foreground color} for this canvas\n     * @param {(String|fabric.Pattern)} overlayColor Color or pattern to set foreground color to\n     * @param {Function} callback Callback to invoke when foreground color is set\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     * @see {@link http://jsfiddle.net/fabricjs/pB55h/|jsFiddle demo}\n     * @example <caption>Normal overlayColor - color value</caption>\n     * canvas.setOverlayColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));\n     * @example <caption>fabric.Pattern used as overlayColor</caption>\n     * canvas.setOverlayColor({\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'\n     * }, canvas.renderAll.bind(canvas));\n     * @example <caption>fabric.Pattern used as overlayColor with repeat and offset</caption>\n     * canvas.setOverlayColor({\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',\n     *   repeat: 'repeat',\n     *   offsetX: 200,\n     *   offsetY: 100\n     * }, canvas.renderAll.bind(canvas));\n     */ setOverlayColor: function(overlayColor, callback) {\n            return this.__setBgOverlayColor(\"overlayColor\", overlayColor, callback);\n        },\n        /**\n     * Sets {@link fabric.StaticCanvas#backgroundColor|background color} for this canvas\n     * @param {(String|fabric.Pattern)} backgroundColor Color or pattern to set background color to\n     * @param {Function} callback Callback to invoke when background color is set\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     * @see {@link http://jsfiddle.net/fabricjs/hXzvk/|jsFiddle demo}\n     * @example <caption>Normal backgroundColor - color value</caption>\n     * canvas.setBackgroundColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));\n     * @example <caption>fabric.Pattern used as backgroundColor</caption>\n     * canvas.setBackgroundColor({\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'\n     * }, canvas.renderAll.bind(canvas));\n     * @example <caption>fabric.Pattern used as backgroundColor with repeat and offset</caption>\n     * canvas.setBackgroundColor({\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',\n     *   repeat: 'repeat',\n     *   offsetX: 200,\n     *   offsetY: 100\n     * }, canvas.renderAll.bind(canvas));\n     */ setBackgroundColor: function(backgroundColor, callback) {\n            return this.__setBgOverlayColor(\"backgroundColor\", backgroundColor, callback);\n        },\n        /**\n     * @private\n     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundImage|backgroundImage}\n     * or {@link fabric.StaticCanvas#overlayImage|overlayImage})\n     * @param {(fabric.Image|String|null)} image fabric.Image instance, URL of an image or null to set background or overlay to\n     * @param {Function} callback Callback to invoke when image is loaded and set as background or overlay. The first argument is the created image, the second argument is a flag indicating whether an error occurred or not.\n     * @param {Object} [options] Optional options to set for the {@link fabric.Image|image}.\n     */ __setBgOverlayImage: function(property, image, callback, options) {\n            if (typeof image === \"string\") {\n                fabric.util.loadImage(image, function(img, isError) {\n                    if (img) {\n                        var instance = new fabric.Image(img, options);\n                        this[property] = instance;\n                        instance.canvas = this;\n                    }\n                    callback && callback(img, isError);\n                }, this, options && options.crossOrigin);\n            } else {\n                options && image.setOptions(options);\n                this[property] = image;\n                image && (image.canvas = this);\n                callback && callback(image, false);\n            }\n            return this;\n        },\n        /**\n     * @private\n     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundColor|backgroundColor}\n     * or {@link fabric.StaticCanvas#overlayColor|overlayColor})\n     * @param {(Object|String|null)} color Object with pattern information, color value or null\n     * @param {Function} [callback] Callback is invoked when color is set\n     */ __setBgOverlayColor: function(property, color, callback) {\n            this[property] = color;\n            this._initGradient(color, property);\n            this._initPattern(color, property, callback);\n            return this;\n        },\n        /**\n     * @private\n     */ _createCanvasElement: function() {\n            var element = createCanvasElement();\n            if (!element) {\n                throw CANVAS_INIT_ERROR;\n            }\n            if (!element.style) {\n                element.style = {};\n            }\n            if (typeof element.getContext === \"undefined\") {\n                throw CANVAS_INIT_ERROR;\n            }\n            return element;\n        },\n        /**\n     * @private\n     * @param {Object} [options] Options object\n     */ _initOptions: function(options) {\n            var lowerCanvasEl = this.lowerCanvasEl;\n            this._setOptions(options);\n            this.width = this.width || parseInt(lowerCanvasEl.width, 10) || 0;\n            this.height = this.height || parseInt(lowerCanvasEl.height, 10) || 0;\n            if (!this.lowerCanvasEl.style) {\n                return;\n            }\n            lowerCanvasEl.width = this.width;\n            lowerCanvasEl.height = this.height;\n            lowerCanvasEl.style.width = this.width + \"px\";\n            lowerCanvasEl.style.height = this.height + \"px\";\n            this.viewportTransform = this.viewportTransform.slice();\n        },\n        /**\n     * Creates a bottom canvas\n     * @private\n     * @param {HTMLElement} [canvasEl]\n     */ _createLowerCanvas: function(canvasEl) {\n            // canvasEl === 'HTMLCanvasElement' does not work on jsdom/node\n            if (canvasEl && canvasEl.getContext) {\n                this.lowerCanvasEl = canvasEl;\n            } else {\n                this.lowerCanvasEl = fabric.util.getById(canvasEl) || this._createCanvasElement();\n            }\n            fabric.util.addClass(this.lowerCanvasEl, \"lower-canvas\");\n            this._originalCanvasStyle = this.lowerCanvasEl.style;\n            if (this.interactive) {\n                this._applyCanvasStyle(this.lowerCanvasEl);\n            }\n            this.contextContainer = this.lowerCanvasEl.getContext(\"2d\");\n        },\n        /**\n     * Returns canvas width (in px)\n     * @return {Number}\n     */ getWidth: function() {\n            return this.width;\n        },\n        /**\n     * Returns canvas height (in px)\n     * @return {Number}\n     */ getHeight: function() {\n            return this.height;\n        },\n        /**\n     * Sets width of this canvas instance\n     * @param {Number|String} value                         Value to set width to\n     * @param {Object}        [options]                     Options object\n     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions\n     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ setWidth: function(value, options) {\n            return this.setDimensions({\n                width: value\n            }, options);\n        },\n        /**\n     * Sets height of this canvas instance\n     * @param {Number|String} value                         Value to set height to\n     * @param {Object}        [options]                     Options object\n     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions\n     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ setHeight: function(value, options) {\n            return this.setDimensions({\n                height: value\n            }, options);\n        },\n        /**\n     * Sets dimensions (width, height) of this canvas instance. when options.cssOnly flag active you should also supply the unit of measure (px/%/em)\n     * @param {Object}        dimensions                    Object with width/height properties\n     * @param {Number|String} [dimensions.width]            Width of canvas element\n     * @param {Number|String} [dimensions.height]           Height of canvas element\n     * @param {Object}        [options]                     Options object\n     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions\n     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ setDimensions: function(dimensions, options) {\n            var cssValue;\n            options = options || {};\n            for(var prop in dimensions){\n                cssValue = dimensions[prop];\n                if (!options.cssOnly) {\n                    this._setBackstoreDimension(prop, dimensions[prop]);\n                    cssValue += \"px\";\n                    this.hasLostContext = true;\n                }\n                if (!options.backstoreOnly) {\n                    this._setCssDimension(prop, cssValue);\n                }\n            }\n            if (this._isCurrentlyDrawing) {\n                this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles(this.contextTop);\n            }\n            this._initRetinaScaling();\n            this.calcOffset();\n            if (!options.cssOnly) {\n                this.requestRenderAll();\n            }\n            return this;\n        },\n        /**\n     * Helper for setting width/height\n     * @private\n     * @param {String} prop property (width|height)\n     * @param {Number} value value to set property to\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ _setBackstoreDimension: function(prop, value) {\n            this.lowerCanvasEl[prop] = value;\n            if (this.upperCanvasEl) {\n                this.upperCanvasEl[prop] = value;\n            }\n            if (this.cacheCanvasEl) {\n                this.cacheCanvasEl[prop] = value;\n            }\n            this[prop] = value;\n            return this;\n        },\n        /**\n     * Helper for setting css width/height\n     * @private\n     * @param {String} prop property (width|height)\n     * @param {String} value value to set property to\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ _setCssDimension: function(prop, value) {\n            this.lowerCanvasEl.style[prop] = value;\n            if (this.upperCanvasEl) {\n                this.upperCanvasEl.style[prop] = value;\n            }\n            if (this.wrapperEl) {\n                this.wrapperEl.style[prop] = value;\n            }\n            return this;\n        },\n        /**\n     * Returns canvas zoom level\n     * @return {Number}\n     */ getZoom: function() {\n            return this.viewportTransform[0];\n        },\n        /**\n     * Sets viewport transformation of this canvas instance\n     * @param {Array} vpt a Canvas 2D API transform matrix\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ setViewportTransform: function(vpt) {\n            var activeObject = this._activeObject, backgroundObject = this.backgroundImage, overlayObject = this.overlayImage, object, i, len;\n            this.viewportTransform = vpt;\n            for(i = 0, len = this._objects.length; i < len; i++){\n                object = this._objects[i];\n                object.group || object.setCoords(true);\n            }\n            if (activeObject) {\n                activeObject.setCoords();\n            }\n            if (backgroundObject) {\n                backgroundObject.setCoords(true);\n            }\n            if (overlayObject) {\n                overlayObject.setCoords(true);\n            }\n            this.calcViewportBoundaries();\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * Sets zoom level of this canvas instance, the zoom centered around point\n     * meaning that following zoom to point with the same point will have the visual\n     * effect of the zoom originating from that point. The point won't move.\n     * It has nothing to do with canvas center or visual center of the viewport.\n     * @param {fabric.Point} point to zoom with respect to\n     * @param {Number} value to set zoom to, less than 1 zooms out\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ zoomToPoint: function(point, value) {\n            // TODO: just change the scale, preserve other transformations\n            var before = point, vpt = this.viewportTransform.slice(0);\n            point = transformPoint(point, invertTransform(this.viewportTransform));\n            vpt[0] = value;\n            vpt[3] = value;\n            var after = transformPoint(point, vpt);\n            vpt[4] += before.x - after.x;\n            vpt[5] += before.y - after.y;\n            return this.setViewportTransform(vpt);\n        },\n        /**\n     * Sets zoom level of this canvas instance\n     * @param {Number} value to set zoom to, less than 1 zooms out\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ setZoom: function(value) {\n            this.zoomToPoint(new fabric.Point(0, 0), value);\n            return this;\n        },\n        /**\n     * Pan viewport so as to place point at top left corner of canvas\n     * @param {fabric.Point} point to move to\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ absolutePan: function(point) {\n            var vpt = this.viewportTransform.slice(0);\n            vpt[4] = -point.x;\n            vpt[5] = -point.y;\n            return this.setViewportTransform(vpt);\n        },\n        /**\n     * Pans viewpoint relatively\n     * @param {fabric.Point} point (position vector) to move by\n     * @return {fabric.Canvas} instance\n     * @chainable true\n     */ relativePan: function(point) {\n            return this.absolutePan(new fabric.Point(-point.x - this.viewportTransform[4], -point.y - this.viewportTransform[5]));\n        },\n        /**\n     * Returns &lt;canvas> element corresponding to this instance\n     * @return {HTMLCanvasElement}\n     */ getElement: function() {\n            return this.lowerCanvasEl;\n        },\n        /**\n     * @private\n     * @param {fabric.Object} obj Object that was added\n     */ _onObjectAdded: function(obj) {\n            this.stateful && obj.setupState();\n            obj._set(\"canvas\", this);\n            obj.setCoords();\n            this.fire(\"object:added\", {\n                target: obj\n            });\n            obj.fire(\"added\");\n        },\n        /**\n     * @private\n     * @param {fabric.Object} obj Object that was removed\n     */ _onObjectRemoved: function(obj) {\n            this.fire(\"object:removed\", {\n                target: obj\n            });\n            obj.fire(\"removed\");\n            delete obj.canvas;\n        },\n        /**\n     * Clears specified context of canvas element\n     * @param {CanvasRenderingContext2D} ctx Context to clear\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ clearContext: function(ctx) {\n            ctx.clearRect(0, 0, this.width, this.height);\n            return this;\n        },\n        /**\n     * Returns context of canvas where objects are drawn\n     * @return {CanvasRenderingContext2D}\n     */ getContext: function() {\n            return this.contextContainer;\n        },\n        /**\n     * Clears all contexts (background, main, top) of an instance\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ clear: function() {\n            this.remove.apply(this, this.getObjects());\n            this.backgroundImage = null;\n            this.overlayImage = null;\n            this.backgroundColor = \"\";\n            this.overlayColor = \"\";\n            if (this._hasITextHandlers) {\n                this.off(\"mouse:up\", this._mouseUpITextHandler);\n                this._iTextInstances = null;\n                this._hasITextHandlers = false;\n            }\n            this.clearContext(this.contextContainer);\n            this.fire(\"canvas:cleared\");\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * Renders the canvas\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */ renderAll: function() {\n            var canvasToDrawOn = this.contextContainer;\n            this.renderCanvas(canvasToDrawOn, this._objects);\n            return this;\n        },\n        /**\n     * Function created to be instance bound at initialization\n     * used in requestAnimationFrame rendering\n     * Let the fabricJS call it. If you call it manually you could have more\n     * animationFrame stacking on to of each other\n     * for an imperative rendering, use canvas.renderAll\n     * @private\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */ renderAndReset: function() {\n            this.isRendering = 0;\n            this.renderAll();\n        },\n        /**\n     * Append a renderAll request to next animation frame.\n     * unless one is already in progress, in that case nothing is done\n     * a boolean flag will avoid appending more.\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */ requestRenderAll: function() {\n            if (!this.isRendering) {\n                this.isRendering = fabric.util.requestAnimFrame(this.renderAndResetBound);\n            }\n            return this;\n        },\n        /**\n     * Calculate the position of the 4 corner of canvas with current viewportTransform.\n     * helps to determinate when an object is in the current rendering viewport using\n     * object absolute coordinates ( aCoords )\n     * @return {Object} points.tl\n     * @chainable\n     */ calcViewportBoundaries: function() {\n            var points = {}, width = this.width, height = this.height, iVpt = invertTransform(this.viewportTransform);\n            points.tl = transformPoint({\n                x: 0,\n                y: 0\n            }, iVpt);\n            points.br = transformPoint({\n                x: width,\n                y: height\n            }, iVpt);\n            points.tr = new fabric.Point(points.br.x, points.tl.y);\n            points.bl = new fabric.Point(points.tl.x, points.br.y);\n            this.vptCoords = points;\n            return points;\n        },\n        cancelRequestedRender: function() {\n            if (this.isRendering) {\n                fabric.util.cancelAnimFrame(this.isRendering);\n                this.isRendering = 0;\n            }\n        },\n        /**\n     * Renders background, objects, overlay and controls.\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {Array} objects to render\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */ renderCanvas: function(ctx, objects) {\n            var v = this.viewportTransform, path = this.clipPath;\n            this.cancelRequestedRender();\n            this.calcViewportBoundaries();\n            this.clearContext(ctx);\n            fabric.util.setImageSmoothing(ctx, this.imageSmoothingEnabled);\n            this.fire(\"before:render\", {\n                ctx: ctx\n            });\n            this._renderBackground(ctx);\n            ctx.save();\n            //apply viewport transform once for all rendering process\n            ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n            this._renderObjects(ctx, objects);\n            ctx.restore();\n            if (!this.controlsAboveOverlay && this.interactive) {\n                this.drawControls(ctx);\n            }\n            if (path) {\n                path.canvas = this;\n                // needed to setup a couple of variables\n                path.shouldCache();\n                path._transformDone = true;\n                path.renderCache({\n                    forClipping: true\n                });\n                this.drawClipPathOnCanvas(ctx);\n            }\n            this._renderOverlay(ctx);\n            if (this.controlsAboveOverlay && this.interactive) {\n                this.drawControls(ctx);\n            }\n            this.fire(\"after:render\", {\n                ctx: ctx\n            });\n        },\n        /**\n     * Paint the cached clipPath on the lowerCanvasEl\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ drawClipPathOnCanvas: function(ctx) {\n            var v = this.viewportTransform, path = this.clipPath;\n            ctx.save();\n            ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n            // DEBUG: uncomment this line, comment the following\n            // ctx.globalAlpha = 0.4;\n            ctx.globalCompositeOperation = \"destination-in\";\n            path.transform(ctx);\n            ctx.scale(1 / path.zoomX, 1 / path.zoomY);\n            ctx.drawImage(path._cacheCanvas, -path.cacheTranslationX, -path.cacheTranslationY);\n            ctx.restore();\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Array} objects to render\n     */ _renderObjects: function(ctx, objects) {\n            var i, len;\n            for(i = 0, len = objects.length; i < len; ++i){\n                objects[i] && objects[i].render(ctx);\n            }\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {string} property 'background' or 'overlay'\n     */ _renderBackgroundOrOverlay: function(ctx, property) {\n            var fill = this[property + \"Color\"], object = this[property + \"Image\"], v = this.viewportTransform, needsVpt = this[property + \"Vpt\"];\n            if (!fill && !object) {\n                return;\n            }\n            if (fill) {\n                ctx.save();\n                ctx.beginPath();\n                ctx.moveTo(0, 0);\n                ctx.lineTo(this.width, 0);\n                ctx.lineTo(this.width, this.height);\n                ctx.lineTo(0, this.height);\n                ctx.closePath();\n                ctx.fillStyle = fill.toLive ? fill.toLive(ctx, this) : fill;\n                if (needsVpt) {\n                    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n                }\n                ctx.transform(1, 0, 0, 1, fill.offsetX || 0, fill.offsetY || 0);\n                var m = fill.gradientTransform || fill.patternTransform;\n                m && ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n                ctx.fill();\n                ctx.restore();\n            }\n            if (object) {\n                ctx.save();\n                var skipOffscreen = this.skipOffscreen;\n                // if the object doesn't move with the viewport,\n                // the offscreen concept does not apply;\n                this.skipOffscreen = needsVpt;\n                if (needsVpt) {\n                    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n                }\n                object.render(ctx);\n                this.skipOffscreen = skipOffscreen;\n                ctx.restore();\n            }\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderBackground: function(ctx) {\n            this._renderBackgroundOrOverlay(ctx, \"background\");\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderOverlay: function(ctx) {\n            this._renderBackgroundOrOverlay(ctx, \"overlay\");\n        },\n        /**\n     * Returns coordinates of a center of canvas.\n     * Returned value is an object with top and left properties\n     * @return {Object} object with \"top\" and \"left\" number values\n     * @deprecated migrate to `getCenterPoint`\n     */ getCenter: function() {\n            return {\n                top: this.height / 2,\n                left: this.width / 2\n            };\n        },\n        /**\n     * Returns coordinates of a center of canvas.\n     * @return {fabric.Point} \n     */ getCenterPoint: function() {\n            return new fabric.Point(this.width / 2, this.height / 2);\n        },\n        /**\n     * Centers object horizontally in the canvas\n     * @param {fabric.Object} object Object to center horizontally\n     * @return {fabric.Canvas} thisArg\n     */ centerObjectH: function(object) {\n            return this._centerObject(object, new fabric.Point(this.getCenterPoint().x, object.getCenterPoint().y));\n        },\n        /**\n     * Centers object vertically in the canvas\n     * @param {fabric.Object} object Object to center vertically\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ centerObjectV: function(object) {\n            return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, this.getCenterPoint().y));\n        },\n        /**\n     * Centers object vertically and horizontally in the canvas\n     * @param {fabric.Object} object Object to center vertically and horizontally\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ centerObject: function(object) {\n            var center = this.getCenterPoint();\n            return this._centerObject(object, center);\n        },\n        /**\n     * Centers object vertically and horizontally in the viewport\n     * @param {fabric.Object} object Object to center vertically and horizontally\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ viewportCenterObject: function(object) {\n            var vpCenter = this.getVpCenter();\n            return this._centerObject(object, vpCenter);\n        },\n        /**\n     * Centers object horizontally in the viewport, object.top is unchanged\n     * @param {fabric.Object} object Object to center vertically and horizontally\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ viewportCenterObjectH: function(object) {\n            var vpCenter = this.getVpCenter();\n            this._centerObject(object, new fabric.Point(vpCenter.x, object.getCenterPoint().y));\n            return this;\n        },\n        /**\n     * Centers object Vertically in the viewport, object.top is unchanged\n     * @param {fabric.Object} object Object to center vertically and horizontally\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ viewportCenterObjectV: function(object) {\n            var vpCenter = this.getVpCenter();\n            return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, vpCenter.y));\n        },\n        /**\n     * Calculate the point in canvas that correspond to the center of actual viewport.\n     * @return {fabric.Point} vpCenter, viewport center\n     * @chainable\n     */ getVpCenter: function() {\n            var center = this.getCenterPoint(), iVpt = invertTransform(this.viewportTransform);\n            return transformPoint(center, iVpt);\n        },\n        /**\n     * @private\n     * @param {fabric.Object} object Object to center\n     * @param {fabric.Point} center Center point\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ _centerObject: function(object, center) {\n            object.setPositionByOrigin(center, \"center\", \"center\");\n            object.setCoords();\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * Returns dataless JSON representation of canvas\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {String} json string\n     */ toDatalessJSON: function(propertiesToInclude) {\n            return this.toDatalessObject(propertiesToInclude);\n        },\n        /**\n     * Returns object representation of canvas\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return this._toObjectMethod(\"toObject\", propertiesToInclude);\n        },\n        /**\n     * Returns dataless object representation of canvas\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toDatalessObject: function(propertiesToInclude) {\n            return this._toObjectMethod(\"toDatalessObject\", propertiesToInclude);\n        },\n        /**\n     * @private\n     */ _toObjectMethod: function(methodName, propertiesToInclude) {\n            var clipPath = this.clipPath, data = {\n                version: fabric.version,\n                objects: this._toObjects(methodName, propertiesToInclude)\n            };\n            if (clipPath && !clipPath.excludeFromExport) {\n                data.clipPath = this._toObject(this.clipPath, methodName, propertiesToInclude);\n            }\n            extend(data, this.__serializeBgOverlay(methodName, propertiesToInclude));\n            fabric.util.populateWithProperties(this, data, propertiesToInclude);\n            return data;\n        },\n        /**\n     * @private\n     */ _toObjects: function(methodName, propertiesToInclude) {\n            return this._objects.filter(function(object) {\n                return !object.excludeFromExport;\n            }).map(function(instance) {\n                return this._toObject(instance, methodName, propertiesToInclude);\n            }, this);\n        },\n        /**\n     * @private\n     */ _toObject: function(instance, methodName, propertiesToInclude) {\n            var originalValue;\n            if (!this.includeDefaultValues) {\n                originalValue = instance.includeDefaultValues;\n                instance.includeDefaultValues = false;\n            }\n            var object = instance[methodName](propertiesToInclude);\n            if (!this.includeDefaultValues) {\n                instance.includeDefaultValues = originalValue;\n            }\n            return object;\n        },\n        /**\n     * @private\n     */ __serializeBgOverlay: function(methodName, propertiesToInclude) {\n            var data = {}, bgImage = this.backgroundImage, overlayImage = this.overlayImage, bgColor = this.backgroundColor, overlayColor = this.overlayColor;\n            if (bgColor && bgColor.toObject) {\n                if (!bgColor.excludeFromExport) {\n                    data.background = bgColor.toObject(propertiesToInclude);\n                }\n            } else if (bgColor) {\n                data.background = bgColor;\n            }\n            if (overlayColor && overlayColor.toObject) {\n                if (!overlayColor.excludeFromExport) {\n                    data.overlay = overlayColor.toObject(propertiesToInclude);\n                }\n            } else if (overlayColor) {\n                data.overlay = overlayColor;\n            }\n            if (bgImage && !bgImage.excludeFromExport) {\n                data.backgroundImage = this._toObject(bgImage, methodName, propertiesToInclude);\n            }\n            if (overlayImage && !overlayImage.excludeFromExport) {\n                data.overlayImage = this._toObject(overlayImage, methodName, propertiesToInclude);\n            }\n            return data;\n        },\n        /* _TO_SVG_START_ */ /**\n     * When true, getSvgTransform() will apply the StaticCanvas.viewportTransform to the SVG transformation. When true,\n     * a zoomed canvas will then produce zoomed SVG output.\n     * @type Boolean\n     * @default\n     */ svgViewportTransformation: true,\n        /**\n     * Returns SVG representation of canvas\n     * @function\n     * @param {Object} [options] Options object for SVG output\n     * @param {Boolean} [options.suppressPreamble=false] If true xml tag is not included\n     * @param {Object} [options.viewBox] SVG viewbox object\n     * @param {Number} [options.viewBox.x] x-coordinate of viewbox\n     * @param {Number} [options.viewBox.y] y-coordinate of viewbox\n     * @param {Number} [options.viewBox.width] Width of viewbox\n     * @param {Number} [options.viewBox.height] Height of viewbox\n     * @param {String} [options.encoding=UTF-8] Encoding of SVG output\n     * @param {String} [options.width] desired width of svg with or without units\n     * @param {String} [options.height] desired height of svg with or without units\n     * @param {Function} [reviver] Method for further parsing of svg elements, called after each fabric object converted into svg representation.\n     * @return {String} SVG string\n     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}\n     * @see {@link http://jsfiddle.net/fabricjs/jQ3ZZ/|jsFiddle demo}\n     * @example <caption>Normal SVG output</caption>\n     * var svg = canvas.toSVG();\n     * @example <caption>SVG output without preamble (without &lt;?xml ../>)</caption>\n     * var svg = canvas.toSVG({suppressPreamble: true});\n     * @example <caption>SVG output with viewBox attribute</caption>\n     * var svg = canvas.toSVG({\n     *   viewBox: {\n     *     x: 100,\n     *     y: 100,\n     *     width: 200,\n     *     height: 300\n     *   }\n     * });\n     * @example <caption>SVG output with different encoding (default: UTF-8)</caption>\n     * var svg = canvas.toSVG({encoding: 'ISO-8859-1'});\n     * @example <caption>Modify SVG output with reviver function</caption>\n     * var svg = canvas.toSVG(null, function(svg) {\n     *   return svg.replace('stroke-dasharray: ; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; ', '');\n     * });\n     */ toSVG: function(options, reviver) {\n            options || (options = {});\n            options.reviver = reviver;\n            var markup = [];\n            this._setSVGPreamble(markup, options);\n            this._setSVGHeader(markup, options);\n            if (this.clipPath) {\n                markup.push('<g clip-path=\"url(#' + this.clipPath.clipPathId + ')\" >\\n');\n            }\n            this._setSVGBgOverlayColor(markup, \"background\");\n            this._setSVGBgOverlayImage(markup, \"backgroundImage\", reviver);\n            this._setSVGObjects(markup, reviver);\n            if (this.clipPath) {\n                markup.push(\"</g>\\n\");\n            }\n            this._setSVGBgOverlayColor(markup, \"overlay\");\n            this._setSVGBgOverlayImage(markup, \"overlayImage\", reviver);\n            markup.push(\"</svg>\");\n            return markup.join(\"\");\n        },\n        /**\n     * @private\n     */ _setSVGPreamble: function(markup, options) {\n            if (options.suppressPreamble) {\n                return;\n            }\n            markup.push('<?xml version=\"1.0\" encoding=\"', options.encoding || \"UTF-8\", '\" standalone=\"no\" ?>\\n', '<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" ', '\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\\n');\n        },\n        /**\n     * @private\n     */ _setSVGHeader: function(markup, options) {\n            var width = options.width || this.width, height = options.height || this.height, vpt, viewBox = 'viewBox=\"0 0 ' + this.width + \" \" + this.height + '\" ', NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;\n            if (options.viewBox) {\n                viewBox = 'viewBox=\"' + options.viewBox.x + \" \" + options.viewBox.y + \" \" + options.viewBox.width + \" \" + options.viewBox.height + '\" ';\n            } else {\n                if (this.svgViewportTransformation) {\n                    vpt = this.viewportTransform;\n                    viewBox = 'viewBox=\"' + toFixed(-vpt[4] / vpt[0], NUM_FRACTION_DIGITS) + \" \" + toFixed(-vpt[5] / vpt[3], NUM_FRACTION_DIGITS) + \" \" + toFixed(this.width / vpt[0], NUM_FRACTION_DIGITS) + \" \" + toFixed(this.height / vpt[3], NUM_FRACTION_DIGITS) + '\" ';\n                }\n            }\n            markup.push(\"<svg \", 'xmlns=\"http://www.w3.org/2000/svg\" ', 'xmlns:xlink=\"http://www.w3.org/1999/xlink\" ', 'version=\"1.1\" ', 'width=\"', width, '\" ', 'height=\"', height, '\" ', viewBox, 'xml:space=\"preserve\">\\n', \"<desc>Created with Fabric.js \", fabric.version, \"</desc>\\n\", \"<defs>\\n\", this.createSVGFontFacesMarkup(), this.createSVGRefElementsMarkup(), this.createSVGClipPathMarkup(options), \"</defs>\\n\");\n        },\n        createSVGClipPathMarkup: function(options) {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                clipPath.clipPathId = \"CLIPPATH_\" + fabric.Object.__uid++;\n                return '<clipPath id=\"' + clipPath.clipPathId + '\" >\\n' + this.clipPath.toClipPathSVG(options.reviver) + \"</clipPath>\\n\";\n            }\n            return \"\";\n        },\n        /**\n     * Creates markup containing SVG referenced elements like patterns, gradients etc.\n     * @return {String}\n     */ createSVGRefElementsMarkup: function() {\n            var _this = this, markup = [\n                \"background\",\n                \"overlay\"\n            ].map(function(prop) {\n                var fill = _this[prop + \"Color\"];\n                if (fill && fill.toLive) {\n                    var shouldTransform = _this[prop + \"Vpt\"], vpt = _this.viewportTransform, object = {\n                        width: _this.width / (shouldTransform ? vpt[0] : 1),\n                        height: _this.height / (shouldTransform ? vpt[3] : 1)\n                    };\n                    return fill.toSVG(object, {\n                        additionalTransform: shouldTransform ? fabric.util.matrixToSVG(vpt) : \"\"\n                    });\n                }\n            });\n            return markup.join(\"\");\n        },\n        /**\n     * Creates markup containing SVG font faces,\n     * font URLs for font faces must be collected by developers\n     * and are not extracted from the DOM by fabricjs\n     * @param {Array} objects Array of fabric objects\n     * @return {String}\n     */ createSVGFontFacesMarkup: function() {\n            var markup = \"\", fontList = {}, obj, fontFamily, style, row, rowIndex, _char, charIndex, i, len, fontPaths = fabric.fontPaths, objects = [];\n            this._objects.forEach(function add(object) {\n                objects.push(object);\n                if (object._objects) {\n                    object._objects.forEach(add);\n                }\n            });\n            for(i = 0, len = objects.length; i < len; i++){\n                obj = objects[i];\n                fontFamily = obj.fontFamily;\n                if (obj.type.indexOf(\"text\") === -1 || fontList[fontFamily] || !fontPaths[fontFamily]) {\n                    continue;\n                }\n                fontList[fontFamily] = true;\n                if (!obj.styles) {\n                    continue;\n                }\n                style = obj.styles;\n                for(rowIndex in style){\n                    row = style[rowIndex];\n                    for(charIndex in row){\n                        _char = row[charIndex];\n                        fontFamily = _char.fontFamily;\n                        if (!fontList[fontFamily] && fontPaths[fontFamily]) {\n                            fontList[fontFamily] = true;\n                        }\n                    }\n                }\n            }\n            for(var j in fontList){\n                markup += [\n                    \"\t\t@font-face {\\n\",\n                    \"\t\t\tfont-family: '\",\n                    j,\n                    \"';\\n\",\n                    \"\t\t\tsrc: url('\",\n                    fontPaths[j],\n                    \"');\\n\",\n                    \"\t\t}\\n\"\n                ].join(\"\");\n            }\n            if (markup) {\n                markup = [\n                    '\t<style type=\"text/css\">',\n                    \"<![CDATA[\\n\",\n                    markup,\n                    \"]]>\",\n                    \"</style>\\n\"\n                ].join(\"\");\n            }\n            return markup;\n        },\n        /**\n     * @private\n     */ _setSVGObjects: function(markup, reviver) {\n            var instance, i, len, objects = this._objects;\n            for(i = 0, len = objects.length; i < len; i++){\n                instance = objects[i];\n                if (instance.excludeFromExport) {\n                    continue;\n                }\n                this._setSVGObject(markup, instance, reviver);\n            }\n        },\n        /**\n     * @private\n     */ _setSVGObject: function(markup, instance, reviver) {\n            markup.push(instance.toSVG(reviver));\n        },\n        /**\n     * @private\n     */ _setSVGBgOverlayImage: function(markup, property, reviver) {\n            if (this[property] && !this[property].excludeFromExport && this[property].toSVG) {\n                markup.push(this[property].toSVG(reviver));\n            }\n        },\n        /**\n     * @private\n     */ _setSVGBgOverlayColor: function(markup, property) {\n            var filler = this[property + \"Color\"], vpt = this.viewportTransform, finalWidth = this.width, finalHeight = this.height;\n            if (!filler) {\n                return;\n            }\n            if (filler.toLive) {\n                var repeat = filler.repeat, iVpt = fabric.util.invertTransform(vpt), shouldInvert = this[property + \"Vpt\"], additionalTransform = shouldInvert ? fabric.util.matrixToSVG(iVpt) : \"\";\n                markup.push('<rect transform=\"' + additionalTransform + \" translate(\", finalWidth / 2, \",\", finalHeight / 2, ')\"', ' x=\"', filler.offsetX - finalWidth / 2, '\" y=\"', filler.offsetY - finalHeight / 2, '\" ', 'width=\"', repeat === \"repeat-y\" || repeat === \"no-repeat\" ? filler.source.width : finalWidth, '\" height=\"', repeat === \"repeat-x\" || repeat === \"no-repeat\" ? filler.source.height : finalHeight, '\" fill=\"url(#SVGID_' + filler.id + ')\"', \"></rect>\\n\");\n            } else {\n                markup.push('<rect x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" ', 'fill=\"', filler, '\"', \"></rect>\\n\");\n            }\n        },\n        /* _TO_SVG_END_ */ /**\n     * Moves an object or the objects of a multiple selection\n     * to the bottom of the stack of drawn objects\n     * @param {fabric.Object} object Object to send to back\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ sendToBack: function(object) {\n            if (!object) {\n                return this;\n            }\n            var activeSelection = this._activeObject, i, obj, objs;\n            if (object === activeSelection && object.type === \"activeSelection\") {\n                objs = activeSelection._objects;\n                for(i = objs.length; i--;){\n                    obj = objs[i];\n                    removeFromArray(this._objects, obj);\n                    this._objects.unshift(obj);\n                }\n            } else {\n                removeFromArray(this._objects, object);\n                this._objects.unshift(object);\n            }\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * Moves an object or the objects of a multiple selection\n     * to the top of the stack of drawn objects\n     * @param {fabric.Object} object Object to send\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ bringToFront: function(object) {\n            if (!object) {\n                return this;\n            }\n            var activeSelection = this._activeObject, i, obj, objs;\n            if (object === activeSelection && object.type === \"activeSelection\") {\n                objs = activeSelection._objects;\n                for(i = 0; i < objs.length; i++){\n                    obj = objs[i];\n                    removeFromArray(this._objects, obj);\n                    this._objects.push(obj);\n                }\n            } else {\n                removeFromArray(this._objects, object);\n                this._objects.push(object);\n            }\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * Moves an object or a selection down in stack of drawn objects\n     * An optional parameter, intersecting allows to move the object in behind\n     * the first intersecting object. Where intersection is calculated with\n     * bounding box. If no intersection is found, there will not be change in the\n     * stack.\n     * @param {fabric.Object} object Object to send\n     * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ sendBackwards: function(object, intersecting) {\n            if (!object) {\n                return this;\n            }\n            var activeSelection = this._activeObject, i, obj, idx, newIdx, objs, objsMoved = 0;\n            if (object === activeSelection && object.type === \"activeSelection\") {\n                objs = activeSelection._objects;\n                for(i = 0; i < objs.length; i++){\n                    obj = objs[i];\n                    idx = this._objects.indexOf(obj);\n                    if (idx > 0 + objsMoved) {\n                        newIdx = idx - 1;\n                        removeFromArray(this._objects, obj);\n                        this._objects.splice(newIdx, 0, obj);\n                    }\n                    objsMoved++;\n                }\n            } else {\n                idx = this._objects.indexOf(object);\n                if (idx !== 0) {\n                    // if object is not on the bottom of stack\n                    newIdx = this._findNewLowerIndex(object, idx, intersecting);\n                    removeFromArray(this._objects, object);\n                    this._objects.splice(newIdx, 0, object);\n                }\n            }\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * @private\n     */ _findNewLowerIndex: function(object, idx, intersecting) {\n            var newIdx, i;\n            if (intersecting) {\n                newIdx = idx;\n                // traverse down the stack looking for the nearest intersecting object\n                for(i = idx - 1; i >= 0; --i){\n                    var isIntersecting = object.intersectsWithObject(this._objects[i]) || object.isContainedWithinObject(this._objects[i]) || this._objects[i].isContainedWithinObject(object);\n                    if (isIntersecting) {\n                        newIdx = i;\n                        break;\n                    }\n                }\n            } else {\n                newIdx = idx - 1;\n            }\n            return newIdx;\n        },\n        /**\n     * Moves an object or a selection up in stack of drawn objects\n     * An optional parameter, intersecting allows to move the object in front\n     * of the first intersecting object. Where intersection is calculated with\n     * bounding box. If no intersection is found, there will not be change in the\n     * stack.\n     * @param {fabric.Object} object Object to send\n     * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ bringForward: function(object, intersecting) {\n            if (!object) {\n                return this;\n            }\n            var activeSelection = this._activeObject, i, obj, idx, newIdx, objs, objsMoved = 0;\n            if (object === activeSelection && object.type === \"activeSelection\") {\n                objs = activeSelection._objects;\n                for(i = objs.length; i--;){\n                    obj = objs[i];\n                    idx = this._objects.indexOf(obj);\n                    if (idx < this._objects.length - 1 - objsMoved) {\n                        newIdx = idx + 1;\n                        removeFromArray(this._objects, obj);\n                        this._objects.splice(newIdx, 0, obj);\n                    }\n                    objsMoved++;\n                }\n            } else {\n                idx = this._objects.indexOf(object);\n                if (idx !== this._objects.length - 1) {\n                    // if object is not on top of stack (last item in an array)\n                    newIdx = this._findNewUpperIndex(object, idx, intersecting);\n                    removeFromArray(this._objects, object);\n                    this._objects.splice(newIdx, 0, object);\n                }\n            }\n            this.renderOnAddRemove && this.requestRenderAll();\n            return this;\n        },\n        /**\n     * @private\n     */ _findNewUpperIndex: function(object, idx, intersecting) {\n            var newIdx, i, len;\n            if (intersecting) {\n                newIdx = idx;\n                // traverse up the stack looking for the nearest intersecting object\n                for(i = idx + 1, len = this._objects.length; i < len; ++i){\n                    var isIntersecting = object.intersectsWithObject(this._objects[i]) || object.isContainedWithinObject(this._objects[i]) || this._objects[i].isContainedWithinObject(object);\n                    if (isIntersecting) {\n                        newIdx = i;\n                        break;\n                    }\n                }\n            } else {\n                newIdx = idx + 1;\n            }\n            return newIdx;\n        },\n        /**\n     * Moves an object to specified level in stack of drawn objects\n     * @param {fabric.Object} object Object to send\n     * @param {Number} index Position to move to\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ moveTo: function(object, index) {\n            removeFromArray(this._objects, object);\n            this._objects.splice(index, 0, object);\n            return this.renderOnAddRemove && this.requestRenderAll();\n        },\n        /**\n     * Clears a canvas element and dispose objects\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ dispose: function() {\n            // cancel eventually ongoing renders\n            if (this.isRendering) {\n                fabric.util.cancelAnimFrame(this.isRendering);\n                this.isRendering = 0;\n            }\n            this.forEachObject(function(object) {\n                object.dispose && object.dispose();\n            });\n            this._objects = [];\n            if (this.backgroundImage && this.backgroundImage.dispose) {\n                this.backgroundImage.dispose();\n            }\n            this.backgroundImage = null;\n            if (this.overlayImage && this.overlayImage.dispose) {\n                this.overlayImage.dispose();\n            }\n            this.overlayImage = null;\n            this._iTextInstances = null;\n            this.contextContainer = null;\n            // restore canvas style\n            this.lowerCanvasEl.classList.remove(\"lower-canvas\");\n            fabric.util.setStyle(this.lowerCanvasEl, this._originalCanvasStyle);\n            delete this._originalCanvasStyle;\n            // restore canvas size to original size in case retina scaling was applied\n            this.lowerCanvasEl.setAttribute(\"width\", this.width);\n            this.lowerCanvasEl.setAttribute(\"height\", this.height);\n            fabric.util.cleanUpJsdomNode(this.lowerCanvasEl);\n            this.lowerCanvasEl = undefined;\n            return this;\n        },\n        /**\n     * Returns a string representation of an instance\n     * @return {String} string representation of an instance\n     */ toString: function() {\n            return \"#<fabric.Canvas (\" + this.complexity() + \"): \" + \"{ objects: \" + this._objects.length + \" }>\";\n        }\n    });\n    extend(fabric.StaticCanvas.prototype, fabric.Observable);\n    extend(fabric.StaticCanvas.prototype, fabric.Collection);\n    extend(fabric.StaticCanvas.prototype, fabric.DataURLExporter);\n    extend(fabric.StaticCanvas, /** @lends fabric.StaticCanvas */ {\n        /**\n     * @static\n     * @type String\n     * @default\n     */ EMPTY_JSON: '{\"objects\": [], \"background\": \"white\"}',\n        /**\n     * Provides a way to check support of some of the canvas methods\n     * (either those of HTMLCanvasElement itself, or rendering context)\n     *\n     * @param {String} methodName Method to check support for;\n     *                            Could be one of \"setLineDash\"\n     * @return {Boolean | null} `true` if method is supported (or at least exists),\n     *                          `null` if canvas element or context can not be initialized\n     */ supports: function(methodName) {\n            var el = createCanvasElement();\n            if (!el || !el.getContext) {\n                return null;\n            }\n            var ctx = el.getContext(\"2d\");\n            if (!ctx) {\n                return null;\n            }\n            switch(methodName){\n                case \"setLineDash\":\n                    return typeof ctx.setLineDash !== \"undefined\";\n                default:\n                    return null;\n            }\n        }\n    });\n    /**\n   * Returns Object representation of canvas\n   * this alias is provided because if you call JSON.stringify on an instance,\n   * the toJSON object will be invoked if it exists.\n   * Having a toJSON method means you can do JSON.stringify(myCanvas)\n   * @function\n   * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n   * @return {Object} JSON compatible object\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}\n   * @see {@link http://jsfiddle.net/fabricjs/pec86/|jsFiddle demo}\n   * @example <caption>JSON without additional properties</caption>\n   * var json = canvas.toJSON();\n   * @example <caption>JSON with additional properties included</caption>\n   * var json = canvas.toJSON(['lockMovementX', 'lockMovementY', 'lockRotation', 'lockScalingX', 'lockScalingY']);\n   * @example <caption>JSON without default values</caption>\n   * canvas.includeDefaultValues = false;\n   * var json = canvas.toJSON();\n   */ fabric.StaticCanvas.prototype.toJSON = fabric.StaticCanvas.prototype.toObject;\n    if (fabric.isLikelyNode) {\n        fabric.StaticCanvas.prototype.createPNGStream = function() {\n            var impl = getNodeCanvas(this.lowerCanvasEl);\n            return impl && impl.createPNGStream();\n        };\n        fabric.StaticCanvas.prototype.createJPEGStream = function(opts) {\n            var impl = getNodeCanvas(this.lowerCanvasEl);\n            return impl && impl.createJPEGStream(opts);\n        };\n    }\n})();\n/**\n * BaseBrush class\n * @class fabric.BaseBrush\n * @see {@link http://fabricjs.com/freedrawing|Freedrawing demo}\n */ fabric.BaseBrush = fabric.util.createClass(/** @lends fabric.BaseBrush.prototype */ {\n    /**\n   * Color of a brush\n   * @type String\n   * @default\n   */ color: \"rgb(0, 0, 0)\",\n    /**\n   * Width of a brush, has to be a Number, no string literals\n   * @type Number\n   * @default\n   */ width: 1,\n    /**\n   * Shadow object representing shadow of this shape.\n   * <b>Backwards incompatibility note:</b> This property replaces \"shadowColor\" (String), \"shadowOffsetX\" (Number),\n   * \"shadowOffsetY\" (Number) and \"shadowBlur\" (Number) since v1.2.12\n   * @type fabric.Shadow\n   * @default\n   */ shadow: null,\n    /**\n   * Line endings style of a brush (one of \"butt\", \"round\", \"square\")\n   * @type String\n   * @default\n   */ strokeLineCap: \"round\",\n    /**\n   * Corner style of a brush (one of \"bevel\", \"round\", \"miter\")\n   * @type String\n   * @default\n   */ strokeLineJoin: \"round\",\n    /**\n   * Maximum miter length (used for strokeLineJoin = \"miter\") of a brush's\n   * @type Number\n   * @default\n   */ strokeMiterLimit: 10,\n    /**\n   * Stroke Dash Array.\n   * @type Array\n   * @default\n   */ strokeDashArray: null,\n    /**\n   * When `true`, the free drawing is limited to the whiteboard size. Default to false.\n   * @type Boolean\n   * @default false\n  */ limitedToCanvasSize: false,\n    /**\n   * Sets brush styles\n   * @private\n   * @param {CanvasRenderingContext2D} ctx\n   */ _setBrushStyles: function(ctx) {\n        ctx.strokeStyle = this.color;\n        ctx.lineWidth = this.width;\n        ctx.lineCap = this.strokeLineCap;\n        ctx.miterLimit = this.strokeMiterLimit;\n        ctx.lineJoin = this.strokeLineJoin;\n        ctx.setLineDash(this.strokeDashArray || []);\n    },\n    /**\n   * Sets the transformation on given context\n   * @param {RenderingContext2d} ctx context to render on\n   * @private\n   */ _saveAndTransform: function(ctx) {\n        var v = this.canvas.viewportTransform;\n        ctx.save();\n        ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n    },\n    /**\n   * Sets brush shadow styles\n   * @private\n   */ _setShadow: function() {\n        if (!this.shadow) {\n            return;\n        }\n        var canvas = this.canvas, shadow = this.shadow, ctx = canvas.contextTop, zoom = canvas.getZoom();\n        if (canvas && canvas._isRetinaScaling()) {\n            zoom *= fabric.devicePixelRatio;\n        }\n        ctx.shadowColor = shadow.color;\n        ctx.shadowBlur = shadow.blur * zoom;\n        ctx.shadowOffsetX = shadow.offsetX * zoom;\n        ctx.shadowOffsetY = shadow.offsetY * zoom;\n    },\n    needsFullRender: function() {\n        var color = new fabric.Color(this.color);\n        return color.getAlpha() < 1 || !!this.shadow;\n    },\n    /**\n   * Removes brush shadow styles\n   * @private\n   */ _resetShadow: function() {\n        var ctx = this.canvas.contextTop;\n        ctx.shadowColor = \"\";\n        ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;\n    },\n    /**\n   * Check is pointer is outside canvas boundaries\n   * @param {Object} pointer\n   * @private\n  */ _isOutSideCanvas: function(pointer) {\n        return pointer.x < 0 || pointer.x > this.canvas.getWidth() || pointer.y < 0 || pointer.y > this.canvas.getHeight();\n    }\n});\n(function() {\n    /**\n   * PencilBrush class\n   * @class fabric.PencilBrush\n   * @extends fabric.BaseBrush\n   */ fabric.PencilBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.PencilBrush.prototype */ {\n        /**\n     * Discard points that are less than `decimate` pixel distant from each other\n     * @type Number\n     * @default 0.4\n     */ decimate: 0.4,\n        /**\n     * Draws a straight line between last recorded point to current pointer\n     * Used for `shift` functionality\n     *\n     * @type boolean\n     * @default false\n     */ drawStraightLine: false,\n        /**\n     * The event modifier key that makes the brush draw a straight line.\n     * If `null` or 'none' or any other string that is not a modifier key the feature is disabled.\n     * @type {'altKey' | 'shiftKey' | 'ctrlKey' | 'none' | undefined | null}\n     */ straightLineKey: \"shiftKey\",\n        /**\n     * Constructor\n     * @param {fabric.Canvas} canvas\n     * @return {fabric.PencilBrush} Instance of a pencil brush\n     */ initialize: function(canvas) {\n            this.canvas = canvas;\n            this._points = [];\n        },\n        needsFullRender: function() {\n            return this.callSuper(\"needsFullRender\") || this._hasStraightLine;\n        },\n        /**\n     * Invoked inside on mouse down and mouse move\n     * @param {Object} pointer\n     */ _drawSegment: function(ctx, p1, p2) {\n            var midPoint = p1.midPointFrom(p2);\n            ctx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);\n            return midPoint;\n        },\n        /**\n     * Invoked on mouse down\n     * @param {Object} pointer\n     */ onMouseDown: function(pointer, options) {\n            if (!this.canvas._isMainEvent(options.e)) {\n                return;\n            }\n            this.drawStraightLine = options.e[this.straightLineKey];\n            this._prepareForDrawing(pointer);\n            // capture coordinates immediately\n            // this allows to draw dots (when movement never occurs)\n            this._captureDrawingPath(pointer);\n            this._render();\n        },\n        /**\n     * Invoked on mouse move\n     * @param {Object} pointer\n     */ onMouseMove: function(pointer, options) {\n            if (!this.canvas._isMainEvent(options.e)) {\n                return;\n            }\n            this.drawStraightLine = options.e[this.straightLineKey];\n            if (this.limitedToCanvasSize === true && this._isOutSideCanvas(pointer)) {\n                return;\n            }\n            if (this._captureDrawingPath(pointer) && this._points.length > 1) {\n                if (this.needsFullRender()) {\n                    // redraw curve\n                    // clear top canvas\n                    this.canvas.clearContext(this.canvas.contextTop);\n                    this._render();\n                } else {\n                    var points = this._points, length = points.length, ctx = this.canvas.contextTop;\n                    // draw the curve update\n                    this._saveAndTransform(ctx);\n                    if (this.oldEnd) {\n                        ctx.beginPath();\n                        ctx.moveTo(this.oldEnd.x, this.oldEnd.y);\n                    }\n                    this.oldEnd = this._drawSegment(ctx, points[length - 2], points[length - 1], true);\n                    ctx.stroke();\n                    ctx.restore();\n                }\n            }\n        },\n        /**\n     * Invoked on mouse up\n     */ onMouseUp: function(options) {\n            if (!this.canvas._isMainEvent(options.e)) {\n                return true;\n            }\n            this.drawStraightLine = false;\n            this.oldEnd = undefined;\n            this._finalizeAndAddPath();\n            return false;\n        },\n        /**\n     * @private\n     * @param {Object} pointer Actual mouse position related to the canvas.\n     */ _prepareForDrawing: function(pointer) {\n            var p = new fabric.Point(pointer.x, pointer.y);\n            this._reset();\n            this._addPoint(p);\n            this.canvas.contextTop.moveTo(p.x, p.y);\n        },\n        /**\n     * @private\n     * @param {fabric.Point} point Point to be added to points array\n     */ _addPoint: function(point) {\n            if (this._points.length > 1 && point.eq(this._points[this._points.length - 1])) {\n                return false;\n            }\n            if (this.drawStraightLine && this._points.length > 1) {\n                this._hasStraightLine = true;\n                this._points.pop();\n            }\n            this._points.push(point);\n            return true;\n        },\n        /**\n     * Clear points array and set contextTop canvas style.\n     * @private\n     */ _reset: function() {\n            this._points = [];\n            this._setBrushStyles(this.canvas.contextTop);\n            this._setShadow();\n            this._hasStraightLine = false;\n        },\n        /**\n     * @private\n     * @param {Object} pointer Actual mouse position related to the canvas.\n     */ _captureDrawingPath: function(pointer) {\n            var pointerPoint = new fabric.Point(pointer.x, pointer.y);\n            return this._addPoint(pointerPoint);\n        },\n        /**\n     * Draw a smooth path on the topCanvas using quadraticCurveTo\n     * @private\n     * @param {CanvasRenderingContext2D} [ctx]\n     */ _render: function(ctx) {\n            var i, len, p1 = this._points[0], p2 = this._points[1];\n            ctx = ctx || this.canvas.contextTop;\n            this._saveAndTransform(ctx);\n            ctx.beginPath();\n            //if we only have 2 points in the path and they are the same\n            //it means that the user only clicked the canvas without moving the mouse\n            //then we should be drawing a dot. A path isn't drawn between two identical dots\n            //that's why we set them apart a bit\n            if (this._points.length === 2 && p1.x === p2.x && p1.y === p2.y) {\n                var width = this.width / 1000;\n                p1 = new fabric.Point(p1.x, p1.y);\n                p2 = new fabric.Point(p2.x, p2.y);\n                p1.x -= width;\n                p2.x += width;\n            }\n            ctx.moveTo(p1.x, p1.y);\n            for(i = 1, len = this._points.length; i < len; i++){\n                // we pick the point between pi + 1 & pi + 2 as the\n                // end point and p1 as our control point.\n                this._drawSegment(ctx, p1, p2);\n                p1 = this._points[i];\n                p2 = this._points[i + 1];\n            }\n            // Draw last line as a straight line while\n            // we wait for the next point to be able to calculate\n            // the bezier control point\n            ctx.lineTo(p1.x, p1.y);\n            ctx.stroke();\n            ctx.restore();\n        },\n        /**\n     * Converts points to SVG path\n     * @param {Array} points Array of points\n     * @return {(string|number)[][]} SVG path commands\n     */ convertPointsToSVGPath: function(points) {\n            var correction = this.width / 1000;\n            return fabric.util.getSmoothPathFromPoints(points, correction);\n        },\n        /**\n     * @private\n     * @param {(string|number)[][]} pathData SVG path commands\n     * @returns {boolean}\n     */ _isEmptySVGPath: function(pathData) {\n            var pathString = fabric.util.joinPath(pathData);\n            return pathString === \"M 0 0 Q 0 0 0 0 L 0 0\";\n        },\n        /**\n     * Creates fabric.Path object to add on canvas\n     * @param {(string|number)[][]} pathData Path data\n     * @return {fabric.Path} Path to add on canvas\n     */ createPath: function(pathData) {\n            var path = new fabric.Path(pathData, {\n                fill: null,\n                stroke: this.color,\n                strokeWidth: this.width,\n                strokeLineCap: this.strokeLineCap,\n                strokeMiterLimit: this.strokeMiterLimit,\n                strokeLineJoin: this.strokeLineJoin,\n                strokeDashArray: this.strokeDashArray\n            });\n            if (this.shadow) {\n                this.shadow.affectStroke = true;\n                path.shadow = new fabric.Shadow(this.shadow);\n            }\n            return path;\n        },\n        /**\n     * Decimate points array with the decimate value\n     */ decimatePoints: function(points, distance) {\n            if (points.length <= 2) {\n                return points;\n            }\n            var zoom = this.canvas.getZoom(), adjustedDistance = Math.pow(distance / zoom, 2), i, l = points.length - 1, lastPoint = points[0], newPoints = [\n                lastPoint\n            ], cDistance;\n            for(i = 1; i < l - 1; i++){\n                cDistance = Math.pow(lastPoint.x - points[i].x, 2) + Math.pow(lastPoint.y - points[i].y, 2);\n                if (cDistance >= adjustedDistance) {\n                    lastPoint = points[i];\n                    newPoints.push(lastPoint);\n                }\n            }\n            /**\n       * Add the last point from the original line to the end of the array.\n       * This ensures decimate doesn't delete the last point on the line, and ensures the line is > 1 point.\n       */ newPoints.push(points[l]);\n            return newPoints;\n        },\n        /**\n     * On mouseup after drawing the path on contextTop canvas\n     * we use the points captured to create an new fabric path object\n     * and add it to the fabric canvas.\n     */ _finalizeAndAddPath: function() {\n            var ctx = this.canvas.contextTop;\n            ctx.closePath();\n            if (this.decimate) {\n                this._points = this.decimatePoints(this._points, this.decimate);\n            }\n            var pathData = this.convertPointsToSVGPath(this._points);\n            if (this._isEmptySVGPath(pathData)) {\n                // do not create 0 width/height paths, as they are\n                // rendered inconsistently across browsers\n                // Firefox 4, for example, renders a dot,\n                // whereas Chrome 10 renders nothing\n                this.canvas.requestRenderAll();\n                return;\n            }\n            var path = this.createPath(pathData);\n            this.canvas.clearContext(this.canvas.contextTop);\n            this.canvas.fire(\"before:path:created\", {\n                path: path\n            });\n            this.canvas.add(path);\n            this.canvas.requestRenderAll();\n            path.setCoords();\n            this._resetShadow();\n            // fire event 'path' created\n            this.canvas.fire(\"path:created\", {\n                path: path\n            });\n        }\n    });\n})();\n/**\n * CircleBrush class\n * @class fabric.CircleBrush\n */ fabric.CircleBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.CircleBrush.prototype */ {\n    /**\n   * Width of a brush\n   * @type Number\n   * @default\n   */ width: 10,\n    /**\n   * Constructor\n   * @param {fabric.Canvas} canvas\n   * @return {fabric.CircleBrush} Instance of a circle brush\n   */ initialize: function(canvas) {\n        this.canvas = canvas;\n        this.points = [];\n    },\n    /**\n   * Invoked inside on mouse down and mouse move\n   * @param {Object} pointer\n   */ drawDot: function(pointer) {\n        var point = this.addPoint(pointer), ctx = this.canvas.contextTop;\n        this._saveAndTransform(ctx);\n        this.dot(ctx, point);\n        ctx.restore();\n    },\n    dot: function(ctx, point) {\n        ctx.fillStyle = point.fill;\n        ctx.beginPath();\n        ctx.arc(point.x, point.y, point.radius, 0, Math.PI * 2, false);\n        ctx.closePath();\n        ctx.fill();\n    },\n    /**\n   * Invoked on mouse down\n   */ onMouseDown: function(pointer) {\n        this.points.length = 0;\n        this.canvas.clearContext(this.canvas.contextTop);\n        this._setShadow();\n        this.drawDot(pointer);\n    },\n    /**\n   * Render the full state of the brush\n   * @private\n   */ _render: function() {\n        var ctx = this.canvas.contextTop, i, len, points = this.points;\n        this._saveAndTransform(ctx);\n        for(i = 0, len = points.length; i < len; i++){\n            this.dot(ctx, points[i]);\n        }\n        ctx.restore();\n    },\n    /**\n   * Invoked on mouse move\n   * @param {Object} pointer\n   */ onMouseMove: function(pointer) {\n        if (this.limitedToCanvasSize === true && this._isOutSideCanvas(pointer)) {\n            return;\n        }\n        if (this.needsFullRender()) {\n            this.canvas.clearContext(this.canvas.contextTop);\n            this.addPoint(pointer);\n            this._render();\n        } else {\n            this.drawDot(pointer);\n        }\n    },\n    /**\n   * Invoked on mouse up\n   */ onMouseUp: function() {\n        var originalRenderOnAddRemove = this.canvas.renderOnAddRemove, i, len;\n        this.canvas.renderOnAddRemove = false;\n        var circles = [];\n        for(i = 0, len = this.points.length; i < len; i++){\n            var point = this.points[i], circle = new fabric.Circle({\n                radius: point.radius,\n                left: point.x,\n                top: point.y,\n                originX: \"center\",\n                originY: \"center\",\n                fill: point.fill\n            });\n            this.shadow && (circle.shadow = new fabric.Shadow(this.shadow));\n            circles.push(circle);\n        }\n        var group = new fabric.Group(circles);\n        group.canvas = this.canvas;\n        this.canvas.fire(\"before:path:created\", {\n            path: group\n        });\n        this.canvas.add(group);\n        this.canvas.fire(\"path:created\", {\n            path: group\n        });\n        this.canvas.clearContext(this.canvas.contextTop);\n        this._resetShadow();\n        this.canvas.renderOnAddRemove = originalRenderOnAddRemove;\n        this.canvas.requestRenderAll();\n    },\n    /**\n   * @param {Object} pointer\n   * @return {fabric.Point} Just added pointer point\n   */ addPoint: function(pointer) {\n        var pointerPoint = new fabric.Point(pointer.x, pointer.y), circleRadius = fabric.util.getRandomInt(Math.max(0, this.width - 20), this.width + 20) / 2, circleColor = new fabric.Color(this.color).setAlpha(fabric.util.getRandomInt(0, 100) / 100).toRgba();\n        pointerPoint.radius = circleRadius;\n        pointerPoint.fill = circleColor;\n        this.points.push(pointerPoint);\n        return pointerPoint;\n    }\n});\n/**\n * SprayBrush class\n * @class fabric.SprayBrush\n */ fabric.SprayBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.SprayBrush.prototype */ {\n    /**\n   * Width of a spray\n   * @type Number\n   * @default\n   */ width: 10,\n    /**\n   * Density of a spray (number of dots per chunk)\n   * @type Number\n   * @default\n   */ density: 20,\n    /**\n   * Width of spray dots\n   * @type Number\n   * @default\n   */ dotWidth: 1,\n    /**\n   * Width variance of spray dots\n   * @type Number\n   * @default\n   */ dotWidthVariance: 1,\n    /**\n   * Whether opacity of a dot should be random\n   * @type Boolean\n   * @default\n   */ randomOpacity: false,\n    /**\n   * Whether overlapping dots (rectangles) should be removed (for performance reasons)\n   * @type Boolean\n   * @default\n   */ optimizeOverlapping: true,\n    /**\n   * Constructor\n   * @param {fabric.Canvas} canvas\n   * @return {fabric.SprayBrush} Instance of a spray brush\n   */ initialize: function(canvas) {\n        this.canvas = canvas;\n        this.sprayChunks = [];\n    },\n    /**\n   * Invoked on mouse down\n   * @param {Object} pointer\n   */ onMouseDown: function(pointer) {\n        this.sprayChunks.length = 0;\n        this.canvas.clearContext(this.canvas.contextTop);\n        this._setShadow();\n        this.addSprayChunk(pointer);\n        this.render(this.sprayChunkPoints);\n    },\n    /**\n   * Invoked on mouse move\n   * @param {Object} pointer\n   */ onMouseMove: function(pointer) {\n        if (this.limitedToCanvasSize === true && this._isOutSideCanvas(pointer)) {\n            return;\n        }\n        this.addSprayChunk(pointer);\n        this.render(this.sprayChunkPoints);\n    },\n    /**\n   * Invoked on mouse up\n   */ onMouseUp: function() {\n        var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;\n        this.canvas.renderOnAddRemove = false;\n        var rects = [];\n        for(var i = 0, ilen = this.sprayChunks.length; i < ilen; i++){\n            var sprayChunk = this.sprayChunks[i];\n            for(var j = 0, jlen = sprayChunk.length; j < jlen; j++){\n                var rect = new fabric.Rect({\n                    width: sprayChunk[j].width,\n                    height: sprayChunk[j].width,\n                    left: sprayChunk[j].x + 1,\n                    top: sprayChunk[j].y + 1,\n                    originX: \"center\",\n                    originY: \"center\",\n                    fill: this.color\n                });\n                rects.push(rect);\n            }\n        }\n        if (this.optimizeOverlapping) {\n            rects = this._getOptimizedRects(rects);\n        }\n        var group = new fabric.Group(rects);\n        this.shadow && group.set(\"shadow\", new fabric.Shadow(this.shadow));\n        this.canvas.fire(\"before:path:created\", {\n            path: group\n        });\n        this.canvas.add(group);\n        this.canvas.fire(\"path:created\", {\n            path: group\n        });\n        this.canvas.clearContext(this.canvas.contextTop);\n        this._resetShadow();\n        this.canvas.renderOnAddRemove = originalRenderOnAddRemove;\n        this.canvas.requestRenderAll();\n    },\n    /**\n   * @private\n   * @param {Array} rects\n   */ _getOptimizedRects: function(rects) {\n        // avoid creating duplicate rects at the same coordinates\n        var uniqueRects = {}, key, i, len;\n        for(i = 0, len = rects.length; i < len; i++){\n            key = rects[i].left + \"\" + rects[i].top;\n            if (!uniqueRects[key]) {\n                uniqueRects[key] = rects[i];\n            }\n        }\n        var uniqueRectsArray = [];\n        for(key in uniqueRects){\n            uniqueRectsArray.push(uniqueRects[key]);\n        }\n        return uniqueRectsArray;\n    },\n    /**\n   * Render new chunk of spray brush\n   */ render: function(sprayChunk) {\n        var ctx = this.canvas.contextTop, i, len;\n        ctx.fillStyle = this.color;\n        this._saveAndTransform(ctx);\n        for(i = 0, len = sprayChunk.length; i < len; i++){\n            var point = sprayChunk[i];\n            if (typeof point.opacity !== \"undefined\") {\n                ctx.globalAlpha = point.opacity;\n            }\n            ctx.fillRect(point.x, point.y, point.width, point.width);\n        }\n        ctx.restore();\n    },\n    /**\n   * Render all spray chunks\n   */ _render: function() {\n        var ctx = this.canvas.contextTop, i, ilen;\n        ctx.fillStyle = this.color;\n        this._saveAndTransform(ctx);\n        for(i = 0, ilen = this.sprayChunks.length; i < ilen; i++){\n            this.render(this.sprayChunks[i]);\n        }\n        ctx.restore();\n    },\n    /**\n   * @param {Object} pointer\n   */ addSprayChunk: function(pointer) {\n        this.sprayChunkPoints = [];\n        var x, y, width, radius = this.width / 2, i;\n        for(i = 0; i < this.density; i++){\n            x = fabric.util.getRandomInt(pointer.x - radius, pointer.x + radius);\n            y = fabric.util.getRandomInt(pointer.y - radius, pointer.y + radius);\n            if (this.dotWidthVariance) {\n                width = fabric.util.getRandomInt(// bottom clamp width to 1\n                Math.max(1, this.dotWidth - this.dotWidthVariance), this.dotWidth + this.dotWidthVariance);\n            } else {\n                width = this.dotWidth;\n            }\n            var point = new fabric.Point(x, y);\n            point.width = width;\n            if (this.randomOpacity) {\n                point.opacity = fabric.util.getRandomInt(0, 100) / 100;\n            }\n            this.sprayChunkPoints.push(point);\n        }\n        this.sprayChunks.push(this.sprayChunkPoints);\n    }\n});\n/**\n * PatternBrush class\n * @class fabric.PatternBrush\n * @extends fabric.BaseBrush\n */ fabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, /** @lends fabric.PatternBrush.prototype */ {\n    getPatternSrc: function() {\n        var dotWidth = 20, dotDistance = 5, patternCanvas = fabric.util.createCanvasElement(), patternCtx = patternCanvas.getContext(\"2d\");\n        patternCanvas.width = patternCanvas.height = dotWidth + dotDistance;\n        patternCtx.fillStyle = this.color;\n        patternCtx.beginPath();\n        patternCtx.arc(dotWidth / 2, dotWidth / 2, dotWidth / 2, 0, Math.PI * 2, false);\n        patternCtx.closePath();\n        patternCtx.fill();\n        return patternCanvas;\n    },\n    getPatternSrcFunction: function() {\n        return String(this.getPatternSrc).replace(\"this.color\", '\"' + this.color + '\"');\n    },\n    /**\n   * Creates \"pattern\" instance property\n   * @param {CanvasRenderingContext2D} ctx\n   */ getPattern: function(ctx) {\n        return ctx.createPattern(this.source || this.getPatternSrc(), \"repeat\");\n    },\n    /**\n   * Sets brush styles\n   * @param {CanvasRenderingContext2D} ctx\n   */ _setBrushStyles: function(ctx) {\n        this.callSuper(\"_setBrushStyles\", ctx);\n        ctx.strokeStyle = this.getPattern(ctx);\n    },\n    /**\n   * Creates path\n   */ createPath: function(pathData) {\n        var path = this.callSuper(\"createPath\", pathData), topLeft = path._getLeftTopCoords().scalarAdd(path.strokeWidth / 2);\n        path.stroke = new fabric.Pattern({\n            source: this.source || this.getPatternSrcFunction(),\n            offsetX: -topLeft.x,\n            offsetY: -topLeft.y\n        });\n        return path;\n    }\n});\n(function() {\n    var getPointer = fabric.util.getPointer, degreesToRadians = fabric.util.degreesToRadians, isTouchEvent = fabric.util.isTouchEvent;\n    /**\n   * Canvas class\n   * @class fabric.Canvas\n   * @extends fabric.StaticCanvas\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#canvas}\n   * @see {@link fabric.Canvas#initialize} for constructor definition\n   *\n   * @fires object:modified at the end of a transform or any change when statefull is true\n   * @fires object:rotating while an object is being rotated from the control\n   * @fires object:scaling while an object is being scaled by controls\n   * @fires object:moving while an object is being dragged\n   * @fires object:skewing while an object is being skewed from the controls\n   *\n   * @fires before:transform before a transform is is started\n   * @fires before:selection:cleared\n   * @fires selection:cleared\n   * @fires selection:updated\n   * @fires selection:created\n   *\n   * @fires path:created after a drawing operation ends and the path is added\n   * @fires mouse:down\n   * @fires mouse:move\n   * @fires mouse:up\n   * @fires mouse:down:before  on mouse down, before the inner fabric logic runs\n   * @fires mouse:move:before on mouse move, before the inner fabric logic runs\n   * @fires mouse:up:before on mouse up, before the inner fabric logic runs\n   * @fires mouse:over\n   * @fires mouse:out\n   * @fires mouse:dblclick whenever a native dbl click event fires on the canvas.\n   *\n   * @fires dragover\n   * @fires dragenter\n   * @fires dragleave\n   * @fires drop:before before drop event. same native event. This is added to handle edge cases\n   * @fires drop\n   * @fires after:render at the end of the render process, receives the context in the callback\n   * @fires before:render at start the render process, receives the context in the callback\n   *\n   */ fabric.Canvas = fabric.util.createClass(fabric.StaticCanvas, /** @lends fabric.Canvas.prototype */ {\n        /**\n     * Constructor\n     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on\n     * @param {Object} [options] Options object\n     * @return {Object} thisArg\n     */ initialize: function(el, options) {\n            options || (options = {});\n            this.renderAndResetBound = this.renderAndReset.bind(this);\n            this.requestRenderAllBound = this.requestRenderAll.bind(this);\n            this._initStatic(el, options);\n            this._initInteractive();\n            this._createCacheCanvas();\n        },\n        /**\n     * When true, objects can be transformed by one side (unproportionally)\n     * when dragged on the corners that normally would not do that.\n     * @type Boolean\n     * @default\n     * @since fabric 4.0 // changed name and default value\n     */ uniformScaling: true,\n        /**\n     * Indicates which key switches uniform scaling.\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\n     * If `null` or 'none' or any other string that is not a modifier key\n     * feature is disabled.\n     * totally wrong named. this sounds like `uniform scaling`\n     * if Canvas.uniformScaling is true, pressing this will set it to false\n     * and viceversa.\n     * @since 1.6.2\n     * @type String\n     * @default\n     */ uniScaleKey: \"shiftKey\",\n        /**\n     * When true, objects use center point as the origin of scale transformation.\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\n     * @since 1.3.4\n     * @type Boolean\n     * @default\n     */ centeredScaling: false,\n        /**\n     * When true, objects use center point as the origin of rotate transformation.\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\n     * @since 1.3.4\n     * @type Boolean\n     * @default\n     */ centeredRotation: false,\n        /**\n     * Indicates which key enable centered Transform\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\n     * If `null` or 'none' or any other string that is not a modifier key\n     * feature is disabled feature disabled.\n     * @since 1.6.2\n     * @type String\n     * @default\n     */ centeredKey: \"altKey\",\n        /**\n     * Indicates which key enable alternate action on corner\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\n     * If `null` or 'none' or any other string that is not a modifier key\n     * feature is disabled feature disabled.\n     * @since 1.6.2\n     * @type String\n     * @default\n     */ altActionKey: \"shiftKey\",\n        /**\n     * Indicates that canvas is interactive. This property should not be changed.\n     * @type Boolean\n     * @default\n     */ interactive: true,\n        /**\n     * Indicates whether group selection should be enabled\n     * @type Boolean\n     * @default\n     */ selection: true,\n        /**\n     * Indicates which key or keys enable multiple click selection\n     * Pass value as a string or array of strings\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\n     * If `null` or empty or containing any other string that is not a modifier key\n     * feature is disabled.\n     * @since 1.6.2\n     * @type String|Array\n     * @default\n     */ selectionKey: \"shiftKey\",\n        /**\n     * Indicates which key enable alternative selection\n     * in case of target overlapping with active object\n     * values: 'altKey', 'shiftKey', 'ctrlKey'.\n     * For a series of reason that come from the general expectations on how\n     * things should work, this feature works only for preserveObjectStacking true.\n     * If `null` or 'none' or any other string that is not a modifier key\n     * feature is disabled.\n     * @since 1.6.5\n     * @type null|String\n     * @default\n     */ altSelectionKey: null,\n        /**\n     * Color of selection\n     * @type String\n     * @default\n     */ selectionColor: \"rgba(100, 100, 255, 0.3)\",\n        /**\n     * Default dash array pattern\n     * If not empty the selection border is dashed\n     * @type Array\n     */ selectionDashArray: [],\n        /**\n     * Color of the border of selection (usually slightly darker than color of selection itself)\n     * @type String\n     * @default\n     */ selectionBorderColor: \"rgba(255, 255, 255, 0.3)\",\n        /**\n     * Width of a line used in object/group selection\n     * @type Number\n     * @default\n     */ selectionLineWidth: 1,\n        /**\n     * Select only shapes that are fully contained in the dragged selection rectangle.\n     * @type Boolean\n     * @default\n     */ selectionFullyContained: false,\n        /**\n     * Default cursor value used when hovering over an object on canvas\n     * @type String\n     * @default\n     */ hoverCursor: \"move\",\n        /**\n     * Default cursor value used when moving an object on canvas\n     * @type String\n     * @default\n     */ moveCursor: \"move\",\n        /**\n     * Default cursor value used for the entire canvas\n     * @type String\n     * @default\n     */ defaultCursor: \"default\",\n        /**\n     * Cursor value used during free drawing\n     * @type String\n     * @default\n     */ freeDrawingCursor: \"crosshair\",\n        /**\n     * Cursor value used for disabled elements ( corners with disabled action )\n     * @type String\n     * @since 2.0.0\n     * @default\n     */ notAllowedCursor: \"not-allowed\",\n        /**\n     * Default element class that's given to wrapper (div) element of canvas\n     * @type String\n     * @default\n     */ containerClass: \"canvas-container\",\n        /**\n     * When true, object detection happens on per-pixel basis rather than on per-bounding-box\n     * @type Boolean\n     * @default\n     */ perPixelTargetFind: false,\n        /**\n     * Number of pixels around target pixel to tolerate (consider active) during object detection\n     * @type Number\n     * @default\n     */ targetFindTolerance: 0,\n        /**\n     * When true, target detection is skipped. Target detection will return always undefined.\n     * click selection won't work anymore, events will fire with no targets.\n     * if something is selected before setting it to true, it will be deselected at the first click.\n     * area selection will still work. check the `selection` property too.\n     * if you deactivate both, you should look into staticCanvas.\n     * @type Boolean\n     * @default\n     */ skipTargetFind: false,\n        /**\n     * When true, mouse events on canvas (mousedown/mousemove/mouseup) result in free drawing.\n     * After mousedown, mousemove creates a shape,\n     * and then mouseup finalizes it and adds an instance of `fabric.Path` onto canvas.\n     * @tutorial {@link http://fabricjs.com/fabric-intro-part-4#free_drawing}\n     * @type Boolean\n     * @default\n     */ isDrawingMode: false,\n        /**\n     * Indicates whether objects should remain in current stack position when selected.\n     * When false objects are brought to top and rendered as part of the selection group\n     * @type Boolean\n     * @default\n     */ preserveObjectStacking: false,\n        /**\n     * Indicates the angle that an object will lock to while rotating.\n     * @type Number\n     * @since 1.6.7\n     * @default\n     */ snapAngle: 0,\n        /**\n     * Indicates the distance from the snapAngle the rotation will lock to the snapAngle.\n     * When `null`, the snapThreshold will default to the snapAngle.\n     * @type null|Number\n     * @since 1.6.7\n     * @default\n     */ snapThreshold: null,\n        /**\n     * Indicates if the right click on canvas can output the context menu or not\n     * @type Boolean\n     * @since 1.6.5\n     * @default\n     */ stopContextMenu: false,\n        /**\n     * Indicates if the canvas can fire right click events\n     * @type Boolean\n     * @since 1.6.5\n     * @default\n     */ fireRightClick: false,\n        /**\n     * Indicates if the canvas can fire middle click events\n     * @type Boolean\n     * @since 1.7.8\n     * @default\n     */ fireMiddleClick: false,\n        /**\n     * Keep track of the subTargets for Mouse Events\n     * @type fabric.Object[]\n     */ targets: [],\n        /**\n     * When the option is enabled, PointerEvent is used instead of MouseEvent.\n     * @type Boolean\n     * @default\n     */ enablePointerEvents: false,\n        /**\n     * Keep track of the hovered target\n     * @type fabric.Object\n     * @private\n     */ _hoveredTarget: null,\n        /**\n     * hold the list of nested targets hovered\n     * @type fabric.Object[]\n     * @private\n     */ _hoveredTargets: [],\n        /**\n     * @private\n     */ _initInteractive: function() {\n            this._currentTransform = null;\n            this._groupSelector = null;\n            this._initWrapperElement();\n            this._createUpperCanvas();\n            this._initEventListeners();\n            this._initRetinaScaling();\n            this.freeDrawingBrush = fabric.PencilBrush && new fabric.PencilBrush(this);\n            this.calcOffset();\n        },\n        /**\n     * Divides objects in two groups, one to render immediately\n     * and one to render as activeGroup.\n     * @return {Array} objects to render immediately and pushes the other in the activeGroup.\n     */ _chooseObjectsToRender: function() {\n            var activeObjects = this.getActiveObjects(), object, objsToRender, activeGroupObjects;\n            if (activeObjects.length > 0 && !this.preserveObjectStacking) {\n                objsToRender = [];\n                activeGroupObjects = [];\n                for(var i = 0, length = this._objects.length; i < length; i++){\n                    object = this._objects[i];\n                    if (activeObjects.indexOf(object) === -1) {\n                        objsToRender.push(object);\n                    } else {\n                        activeGroupObjects.push(object);\n                    }\n                }\n                if (activeObjects.length > 1) {\n                    this._activeObject._objects = activeGroupObjects;\n                }\n                objsToRender.push.apply(objsToRender, activeGroupObjects);\n            } else {\n                objsToRender = this._objects;\n            }\n            return objsToRender;\n        },\n        /**\n     * Renders both the top canvas and the secondary container canvas.\n     * @return {fabric.Canvas} instance\n     * @chainable\n     */ renderAll: function() {\n            if (this.contextTopDirty && !this._groupSelector && !this.isDrawingMode) {\n                this.clearContext(this.contextTop);\n                this.contextTopDirty = false;\n            }\n            if (this.hasLostContext) {\n                this.renderTopLayer(this.contextTop);\n                this.hasLostContext = false;\n            }\n            var canvasToDrawOn = this.contextContainer;\n            this.renderCanvas(canvasToDrawOn, this._chooseObjectsToRender());\n            return this;\n        },\n        renderTopLayer: function(ctx) {\n            ctx.save();\n            if (this.isDrawingMode && this._isCurrentlyDrawing) {\n                this.freeDrawingBrush && this.freeDrawingBrush._render();\n                this.contextTopDirty = true;\n            }\n            // we render the top context - last object\n            if (this.selection && this._groupSelector) {\n                this._drawSelection(ctx);\n                this.contextTopDirty = true;\n            }\n            ctx.restore();\n        },\n        /**\n     * Method to render only the top canvas.\n     * Also used to render the group selection box.\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ renderTop: function() {\n            var ctx = this.contextTop;\n            this.clearContext(ctx);\n            this.renderTopLayer(ctx);\n            this.fire(\"after:render\");\n            return this;\n        },\n        /**\n     * @private\n     */ _normalizePointer: function(object, pointer) {\n            var m = object.calcTransformMatrix(), invertedM = fabric.util.invertTransform(m), vptPointer = this.restorePointerVpt(pointer);\n            return fabric.util.transformPoint(vptPointer, invertedM);\n        },\n        /**\n     * Returns true if object is transparent at a certain location\n     * @param {fabric.Object} target Object to check\n     * @param {Number} x Left coordinate\n     * @param {Number} y Top coordinate\n     * @return {Boolean}\n     */ isTargetTransparent: function(target, x, y) {\n            // in case the target is the activeObject, we cannot execute this optimization\n            // because we need to draw controls too.\n            if (target.shouldCache() && target._cacheCanvas && target !== this._activeObject) {\n                var normalizedPointer = this._normalizePointer(target, {\n                    x: x,\n                    y: y\n                }), targetRelativeX = Math.max(target.cacheTranslationX + normalizedPointer.x * target.zoomX, 0), targetRelativeY = Math.max(target.cacheTranslationY + normalizedPointer.y * target.zoomY, 0);\n                var isTransparent = fabric.util.isTransparent(target._cacheContext, Math.round(targetRelativeX), Math.round(targetRelativeY), this.targetFindTolerance);\n                return isTransparent;\n            }\n            var ctx = this.contextCache, originalColor = target.selectionBackgroundColor, v = this.viewportTransform;\n            target.selectionBackgroundColor = \"\";\n            this.clearContext(ctx);\n            ctx.save();\n            ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n            target.render(ctx);\n            ctx.restore();\n            target.selectionBackgroundColor = originalColor;\n            var isTransparent = fabric.util.isTransparent(ctx, x, y, this.targetFindTolerance);\n            return isTransparent;\n        },\n        /**\n     * takes an event and determines if selection key has been pressed\n     * @private\n     * @param {Event} e Event object\n     */ _isSelectionKeyPressed: function(e) {\n            var selectionKeyPressed = false;\n            if (Array.isArray(this.selectionKey)) {\n                selectionKeyPressed = !!this.selectionKey.find(function(key) {\n                    return e[key] === true;\n                });\n            } else {\n                selectionKeyPressed = e[this.selectionKey];\n            }\n            return selectionKeyPressed;\n        },\n        /**\n     * @private\n     * @param {Event} e Event object\n     * @param {fabric.Object} target\n     */ _shouldClearSelection: function(e, target) {\n            var activeObjects = this.getActiveObjects(), activeObject = this._activeObject;\n            return !target || target && activeObject && activeObjects.length > 1 && activeObjects.indexOf(target) === -1 && activeObject !== target && !this._isSelectionKeyPressed(e) || target && !target.evented || target && !target.selectable && activeObject && activeObject !== target;\n        },\n        /**\n     * centeredScaling from object can't override centeredScaling from canvas.\n     * this should be fixed, since object setting should take precedence over canvas.\n     * also this should be something that will be migrated in the control properties.\n     * as ability to define the origin of the transformation that the control provide.\n     * @private\n     * @param {fabric.Object} target\n     * @param {String} action\n     * @param {Boolean} altKey\n     */ _shouldCenterTransform: function(target, action, altKey) {\n            if (!target) {\n                return;\n            }\n            var centerTransform;\n            if (action === \"scale\" || action === \"scaleX\" || action === \"scaleY\" || action === \"resizing\") {\n                centerTransform = this.centeredScaling || target.centeredScaling;\n            } else if (action === \"rotate\") {\n                centerTransform = this.centeredRotation || target.centeredRotation;\n            }\n            return centerTransform ? !altKey : altKey;\n        },\n        /**\n     * should disappear before release 4.0\n     * @private\n     */ _getOriginFromCorner: function(target, corner) {\n            var origin = {\n                x: target.originX,\n                y: target.originY\n            };\n            if (corner === \"ml\" || corner === \"tl\" || corner === \"bl\") {\n                origin.x = \"right\";\n            } else if (corner === \"mr\" || corner === \"tr\" || corner === \"br\") {\n                origin.x = \"left\";\n            }\n            if (corner === \"tl\" || corner === \"mt\" || corner === \"tr\") {\n                origin.y = \"bottom\";\n            } else if (corner === \"bl\" || corner === \"mb\" || corner === \"br\") {\n                origin.y = \"top\";\n            }\n            return origin;\n        },\n        /**\n     * @private\n     * @param {Boolean} alreadySelected true if target is already selected\n     * @param {String} corner a string representing the corner ml, mr, tl ...\n     * @param {Event} e Event object\n     * @param {fabric.Object} [target] inserted back to help overriding. Unused\n     */ _getActionFromCorner: function(alreadySelected, corner, e, target) {\n            if (!corner || !alreadySelected) {\n                return \"drag\";\n            }\n            var control = target.controls[corner];\n            return control.getActionName(e, control, target);\n        },\n        /**\n     * @private\n     * @param {Event} e Event object\n     * @param {fabric.Object} target\n     */ _setupCurrentTransform: function(e, target, alreadySelected) {\n            if (!target) {\n                return;\n            }\n            var pointer = this.getPointer(e), corner = target.__corner, control = target.controls[corner], actionHandler = alreadySelected && corner ? control.getActionHandler(e, target, control) : fabric.controlsUtils.dragHandler, action = this._getActionFromCorner(alreadySelected, corner, e, target), origin = this._getOriginFromCorner(target, corner), altKey = e[this.centeredKey], transform = {\n                target: target,\n                action: action,\n                actionHandler: actionHandler,\n                corner: corner,\n                scaleX: target.scaleX,\n                scaleY: target.scaleY,\n                skewX: target.skewX,\n                skewY: target.skewY,\n                // used by transation\n                offsetX: pointer.x - target.left,\n                offsetY: pointer.y - target.top,\n                originX: origin.x,\n                originY: origin.y,\n                ex: pointer.x,\n                ey: pointer.y,\n                lastX: pointer.x,\n                lastY: pointer.y,\n                // unsure they are useful anymore.\n                // left: target.left,\n                // top: target.top,\n                theta: degreesToRadians(target.angle),\n                // end of unsure\n                width: target.width * target.scaleX,\n                shiftKey: e.shiftKey,\n                altKey: altKey,\n                original: fabric.util.saveObjectTransform(target)\n            };\n            if (this._shouldCenterTransform(target, action, altKey)) {\n                transform.originX = \"center\";\n                transform.originY = \"center\";\n            }\n            transform.original.originX = origin.x;\n            transform.original.originY = origin.y;\n            this._currentTransform = transform;\n            this._beforeTransform(e);\n        },\n        /**\n     * Set the cursor type of the canvas element\n     * @param {String} value Cursor type of the canvas element.\n     * @see http://www.w3.org/TR/css3-ui/#cursor\n     */ setCursor: function(value) {\n            this.upperCanvasEl.style.cursor = value;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx to draw the selection on\n     */ _drawSelection: function(ctx) {\n            var selector = this._groupSelector, viewportStart = new fabric.Point(selector.ex, selector.ey), start = fabric.util.transformPoint(viewportStart, this.viewportTransform), viewportExtent = new fabric.Point(selector.ex + selector.left, selector.ey + selector.top), extent = fabric.util.transformPoint(viewportExtent, this.viewportTransform), minX = Math.min(start.x, extent.x), minY = Math.min(start.y, extent.y), maxX = Math.max(start.x, extent.x), maxY = Math.max(start.y, extent.y), strokeOffset = this.selectionLineWidth / 2;\n            if (this.selectionColor) {\n                ctx.fillStyle = this.selectionColor;\n                ctx.fillRect(minX, minY, maxX - minX, maxY - minY);\n            }\n            if (!this.selectionLineWidth || !this.selectionBorderColor) {\n                return;\n            }\n            ctx.lineWidth = this.selectionLineWidth;\n            ctx.strokeStyle = this.selectionBorderColor;\n            minX += strokeOffset;\n            minY += strokeOffset;\n            maxX -= strokeOffset;\n            maxY -= strokeOffset;\n            // selection border\n            fabric.Object.prototype._setLineDash.call(this, ctx, this.selectionDashArray);\n            ctx.strokeRect(minX, minY, maxX - minX, maxY - minY);\n        },\n        /**\n     * Method that determines what object we are clicking on\n     * the skipGroup parameter is for internal use, is needed for shift+click action\n     * 11/09/2018 TODO: would be cool if findTarget could discern between being a full target\n     * or the outside part of the corner.\n     * @param {Event} e mouse event\n     * @param {Boolean} skipGroup when true, activeGroup is skipped and only objects are traversed through\n     * @return {fabric.Object} the target found\n     */ findTarget: function(e, skipGroup) {\n            if (this.skipTargetFind) {\n                return;\n            }\n            var ignoreZoom = true, pointer = this.getPointer(e, ignoreZoom), activeObject = this._activeObject, aObjects = this.getActiveObjects(), activeTarget, activeTargetSubs, isTouch = isTouchEvent(e), shouldLookForActive = aObjects.length > 1 && !skipGroup || aObjects.length === 1;\n            // first check current group (if one exists)\n            // active group does not check sub targets like normal groups.\n            // if active group just exits.\n            this.targets = [];\n            // if we hit the corner of an activeObject, let's return that.\n            if (shouldLookForActive && activeObject._findTargetCorner(pointer, isTouch)) {\n                return activeObject;\n            }\n            if (aObjects.length > 1 && !skipGroup && activeObject === this._searchPossibleTargets([\n                activeObject\n            ], pointer)) {\n                return activeObject;\n            }\n            if (aObjects.length === 1 && activeObject === this._searchPossibleTargets([\n                activeObject\n            ], pointer)) {\n                if (!this.preserveObjectStacking) {\n                    return activeObject;\n                } else {\n                    activeTarget = activeObject;\n                    activeTargetSubs = this.targets;\n                    this.targets = [];\n                }\n            }\n            var target = this._searchPossibleTargets(this._objects, pointer);\n            if (e[this.altSelectionKey] && target && activeTarget && target !== activeTarget) {\n                target = activeTarget;\n                this.targets = activeTargetSubs;\n            }\n            return target;\n        },\n        /**\n     * Checks point is inside the object.\n     * @param {Object} [pointer] x,y object of point coordinates we want to check.\n     * @param {fabric.Object} obj Object to test against\n     * @param {Object} [globalPointer] x,y object of point coordinates relative to canvas used to search per pixel target.\n     * @return {Boolean} true if point is contained within an area of given object\n     * @private\n     */ _checkTarget: function(pointer, obj, globalPointer) {\n            if (obj && obj.visible && obj.evented && // http://www.geog.ubc.ca/courses/klink/gis.notes/ncgia/u32.html\n            // http://idav.ucdavis.edu/~okreylos/TAship/Spring2000/PointInPolygon.html\n            obj.containsPoint(pointer)) {\n                if ((this.perPixelTargetFind || obj.perPixelTargetFind) && !obj.isEditing) {\n                    var isTransparent = this.isTargetTransparent(obj, globalPointer.x, globalPointer.y);\n                    if (!isTransparent) {\n                        return true;\n                    }\n                } else {\n                    return true;\n                }\n            }\n        },\n        /**\n     * Function used to search inside objects an object that contains pointer in bounding box or that contains pointerOnCanvas when painted\n     * @param {Array} [objects] objects array to look into\n     * @param {Object} [pointer] x,y object of point coordinates we want to check.\n     * @return {fabric.Object} object that contains pointer\n     * @private\n     */ _searchPossibleTargets: function(objects, pointer) {\n            // Cache all targets where their bounding box contains point.\n            var target, i = objects.length, subTarget;\n            // Do not check for currently grouped objects, since we check the parent group itself.\n            // until we call this function specifically to search inside the activeGroup\n            while(i--){\n                var objToCheck = objects[i];\n                var pointerToUse = objToCheck.group ? this._normalizePointer(objToCheck.group, pointer) : pointer;\n                if (this._checkTarget(pointerToUse, objToCheck, pointer)) {\n                    target = objects[i];\n                    if (target.subTargetCheck && target instanceof fabric.Group) {\n                        subTarget = this._searchPossibleTargets(target._objects, pointer);\n                        subTarget && this.targets.push(subTarget);\n                    }\n                    break;\n                }\n            }\n            return target;\n        },\n        /**\n     * Returns pointer coordinates without the effect of the viewport\n     * @param {Object} pointer with \"x\" and \"y\" number values\n     * @return {Object} object with \"x\" and \"y\" number values\n     */ restorePointerVpt: function(pointer) {\n            return fabric.util.transformPoint(pointer, fabric.util.invertTransform(this.viewportTransform));\n        },\n        /**\n     * Returns pointer coordinates relative to canvas.\n     * Can return coordinates with or without viewportTransform.\n     * ignoreZoom false gives back coordinates that represent\n     * the point clicked on canvas element.\n     * ignoreZoom true gives back coordinates after being processed\n     * by the viewportTransform ( sort of coordinates of what is displayed\n     * on the canvas where you are clicking.\n     * ignoreZoom true = HTMLElement coordinates relative to top,left\n     * ignoreZoom false, default = fabric space coordinates, the same used for shape position\n     * To interact with your shapes top and left you want to use ignoreZoom true\n     * most of the time, while ignoreZoom false will give you coordinates\n     * compatible with the object.oCoords system.\n     * of the time.\n     * @param {Event} e\n     * @param {Boolean} ignoreZoom\n     * @return {Object} object with \"x\" and \"y\" number values\n     */ getPointer: function(e, ignoreZoom) {\n            // return cached values if we are in the event processing chain\n            if (this._absolutePointer && !ignoreZoom) {\n                return this._absolutePointer;\n            }\n            if (this._pointer && ignoreZoom) {\n                return this._pointer;\n            }\n            var pointer = getPointer(e), upperCanvasEl = this.upperCanvasEl, bounds = upperCanvasEl.getBoundingClientRect(), boundsWidth = bounds.width || 0, boundsHeight = bounds.height || 0, cssScale;\n            if (!boundsWidth || !boundsHeight) {\n                if (\"top\" in bounds && \"bottom\" in bounds) {\n                    boundsHeight = Math.abs(bounds.top - bounds.bottom);\n                }\n                if (\"right\" in bounds && \"left\" in bounds) {\n                    boundsWidth = Math.abs(bounds.right - bounds.left);\n                }\n            }\n            this.calcOffset();\n            pointer.x = pointer.x - this._offset.left;\n            pointer.y = pointer.y - this._offset.top;\n            if (!ignoreZoom) {\n                pointer = this.restorePointerVpt(pointer);\n            }\n            var retinaScaling = this.getRetinaScaling();\n            if (retinaScaling !== 1) {\n                pointer.x /= retinaScaling;\n                pointer.y /= retinaScaling;\n            }\n            if (boundsWidth === 0 || boundsHeight === 0) {\n                // If bounds are not available (i.e. not visible), do not apply scale.\n                cssScale = {\n                    width: 1,\n                    height: 1\n                };\n            } else {\n                cssScale = {\n                    width: upperCanvasEl.width / boundsWidth,\n                    height: upperCanvasEl.height / boundsHeight\n                };\n            }\n            return {\n                x: pointer.x * cssScale.width,\n                y: pointer.y * cssScale.height\n            };\n        },\n        /**\n     * @private\n     * @throws {CANVAS_INIT_ERROR} If canvas can not be initialized\n     */ _createUpperCanvas: function() {\n            var lowerCanvasClass = this.lowerCanvasEl.className.replace(/\\s*lower-canvas\\s*/, \"\"), lowerCanvasEl = this.lowerCanvasEl, upperCanvasEl = this.upperCanvasEl;\n            // there is no need to create a new upperCanvas element if we have already one.\n            if (upperCanvasEl) {\n                upperCanvasEl.className = \"\";\n            } else {\n                upperCanvasEl = this._createCanvasElement();\n                this.upperCanvasEl = upperCanvasEl;\n            }\n            fabric.util.addClass(upperCanvasEl, \"upper-canvas \" + lowerCanvasClass);\n            this.wrapperEl.appendChild(upperCanvasEl);\n            this._copyCanvasStyle(lowerCanvasEl, upperCanvasEl);\n            this._applyCanvasStyle(upperCanvasEl);\n            this.contextTop = upperCanvasEl.getContext(\"2d\");\n        },\n        /**\n     * Returns context of top canvas where interactions are drawn\n     * @returns {CanvasRenderingContext2D}\n     */ getTopContext: function() {\n            return this.contextTop;\n        },\n        /**\n     * @private\n     */ _createCacheCanvas: function() {\n            this.cacheCanvasEl = this._createCanvasElement();\n            this.cacheCanvasEl.setAttribute(\"width\", this.width);\n            this.cacheCanvasEl.setAttribute(\"height\", this.height);\n            this.contextCache = this.cacheCanvasEl.getContext(\"2d\");\n        },\n        /**\n     * @private\n     */ _initWrapperElement: function() {\n            this.wrapperEl = fabric.util.wrapElement(this.lowerCanvasEl, \"div\", {\n                \"class\": this.containerClass\n            });\n            fabric.util.setStyle(this.wrapperEl, {\n                width: this.width + \"px\",\n                height: this.height + \"px\",\n                position: \"relative\"\n            });\n            fabric.util.makeElementUnselectable(this.wrapperEl);\n        },\n        /**\n     * @private\n     * @param {HTMLElement} element canvas element to apply styles on\n     */ _applyCanvasStyle: function(element) {\n            var width = this.width || element.width, height = this.height || element.height;\n            fabric.util.setStyle(element, {\n                position: \"absolute\",\n                width: width + \"px\",\n                height: height + \"px\",\n                left: 0,\n                top: 0,\n                \"touch-action\": this.allowTouchScrolling ? \"manipulation\" : \"none\",\n                \"-ms-touch-action\": this.allowTouchScrolling ? \"manipulation\" : \"none\"\n            });\n            element.width = width;\n            element.height = height;\n            fabric.util.makeElementUnselectable(element);\n        },\n        /**\n     * Copy the entire inline style from one element (fromEl) to another (toEl)\n     * @private\n     * @param {Element} fromEl Element style is copied from\n     * @param {Element} toEl Element copied style is applied to\n     */ _copyCanvasStyle: function(fromEl, toEl) {\n            toEl.style.cssText = fromEl.style.cssText;\n        },\n        /**\n     * Returns context of canvas where object selection is drawn\n     * @return {CanvasRenderingContext2D}\n     */ getSelectionContext: function() {\n            return this.contextTop;\n        },\n        /**\n     * Returns &lt;canvas> element on which object selection is drawn\n     * @return {HTMLCanvasElement}\n     */ getSelectionElement: function() {\n            return this.upperCanvasEl;\n        },\n        /**\n     * Returns currently active object\n     * @return {fabric.Object} active object\n     */ getActiveObject: function() {\n            return this._activeObject;\n        },\n        /**\n     * Returns an array with the current selected objects\n     * @return {fabric.Object} active object\n     */ getActiveObjects: function() {\n            var active = this._activeObject;\n            if (active) {\n                if (active.type === \"activeSelection\" && active._objects) {\n                    return active._objects.slice(0);\n                } else {\n                    return [\n                        active\n                    ];\n                }\n            }\n            return [];\n        },\n        /**\n     * @private\n     * @param {fabric.Object} obj Object that was removed\n     */ _onObjectRemoved: function(obj) {\n            // removing active object should fire \"selection:cleared\" events\n            if (obj === this._activeObject) {\n                this.fire(\"before:selection:cleared\", {\n                    target: obj\n                });\n                this._discardActiveObject();\n                this.fire(\"selection:cleared\", {\n                    target: obj\n                });\n                obj.fire(\"deselected\");\n            }\n            if (obj === this._hoveredTarget) {\n                this._hoveredTarget = null;\n                this._hoveredTargets = [];\n            }\n            this.callSuper(\"_onObjectRemoved\", obj);\n        },\n        /**\n     * @private\n     * Compares the old activeObject with the current one and fires correct events\n     * @param {fabric.Object} obj old activeObject\n     */ _fireSelectionEvents: function(oldObjects, e) {\n            var somethingChanged = false, objects = this.getActiveObjects(), added = [], removed = [];\n            oldObjects.forEach(function(oldObject) {\n                if (objects.indexOf(oldObject) === -1) {\n                    somethingChanged = true;\n                    oldObject.fire(\"deselected\", {\n                        e: e,\n                        target: oldObject\n                    });\n                    removed.push(oldObject);\n                }\n            });\n            objects.forEach(function(object) {\n                if (oldObjects.indexOf(object) === -1) {\n                    somethingChanged = true;\n                    object.fire(\"selected\", {\n                        e: e,\n                        target: object\n                    });\n                    added.push(object);\n                }\n            });\n            if (oldObjects.length > 0 && objects.length > 0) {\n                somethingChanged && this.fire(\"selection:updated\", {\n                    e: e,\n                    selected: added,\n                    deselected: removed\n                });\n            } else if (objects.length > 0) {\n                this.fire(\"selection:created\", {\n                    e: e,\n                    selected: added\n                });\n            } else if (oldObjects.length > 0) {\n                this.fire(\"selection:cleared\", {\n                    e: e,\n                    deselected: removed\n                });\n            }\n        },\n        /**\n     * Sets given object as the only active object on canvas\n     * @param {fabric.Object} object Object to set as an active one\n     * @param {Event} [e] Event (passed along when firing \"object:selected\")\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ setActiveObject: function(object, e) {\n            var currentActives = this.getActiveObjects();\n            this._setActiveObject(object, e);\n            this._fireSelectionEvents(currentActives, e);\n            return this;\n        },\n        /**\n     * This is a private method for now.\n     * This is supposed to be equivalent to setActiveObject but without firing\n     * any event. There is commitment to have this stay this way.\n     * This is the functional part of setActiveObject.\n     * @private\n     * @param {Object} object to set as active\n     * @param {Event} [e] Event (passed along when firing \"object:selected\")\n     * @return {Boolean} true if the selection happened\n     */ _setActiveObject: function(object, e) {\n            if (this._activeObject === object) {\n                return false;\n            }\n            if (!this._discardActiveObject(e, object)) {\n                return false;\n            }\n            if (object.onSelect({\n                e: e\n            })) {\n                return false;\n            }\n            this._activeObject = object;\n            return true;\n        },\n        /**\n     * This is a private method for now.\n     * This is supposed to be equivalent to discardActiveObject but without firing\n     * any events. There is commitment to have this stay this way.\n     * This is the functional part of discardActiveObject.\n     * @param {Event} [e] Event (passed along when firing \"object:deselected\")\n     * @param {Object} object to set as active\n     * @return {Boolean} true if the selection happened\n     * @private\n     */ _discardActiveObject: function(e, object) {\n            var obj = this._activeObject;\n            if (obj) {\n                // onDeselect return TRUE to cancel selection;\n                if (obj.onDeselect({\n                    e: e,\n                    object: object\n                })) {\n                    return false;\n                }\n                this._activeObject = null;\n            }\n            return true;\n        },\n        /**\n     * Discards currently active object and fire events. If the function is called by fabric\n     * as a consequence of a mouse event, the event is passed as a parameter and\n     * sent to the fire function for the custom events. When used as a method the\n     * e param does not have any application.\n     * @param {event} e\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ discardActiveObject: function(e) {\n            var currentActives = this.getActiveObjects(), activeObject = this.getActiveObject();\n            if (currentActives.length) {\n                this.fire(\"before:selection:cleared\", {\n                    target: activeObject,\n                    e: e\n                });\n            }\n            this._discardActiveObject(e);\n            this._fireSelectionEvents(currentActives, e);\n            return this;\n        },\n        /**\n     * Clears a canvas element and removes all event listeners\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ dispose: function() {\n            var wrapper = this.wrapperEl;\n            this.removeListeners();\n            wrapper.removeChild(this.upperCanvasEl);\n            wrapper.removeChild(this.lowerCanvasEl);\n            this.contextCache = null;\n            this.contextTop = null;\n            [\n                \"upperCanvasEl\",\n                \"cacheCanvasEl\"\n            ].forEach((function(element) {\n                fabric.util.cleanUpJsdomNode(this[element]);\n                this[element] = undefined;\n            }).bind(this));\n            if (wrapper.parentNode) {\n                wrapper.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl);\n            }\n            delete this.wrapperEl;\n            fabric.StaticCanvas.prototype.dispose.call(this);\n            return this;\n        },\n        /**\n     * Clears all contexts (background, main, top) of an instance\n     * @return {fabric.Canvas} thisArg\n     * @chainable\n     */ clear: function() {\n            // this.discardActiveGroup();\n            this.discardActiveObject();\n            this.clearContext(this.contextTop);\n            return this.callSuper(\"clear\");\n        },\n        /**\n     * Draws objects' controls (borders/controls)\n     * @param {CanvasRenderingContext2D} ctx Context to render controls on\n     */ drawControls: function(ctx) {\n            var activeObject = this._activeObject;\n            if (activeObject) {\n                activeObject._renderControls(ctx);\n            }\n        },\n        /**\n     * @private\n     */ _toObject: function(instance, methodName, propertiesToInclude) {\n            //If the object is part of the current selection group, it should\n            //be transformed appropriately\n            //i.e. it should be serialised as it would appear if the selection group\n            //were to be destroyed.\n            var originalProperties = this._realizeGroupTransformOnObject(instance), object = this.callSuper(\"_toObject\", instance, methodName, propertiesToInclude);\n            //Undo the damage we did by changing all of its properties\n            this._unwindGroupTransformOnObject(instance, originalProperties);\n            return object;\n        },\n        /**\n     * Realises an object's group transformation on it\n     * @private\n     * @param {fabric.Object} [instance] the object to transform (gets mutated)\n     * @returns the original values of instance which were changed\n     */ _realizeGroupTransformOnObject: function(instance) {\n            if (instance.group && instance.group.type === \"activeSelection\" && this._activeObject === instance.group) {\n                var layoutProps = [\n                    \"angle\",\n                    \"flipX\",\n                    \"flipY\",\n                    \"left\",\n                    \"scaleX\",\n                    \"scaleY\",\n                    \"skewX\",\n                    \"skewY\",\n                    \"top\"\n                ];\n                //Copy all the positionally relevant properties across now\n                var originalValues = {};\n                layoutProps.forEach(function(prop) {\n                    originalValues[prop] = instance[prop];\n                });\n                fabric.util.addTransformToObject(instance, this._activeObject.calcOwnMatrix());\n                return originalValues;\n            } else {\n                return null;\n            }\n        },\n        /**\n     * Restores the changed properties of instance\n     * @private\n     * @param {fabric.Object} [instance] the object to un-transform (gets mutated)\n     * @param {Object} [originalValues] the original values of instance, as returned by _realizeGroupTransformOnObject\n     */ _unwindGroupTransformOnObject: function(instance, originalValues) {\n            if (originalValues) {\n                instance.set(originalValues);\n            }\n        },\n        /**\n     * @private\n     */ _setSVGObject: function(markup, instance, reviver) {\n            //If the object is in a selection group, simulate what would happen to that\n            //object when the group is deselected\n            var originalProperties = this._realizeGroupTransformOnObject(instance);\n            this.callSuper(\"_setSVGObject\", markup, instance, reviver);\n            this._unwindGroupTransformOnObject(instance, originalProperties);\n        },\n        setViewportTransform: function(vpt) {\n            if (this.renderOnAddRemove && this._activeObject && this._activeObject.isEditing) {\n                this._activeObject.clearContextTop();\n            }\n            fabric.StaticCanvas.prototype.setViewportTransform.call(this, vpt);\n        }\n    });\n    // copying static properties manually to work around Opera's bug,\n    // where \"prototype\" property is enumerable and overrides existing prototype\n    for(var prop in fabric.StaticCanvas){\n        if (prop !== \"prototype\") {\n            fabric.Canvas[prop] = fabric.StaticCanvas[prop];\n        }\n    }\n})();\n(function() {\n    var addListener = fabric.util.addListener, removeListener = fabric.util.removeListener, RIGHT_CLICK = 3, MIDDLE_CLICK = 2, LEFT_CLICK = 1, addEventOptions = {\n        passive: false\n    };\n    function checkClick(e, value) {\n        return e.button && e.button === value - 1;\n    }\n    fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {\n        /**\n     * Contains the id of the touch event that owns the fabric transform\n     * @type Number\n     * @private\n     */ mainTouchId: null,\n        /**\n     * Adds mouse listeners to canvas\n     * @private\n     */ _initEventListeners: function() {\n            // in case we initialized the class twice. This should not happen normally\n            // but in some kind of applications where the canvas element may be changed\n            // this is a workaround to having double listeners.\n            this.removeListeners();\n            this._bindEvents();\n            this.addOrRemove(addListener, \"add\");\n        },\n        /**\n     * return an event prefix pointer or mouse.\n     * @private\n     */ _getEventPrefix: function() {\n            return this.enablePointerEvents ? \"pointer\" : \"mouse\";\n        },\n        addOrRemove: function(functor, eventjsFunctor) {\n            var canvasElement = this.upperCanvasEl, eventTypePrefix = this._getEventPrefix();\n            functor(fabric.window, \"resize\", this._onResize);\n            functor(canvasElement, eventTypePrefix + \"down\", this._onMouseDown);\n            functor(canvasElement, eventTypePrefix + \"move\", this._onMouseMove, addEventOptions);\n            functor(canvasElement, eventTypePrefix + \"out\", this._onMouseOut);\n            functor(canvasElement, eventTypePrefix + \"enter\", this._onMouseEnter);\n            functor(canvasElement, \"wheel\", this._onMouseWheel);\n            functor(canvasElement, \"contextmenu\", this._onContextMenu);\n            functor(canvasElement, \"dblclick\", this._onDoubleClick);\n            functor(canvasElement, \"dragover\", this._onDragOver);\n            functor(canvasElement, \"dragenter\", this._onDragEnter);\n            functor(canvasElement, \"dragleave\", this._onDragLeave);\n            functor(canvasElement, \"drop\", this._onDrop);\n            if (!this.enablePointerEvents) {\n                functor(canvasElement, \"touchstart\", this._onTouchStart, addEventOptions);\n            }\n            if (typeof eventjs !== \"undefined\" && eventjsFunctor in eventjs) {\n                eventjs[eventjsFunctor](canvasElement, \"gesture\", this._onGesture);\n                eventjs[eventjsFunctor](canvasElement, \"drag\", this._onDrag);\n                eventjs[eventjsFunctor](canvasElement, \"orientation\", this._onOrientationChange);\n                eventjs[eventjsFunctor](canvasElement, \"shake\", this._onShake);\n                eventjs[eventjsFunctor](canvasElement, \"longpress\", this._onLongPress);\n            }\n        },\n        /**\n     * Removes all event listeners\n     */ removeListeners: function() {\n            this.addOrRemove(removeListener, \"remove\");\n            // if you dispose on a mouseDown, before mouse up, you need to clean document to...\n            var eventTypePrefix = this._getEventPrefix();\n            removeListener(fabric.document, eventTypePrefix + \"up\", this._onMouseUp);\n            removeListener(fabric.document, \"touchend\", this._onTouchEnd, addEventOptions);\n            removeListener(fabric.document, eventTypePrefix + \"move\", this._onMouseMove, addEventOptions);\n            removeListener(fabric.document, \"touchmove\", this._onMouseMove, addEventOptions);\n        },\n        /**\n     * @private\n     */ _bindEvents: function() {\n            if (this.eventsBound) {\n                // for any reason we pass here twice we do not want to bind events twice.\n                return;\n            }\n            this._onMouseDown = this._onMouseDown.bind(this);\n            this._onTouchStart = this._onTouchStart.bind(this);\n            this._onMouseMove = this._onMouseMove.bind(this);\n            this._onMouseUp = this._onMouseUp.bind(this);\n            this._onTouchEnd = this._onTouchEnd.bind(this);\n            this._onResize = this._onResize.bind(this);\n            this._onGesture = this._onGesture.bind(this);\n            this._onDrag = this._onDrag.bind(this);\n            this._onShake = this._onShake.bind(this);\n            this._onLongPress = this._onLongPress.bind(this);\n            this._onOrientationChange = this._onOrientationChange.bind(this);\n            this._onMouseWheel = this._onMouseWheel.bind(this);\n            this._onMouseOut = this._onMouseOut.bind(this);\n            this._onMouseEnter = this._onMouseEnter.bind(this);\n            this._onContextMenu = this._onContextMenu.bind(this);\n            this._onDoubleClick = this._onDoubleClick.bind(this);\n            this._onDragOver = this._onDragOver.bind(this);\n            this._onDragEnter = this._simpleEventHandler.bind(this, \"dragenter\");\n            this._onDragLeave = this._simpleEventHandler.bind(this, \"dragleave\");\n            this._onDrop = this._onDrop.bind(this);\n            this.eventsBound = true;\n        },\n        /**\n     * @private\n     * @param {Event} [e] Event object fired on Event.js gesture\n     * @param {Event} [self] Inner Event object\n     */ _onGesture: function(e, self) {\n            this.__onTransformGesture && this.__onTransformGesture(e, self);\n        },\n        /**\n     * @private\n     * @param {Event} [e] Event object fired on Event.js drag\n     * @param {Event} [self] Inner Event object\n     */ _onDrag: function(e, self) {\n            this.__onDrag && this.__onDrag(e, self);\n        },\n        /**\n     * @private\n     * @param {Event} [e] Event object fired on wheel event\n     */ _onMouseWheel: function(e) {\n            this.__onMouseWheel(e);\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onMouseOut: function(e) {\n            var target = this._hoveredTarget;\n            this.fire(\"mouse:out\", {\n                target: target,\n                e: e\n            });\n            this._hoveredTarget = null;\n            target && target.fire(\"mouseout\", {\n                e: e\n            });\n            var _this = this;\n            this._hoveredTargets.forEach(function(_target) {\n                _this.fire(\"mouse:out\", {\n                    target: _target,\n                    e: e\n                });\n                _target && _target.fire(\"mouseout\", {\n                    e: e\n                });\n            });\n            this._hoveredTargets = [];\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mouseenter\n     */ _onMouseEnter: function(e) {\n            // This find target and consequent 'mouse:over' is used to\n            // clear old instances on hovered target.\n            // calling findTarget has the side effect of killing target.__corner.\n            // as a short term fix we are not firing this if we are currently transforming.\n            // as a long term fix we need to separate the action of finding a target with the\n            // side effects we added to it.\n            if (!this._currentTransform && !this.findTarget(e)) {\n                this.fire(\"mouse:over\", {\n                    target: null,\n                    e: e\n                });\n                this._hoveredTarget = null;\n                this._hoveredTargets = [];\n            }\n        },\n        /**\n     * @private\n     * @param {Event} [e] Event object fired on Event.js orientation change\n     * @param {Event} [self] Inner Event object\n     */ _onOrientationChange: function(e, self) {\n            this.__onOrientationChange && this.__onOrientationChange(e, self);\n        },\n        /**\n     * @private\n     * @param {Event} [e] Event object fired on Event.js shake\n     * @param {Event} [self] Inner Event object\n     */ _onShake: function(e, self) {\n            this.__onShake && this.__onShake(e, self);\n        },\n        /**\n     * @private\n     * @param {Event} [e] Event object fired on Event.js shake\n     * @param {Event} [self] Inner Event object\n     */ _onLongPress: function(e, self) {\n            this.__onLongPress && this.__onLongPress(e, self);\n        },\n        /**\n     * prevent default to allow drop event to be fired\n     * @private\n     * @param {Event} [e] Event object fired on Event.js shake\n     */ _onDragOver: function(e) {\n            e.preventDefault();\n            var target = this._simpleEventHandler(\"dragover\", e);\n            this._fireEnterLeaveEvents(target, e);\n        },\n        /**\n     * `drop:before` is a an event that allow you to schedule logic\n     * before the `drop` event. Prefer `drop` event always, but if you need\n     * to run some drop-disabling logic on an event, since there is no way\n     * to handle event handlers ordering, use `drop:before`\n     * @param {Event} e\n     */ _onDrop: function(e) {\n            this._simpleEventHandler(\"drop:before\", e);\n            return this._simpleEventHandler(\"drop\", e);\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onContextMenu: function(e) {\n            if (this.stopContextMenu) {\n                e.stopPropagation();\n                e.preventDefault();\n            }\n            return false;\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onDoubleClick: function(e) {\n            this._cacheTransformEventData(e);\n            this._handleEvent(e, \"dblclick\");\n            this._resetTransformEventData(e);\n        },\n        /**\n     * Return a the id of an event.\n     * returns either the pointerId or the identifier or 0 for the mouse event\n     * @private\n     * @param {Event} evt Event object\n     */ getPointerId: function(evt) {\n            var changedTouches = evt.changedTouches;\n            if (changedTouches) {\n                return changedTouches[0] && changedTouches[0].identifier;\n            }\n            if (this.enablePointerEvents) {\n                return evt.pointerId;\n            }\n            return -1;\n        },\n        /**\n     * Determines if an event has the id of the event that is considered main\n     * @private\n     * @param {evt} event Event object\n     */ _isMainEvent: function(evt) {\n            if (evt.isPrimary === true) {\n                return true;\n            }\n            if (evt.isPrimary === false) {\n                return false;\n            }\n            if (evt.type === \"touchend\" && evt.touches.length === 0) {\n                return true;\n            }\n            if (evt.changedTouches) {\n                return evt.changedTouches[0].identifier === this.mainTouchId;\n            }\n            return true;\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onTouchStart: function(e) {\n            e.preventDefault();\n            if (this.mainTouchId === null) {\n                this.mainTouchId = this.getPointerId(e);\n            }\n            this.__onMouseDown(e);\n            this._resetTransformEventData();\n            var canvasElement = this.upperCanvasEl, eventTypePrefix = this._getEventPrefix();\n            addListener(fabric.document, \"touchend\", this._onTouchEnd, addEventOptions);\n            addListener(fabric.document, \"touchmove\", this._onMouseMove, addEventOptions);\n            // Unbind mousedown to prevent double triggers from touch devices\n            removeListener(canvasElement, eventTypePrefix + \"down\", this._onMouseDown);\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onMouseDown: function(e) {\n            this.__onMouseDown(e);\n            this._resetTransformEventData();\n            var canvasElement = this.upperCanvasEl, eventTypePrefix = this._getEventPrefix();\n            removeListener(canvasElement, eventTypePrefix + \"move\", this._onMouseMove, addEventOptions);\n            addListener(fabric.document, eventTypePrefix + \"up\", this._onMouseUp);\n            addListener(fabric.document, eventTypePrefix + \"move\", this._onMouseMove, addEventOptions);\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onTouchEnd: function(e) {\n            if (e.touches.length > 0) {\n                // if there are still touches stop here\n                return;\n            }\n            this.__onMouseUp(e);\n            this._resetTransformEventData();\n            this.mainTouchId = null;\n            var eventTypePrefix = this._getEventPrefix();\n            removeListener(fabric.document, \"touchend\", this._onTouchEnd, addEventOptions);\n            removeListener(fabric.document, \"touchmove\", this._onMouseMove, addEventOptions);\n            var _this = this;\n            if (this._willAddMouseDown) {\n                clearTimeout(this._willAddMouseDown);\n            }\n            this._willAddMouseDown = setTimeout(function() {\n                // Wait 400ms before rebinding mousedown to prevent double triggers\n                // from touch devices\n                addListener(_this.upperCanvasEl, eventTypePrefix + \"down\", _this._onMouseDown);\n                _this._willAddMouseDown = 0;\n            }, 400);\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mouseup\n     */ _onMouseUp: function(e) {\n            this.__onMouseUp(e);\n            this._resetTransformEventData();\n            var canvasElement = this.upperCanvasEl, eventTypePrefix = this._getEventPrefix();\n            if (this._isMainEvent(e)) {\n                removeListener(fabric.document, eventTypePrefix + \"up\", this._onMouseUp);\n                removeListener(fabric.document, eventTypePrefix + \"move\", this._onMouseMove, addEventOptions);\n                addListener(canvasElement, eventTypePrefix + \"move\", this._onMouseMove, addEventOptions);\n            }\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousemove\n     */ _onMouseMove: function(e) {\n            !this.allowTouchScrolling && e.preventDefault && e.preventDefault();\n            this.__onMouseMove(e);\n        },\n        /**\n     * @private\n     */ _onResize: function() {\n            this.calcOffset();\n        },\n        /**\n     * Decides whether the canvas should be redrawn in mouseup and mousedown events.\n     * @private\n     * @param {Object} target\n     */ _shouldRender: function(target) {\n            var activeObject = this._activeObject;\n            if (!!activeObject !== !!target || activeObject && target && activeObject !== target) {\n                // this covers: switch of target, from target to no target, selection of target\n                // multiSelection with key and mouse\n                return true;\n            } else if (activeObject && activeObject.isEditing) {\n                // if we mouse up/down over a editing textbox a cursor change,\n                // there is no need to re render\n                return false;\n            }\n            return false;\n        },\n        /**\n     * Method that defines the actions when mouse is released on canvas.\n     * The method resets the currentTransform parameters, store the image corner\n     * position in the image object and render the canvas on top.\n     * @private\n     * @param {Event} e Event object fired on mouseup\n     */ __onMouseUp: function(e) {\n            var target, transform = this._currentTransform, groupSelector = this._groupSelector, shouldRender = false, isClick = !groupSelector || groupSelector.left === 0 && groupSelector.top === 0;\n            this._cacheTransformEventData(e);\n            target = this._target;\n            this._handleEvent(e, \"up:before\");\n            // if right/middle click just fire events and return\n            // target undefined will make the _handleEvent search the target\n            if (checkClick(e, RIGHT_CLICK)) {\n                if (this.fireRightClick) {\n                    this._handleEvent(e, \"up\", RIGHT_CLICK, isClick);\n                }\n                return;\n            }\n            if (checkClick(e, MIDDLE_CLICK)) {\n                if (this.fireMiddleClick) {\n                    this._handleEvent(e, \"up\", MIDDLE_CLICK, isClick);\n                }\n                this._resetTransformEventData();\n                return;\n            }\n            if (this.isDrawingMode && this._isCurrentlyDrawing) {\n                this._onMouseUpInDrawingMode(e);\n                return;\n            }\n            if (!this._isMainEvent(e)) {\n                return;\n            }\n            if (transform) {\n                this._finalizeCurrentTransform(e);\n                shouldRender = transform.actionPerformed;\n            }\n            if (!isClick) {\n                var targetWasActive = target === this._activeObject;\n                this._maybeGroupObjects(e);\n                if (!shouldRender) {\n                    shouldRender = this._shouldRender(target) || !targetWasActive && target === this._activeObject;\n                }\n            }\n            var corner, pointer;\n            if (target) {\n                corner = target._findTargetCorner(this.getPointer(e, true), fabric.util.isTouchEvent(e));\n                if (target.selectable && target !== this._activeObject && target.activeOn === \"up\") {\n                    this.setActiveObject(target, e);\n                    shouldRender = true;\n                } else {\n                    var control = target.controls[corner], mouseUpHandler = control && control.getMouseUpHandler(e, target, control);\n                    if (mouseUpHandler) {\n                        pointer = this.getPointer(e);\n                        mouseUpHandler(e, transform, pointer.x, pointer.y);\n                    }\n                }\n                target.isMoving = false;\n            }\n            // if we are ending up a transform on a different control or a new object\n            // fire the original mouse up from the corner that started the transform\n            if (transform && (transform.target !== target || transform.corner !== corner)) {\n                var originalControl = transform.target && transform.target.controls[transform.corner], originalMouseUpHandler = originalControl && originalControl.getMouseUpHandler(e, target, control);\n                pointer = pointer || this.getPointer(e);\n                originalMouseUpHandler && originalMouseUpHandler(e, transform, pointer.x, pointer.y);\n            }\n            this._setCursorFromEvent(e, target);\n            this._handleEvent(e, \"up\", LEFT_CLICK, isClick);\n            this._groupSelector = null;\n            this._currentTransform = null;\n            // reset the target information about which corner is selected\n            target && (target.__corner = 0);\n            if (shouldRender) {\n                this.requestRenderAll();\n            } else if (!isClick) {\n                this.renderTop();\n            }\n        },\n        /**\n     * @private\n     * Handle event firing for target and subtargets\n     * @param {Event} e event from mouse\n     * @param {String} eventType event to fire (up, down or move)\n     * @return {Fabric.Object} target return the the target found, for internal reasons.\n     */ _simpleEventHandler: function(eventType, e) {\n            var target = this.findTarget(e), targets = this.targets, options = {\n                e: e,\n                target: target,\n                subTargets: targets\n            };\n            this.fire(eventType, options);\n            target && target.fire(eventType, options);\n            if (!targets) {\n                return target;\n            }\n            for(var i = 0; i < targets.length; i++){\n                targets[i].fire(eventType, options);\n            }\n            return target;\n        },\n        /**\n     * @private\n     * Handle event firing for target and subtargets\n     * @param {Event} e event from mouse\n     * @param {String} eventType event to fire (up, down or move)\n     * @param {fabric.Object} targetObj receiving event\n     * @param {Number} [button] button used in the event 1 = left, 2 = middle, 3 = right\n     * @param {Boolean} isClick for left button only, indicates that the mouse up happened without move.\n     */ _handleEvent: function(e, eventType, button, isClick) {\n            var target = this._target, targets = this.targets || [], options = {\n                e: e,\n                target: target,\n                subTargets: targets,\n                button: button || LEFT_CLICK,\n                isClick: isClick || false,\n                pointer: this._pointer,\n                absolutePointer: this._absolutePointer,\n                transform: this._currentTransform\n            };\n            if (eventType === \"up\") {\n                options.currentTarget = this.findTarget(e);\n                options.currentSubTargets = this.targets;\n            }\n            this.fire(\"mouse:\" + eventType, options);\n            target && target.fire(\"mouse\" + eventType, options);\n            for(var i = 0; i < targets.length; i++){\n                targets[i].fire(\"mouse\" + eventType, options);\n            }\n        },\n        /**\n     * @private\n     * @param {Event} e send the mouse event that generate the finalize down, so it can be used in the event\n     */ _finalizeCurrentTransform: function(e) {\n            var transform = this._currentTransform, target = transform.target, options = {\n                e: e,\n                target: target,\n                transform: transform,\n                action: transform.action\n            };\n            if (target._scaling) {\n                target._scaling = false;\n            }\n            target.setCoords();\n            if (transform.actionPerformed || this.stateful && target.hasStateChanged()) {\n                this._fire(\"modified\", options);\n            }\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ _onMouseDownInDrawingMode: function(e) {\n            this._isCurrentlyDrawing = true;\n            if (this.getActiveObject()) {\n                this.discardActiveObject(e).requestRenderAll();\n            }\n            var pointer = this.getPointer(e);\n            this.freeDrawingBrush.onMouseDown(pointer, {\n                e: e,\n                pointer: pointer\n            });\n            this._handleEvent(e, \"down\");\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mousemove\n     */ _onMouseMoveInDrawingMode: function(e) {\n            if (this._isCurrentlyDrawing) {\n                var pointer = this.getPointer(e);\n                this.freeDrawingBrush.onMouseMove(pointer, {\n                    e: e,\n                    pointer: pointer\n                });\n            }\n            this.setCursor(this.freeDrawingCursor);\n            this._handleEvent(e, \"move\");\n        },\n        /**\n     * @private\n     * @param {Event} e Event object fired on mouseup\n     */ _onMouseUpInDrawingMode: function(e) {\n            var pointer = this.getPointer(e);\n            this._isCurrentlyDrawing = this.freeDrawingBrush.onMouseUp({\n                e: e,\n                pointer: pointer\n            });\n            this._handleEvent(e, \"up\");\n        },\n        /**\n     * Method that defines the actions when mouse is clicked on canvas.\n     * The method inits the currentTransform parameters and renders all the\n     * canvas so the current image can be placed on the top canvas and the rest\n     * in on the container one.\n     * @private\n     * @param {Event} e Event object fired on mousedown\n     */ __onMouseDown: function(e) {\n            this._cacheTransformEventData(e);\n            this._handleEvent(e, \"down:before\");\n            var target = this._target;\n            // if right click just fire events\n            if (checkClick(e, RIGHT_CLICK)) {\n                if (this.fireRightClick) {\n                    this._handleEvent(e, \"down\", RIGHT_CLICK);\n                }\n                return;\n            }\n            if (checkClick(e, MIDDLE_CLICK)) {\n                if (this.fireMiddleClick) {\n                    this._handleEvent(e, \"down\", MIDDLE_CLICK);\n                }\n                return;\n            }\n            if (this.isDrawingMode) {\n                this._onMouseDownInDrawingMode(e);\n                return;\n            }\n            if (!this._isMainEvent(e)) {\n                return;\n            }\n            // ignore if some object is being transformed at this moment\n            if (this._currentTransform) {\n                return;\n            }\n            var pointer = this._pointer;\n            // save pointer for check in __onMouseUp event\n            this._previousPointer = pointer;\n            var shouldRender = this._shouldRender(target), shouldGroup = this._shouldGroup(e, target);\n            if (this._shouldClearSelection(e, target)) {\n                this.discardActiveObject(e);\n            } else if (shouldGroup) {\n                this._handleGrouping(e, target);\n                target = this._activeObject;\n            }\n            if (this.selection && (!target || !target.selectable && !target.isEditing && target !== this._activeObject)) {\n                this._groupSelector = {\n                    ex: this._absolutePointer.x,\n                    ey: this._absolutePointer.y,\n                    top: 0,\n                    left: 0\n                };\n            }\n            if (target) {\n                var alreadySelected = target === this._activeObject;\n                if (target.selectable && target.activeOn === \"down\") {\n                    this.setActiveObject(target, e);\n                }\n                var corner = target._findTargetCorner(this.getPointer(e, true), fabric.util.isTouchEvent(e));\n                target.__corner = corner;\n                if (target === this._activeObject && (corner || !shouldGroup)) {\n                    this._setupCurrentTransform(e, target, alreadySelected);\n                    var control = target.controls[corner], pointer = this.getPointer(e), mouseDownHandler = control && control.getMouseDownHandler(e, target, control);\n                    if (mouseDownHandler) {\n                        mouseDownHandler(e, this._currentTransform, pointer.x, pointer.y);\n                    }\n                }\n            }\n            this._handleEvent(e, \"down\");\n            // we must renderAll so that we update the visuals\n            (shouldRender || shouldGroup) && this.requestRenderAll();\n        },\n        /**\n     * reset cache form common information needed during event processing\n     * @private\n     */ _resetTransformEventData: function() {\n            this._target = null;\n            this._pointer = null;\n            this._absolutePointer = null;\n        },\n        /**\n     * Cache common information needed during event processing\n     * @private\n     * @param {Event} e Event object fired on event\n     */ _cacheTransformEventData: function(e) {\n            // reset in order to avoid stale caching\n            this._resetTransformEventData();\n            this._pointer = this.getPointer(e, true);\n            this._absolutePointer = this.restorePointerVpt(this._pointer);\n            this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(e) || null;\n        },\n        /**\n     * @private\n     */ _beforeTransform: function(e) {\n            var t = this._currentTransform;\n            this.stateful && t.target.saveState();\n            this.fire(\"before:transform\", {\n                e: e,\n                transform: t\n            });\n        },\n        /**\n     * Method that defines the actions when mouse is hovering the canvas.\n     * The currentTransform parameter will define whether the user is rotating/scaling/translating\n     * an image or neither of them (only hovering). A group selection is also possible and would cancel\n     * all any other type of action.\n     * In case of an image transformation only the top canvas will be rendered.\n     * @private\n     * @param {Event} e Event object fired on mousemove\n     */ __onMouseMove: function(e) {\n            this._handleEvent(e, \"move:before\");\n            this._cacheTransformEventData(e);\n            var target, pointer;\n            if (this.isDrawingMode) {\n                this._onMouseMoveInDrawingMode(e);\n                return;\n            }\n            if (!this._isMainEvent(e)) {\n                return;\n            }\n            var groupSelector = this._groupSelector;\n            // We initially clicked in an empty area, so we draw a box for multiple selection\n            if (groupSelector) {\n                pointer = this._absolutePointer;\n                groupSelector.left = pointer.x - groupSelector.ex;\n                groupSelector.top = pointer.y - groupSelector.ey;\n                this.renderTop();\n            } else if (!this._currentTransform) {\n                target = this.findTarget(e) || null;\n                this._setCursorFromEvent(e, target);\n                this._fireOverOutEvents(target, e);\n            } else {\n                this._transformObject(e);\n            }\n            this._handleEvent(e, \"move\");\n            this._resetTransformEventData();\n        },\n        /**\n     * Manage the mouseout, mouseover events for the fabric object on the canvas\n     * @param {Fabric.Object} target the target where the target from the mousemove event\n     * @param {Event} e Event object fired on mousemove\n     * @private\n     */ _fireOverOutEvents: function(target, e) {\n            var _hoveredTarget = this._hoveredTarget, _hoveredTargets = this._hoveredTargets, targets = this.targets, length = Math.max(_hoveredTargets.length, targets.length);\n            this.fireSyntheticInOutEvents(target, e, {\n                oldTarget: _hoveredTarget,\n                evtOut: \"mouseout\",\n                canvasEvtOut: \"mouse:out\",\n                evtIn: \"mouseover\",\n                canvasEvtIn: \"mouse:over\"\n            });\n            for(var i = 0; i < length; i++){\n                this.fireSyntheticInOutEvents(targets[i], e, {\n                    oldTarget: _hoveredTargets[i],\n                    evtOut: \"mouseout\",\n                    evtIn: \"mouseover\"\n                });\n            }\n            this._hoveredTarget = target;\n            this._hoveredTargets = this.targets.concat();\n        },\n        /**\n     * Manage the dragEnter, dragLeave events for the fabric objects on the canvas\n     * @param {Fabric.Object} target the target where the target from the onDrag event\n     * @param {Event} e Event object fired on ondrag\n     * @private\n     */ _fireEnterLeaveEvents: function(target, e) {\n            var _draggedoverTarget = this._draggedoverTarget, _hoveredTargets = this._hoveredTargets, targets = this.targets, length = Math.max(_hoveredTargets.length, targets.length);\n            this.fireSyntheticInOutEvents(target, e, {\n                oldTarget: _draggedoverTarget,\n                evtOut: \"dragleave\",\n                evtIn: \"dragenter\"\n            });\n            for(var i = 0; i < length; i++){\n                this.fireSyntheticInOutEvents(targets[i], e, {\n                    oldTarget: _hoveredTargets[i],\n                    evtOut: \"dragleave\",\n                    evtIn: \"dragenter\"\n                });\n            }\n            this._draggedoverTarget = target;\n        },\n        /**\n     * Manage the synthetic in/out events for the fabric objects on the canvas\n     * @param {Fabric.Object} target the target where the target from the supported events\n     * @param {Event} e Event object fired\n     * @param {Object} config configuration for the function to work\n     * @param {String} config.targetName property on the canvas where the old target is stored\n     * @param {String} [config.canvasEvtOut] name of the event to fire at canvas level for out\n     * @param {String} config.evtOut name of the event to fire for out\n     * @param {String} [config.canvasEvtIn] name of the event to fire at canvas level for in\n     * @param {String} config.evtIn name of the event to fire for in\n     * @private\n     */ fireSyntheticInOutEvents: function(target, e, config) {\n            var inOpt, outOpt, oldTarget = config.oldTarget, outFires, inFires, targetChanged = oldTarget !== target, canvasEvtIn = config.canvasEvtIn, canvasEvtOut = config.canvasEvtOut;\n            if (targetChanged) {\n                inOpt = {\n                    e: e,\n                    target: target,\n                    previousTarget: oldTarget\n                };\n                outOpt = {\n                    e: e,\n                    target: oldTarget,\n                    nextTarget: target\n                };\n            }\n            inFires = target && targetChanged;\n            outFires = oldTarget && targetChanged;\n            if (outFires) {\n                canvasEvtOut && this.fire(canvasEvtOut, outOpt);\n                oldTarget.fire(config.evtOut, outOpt);\n            }\n            if (inFires) {\n                canvasEvtIn && this.fire(canvasEvtIn, inOpt);\n                target.fire(config.evtIn, inOpt);\n            }\n        },\n        /**\n     * Method that defines actions when an Event Mouse Wheel\n     * @param {Event} e Event object fired on mouseup\n     */ __onMouseWheel: function(e) {\n            this._cacheTransformEventData(e);\n            this._handleEvent(e, \"wheel\");\n            this._resetTransformEventData();\n        },\n        /**\n     * @private\n     * @param {Event} e Event fired on mousemove\n     */ _transformObject: function(e) {\n            var pointer = this.getPointer(e), transform = this._currentTransform;\n            transform.reset = false;\n            transform.shiftKey = e.shiftKey;\n            transform.altKey = e[this.centeredKey];\n            this._performTransformAction(e, transform, pointer);\n            transform.actionPerformed && this.requestRenderAll();\n        },\n        /**\n     * @private\n     */ _performTransformAction: function(e, transform, pointer) {\n            var x = pointer.x, y = pointer.y, action = transform.action, actionPerformed = false, actionHandler = transform.actionHandler;\n            // this object could be created from the function in the control handlers\n            if (actionHandler) {\n                actionPerformed = actionHandler(e, transform, x, y);\n            }\n            if (action === \"drag\" && actionPerformed) {\n                transform.target.isMoving = true;\n                this.setCursor(transform.target.moveCursor || this.moveCursor);\n            }\n            transform.actionPerformed = transform.actionPerformed || actionPerformed;\n        },\n        /**\n     * @private\n     */ _fire: fabric.controlsUtils.fireEvent,\n        /**\n     * Sets the cursor depending on where the canvas is being hovered.\n     * Note: very buggy in Opera\n     * @param {Event} e Event object\n     * @param {Object} target Object that the mouse is hovering, if so.\n     */ _setCursorFromEvent: function(e, target) {\n            if (!target) {\n                this.setCursor(this.defaultCursor);\n                return false;\n            }\n            var hoverCursor = target.hoverCursor || this.hoverCursor, activeSelection = this._activeObject && this._activeObject.type === \"activeSelection\" ? this._activeObject : null, // only show proper corner when group selection is not active\n            corner = (!activeSelection || !activeSelection.contains(target)) && target._findTargetCorner(this.getPointer(e, true));\n            if (!corner) {\n                if (target.subTargetCheck) {\n                    // hoverCursor should come from top-most subTarget,\n                    // so we walk the array backwards\n                    this.targets.concat().reverse().map(function(_target) {\n                        hoverCursor = _target.hoverCursor || hoverCursor;\n                    });\n                }\n                this.setCursor(hoverCursor);\n            } else {\n                this.setCursor(this.getCornerCursor(corner, target, e));\n            }\n        },\n        /**\n     * @private\n     */ getCornerCursor: function(corner, target, e) {\n            var control = target.controls[corner];\n            return control.cursorStyleHandler(e, control, target);\n        }\n    });\n})();\n(function() {\n    var min = Math.min, max = Math.max;\n    fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {\n        /**\n     * @private\n     * @param {Event} e Event object\n     * @param {fabric.Object} target\n     * @return {Boolean}\n     */ _shouldGroup: function(e, target) {\n            var activeObject = this._activeObject;\n            return activeObject && this._isSelectionKeyPressed(e) && target && target.selectable && this.selection && (activeObject !== target || activeObject.type === \"activeSelection\") && !target.onSelect({\n                e: e\n            });\n        },\n        /**\n     * @private\n     * @param {Event} e Event object\n     * @param {fabric.Object} target\n     */ _handleGrouping: function(e, target) {\n            var activeObject = this._activeObject;\n            // avoid multi select when shift click on a corner\n            if (activeObject.__corner) {\n                return;\n            }\n            if (target === activeObject) {\n                // if it's a group, find target again, using activeGroup objects\n                target = this.findTarget(e, true);\n                // if even object is not found or we are on activeObjectCorner, bail out\n                if (!target || !target.selectable) {\n                    return;\n                }\n            }\n            if (activeObject && activeObject.type === \"activeSelection\") {\n                this._updateActiveSelection(target, e);\n            } else {\n                this._createActiveSelection(target, e);\n            }\n        },\n        /**\n     * @private\n     */ _updateActiveSelection: function(target, e) {\n            var activeSelection = this._activeObject, currentActiveObjects = activeSelection._objects.slice(0);\n            if (activeSelection.contains(target)) {\n                activeSelection.removeWithUpdate(target);\n                this._hoveredTarget = target;\n                this._hoveredTargets = this.targets.concat();\n                if (activeSelection.size() === 1) {\n                    // activate last remaining object\n                    this._setActiveObject(activeSelection.item(0), e);\n                }\n            } else {\n                activeSelection.addWithUpdate(target);\n                this._hoveredTarget = activeSelection;\n                this._hoveredTargets = this.targets.concat();\n            }\n            this._fireSelectionEvents(currentActiveObjects, e);\n        },\n        /**\n     * @private\n     */ _createActiveSelection: function(target, e) {\n            var currentActives = this.getActiveObjects(), group = this._createGroup(target);\n            this._hoveredTarget = group;\n            // ISSUE 4115: should we consider subTargets here?\n            // this._hoveredTargets = [];\n            // this._hoveredTargets = this.targets.concat();\n            this._setActiveObject(group, e);\n            this._fireSelectionEvents(currentActives, e);\n        },\n        /**\n     * @private\n     * @param {Object} target\n     */ _createGroup: function(target) {\n            var objects = this._objects, isActiveLower = objects.indexOf(this._activeObject) < objects.indexOf(target), groupObjects = isActiveLower ? [\n                this._activeObject,\n                target\n            ] : [\n                target,\n                this._activeObject\n            ];\n            this._activeObject.isEditing && this._activeObject.exitEditing();\n            return new fabric.ActiveSelection(groupObjects, {\n                canvas: this\n            });\n        },\n        /**\n     * @private\n     * @param {Event} e mouse event\n     */ _groupSelectedObjects: function(e) {\n            var group = this._collectObjects(e), aGroup;\n            // do not create group for 1 element only\n            if (group.length === 1) {\n                this.setActiveObject(group[0], e);\n            } else if (group.length > 1) {\n                aGroup = new fabric.ActiveSelection(group.reverse(), {\n                    canvas: this\n                });\n                this.setActiveObject(aGroup, e);\n            }\n        },\n        /**\n     * @private\n     */ _collectObjects: function(e) {\n            var group = [], currentObject, x1 = this._groupSelector.ex, y1 = this._groupSelector.ey, x2 = x1 + this._groupSelector.left, y2 = y1 + this._groupSelector.top, selectionX1Y1 = new fabric.Point(min(x1, x2), min(y1, y2)), selectionX2Y2 = new fabric.Point(max(x1, x2), max(y1, y2)), allowIntersect = !this.selectionFullyContained, isClick = x1 === x2 && y1 === y2;\n            // we iterate reverse order to collect top first in case of click.\n            for(var i = this._objects.length; i--;){\n                currentObject = this._objects[i];\n                if (!currentObject || !currentObject.selectable || !currentObject.visible) {\n                    continue;\n                }\n                if (allowIntersect && currentObject.intersectsWithRect(selectionX1Y1, selectionX2Y2, true) || currentObject.isContainedWithinRect(selectionX1Y1, selectionX2Y2, true) || allowIntersect && currentObject.containsPoint(selectionX1Y1, null, true) || allowIntersect && currentObject.containsPoint(selectionX2Y2, null, true)) {\n                    group.push(currentObject);\n                    // only add one object if it's a click\n                    if (isClick) {\n                        break;\n                    }\n                }\n            }\n            if (group.length > 1) {\n                group = group.filter(function(object) {\n                    return !object.onSelect({\n                        e: e\n                    });\n                });\n            }\n            return group;\n        },\n        /**\n     * @private\n     */ _maybeGroupObjects: function(e) {\n            if (this.selection && this._groupSelector) {\n                this._groupSelectedObjects(e);\n            }\n            this.setCursor(this.defaultCursor);\n            // clear selection and current transformation\n            this._groupSelector = null;\n        }\n    });\n})();\n(function() {\n    fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\n        /**\n     * Exports canvas element to a dataurl image. Note that when multiplier is used, cropping is scaled appropriately\n     * @param {Object} [options] Options object\n     * @param {String} [options.format=png] The format of the output image. Either \"jpeg\" or \"png\"\n     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.\n     * @param {Number} [options.multiplier=1] Multiplier to scale by, to have consistent\n     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14\n     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14\n     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14\n     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14\n     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 2.0.0\n     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format\n     * @see {@link http://jsfiddle.net/fabricjs/NfZVb/|jsFiddle demo}\n     * @example <caption>Generate jpeg dataURL with lower quality</caption>\n     * var dataURL = canvas.toDataURL({\n     *   format: 'jpeg',\n     *   quality: 0.8\n     * });\n     * @example <caption>Generate cropped png dataURL (clipping of canvas)</caption>\n     * var dataURL = canvas.toDataURL({\n     *   format: 'png',\n     *   left: 100,\n     *   top: 100,\n     *   width: 200,\n     *   height: 200\n     * });\n     * @example <caption>Generate double scaled png dataURL</caption>\n     * var dataURL = canvas.toDataURL({\n     *   format: 'png',\n     *   multiplier: 2\n     * });\n     */ toDataURL: function(options) {\n            options || (options = {});\n            var format = options.format || \"png\", quality = options.quality || 1, multiplier = (options.multiplier || 1) * (options.enableRetinaScaling ? this.getRetinaScaling() : 1), canvasEl = this.toCanvasElement(multiplier, options);\n            return fabric.util.toDataURL(canvasEl, format, quality);\n        },\n        /**\n     * Create a new HTMLCanvas element painted with the current canvas content.\n     * No need to resize the actual one or repaint it.\n     * Will transfer object ownership to a new canvas, paint it, and set everything back.\n     * This is an intermediary step used to get to a dataUrl but also it is useful to\n     * create quick image copies of a canvas without passing for the dataUrl string\n     * @param {Number} [multiplier] a zoom factor.\n     * @param {Object} [cropping] Cropping informations\n     * @param {Number} [cropping.left] Cropping left offset.\n     * @param {Number} [cropping.top] Cropping top offset.\n     * @param {Number} [cropping.width] Cropping width.\n     * @param {Number} [cropping.height] Cropping height.\n     */ toCanvasElement: function(multiplier, cropping) {\n            multiplier = multiplier || 1;\n            cropping = cropping || {};\n            var scaledWidth = (cropping.width || this.width) * multiplier, scaledHeight = (cropping.height || this.height) * multiplier, zoom = this.getZoom(), originalWidth = this.width, originalHeight = this.height, newZoom = zoom * multiplier, vp = this.viewportTransform, translateX = (vp[4] - (cropping.left || 0)) * multiplier, translateY = (vp[5] - (cropping.top || 0)) * multiplier, originalInteractive = this.interactive, newVp = [\n                newZoom,\n                0,\n                0,\n                newZoom,\n                translateX,\n                translateY\n            ], originalRetina = this.enableRetinaScaling, canvasEl = fabric.util.createCanvasElement(), originalContextTop = this.contextTop;\n            canvasEl.width = scaledWidth;\n            canvasEl.height = scaledHeight;\n            this.contextTop = null;\n            this.enableRetinaScaling = false;\n            this.interactive = false;\n            this.viewportTransform = newVp;\n            this.width = scaledWidth;\n            this.height = scaledHeight;\n            this.calcViewportBoundaries();\n            this.renderCanvas(canvasEl.getContext(\"2d\"), this._objects);\n            this.viewportTransform = vp;\n            this.width = originalWidth;\n            this.height = originalHeight;\n            this.calcViewportBoundaries();\n            this.interactive = originalInteractive;\n            this.enableRetinaScaling = originalRetina;\n            this.contextTop = originalContextTop;\n            return canvasEl;\n        }\n    });\n})();\nfabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\n    /**\n   * Populates canvas with data from the specified JSON.\n   * JSON format must conform to the one of {@link fabric.Canvas#toJSON}\n   * @param {String|Object} json JSON string or object\n   * @param {Function} callback Callback, invoked when json is parsed\n   *                            and corresponding objects (e.g: {@link fabric.Image})\n   *                            are initialized\n   * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.\n   * @return {fabric.Canvas} instance\n   * @chainable\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#deserialization}\n   * @see {@link http://jsfiddle.net/fabricjs/fmgXt/|jsFiddle demo}\n   * @example <caption>loadFromJSON</caption>\n   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas));\n   * @example <caption>loadFromJSON with reviver</caption>\n   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas), function(o, object) {\n   *   // `o` = json object\n   *   // `object` = fabric.Object instance\n   *   // ... do some stuff ...\n   * });\n   */ loadFromJSON: function(json, callback, reviver) {\n        if (!json) {\n            return;\n        }\n        // serialize if it wasn't already\n        var serialized = typeof json === \"string\" ? JSON.parse(json) : fabric.util.object.clone(json);\n        var _this = this, clipPath = serialized.clipPath, renderOnAddRemove = this.renderOnAddRemove;\n        this.renderOnAddRemove = false;\n        delete serialized.clipPath;\n        this._enlivenObjects(serialized.objects, function(enlivenedObjects) {\n            _this.clear();\n            _this._setBgOverlay(serialized, function() {\n                if (clipPath) {\n                    _this._enlivenObjects([\n                        clipPath\n                    ], function(enlivenedCanvasClip) {\n                        _this.clipPath = enlivenedCanvasClip[0];\n                        _this.__setupCanvas.call(_this, serialized, enlivenedObjects, renderOnAddRemove, callback);\n                    });\n                } else {\n                    _this.__setupCanvas.call(_this, serialized, enlivenedObjects, renderOnAddRemove, callback);\n                }\n            });\n        }, reviver);\n        return this;\n    },\n    /**\n   * @private\n   * @param {Object} serialized Object with background and overlay information\n   * @param {Array} restored canvas objects\n   * @param {Function} cached renderOnAddRemove callback\n   * @param {Function} callback Invoked after all background and overlay images/patterns loaded\n   */ __setupCanvas: function(serialized, enlivenedObjects, renderOnAddRemove, callback) {\n        var _this = this;\n        enlivenedObjects.forEach(function(obj, index) {\n            // we splice the array just in case some custom classes restored from JSON\n            // will add more object to canvas at canvas init.\n            _this.insertAt(obj, index);\n        });\n        this.renderOnAddRemove = renderOnAddRemove;\n        // remove parts i cannot set as options\n        delete serialized.objects;\n        delete serialized.backgroundImage;\n        delete serialized.overlayImage;\n        delete serialized.background;\n        delete serialized.overlay;\n        // this._initOptions does too many things to just\n        // call it. Normally loading an Object from JSON\n        // create the Object instance. Here the Canvas is\n        // already an instance and we are just loading things over it\n        this._setOptions(serialized);\n        this.renderAll();\n        callback && callback();\n    },\n    /**\n   * @private\n   * @param {Object} serialized Object with background and overlay information\n   * @param {Function} callback Invoked after all background and overlay images/patterns loaded\n   */ _setBgOverlay: function(serialized, callback) {\n        var loaded = {\n            backgroundColor: false,\n            overlayColor: false,\n            backgroundImage: false,\n            overlayImage: false\n        };\n        if (!serialized.backgroundImage && !serialized.overlayImage && !serialized.background && !serialized.overlay) {\n            callback && callback();\n            return;\n        }\n        var cbIfLoaded = function() {\n            if (loaded.backgroundImage && loaded.overlayImage && loaded.backgroundColor && loaded.overlayColor) {\n                callback && callback();\n            }\n        };\n        this.__setBgOverlay(\"backgroundImage\", serialized.backgroundImage, loaded, cbIfLoaded);\n        this.__setBgOverlay(\"overlayImage\", serialized.overlayImage, loaded, cbIfLoaded);\n        this.__setBgOverlay(\"backgroundColor\", serialized.background, loaded, cbIfLoaded);\n        this.__setBgOverlay(\"overlayColor\", serialized.overlay, loaded, cbIfLoaded);\n    },\n    /**\n   * @private\n   * @param {String} property Property to set (backgroundImage, overlayImage, backgroundColor, overlayColor)\n   * @param {(Object|String)} value Value to set\n   * @param {Object} loaded Set loaded property to true if property is set\n   * @param {Object} callback Callback function to invoke after property is set\n   */ __setBgOverlay: function(property, value, loaded, callback) {\n        var _this = this;\n        if (!value) {\n            loaded[property] = true;\n            callback && callback();\n            return;\n        }\n        if (property === \"backgroundImage\" || property === \"overlayImage\") {\n            fabric.util.enlivenObjects([\n                value\n            ], function(enlivedObject) {\n                _this[property] = enlivedObject[0];\n                loaded[property] = true;\n                callback && callback();\n            });\n        } else {\n            this[\"set\" + fabric.util.string.capitalize(property, true)](value, function() {\n                loaded[property] = true;\n                callback && callback();\n            });\n        }\n    },\n    /**\n   * @private\n   * @param {Array} objects\n   * @param {Function} callback\n   * @param {Function} [reviver]\n   */ _enlivenObjects: function(objects, callback, reviver) {\n        if (!objects || objects.length === 0) {\n            callback && callback([]);\n            return;\n        }\n        fabric.util.enlivenObjects(objects, function(enlivenedObjects) {\n            callback && callback(enlivenedObjects);\n        }, null, reviver);\n    },\n    /**\n   * @private\n   * @param {String} format\n   * @param {Function} callback\n   */ _toDataURL: function(format, callback) {\n        this.clone(function(clone) {\n            callback(clone.toDataURL(format));\n        });\n    },\n    /**\n   * @private\n   * @param {String} format\n   * @param {Number} multiplier\n   * @param {Function} callback\n   */ _toDataURLWithMultiplier: function(format, multiplier, callback) {\n        this.clone(function(clone) {\n            callback(clone.toDataURLWithMultiplier(format, multiplier));\n        });\n    },\n    /**\n   * Clones canvas instance\n   * @param {Object} [callback] Receives cloned instance as a first argument\n   * @param {Array} [properties] Array of properties to include in the cloned canvas and children\n   */ clone: function(callback, properties) {\n        var data = JSON.stringify(this.toJSON(properties));\n        this.cloneWithoutData(function(clone) {\n            clone.loadFromJSON(data, function() {\n                callback && callback(clone);\n            });\n        });\n    },\n    /**\n   * Clones canvas instance without cloning existing data.\n   * This essentially copies canvas dimensions, clipping properties, etc.\n   * but leaves data empty (so that you can populate it with your own)\n   * @param {Object} [callback] Receives cloned instance as a first argument\n   */ cloneWithoutData: function(callback) {\n        var el = fabric.util.createCanvasElement();\n        el.width = this.width;\n        el.height = this.height;\n        var clone = new fabric.Canvas(el);\n        if (this.backgroundImage) {\n            clone.setBackgroundImage(this.backgroundImage.src, function() {\n                clone.renderAll();\n                callback && callback(clone);\n            });\n            clone.backgroundImageOpacity = this.backgroundImageOpacity;\n            clone.backgroundImageStretch = this.backgroundImageStretch;\n        } else {\n            callback && callback(clone);\n        }\n    }\n});\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, clone = fabric.util.object.clone, toFixed = fabric.util.toFixed, capitalize = fabric.util.string.capitalize, degreesToRadians = fabric.util.degreesToRadians, objectCaching = !fabric.isLikelyNode, ALIASING_LIMIT = 2;\n    if (fabric.Object) {\n        return;\n    }\n    /**\n   * Root object class from which all 2d shape classes inherit from\n   * @class fabric.Object\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#objects}\n   * @see {@link fabric.Object#initialize} for constructor definition\n   *\n   * @fires added\n   * @fires removed\n   *\n   * @fires selected\n   * @fires deselected\n   * @fires modified\n   * @fires modified\n   * @fires moved\n   * @fires scaled\n   * @fires rotated\n   * @fires skewed\n   *\n   * @fires rotating\n   * @fires scaling\n   * @fires moving\n   * @fires skewing\n   *\n   * @fires mousedown\n   * @fires mouseup\n   * @fires mouseover\n   * @fires mouseout\n   * @fires mousewheel\n   * @fires mousedblclick\n   *\n   * @fires dragover\n   * @fires dragenter\n   * @fires dragleave\n   * @fires drop\n   */ fabric.Object = fabric.util.createClass(fabric.CommonMethods, /** @lends fabric.Object.prototype */ {\n        /**\n     * Type of an object (rect, circle, path, etc.).\n     * Note that this property is meant to be read-only and not meant to be modified.\n     * If you modify, certain parts of Fabric (such as JSON loading) won't work correctly.\n     * @type String\n     * @default\n     */ type: \"object\",\n        /**\n     * Horizontal origin of transformation of an object (one of \"left\", \"right\", \"center\")\n     * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups\n     * @type String\n     * @default\n     */ originX: \"left\",\n        /**\n     * Vertical origin of transformation of an object (one of \"top\", \"bottom\", \"center\")\n     * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups\n     * @type String\n     * @default\n     */ originY: \"top\",\n        /**\n     * Top position of an object. Note that by default it's relative to object top. You can change this by setting originY={top/center/bottom}\n     * @type Number\n     * @default\n     */ top: 0,\n        /**\n     * Left position of an object. Note that by default it's relative to object left. You can change this by setting originX={left/center/right}\n     * @type Number\n     * @default\n     */ left: 0,\n        /**\n     * Object width\n     * @type Number\n     * @default\n     */ width: 0,\n        /**\n     * Object height\n     * @type Number\n     * @default\n     */ height: 0,\n        /**\n     * Object scale factor (horizontal)\n     * @type Number\n     * @default\n     */ scaleX: 1,\n        /**\n     * Object scale factor (vertical)\n     * @type Number\n     * @default\n     */ scaleY: 1,\n        /**\n     * When true, an object is rendered as flipped horizontally\n     * @type Boolean\n     * @default\n     */ flipX: false,\n        /**\n     * When true, an object is rendered as flipped vertically\n     * @type Boolean\n     * @default\n     */ flipY: false,\n        /**\n     * Opacity of an object\n     * @type Number\n     * @default\n     */ opacity: 1,\n        /**\n     * Angle of rotation of an object (in degrees)\n     * @type Number\n     * @default\n     */ angle: 0,\n        /**\n     * Angle of skew on x axes of an object (in degrees)\n     * @type Number\n     * @default\n     */ skewX: 0,\n        /**\n     * Angle of skew on y axes of an object (in degrees)\n     * @type Number\n     * @default\n     */ skewY: 0,\n        /**\n     * Size of object's controlling corners (in pixels)\n     * @type Number\n     * @default\n     */ cornerSize: 13,\n        /**\n     * Size of object's controlling corners when touch interaction is detected\n     * @type Number\n     * @default\n     */ touchCornerSize: 24,\n        /**\n     * When true, object's controlling corners are rendered as transparent inside (i.e. stroke instead of fill)\n     * @type Boolean\n     * @default\n     */ transparentCorners: true,\n        /**\n     * Default cursor value used when hovering over this object on canvas\n     * @type String\n     * @default\n     */ hoverCursor: null,\n        /**\n     * Default cursor value used when moving this object on canvas\n     * @type String\n     * @default\n     */ moveCursor: null,\n        /**\n     * Padding between object and its controlling borders (in pixels)\n     * @type Number\n     * @default\n     */ padding: 0,\n        /**\n     * Color of controlling borders of an object (when it's active)\n     * @type String\n     * @default\n     */ borderColor: \"rgb(178,204,255)\",\n        /**\n     * Array specifying dash pattern of an object's borders (hasBorder must be true)\n     * @since 1.6.2\n     * @type Array\n     */ borderDashArray: null,\n        /**\n     * Color of controlling corners of an object (when it's active)\n     * @type String\n     * @default\n     */ cornerColor: \"rgb(178,204,255)\",\n        /**\n     * Color of controlling corners of an object (when it's active and transparentCorners false)\n     * @since 1.6.2\n     * @type String\n     * @default\n     */ cornerStrokeColor: null,\n        /**\n     * Specify style of control, 'rect' or 'circle'\n     * @since 1.6.2\n     * @type String\n     */ cornerStyle: \"rect\",\n        /**\n     * Array specifying dash pattern of an object's control (hasBorder must be true)\n     * @since 1.6.2\n     * @type Array\n     */ cornerDashArray: null,\n        /**\n     * When true, this object will use center point as the origin of transformation\n     * when being scaled via the controls.\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\n     * @since 1.3.4\n     * @type Boolean\n     * @default\n     */ centeredScaling: false,\n        /**\n     * When true, this object will use center point as the origin of transformation\n     * when being rotated via the controls.\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\n     * @since 1.3.4\n     * @type Boolean\n     * @default\n     */ centeredRotation: true,\n        /**\n     * Color of object's fill\n     * takes css colors https://www.w3.org/TR/css-color-3/\n     * @type String\n     * @default\n     */ fill: \"rgb(0,0,0)\",\n        /**\n     * Fill rule used to fill an object\n     * accepted values are nonzero, evenodd\n     * <b>Backwards incompatibility note:</b> This property was used for setting globalCompositeOperation until v1.4.12 (use `fabric.Object#globalCompositeOperation` instead)\n     * @type String\n     * @default\n     */ fillRule: \"nonzero\",\n        /**\n     * Composite rule used for canvas globalCompositeOperation\n     * @type String\n     * @default\n     */ globalCompositeOperation: \"source-over\",\n        /**\n     * Background color of an object.\n     * takes css colors https://www.w3.org/TR/css-color-3/\n     * @type String\n     * @default\n     */ backgroundColor: \"\",\n        /**\n     * Selection Background color of an object. colored layer behind the object when it is active.\n     * does not mix good with globalCompositeOperation methods.\n     * @type String\n     * @default\n     */ selectionBackgroundColor: \"\",\n        /**\n     * When defined, an object is rendered via stroke and this property specifies its color\n     * takes css colors https://www.w3.org/TR/css-color-3/\n     * @type String\n     * @default\n     */ stroke: null,\n        /**\n     * Width of a stroke used to render this object\n     * @type Number\n     * @default\n     */ strokeWidth: 1,\n        /**\n     * Array specifying dash pattern of an object's stroke (stroke must be defined)\n     * @type Array\n     */ strokeDashArray: null,\n        /**\n     * Line offset of an object's stroke\n     * @type Number\n     * @default\n     */ strokeDashOffset: 0,\n        /**\n     * Line endings style of an object's stroke (one of \"butt\", \"round\", \"square\")\n     * @type String\n     * @default\n     */ strokeLineCap: \"butt\",\n        /**\n     * Corner style of an object's stroke (one of \"bevel\", \"round\", \"miter\")\n     * @type String\n     * @default\n     */ strokeLineJoin: \"miter\",\n        /**\n     * Maximum miter length (used for strokeLineJoin = \"miter\") of an object's stroke\n     * @type Number\n     * @default\n     */ strokeMiterLimit: 4,\n        /**\n     * Shadow object representing shadow of this shape\n     * @type fabric.Shadow\n     * @default\n     */ shadow: null,\n        /**\n     * Opacity of object's controlling borders when object is active and moving\n     * @type Number\n     * @default\n     */ borderOpacityWhenMoving: 0.4,\n        /**\n     * Scale factor of object's controlling borders\n     * bigger number will make a thicker border\n     * border is 1, so this is basically a border thickness\n     * since there is no way to change the border itself.\n     * @type Number\n     * @default\n     */ borderScaleFactor: 1,\n        /**\n     * Minimum allowed scale value of an object\n     * @type Number\n     * @default\n     */ minScaleLimit: 0,\n        /**\n     * When set to `false`, an object can not be selected for modification (using either point-click-based or group-based selection).\n     * But events still fire on it.\n     * @type Boolean\n     * @default\n     */ selectable: true,\n        /**\n     * When set to `false`, an object can not be a target of events. All events propagate through it. Introduced in v1.3.4\n     * @type Boolean\n     * @default\n     */ evented: true,\n        /**\n     * When set to `false`, an object is not rendered on canvas\n     * @type Boolean\n     * @default\n     */ visible: true,\n        /**\n     * When set to `false`, object's controls are not displayed and can not be used to manipulate object\n     * @type Boolean\n     * @default\n     */ hasControls: true,\n        /**\n     * When set to `false`, object's controlling borders are not rendered\n     * @type Boolean\n     * @default\n     */ hasBorders: true,\n        /**\n     * When set to `true`, objects are \"found\" on canvas on per-pixel basis rather than according to bounding box\n     * @type Boolean\n     * @default\n     */ perPixelTargetFind: false,\n        /**\n     * When `false`, default object's values are not included in its serialization\n     * @type Boolean\n     * @default\n     */ includeDefaultValues: true,\n        /**\n     * When `true`, object horizontal movement is locked\n     * @type Boolean\n     * @default\n     */ lockMovementX: false,\n        /**\n     * When `true`, object vertical movement is locked\n     * @type Boolean\n     * @default\n     */ lockMovementY: false,\n        /**\n     * When `true`, object rotation is locked\n     * @type Boolean\n     * @default\n     */ lockRotation: false,\n        /**\n     * When `true`, object horizontal scaling is locked\n     * @type Boolean\n     * @default\n     */ lockScalingX: false,\n        /**\n     * When `true`, object vertical scaling is locked\n     * @type Boolean\n     * @default\n     */ lockScalingY: false,\n        /**\n     * When `true`, object horizontal skewing is locked\n     * @type Boolean\n     * @default\n     */ lockSkewingX: false,\n        /**\n     * When `true`, object vertical skewing is locked\n     * @type Boolean\n     * @default\n     */ lockSkewingY: false,\n        /**\n     * When `true`, object cannot be flipped by scaling into negative values\n     * @type Boolean\n     * @default\n     */ lockScalingFlip: false,\n        /**\n     * When `true`, object is not exported in OBJECT/JSON\n     * @since 1.6.3\n     * @type Boolean\n     * @default\n     */ excludeFromExport: false,\n        /**\n     * When `true`, object is cached on an additional canvas.\n     * When `false`, object is not cached unless necessary ( clipPath )\n     * default to true\n     * @since 1.7.0\n     * @type Boolean\n     * @default true\n     */ objectCaching: objectCaching,\n        /**\n     * When `true`, object properties are checked for cache invalidation. In some particular\n     * situation you may want this to be disabled ( spray brush, very big, groups)\n     * or if your application does not allow you to modify properties for groups child you want\n     * to disable it for groups.\n     * default to false\n     * since 1.7.0\n     * @type Boolean\n     * @default false\n     */ statefullCache: false,\n        /**\n     * When `true`, cache does not get updated during scaling. The picture will get blocky if scaled\n     * too much and will be redrawn with correct details at the end of scaling.\n     * this setting is performance and application dependant.\n     * default to true\n     * since 1.7.0\n     * @type Boolean\n     * @default true\n     */ noScaleCache: true,\n        /**\n     * When `false`, the stoke width will scale with the object.\n     * When `true`, the stroke will always match the exact pixel size entered for stroke width.\n     * this Property does not work on Text classes or drawing call that uses strokeText,fillText methods\n     * default to false\n     * @since 2.6.0\n     * @type Boolean\n     * @default false\n     * @type Boolean\n     * @default false\n     */ strokeUniform: false,\n        /**\n     * When set to `true`, object's cache will be rerendered next render call.\n     * since 1.7.0\n     * @type Boolean\n     * @default true\n     */ dirty: true,\n        /**\n     * keeps the value of the last hovered corner during mouse move.\n     * 0 is no corner, or 'mt', 'ml', 'mtr' etc..\n     * It should be private, but there is no harm in using it as\n     * a read-only property.\n     * @type number|string|any\n     * @default 0\n     */ __corner: 0,\n        /**\n     * Determines if the fill or the stroke is drawn first (one of \"fill\" or \"stroke\")\n     * @type String\n     * @default\n     */ paintFirst: \"fill\",\n        /**\n     * When 'down', object is set to active on mousedown/touchstart\n     * When 'up', object is set to active on mouseup/touchend\n     * Experimental. Let's see if this breaks anything before supporting officially\n     * @private\n     * since 4.4.0\n     * @type String\n     * @default 'down'\n     */ activeOn: \"down\",\n        /**\n     * List of properties to consider when checking if state\n     * of an object is changed (fabric.Object#hasStateChanged)\n     * as well as for history (undo/redo) purposes\n     * @type Array\n     */ stateProperties: (\"top left width height scaleX scaleY flipX flipY originX originY transformMatrix \" + \"stroke strokeWidth strokeDashArray strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit \" + \"angle opacity fill globalCompositeOperation shadow visible backgroundColor \" + \"skewX skewY fillRule paintFirst clipPath strokeUniform\").split(\" \"),\n        /**\n     * List of properties to consider when checking if cache needs refresh\n     * Those properties are checked by statefullCache ON ( or lazy mode if we want ) or from single\n     * calls to Object.set(key, value). If the key is in this list, the object is marked as dirty\n     * and refreshed at the next render\n     * @type Array\n     */ cacheProperties: (\"fill stroke strokeWidth strokeDashArray width height paintFirst strokeUniform\" + \" strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit backgroundColor clipPath\").split(\" \"),\n        /**\n     * List of properties to consider for animating colors.\n     * @type Array\n     */ colorProperties: \"fill stroke backgroundColor\".split(\" \"),\n        /**\n     * a fabricObject that, without stroke define a clipping area with their shape. filled in black\n     * the clipPath object gets used when the object has rendered, and the context is placed in the center\n     * of the object cacheCanvas.\n     * If you want 0,0 of a clipPath to align with an object center, use clipPath.originX/Y to 'center'\n     * @type fabric.Object\n     */ clipPath: undefined,\n        /**\n     * Meaningful ONLY when the object is used as clipPath.\n     * if true, the clipPath will make the object clip to the outside of the clipPath\n     * since 2.4.0\n     * @type boolean\n     * @default false\n     */ inverted: false,\n        /**\n     * Meaningful ONLY when the object is used as clipPath.\n     * if true, the clipPath will have its top and left relative to canvas, and will\n     * not be influenced by the object transform. This will make the clipPath relative\n     * to the canvas, but clipping just a particular object.\n     * WARNING this is beta, this feature may change or be renamed.\n     * since 2.4.0\n     * @type boolean\n     * @default false\n     */ absolutePositioned: false,\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     */ initialize: function(options) {\n            if (options) {\n                this.setOptions(options);\n            }\n        },\n        /**\n     * Create a the canvas used to keep the cached copy of the object\n     * @private\n     */ _createCacheCanvas: function() {\n            this._cacheProperties = {};\n            this._cacheCanvas = fabric.util.createCanvasElement();\n            this._cacheContext = this._cacheCanvas.getContext(\"2d\");\n            this._updateCacheCanvas();\n            // if canvas gets created, is empty, so dirty.\n            this.dirty = true;\n        },\n        /**\n     * Limit the cache dimensions so that X * Y do not cross fabric.perfLimitSizeTotal\n     * and each side do not cross fabric.cacheSideLimit\n     * those numbers are configurable so that you can get as much detail as you want\n     * making bargain with performances.\n     * @param {Object} dims\n     * @param {Object} dims.width width of canvas\n     * @param {Object} dims.height height of canvas\n     * @param {Object} dims.zoomX zoomX zoom value to unscale the canvas before drawing cache\n     * @param {Object} dims.zoomY zoomY zoom value to unscale the canvas before drawing cache\n     * @return {Object}.width width of canvas\n     * @return {Object}.height height of canvas\n     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache\n     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache\n     */ _limitCacheSize: function(dims) {\n            var perfLimitSizeTotal = fabric.perfLimitSizeTotal, width = dims.width, height = dims.height, max = fabric.maxCacheSideLimit, min = fabric.minCacheSideLimit;\n            if (width <= max && height <= max && width * height <= perfLimitSizeTotal) {\n                if (width < min) {\n                    dims.width = min;\n                }\n                if (height < min) {\n                    dims.height = min;\n                }\n                return dims;\n            }\n            var ar = width / height, limitedDims = fabric.util.limitDimsByArea(ar, perfLimitSizeTotal), capValue = fabric.util.capValue, x = capValue(min, limitedDims.x, max), y = capValue(min, limitedDims.y, max);\n            if (width > x) {\n                dims.zoomX /= width / x;\n                dims.width = x;\n                dims.capped = true;\n            }\n            if (height > y) {\n                dims.zoomY /= height / y;\n                dims.height = y;\n                dims.capped = true;\n            }\n            return dims;\n        },\n        /**\n     * Return the dimension and the zoom level needed to create a cache canvas\n     * big enough to host the object to be cached.\n     * @private\n     * @return {Object}.x width of object to be cached\n     * @return {Object}.y height of object to be cached\n     * @return {Object}.width width of canvas\n     * @return {Object}.height height of canvas\n     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache\n     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache\n     */ _getCacheCanvasDimensions: function() {\n            var objectScale = this.getTotalObjectScaling(), // caculate dimensions without skewing\n            dim = this._getTransformedDimensions(0, 0), neededX = dim.x * objectScale.scaleX / this.scaleX, neededY = dim.y * objectScale.scaleY / this.scaleY;\n            return {\n                // for sure this ALIASING_LIMIT is slightly creating problem\n                // in situation in which the cache canvas gets an upper limit\n                // also objectScale contains already scaleX and scaleY\n                width: Math.ceil(neededX + ALIASING_LIMIT),\n                height: Math.ceil(neededY + ALIASING_LIMIT),\n                zoomX: objectScale.scaleX,\n                zoomY: objectScale.scaleY,\n                x: neededX,\n                y: neededY\n            };\n        },\n        /**\n     * Update width and height of the canvas for cache\n     * returns true or false if canvas needed resize.\n     * @private\n     * @return {Boolean} true if the canvas has been resized\n     */ _updateCacheCanvas: function() {\n            var targetCanvas = this.canvas;\n            if (this.noScaleCache && targetCanvas && targetCanvas._currentTransform) {\n                var target = targetCanvas._currentTransform.target, action = targetCanvas._currentTransform.action;\n                if (this === target && action.slice && action.slice(0, 5) === \"scale\") {\n                    return false;\n                }\n            }\n            var canvas = this._cacheCanvas, dims = this._limitCacheSize(this._getCacheCanvasDimensions()), width = dims.width, height = dims.height, drawingWidth, drawingHeight, zoomX = dims.zoomX, zoomY = dims.zoomY, dimensionsChanged = width !== this.cacheWidth || height !== this.cacheHeight, zoomChanged = this.zoomX !== zoomX || this.zoomY !== zoomY, shouldRedraw = dimensionsChanged || zoomChanged;\n            if (shouldRedraw) {\n                if (dimensionsChanged) {\n                    canvas.width = width;\n                    canvas.height = height;\n                } else {\n                    this._cacheContext.setTransform(1, 0, 0, 1, 0, 0);\n                    this._cacheContext.clearRect(0, 0, canvas.width, canvas.height);\n                }\n                drawingWidth = dims.x / 2;\n                drawingHeight = dims.y / 2;\n                this.cacheTranslationX = Math.round(canvas.width / 2 - drawingWidth) + drawingWidth;\n                this.cacheTranslationY = Math.round(canvas.height / 2 - drawingHeight) + drawingHeight;\n                this.cacheWidth = width;\n                this.cacheHeight = height;\n                this._cacheContext.translate(this.cacheTranslationX, this.cacheTranslationY);\n                this._cacheContext.scale(zoomX, zoomY);\n                this.zoomX = zoomX;\n                this.zoomY = zoomY;\n                return true;\n            }\n            return false;\n        },\n        /**\n     * Sets object's properties from options\n     * @param {Object} [options] Options object\n     */ setOptions: function(options) {\n            this._setOptions(options);\n            this._initGradient(options.fill, \"fill\");\n            this._initGradient(options.stroke, \"stroke\");\n            this._initPattern(options.fill, \"fill\");\n            this._initPattern(options.stroke, \"stroke\");\n        },\n        /**\n     * Transforms context when rendering an object\n     * @param {CanvasRenderingContext2D} ctx Context\n     */ transform: function(ctx) {\n            var needFullTransform = this.group && !this.group._transformDone || this.group && this.canvas && ctx === this.canvas.contextTop;\n            var m = this.calcTransformMatrix(!needFullTransform);\n            ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n        },\n        /**\n     * Returns an object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS, object = {\n                type: this.type,\n                version: fabric.version,\n                originX: this.originX,\n                originY: this.originY,\n                left: toFixed(this.left, NUM_FRACTION_DIGITS),\n                top: toFixed(this.top, NUM_FRACTION_DIGITS),\n                width: toFixed(this.width, NUM_FRACTION_DIGITS),\n                height: toFixed(this.height, NUM_FRACTION_DIGITS),\n                fill: this.fill && this.fill.toObject ? this.fill.toObject() : this.fill,\n                stroke: this.stroke && this.stroke.toObject ? this.stroke.toObject() : this.stroke,\n                strokeWidth: toFixed(this.strokeWidth, NUM_FRACTION_DIGITS),\n                strokeDashArray: this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray,\n                strokeLineCap: this.strokeLineCap,\n                strokeDashOffset: this.strokeDashOffset,\n                strokeLineJoin: this.strokeLineJoin,\n                strokeUniform: this.strokeUniform,\n                strokeMiterLimit: toFixed(this.strokeMiterLimit, NUM_FRACTION_DIGITS),\n                scaleX: toFixed(this.scaleX, NUM_FRACTION_DIGITS),\n                scaleY: toFixed(this.scaleY, NUM_FRACTION_DIGITS),\n                angle: toFixed(this.angle, NUM_FRACTION_DIGITS),\n                flipX: this.flipX,\n                flipY: this.flipY,\n                opacity: toFixed(this.opacity, NUM_FRACTION_DIGITS),\n                shadow: this.shadow && this.shadow.toObject ? this.shadow.toObject() : this.shadow,\n                visible: this.visible,\n                backgroundColor: this.backgroundColor,\n                fillRule: this.fillRule,\n                paintFirst: this.paintFirst,\n                globalCompositeOperation: this.globalCompositeOperation,\n                skewX: toFixed(this.skewX, NUM_FRACTION_DIGITS),\n                skewY: toFixed(this.skewY, NUM_FRACTION_DIGITS)\n            };\n            if (this.clipPath && !this.clipPath.excludeFromExport) {\n                object.clipPath = this.clipPath.toObject(propertiesToInclude);\n                object.clipPath.inverted = this.clipPath.inverted;\n                object.clipPath.absolutePositioned = this.clipPath.absolutePositioned;\n            }\n            fabric.util.populateWithProperties(this, object, propertiesToInclude);\n            if (!this.includeDefaultValues) {\n                object = this._removeDefaultValues(object);\n            }\n            return object;\n        },\n        /**\n     * Returns (dataless) object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of an instance\n     */ toDatalessObject: function(propertiesToInclude) {\n            // will be overwritten by subclasses\n            return this.toObject(propertiesToInclude);\n        },\n        /**\n     * @private\n     * @param {Object} object\n     */ _removeDefaultValues: function(object) {\n            var prototype = fabric.util.getKlass(object.type).prototype, stateProperties = prototype.stateProperties;\n            stateProperties.forEach(function(prop) {\n                if (prop === \"left\" || prop === \"top\") {\n                    return;\n                }\n                if (object[prop] === prototype[prop]) {\n                    delete object[prop];\n                }\n                // basically a check for [] === []\n                if (Array.isArray(object[prop]) && Array.isArray(prototype[prop]) && object[prop].length === 0 && prototype[prop].length === 0) {\n                    delete object[prop];\n                }\n            });\n            return object;\n        },\n        /**\n     * Returns a string representation of an instance\n     * @return {String}\n     */ toString: function() {\n            return \"#<fabric.\" + capitalize(this.type) + \">\";\n        },\n        /**\n     * Return the object scale factor counting also the group scaling\n     * @return {Object} object with scaleX and scaleY properties\n     */ getObjectScaling: function() {\n            // if the object is a top level one, on the canvas, we go for simple aritmetic\n            // otherwise the complex method with angles will return approximations and decimals\n            // and will likely kill the cache when not needed\n            // https://github.com/fabricjs/fabric.js/issues/7157\n            if (!this.group) {\n                return {\n                    scaleX: this.scaleX,\n                    scaleY: this.scaleY\n                };\n            }\n            // if we are inside a group total zoom calculation is complex, we defer to generic matrices\n            var options = fabric.util.qrDecompose(this.calcTransformMatrix());\n            return {\n                scaleX: Math.abs(options.scaleX),\n                scaleY: Math.abs(options.scaleY)\n            };\n        },\n        /**\n     * Return the object scale factor counting also the group scaling, zoom and retina\n     * @return {Object} object with scaleX and scaleY properties\n     */ getTotalObjectScaling: function() {\n            var scale = this.getObjectScaling(), scaleX = scale.scaleX, scaleY = scale.scaleY;\n            if (this.canvas) {\n                var zoom = this.canvas.getZoom();\n                var retina = this.canvas.getRetinaScaling();\n                scaleX *= zoom * retina;\n                scaleY *= zoom * retina;\n            }\n            return {\n                scaleX: scaleX,\n                scaleY: scaleY\n            };\n        },\n        /**\n     * Return the object opacity counting also the group property\n     * @return {Number}\n     */ getObjectOpacity: function() {\n            var opacity = this.opacity;\n            if (this.group) {\n                opacity *= this.group.getObjectOpacity();\n            }\n            return opacity;\n        },\n        /**\n     * @private\n     * @param {String} key\n     * @param {*} value\n     * @return {fabric.Object} thisArg\n     */ _set: function(key, value) {\n            var shouldConstrainValue = key === \"scaleX\" || key === \"scaleY\", isChanged = this[key] !== value, groupNeedsUpdate = false;\n            if (shouldConstrainValue) {\n                value = this._constrainScale(value);\n            }\n            if (key === \"scaleX\" && value < 0) {\n                this.flipX = !this.flipX;\n                value *= -1;\n            } else if (key === \"scaleY\" && value < 0) {\n                this.flipY = !this.flipY;\n                value *= -1;\n            } else if (key === \"shadow\" && value && !(value instanceof fabric.Shadow)) {\n                value = new fabric.Shadow(value);\n            } else if (key === \"dirty\" && this.group) {\n                this.group.set(\"dirty\", value);\n            }\n            this[key] = value;\n            if (isChanged) {\n                groupNeedsUpdate = this.group && this.group.isOnACache();\n                if (this.cacheProperties.indexOf(key) > -1) {\n                    this.dirty = true;\n                    groupNeedsUpdate && this.group.set(\"dirty\", true);\n                } else if (groupNeedsUpdate && this.stateProperties.indexOf(key) > -1) {\n                    this.group.set(\"dirty\", true);\n                }\n            }\n            return this;\n        },\n        /**\n     * This callback function is called by the parent group of an object every\n     * time a non-delegated property changes on the group. It is passed the key\n     * and value as parameters. Not adding in this function's signature to avoid\n     * Travis build error about unused variables.\n     */ setOnGroup: function() {\n        // implemented by sub-classes, as needed.\n        },\n        /**\n     * Retrieves viewportTransform from Object's canvas if possible\n     * @method getViewportTransform\n     * @memberOf fabric.Object.prototype\n     * @return {Array}\n     */ getViewportTransform: function() {\n            if (this.canvas && this.canvas.viewportTransform) {\n                return this.canvas.viewportTransform;\n            }\n            return fabric.iMatrix.concat();\n        },\n        /*\n     * @private\n     * return if the object would be visible in rendering\n     * @memberOf fabric.Object.prototype\n     * @return {Boolean}\n     */ isNotVisible: function() {\n            return this.opacity === 0 || !this.width && !this.height && this.strokeWidth === 0 || !this.visible;\n        },\n        /**\n     * Renders an object on a specified context\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ render: function(ctx) {\n            // do not render if width/height are zeros or object is not visible\n            if (this.isNotVisible()) {\n                return;\n            }\n            if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {\n                return;\n            }\n            ctx.save();\n            this._setupCompositeOperation(ctx);\n            this.drawSelectionBackground(ctx);\n            this.transform(ctx);\n            this._setOpacity(ctx);\n            this._setShadow(ctx, this);\n            if (this.shouldCache()) {\n                this.renderCache();\n                this.drawCacheOnCanvas(ctx);\n            } else {\n                this._removeCacheCanvas();\n                this.dirty = false;\n                this.drawObject(ctx);\n                if (this.objectCaching && this.statefullCache) {\n                    this.saveState({\n                        propertySet: \"cacheProperties\"\n                    });\n                }\n            }\n            ctx.restore();\n        },\n        renderCache: function(options) {\n            options = options || {};\n            if (!this._cacheCanvas || !this._cacheContext) {\n                this._createCacheCanvas();\n            }\n            if (this.isCacheDirty()) {\n                this.statefullCache && this.saveState({\n                    propertySet: \"cacheProperties\"\n                });\n                this.drawObject(this._cacheContext, options.forClipping);\n                this.dirty = false;\n            }\n        },\n        /**\n     * Remove cacheCanvas and its dimensions from the objects\n     */ _removeCacheCanvas: function() {\n            this._cacheCanvas = null;\n            this._cacheContext = null;\n            this.cacheWidth = 0;\n            this.cacheHeight = 0;\n        },\n        /**\n     * return true if the object will draw a stroke\n     * Does not consider text styles. This is just a shortcut used at rendering time\n     * We want it to be an approximation and be fast.\n     * wrote to avoid extra caching, it has to return true when stroke happens,\n     * can guess when it will not happen at 100% chance, does not matter if it misses\n     * some use case where the stroke is invisible.\n     * @since 3.0.0\n     * @returns Boolean\n     */ hasStroke: function() {\n            return this.stroke && this.stroke !== \"transparent\" && this.strokeWidth !== 0;\n        },\n        /**\n     * return true if the object will draw a fill\n     * Does not consider text styles. This is just a shortcut used at rendering time\n     * We want it to be an approximation and be fast.\n     * wrote to avoid extra caching, it has to return true when fill happens,\n     * can guess when it will not happen at 100% chance, does not matter if it misses\n     * some use case where the fill is invisible.\n     * @since 3.0.0\n     * @returns Boolean\n     */ hasFill: function() {\n            return this.fill && this.fill !== \"transparent\";\n        },\n        /**\n     * When set to `true`, force the object to have its own cache, even if it is inside a group\n     * it may be needed when your object behave in a particular way on the cache and always needs\n     * its own isolated canvas to render correctly.\n     * Created to be overridden\n     * since 1.7.12\n     * @returns Boolean\n     */ needsItsOwnCache: function() {\n            if (this.paintFirst === \"stroke\" && this.hasFill() && this.hasStroke() && typeof this.shadow === \"object\") {\n                return true;\n            }\n            if (this.clipPath) {\n                return true;\n            }\n            return false;\n        },\n        /**\n     * Decide if the object should cache or not. Create its own cache level\n     * objectCaching is a global flag, wins over everything\n     * needsItsOwnCache should be used when the object drawing method requires\n     * a cache step. None of the fabric classes requires it.\n     * Generally you do not cache objects in groups because the group outside is cached.\n     * Read as: cache if is needed, or if the feature is enabled but we are not already caching.\n     * @return {Boolean}\n     */ shouldCache: function() {\n            this.ownCaching = this.needsItsOwnCache() || this.objectCaching && (!this.group || !this.group.isOnACache());\n            return this.ownCaching;\n        },\n        /**\n     * Check if this object or a child object will cast a shadow\n     * used by Group.shouldCache to know if child has a shadow recursively\n     * @return {Boolean}\n     */ willDrawShadow: function() {\n            return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0);\n        },\n        /**\n     * Execute the drawing operation for an object clipPath\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {fabric.Object} clipPath\n     */ drawClipPathOnCache: function(ctx, clipPath) {\n            ctx.save();\n            // DEBUG: uncomment this line, comment the following\n            // ctx.globalAlpha = 0.4\n            if (clipPath.inverted) {\n                ctx.globalCompositeOperation = \"destination-out\";\n            } else {\n                ctx.globalCompositeOperation = \"destination-in\";\n            }\n            //ctx.scale(1 / 2, 1 / 2);\n            if (clipPath.absolutePositioned) {\n                var m = fabric.util.invertTransform(this.calcTransformMatrix());\n                ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n            }\n            clipPath.transform(ctx);\n            ctx.scale(1 / clipPath.zoomX, 1 / clipPath.zoomY);\n            ctx.drawImage(clipPath._cacheCanvas, -clipPath.cacheTranslationX, -clipPath.cacheTranslationY);\n            ctx.restore();\n        },\n        /**\n     * Execute the drawing operation for an object on a specified context\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ drawObject: function(ctx, forClipping) {\n            var originalFill = this.fill, originalStroke = this.stroke;\n            if (forClipping) {\n                this.fill = \"black\";\n                this.stroke = \"\";\n                this._setClippingProperties(ctx);\n            } else {\n                this._renderBackground(ctx);\n            }\n            this._render(ctx);\n            this._drawClipPath(ctx, this.clipPath);\n            this.fill = originalFill;\n            this.stroke = originalStroke;\n        },\n        /**\n     * Prepare clipPath state and cache and draw it on instance's cache\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {fabric.Object} clipPath\n     */ _drawClipPath: function(ctx, clipPath) {\n            if (!clipPath) {\n                return;\n            }\n            // needed to setup a couple of variables\n            // path canvas gets overridden with this one.\n            // TODO find a better solution?\n            clipPath.canvas = this.canvas;\n            clipPath.shouldCache();\n            clipPath._transformDone = true;\n            clipPath.renderCache({\n                forClipping: true\n            });\n            this.drawClipPathOnCache(ctx, clipPath);\n        },\n        /**\n     * Paint the cached copy of the object on the target context.\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ drawCacheOnCanvas: function(ctx) {\n            ctx.scale(1 / this.zoomX, 1 / this.zoomY);\n            ctx.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);\n        },\n        /**\n     * Check if cache is dirty\n     * @param {Boolean} skipCanvas skip canvas checks because this object is painted\n     * on parent canvas.\n     */ isCacheDirty: function(skipCanvas) {\n            if (this.isNotVisible()) {\n                return false;\n            }\n            if (this._cacheCanvas && this._cacheContext && !skipCanvas && this._updateCacheCanvas()) {\n                // in this case the context is already cleared.\n                return true;\n            } else {\n                if (this.dirty || this.clipPath && this.clipPath.absolutePositioned || this.statefullCache && this.hasStateChanged(\"cacheProperties\")) {\n                    if (this._cacheCanvas && this._cacheContext && !skipCanvas) {\n                        var width = this.cacheWidth / this.zoomX;\n                        var height = this.cacheHeight / this.zoomY;\n                        this._cacheContext.clearRect(-width / 2, -height / 2, width, height);\n                    }\n                    return true;\n                }\n            }\n            return false;\n        },\n        /**\n     * Draws a background for the object big as its untransformed dimensions\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderBackground: function(ctx) {\n            if (!this.backgroundColor) {\n                return;\n            }\n            var dim = this._getNonTransformedDimensions();\n            ctx.fillStyle = this.backgroundColor;\n            ctx.fillRect(-dim.x / 2, -dim.y / 2, dim.x, dim.y);\n            // if there is background color no other shadows\n            // should be casted\n            this._removeShadow(ctx);\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _setOpacity: function(ctx) {\n            if (this.group && !this.group._transformDone) {\n                ctx.globalAlpha = this.getObjectOpacity();\n            } else {\n                ctx.globalAlpha *= this.opacity;\n            }\n        },\n        _setStrokeStyles: function(ctx, decl) {\n            var stroke = decl.stroke;\n            if (stroke) {\n                ctx.lineWidth = decl.strokeWidth;\n                ctx.lineCap = decl.strokeLineCap;\n                ctx.lineDashOffset = decl.strokeDashOffset;\n                ctx.lineJoin = decl.strokeLineJoin;\n                ctx.miterLimit = decl.strokeMiterLimit;\n                if (stroke.toLive) {\n                    if (stroke.gradientUnits === \"percentage\" || stroke.gradientTransform || stroke.patternTransform) {\n                        // need to transform gradient in a pattern.\n                        // this is a slow process. If you are hitting this codepath, and the object\n                        // is not using caching, you should consider switching it on.\n                        // we need a canvas as big as the current object caching canvas.\n                        this._applyPatternForTransformedGradient(ctx, stroke);\n                    } else {\n                        // is a simple gradient or pattern\n                        ctx.strokeStyle = stroke.toLive(ctx, this);\n                        this._applyPatternGradientTransform(ctx, stroke);\n                    }\n                } else {\n                    // is a color\n                    ctx.strokeStyle = decl.stroke;\n                }\n            }\n        },\n        _setFillStyles: function(ctx, decl) {\n            var fill = decl.fill;\n            if (fill) {\n                if (fill.toLive) {\n                    ctx.fillStyle = fill.toLive(ctx, this);\n                    this._applyPatternGradientTransform(ctx, decl.fill);\n                } else {\n                    ctx.fillStyle = fill;\n                }\n            }\n        },\n        _setClippingProperties: function(ctx) {\n            ctx.globalAlpha = 1;\n            ctx.strokeStyle = \"transparent\";\n            ctx.fillStyle = \"#000000\";\n        },\n        /**\n     * @private\n     * Sets line dash\n     * @param {CanvasRenderingContext2D} ctx Context to set the dash line on\n     * @param {Array} dashArray array representing dashes\n     */ _setLineDash: function(ctx, dashArray) {\n            if (!dashArray || dashArray.length === 0) {\n                return;\n            }\n            // Spec requires the concatenation of two copies the dash list when the number of elements is odd\n            if (1 & dashArray.length) {\n                dashArray.push.apply(dashArray, dashArray);\n            }\n            ctx.setLineDash(dashArray);\n        },\n        /**\n     * Renders controls and borders for the object\n     * the context here is not transformed\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Object} [styleOverride] properties to override the object style\n     */ _renderControls: function(ctx, styleOverride) {\n            var vpt = this.getViewportTransform(), matrix = this.calcTransformMatrix(), options, drawBorders, drawControls;\n            styleOverride = styleOverride || {};\n            drawBorders = typeof styleOverride.hasBorders !== \"undefined\" ? styleOverride.hasBorders : this.hasBorders;\n            drawControls = typeof styleOverride.hasControls !== \"undefined\" ? styleOverride.hasControls : this.hasControls;\n            matrix = fabric.util.multiplyTransformMatrices(vpt, matrix);\n            options = fabric.util.qrDecompose(matrix);\n            ctx.save();\n            ctx.translate(options.translateX, options.translateY);\n            ctx.lineWidth = 1 * this.borderScaleFactor;\n            if (!this.group) {\n                ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;\n            }\n            if (this.flipX) {\n                options.angle -= 180;\n            }\n            ctx.rotate(degreesToRadians(this.group ? options.angle : this.angle));\n            if (styleOverride.forActiveSelection || this.group) {\n                drawBorders && this.drawBordersInGroup(ctx, options, styleOverride);\n            } else {\n                drawBorders && this.drawBorders(ctx, styleOverride);\n            }\n            drawControls && this.drawControls(ctx, styleOverride);\n            ctx.restore();\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _setShadow: function(ctx) {\n            if (!this.shadow) {\n                return;\n            }\n            var shadow = this.shadow, canvas = this.canvas, scaling, multX = canvas && canvas.viewportTransform[0] || 1, multY = canvas && canvas.viewportTransform[3] || 1;\n            if (shadow.nonScaling) {\n                scaling = {\n                    scaleX: 1,\n                    scaleY: 1\n                };\n            } else {\n                scaling = this.getObjectScaling();\n            }\n            if (canvas && canvas._isRetinaScaling()) {\n                multX *= fabric.devicePixelRatio;\n                multY *= fabric.devicePixelRatio;\n            }\n            ctx.shadowColor = shadow.color;\n            ctx.shadowBlur = shadow.blur * fabric.browserShadowBlurConstant * (multX + multY) * (scaling.scaleX + scaling.scaleY) / 4;\n            ctx.shadowOffsetX = shadow.offsetX * multX * scaling.scaleX;\n            ctx.shadowOffsetY = shadow.offsetY * multY * scaling.scaleY;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _removeShadow: function(ctx) {\n            if (!this.shadow) {\n                return;\n            }\n            ctx.shadowColor = \"\";\n            ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Object} filler fabric.Pattern or fabric.Gradient\n     * @return {Object} offset.offsetX offset for text rendering\n     * @return {Object} offset.offsetY offset for text rendering\n     */ _applyPatternGradientTransform: function(ctx, filler) {\n            if (!filler || !filler.toLive) {\n                return {\n                    offsetX: 0,\n                    offsetY: 0\n                };\n            }\n            var t = filler.gradientTransform || filler.patternTransform;\n            var offsetX = -this.width / 2 + filler.offsetX || 0, offsetY = -this.height / 2 + filler.offsetY || 0;\n            if (filler.gradientUnits === \"percentage\") {\n                ctx.transform(this.width, 0, 0, this.height, offsetX, offsetY);\n            } else {\n                ctx.transform(1, 0, 0, 1, offsetX, offsetY);\n            }\n            if (t) {\n                ctx.transform(t[0], t[1], t[2], t[3], t[4], t[5]);\n            }\n            return {\n                offsetX: offsetX,\n                offsetY: offsetY\n            };\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderPaintInOrder: function(ctx) {\n            if (this.paintFirst === \"stroke\") {\n                this._renderStroke(ctx);\n                this._renderFill(ctx);\n            } else {\n                this._renderFill(ctx);\n                this._renderStroke(ctx);\n            }\n        },\n        /**\n     * @private\n     * function that actually render something on the context.\n     * empty here to allow Obects to work on tests to benchmark fabric functionalites\n     * not related to rendering\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function() {},\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderFill: function(ctx) {\n            if (!this.fill) {\n                return;\n            }\n            ctx.save();\n            this._setFillStyles(ctx, this);\n            if (this.fillRule === \"evenodd\") {\n                ctx.fill(\"evenodd\");\n            } else {\n                ctx.fill();\n            }\n            ctx.restore();\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderStroke: function(ctx) {\n            if (!this.stroke || this.strokeWidth === 0) {\n                return;\n            }\n            if (this.shadow && !this.shadow.affectStroke) {\n                this._removeShadow(ctx);\n            }\n            ctx.save();\n            if (this.strokeUniform && this.group) {\n                var scaling = this.getObjectScaling();\n                ctx.scale(1 / scaling.scaleX, 1 / scaling.scaleY);\n            } else if (this.strokeUniform) {\n                ctx.scale(1 / this.scaleX, 1 / this.scaleY);\n            }\n            this._setLineDash(ctx, this.strokeDashArray);\n            this._setStrokeStyles(ctx, this);\n            ctx.stroke();\n            ctx.restore();\n        },\n        /**\n     * This function try to patch the missing gradientTransform on canvas gradients.\n     * transforming a context to transform the gradient, is going to transform the stroke too.\n     * we want to transform the gradient but not the stroke operation, so we create\n     * a transformed gradient on a pattern and then we use the pattern instead of the gradient.\n     * this method has drwabacks: is slow, is in low resolution, needs a patch for when the size\n     * is limited.\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {fabric.Gradient} filler a fabric gradient instance\n     */ _applyPatternForTransformedGradient: function(ctx, filler) {\n            var dims = this._limitCacheSize(this._getCacheCanvasDimensions()), pCanvas = fabric.util.createCanvasElement(), pCtx, retinaScaling = this.canvas.getRetinaScaling(), width = dims.x / this.scaleX / retinaScaling, height = dims.y / this.scaleY / retinaScaling;\n            pCanvas.width = Math.ceil(width);\n            pCanvas.height = Math.ceil(height);\n            pCtx = pCanvas.getContext(\"2d\");\n            pCtx.beginPath();\n            pCtx.moveTo(0, 0);\n            pCtx.lineTo(width, 0);\n            pCtx.lineTo(width, height);\n            pCtx.lineTo(0, height);\n            pCtx.closePath();\n            pCtx.translate(width / 2, height / 2);\n            pCtx.scale(dims.zoomX / this.scaleX / retinaScaling, dims.zoomY / this.scaleY / retinaScaling);\n            this._applyPatternGradientTransform(pCtx, filler);\n            pCtx.fillStyle = filler.toLive(ctx);\n            pCtx.fill();\n            ctx.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2);\n            ctx.scale(retinaScaling * this.scaleX / dims.zoomX, retinaScaling * this.scaleY / dims.zoomY);\n            ctx.strokeStyle = pCtx.createPattern(pCanvas, \"no-repeat\");\n        },\n        /**\n     * This function is an helper for svg import. it returns the center of the object in the svg\n     * untransformed coordinates\n     * @private\n     * @return {Object} center point from element coordinates\n     */ _findCenterFromElement: function() {\n            return {\n                x: this.left + this.width / 2,\n                y: this.top + this.height / 2\n            };\n        },\n        /**\n     * This function is an helper for svg import. it decompose the transformMatrix\n     * and assign properties to object.\n     * untransformed coordinates\n     * @private\n     * @chainable\n     */ _assignTransformMatrixProps: function() {\n            if (this.transformMatrix) {\n                var options = fabric.util.qrDecompose(this.transformMatrix);\n                this.flipX = false;\n                this.flipY = false;\n                this.set(\"scaleX\", options.scaleX);\n                this.set(\"scaleY\", options.scaleY);\n                this.angle = options.angle;\n                this.skewX = options.skewX;\n                this.skewY = 0;\n            }\n        },\n        /**\n     * This function is an helper for svg import. it removes the transform matrix\n     * and set to object properties that fabricjs can handle\n     * @private\n     * @param {Object} preserveAspectRatioOptions\n     * @return {thisArg}\n     */ _removeTransformMatrix: function(preserveAspectRatioOptions) {\n            var center = this._findCenterFromElement();\n            if (this.transformMatrix) {\n                this._assignTransformMatrixProps();\n                center = fabric.util.transformPoint(center, this.transformMatrix);\n            }\n            this.transformMatrix = null;\n            if (preserveAspectRatioOptions) {\n                this.scaleX *= preserveAspectRatioOptions.scaleX;\n                this.scaleY *= preserveAspectRatioOptions.scaleY;\n                this.cropX = preserveAspectRatioOptions.cropX;\n                this.cropY = preserveAspectRatioOptions.cropY;\n                center.x += preserveAspectRatioOptions.offsetLeft;\n                center.y += preserveAspectRatioOptions.offsetTop;\n                this.width = preserveAspectRatioOptions.width;\n                this.height = preserveAspectRatioOptions.height;\n            }\n            this.setPositionByOrigin(center, \"center\", \"center\");\n        },\n        /**\n     * Clones an instance, using a callback method will work for every object.\n     * @param {Function} callback Callback is invoked with a clone as a first argument\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     */ clone: function(callback, propertiesToInclude) {\n            var objectForm = this.toObject(propertiesToInclude);\n            if (this.constructor.fromObject) {\n                this.constructor.fromObject(objectForm, callback);\n            } else {\n                fabric.Object._fromObject(\"Object\", objectForm, callback);\n            }\n        },\n        /**\n     * Creates an instance of fabric.Image out of an object\n     * makes use of toCanvasElement.\n     * Once this method was based on toDataUrl and loadImage, so it also had a quality\n     * and format option. toCanvasElement is faster and produce no loss of quality.\n     * If you need to get a real Jpeg or Png from an object, using toDataURL is the right way to do it.\n     * toCanvasElement and then toBlob from the obtained canvas is also a good option.\n     * This method is sync now, but still support the callback because we did not want to break.\n     * When fabricJS 5.0 will be planned, this will probably be changed to not have a callback.\n     * @param {Function} callback callback, invoked with an instance as a first argument\n     * @param {Object} [options] for clone as image, passed to toDataURL\n     * @param {Number} [options.multiplier=1] Multiplier to scale by\n     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14\n     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14\n     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14\n     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14\n     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4\n     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4\n     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2\n     * @return {fabric.Object} thisArg\n     */ cloneAsImage: function(callback, options) {\n            var canvasEl = this.toCanvasElement(options);\n            if (callback) {\n                callback(new fabric.Image(canvasEl));\n            }\n            return this;\n        },\n        /**\n     * Converts an object into a HTMLCanvas element\n     * @param {Object} options Options object\n     * @param {Number} [options.multiplier=1] Multiplier to scale by\n     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14\n     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14\n     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14\n     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14\n     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4\n     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4\n     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2\n     * @return {HTMLCanvasElement} Returns DOM element <canvas> with the fabric.Object\n     */ toCanvasElement: function(options) {\n            options || (options = {});\n            var utils = fabric.util, origParams = utils.saveObjectTransform(this), originalGroup = this.group, originalShadow = this.shadow, abs = Math.abs, multiplier = (options.multiplier || 1) * (options.enableRetinaScaling ? fabric.devicePixelRatio : 1);\n            delete this.group;\n            if (options.withoutTransform) {\n                utils.resetObjectTransform(this);\n            }\n            if (options.withoutShadow) {\n                this.shadow = null;\n            }\n            var el = fabric.util.createCanvasElement(), // skip canvas zoom and calculate with setCoords now.\n            boundingRect = this.getBoundingRect(true, true), shadow = this.shadow, scaling, shadowOffset = {\n                x: 0,\n                y: 0\n            }, shadowBlur, width, height;\n            if (shadow) {\n                shadowBlur = shadow.blur;\n                if (shadow.nonScaling) {\n                    scaling = {\n                        scaleX: 1,\n                        scaleY: 1\n                    };\n                } else {\n                    scaling = this.getObjectScaling();\n                }\n                // consider non scaling shadow.\n                shadowOffset.x = 2 * Math.round(abs(shadow.offsetX) + shadowBlur) * abs(scaling.scaleX);\n                shadowOffset.y = 2 * Math.round(abs(shadow.offsetY) + shadowBlur) * abs(scaling.scaleY);\n            }\n            width = boundingRect.width + shadowOffset.x;\n            height = boundingRect.height + shadowOffset.y;\n            // if the current width/height is not an integer\n            // we need to make it so.\n            el.width = Math.ceil(width);\n            el.height = Math.ceil(height);\n            var canvas = new fabric.StaticCanvas(el, {\n                enableRetinaScaling: false,\n                renderOnAddRemove: false,\n                skipOffscreen: false\n            });\n            if (options.format === \"jpeg\") {\n                canvas.backgroundColor = \"#fff\";\n            }\n            this.setPositionByOrigin(new fabric.Point(canvas.width / 2, canvas.height / 2), \"center\", \"center\");\n            var originalCanvas = this.canvas;\n            canvas.add(this);\n            var canvasEl = canvas.toCanvasElement(multiplier || 1, options);\n            this.shadow = originalShadow;\n            this.set(\"canvas\", originalCanvas);\n            if (originalGroup) {\n                this.group = originalGroup;\n            }\n            this.set(origParams).setCoords();\n            // canvas.dispose will call image.dispose that will nullify the elements\n            // since this canvas is a simple element for the process, we remove references\n            // to objects in this way in order to avoid object trashing.\n            canvas._objects = [];\n            canvas.dispose();\n            canvas = null;\n            return canvasEl;\n        },\n        /**\n     * Converts an object into a data-url-like string\n     * @param {Object} options Options object\n     * @param {String} [options.format=png] The format of the output image. Either \"jpeg\" or \"png\"\n     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.\n     * @param {Number} [options.multiplier=1] Multiplier to scale by\n     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14\n     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14\n     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14\n     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14\n     * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4\n     * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4\n     * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2\n     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format\n     */ toDataURL: function(options) {\n            options || (options = {});\n            return fabric.util.toDataURL(this.toCanvasElement(options), options.format || \"png\", options.quality || 1);\n        },\n        /**\n     * Returns true if specified type is identical to the type of an instance\n     * @param {String} type Type to check against\n     * @return {Boolean}\n     */ isType: function(type) {\n            return arguments.length > 1 ? Array.from(arguments).includes(this.type) : this.type === type;\n        },\n        /**\n     * Returns complexity of an instance\n     * @return {Number} complexity of this instance (is 1 unless subclassed)\n     */ complexity: function() {\n            return 1;\n        },\n        /**\n     * Returns a JSON representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} JSON\n     */ toJSON: function(propertiesToInclude) {\n            // delegate, not alias\n            return this.toObject(propertiesToInclude);\n        },\n        /**\n     * Sets \"angle\" of an instance with centered rotation\n     * @param {Number} angle Angle value (in degrees)\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ rotate: function(angle) {\n            var shouldCenterOrigin = (this.originX !== \"center\" || this.originY !== \"center\") && this.centeredRotation;\n            if (shouldCenterOrigin) {\n                this._setOriginToCenter();\n            }\n            this.set(\"angle\", angle);\n            if (shouldCenterOrigin) {\n                this._resetOrigin();\n            }\n            return this;\n        },\n        /**\n     * Centers object horizontally on canvas to which it was added last.\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ centerH: function() {\n            this.canvas && this.canvas.centerObjectH(this);\n            return this;\n        },\n        /**\n     * Centers object horizontally on current viewport of canvas to which it was added last.\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ viewportCenterH: function() {\n            this.canvas && this.canvas.viewportCenterObjectH(this);\n            return this;\n        },\n        /**\n     * Centers object vertically on canvas to which it was added last.\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ centerV: function() {\n            this.canvas && this.canvas.centerObjectV(this);\n            return this;\n        },\n        /**\n     * Centers object vertically on current viewport of canvas to which it was added last.\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ viewportCenterV: function() {\n            this.canvas && this.canvas.viewportCenterObjectV(this);\n            return this;\n        },\n        /**\n     * Centers object vertically and horizontally on canvas to which is was added last\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ center: function() {\n            this.canvas && this.canvas.centerObject(this);\n            return this;\n        },\n        /**\n     * Centers object on current viewport of canvas to which it was added last.\n     * You might need to call `setCoords` on an object after centering, to update controls area.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ viewportCenter: function() {\n            this.canvas && this.canvas.viewportCenterObject(this);\n            return this;\n        },\n        /**\n     * Returns coordinates of a pointer relative to an object\n     * @param {Event} e Event to operate upon\n     * @param {Object} [pointer] Pointer to operate upon (instead of event)\n     * @return {Object} Coordinates of a pointer (x, y)\n     */ getLocalPointer: function(e, pointer) {\n            pointer = pointer || this.canvas.getPointer(e);\n            var pClicked = new fabric.Point(pointer.x, pointer.y), objectLeftTop = this._getLeftTopCoords();\n            if (this.angle) {\n                pClicked = fabric.util.rotatePoint(pClicked, objectLeftTop, degreesToRadians(-this.angle));\n            }\n            return {\n                x: pClicked.x - objectLeftTop.x,\n                y: pClicked.y - objectLeftTop.y\n            };\n        },\n        /**\n     * Sets canvas globalCompositeOperation for specific object\n     * custom composition operation for the particular object can be specified using globalCompositeOperation property\n     * @param {CanvasRenderingContext2D} ctx Rendering canvas context\n     */ _setupCompositeOperation: function(ctx) {\n            if (this.globalCompositeOperation) {\n                ctx.globalCompositeOperation = this.globalCompositeOperation;\n            }\n        },\n        /**\n     * cancel instance's running animations\n     * override if necessary to dispose artifacts such as `clipPath`\n     */ dispose: function() {\n            if (fabric.runningAnimations) {\n                fabric.runningAnimations.cancelByTarget(this);\n            }\n        }\n    });\n    fabric.util.createAccessors && fabric.util.createAccessors(fabric.Object);\n    extend(fabric.Object.prototype, fabric.Observable);\n    /**\n   * Defines the number of fraction digits to use when serializing object values.\n   * You can use it to increase/decrease precision of such values like left, top, scaleX, scaleY, etc.\n   * @static\n   * @memberOf fabric.Object\n   * @constant\n   * @type Number\n   */ fabric.Object.NUM_FRACTION_DIGITS = 2;\n    /**\n   * Defines which properties should be enlivened from the object passed to {@link fabric.Object._fromObject}\n   * @static\n   * @memberOf fabric.Object\n   * @constant\n   * @type string[]\n   */ fabric.Object.ENLIVEN_PROPS = [\n        \"clipPath\"\n    ];\n    fabric.Object._fromObject = function(className, object, callback, extraParam) {\n        var klass = fabric[className];\n        object = clone(object, true);\n        fabric.util.enlivenPatterns([\n            object.fill,\n            object.stroke\n        ], function(patterns) {\n            if (typeof patterns[0] !== \"undefined\") {\n                object.fill = patterns[0];\n            }\n            if (typeof patterns[1] !== \"undefined\") {\n                object.stroke = patterns[1];\n            }\n            fabric.util.enlivenObjectEnlivables(object, object, function() {\n                var instance = extraParam ? new klass(object[extraParam], object) : new klass(object);\n                callback && callback(instance);\n            });\n        });\n    };\n    /**\n   * Unique id used internally when creating SVG elements\n   * @static\n   * @memberOf fabric.Object\n   * @type Number\n   */ fabric.Object.__uid = 0;\n})( true ? exports : 0);\n(function() {\n    var degreesToRadians = fabric.util.degreesToRadians, originXOffset = {\n        left: -0.5,\n        center: 0,\n        right: 0.5\n    }, originYOffset = {\n        top: -0.5,\n        center: 0,\n        bottom: 0.5\n    };\n    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n        /**\n     * Translates the coordinates from a set of origin to another (based on the object's dimensions)\n     * @param {fabric.Point} point The point which corresponds to the originX and originY params\n     * @param {String} fromOriginX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} fromOriginY Vertical origin: 'top', 'center' or 'bottom'\n     * @param {String} toOriginX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} toOriginY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {fabric.Point}\n     */ translateToGivenOrigin: function(point, fromOriginX, fromOriginY, toOriginX, toOriginY) {\n            var x = point.x, y = point.y, offsetX, offsetY, dim;\n            if (typeof fromOriginX === \"string\") {\n                fromOriginX = originXOffset[fromOriginX];\n            } else {\n                fromOriginX -= 0.5;\n            }\n            if (typeof toOriginX === \"string\") {\n                toOriginX = originXOffset[toOriginX];\n            } else {\n                toOriginX -= 0.5;\n            }\n            offsetX = toOriginX - fromOriginX;\n            if (typeof fromOriginY === \"string\") {\n                fromOriginY = originYOffset[fromOriginY];\n            } else {\n                fromOriginY -= 0.5;\n            }\n            if (typeof toOriginY === \"string\") {\n                toOriginY = originYOffset[toOriginY];\n            } else {\n                toOriginY -= 0.5;\n            }\n            offsetY = toOriginY - fromOriginY;\n            if (offsetX || offsetY) {\n                dim = this._getTransformedDimensions();\n                x = point.x + offsetX * dim.x;\n                y = point.y + offsetY * dim.y;\n            }\n            return new fabric.Point(x, y);\n        },\n        /**\n     * Translates the coordinates from origin to center coordinates (based on the object's dimensions)\n     * @param {fabric.Point} point The point which corresponds to the originX and originY params\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {fabric.Point}\n     */ translateToCenterPoint: function(point, originX, originY) {\n            var p = this.translateToGivenOrigin(point, originX, originY, \"center\", \"center\");\n            if (this.angle) {\n                return fabric.util.rotatePoint(p, point, degreesToRadians(this.angle));\n            }\n            return p;\n        },\n        /**\n     * Translates the coordinates from center to origin coordinates (based on the object's dimensions)\n     * @param {fabric.Point} center The point which corresponds to center of the object\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {fabric.Point}\n     */ translateToOriginPoint: function(center, originX, originY) {\n            var p = this.translateToGivenOrigin(center, \"center\", \"center\", originX, originY);\n            if (this.angle) {\n                return fabric.util.rotatePoint(p, center, degreesToRadians(this.angle));\n            }\n            return p;\n        },\n        /**\n     * Returns the real center coordinates of the object\n     * @return {fabric.Point}\n     */ getCenterPoint: function() {\n            var leftTop = new fabric.Point(this.left, this.top);\n            return this.translateToCenterPoint(leftTop, this.originX, this.originY);\n        },\n        /**\n     * Returns the coordinates of the object based on center coordinates\n     * @param {fabric.Point} point The point which corresponds to the originX and originY params\n     * @return {fabric.Point}\n     */ // getOriginPoint: function(center) {\n        //   return this.translateToOriginPoint(center, this.originX, this.originY);\n        // },\n        /**\n     * Returns the coordinates of the object as if it has a different origin\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {fabric.Point}\n     */ getPointByOrigin: function(originX, originY) {\n            var center = this.getCenterPoint();\n            return this.translateToOriginPoint(center, originX, originY);\n        },\n        /**\n     * Returns the point in local coordinates\n     * @param {fabric.Point} point The point relative to the global coordinate system\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {fabric.Point}\n     */ toLocalPoint: function(point, originX, originY) {\n            var center = this.getCenterPoint(), p, p2;\n            if (typeof originX !== \"undefined\" && typeof originY !== \"undefined\") {\n                p = this.translateToGivenOrigin(center, \"center\", \"center\", originX, originY);\n            } else {\n                p = new fabric.Point(this.left, this.top);\n            }\n            p2 = new fabric.Point(point.x, point.y);\n            if (this.angle) {\n                p2 = fabric.util.rotatePoint(p2, center, -degreesToRadians(this.angle));\n            }\n            return p2.subtractEquals(p);\n        },\n        /**\n     * Returns the point in global coordinates\n     * @param {fabric.Point} The point relative to the local coordinate system\n     * @return {fabric.Point}\n     */ // toGlobalPoint: function(point) {\n        //   return fabric.util.rotatePoint(point, this.getCenterPoint(), degreesToRadians(this.angle)).addEquals(new fabric.Point(this.left, this.top));\n        // },\n        /**\n     * Sets the position of the object taking into consideration the object's origin\n     * @param {fabric.Point} pos The new position of the object\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\n     * @return {void}\n     */ setPositionByOrigin: function(pos, originX, originY) {\n            var center = this.translateToCenterPoint(pos, originX, originY), position = this.translateToOriginPoint(center, this.originX, this.originY);\n            this.set(\"left\", position.x);\n            this.set(\"top\", position.y);\n        },\n        /**\n     * @param {String} to One of 'left', 'center', 'right'\n     */ adjustPosition: function(to) {\n            var angle = degreesToRadians(this.angle), hypotFull = this.getScaledWidth(), xFull = fabric.util.cos(angle) * hypotFull, yFull = fabric.util.sin(angle) * hypotFull, offsetFrom, offsetTo;\n            //TODO: this function does not consider mixed situation like top, center.\n            if (typeof this.originX === \"string\") {\n                offsetFrom = originXOffset[this.originX];\n            } else {\n                offsetFrom = this.originX - 0.5;\n            }\n            if (typeof to === \"string\") {\n                offsetTo = originXOffset[to];\n            } else {\n                offsetTo = to - 0.5;\n            }\n            this.left += xFull * (offsetTo - offsetFrom);\n            this.top += yFull * (offsetTo - offsetFrom);\n            this.setCoords();\n            this.originX = to;\n        },\n        /**\n     * Sets the origin/position of the object to it's center point\n     * @private\n     * @return {void}\n     */ _setOriginToCenter: function() {\n            this._originalOriginX = this.originX;\n            this._originalOriginY = this.originY;\n            var center = this.getCenterPoint();\n            this.originX = \"center\";\n            this.originY = \"center\";\n            this.left = center.x;\n            this.top = center.y;\n        },\n        /**\n     * Resets the origin/position of the object to it's original origin\n     * @private\n     * @return {void}\n     */ _resetOrigin: function() {\n            var originPoint = this.translateToOriginPoint(this.getCenterPoint(), this._originalOriginX, this._originalOriginY);\n            this.originX = this._originalOriginX;\n            this.originY = this._originalOriginY;\n            this.left = originPoint.x;\n            this.top = originPoint.y;\n            this._originalOriginX = null;\n            this._originalOriginY = null;\n        },\n        /**\n     * @private\n     */ _getLeftTopCoords: function() {\n            return this.translateToOriginPoint(this.getCenterPoint(), \"left\", \"top\");\n        }\n    });\n})();\n(function() {\n    function arrayFromCoords(coords) {\n        return [\n            new fabric.Point(coords.tl.x, coords.tl.y),\n            new fabric.Point(coords.tr.x, coords.tr.y),\n            new fabric.Point(coords.br.x, coords.br.y),\n            new fabric.Point(coords.bl.x, coords.bl.y)\n        ];\n    }\n    var util = fabric.util, degreesToRadians = util.degreesToRadians, multiplyMatrices = util.multiplyTransformMatrices, transformPoint = util.transformPoint;\n    util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n        /**\n     * Describe object's corner position in canvas element coordinates.\n     * properties are depending on control keys and padding the main controls.\n     * each property is an object with x, y and corner.\n     * The `corner` property contains in a similar manner the 4 points of the\n     * interactive area of the corner.\n     * The coordinates depends from the controls positionHandler and are used\n     * to draw and locate controls\n     * @memberOf fabric.Object.prototype\n     */ oCoords: null,\n        /**\n     * Describe object's corner position in canvas object absolute coordinates\n     * properties are tl,tr,bl,br and describe the four main corner.\n     * each property is an object with x, y, instance of Fabric.Point.\n     * The coordinates depends from this properties: width, height, scaleX, scaleY\n     * skewX, skewY, angle, strokeWidth, top, left.\n     * Those coordinates are useful to understand where an object is. They get updated\n     * with oCoords but they do not need to be updated when zoom or panning change.\n     * The coordinates get updated with @method setCoords.\n     * You can calculate them without updating with @method calcACoords();\n     * @memberOf fabric.Object.prototype\n     */ aCoords: null,\n        /**\n     * Describe object's corner position in canvas element coordinates.\n     * includes padding. Used of object detection.\n     * set and refreshed with setCoords.\n     * @memberOf fabric.Object.prototype\n     */ lineCoords: null,\n        /**\n     * storage for object transform matrix\n     */ ownMatrixCache: null,\n        /**\n     * storage for object full transform matrix\n     */ matrixCache: null,\n        /**\n     * custom controls interface\n     * controls are added by default_controls.js\n     */ controls: {},\n        /**\n     * return correct set of coordinates for intersection\n     * this will return either aCoords or lineCoords.\n     * @param {Boolean} absolute will return aCoords if true or lineCoords\n     * @return {Object} {tl, tr, br, bl} points\n     */ _getCoords: function(absolute, calculate) {\n            if (calculate) {\n                return absolute ? this.calcACoords() : this.calcLineCoords();\n            }\n            if (!this.aCoords || !this.lineCoords) {\n                this.setCoords(true);\n            }\n            return absolute ? this.aCoords : this.lineCoords;\n        },\n        /**\n     * return correct set of coordinates for intersection\n     * this will return either aCoords or lineCoords.\n     * The coords are returned in an array.\n     * @return {Array} [tl, tr, br, bl] of points\n     */ getCoords: function(absolute, calculate) {\n            return arrayFromCoords(this._getCoords(absolute, calculate));\n        },\n        /**\n     * Checks if object intersects with an area formed by 2 points\n     * @param {Object} pointTL top-left point of area\n     * @param {Object} pointBR bottom-right point of area\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if object intersects with an area formed by 2 points\n     */ intersectsWithRect: function(pointTL, pointBR, absolute, calculate) {\n            var coords = this.getCoords(absolute, calculate), intersection = fabric.Intersection.intersectPolygonRectangle(coords, pointTL, pointBR);\n            return intersection.status === \"Intersection\";\n        },\n        /**\n     * Checks if object intersects with another object\n     * @param {Object} other Object to test\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if object intersects with another object\n     */ intersectsWithObject: function(other, absolute, calculate) {\n            var intersection = fabric.Intersection.intersectPolygonPolygon(this.getCoords(absolute, calculate), other.getCoords(absolute, calculate));\n            return intersection.status === \"Intersection\" || other.isContainedWithinObject(this, absolute, calculate) || this.isContainedWithinObject(other, absolute, calculate);\n        },\n        /**\n     * Checks if object is fully contained within area of another object\n     * @param {Object} other Object to test\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if object is fully contained within area of another object\n     */ isContainedWithinObject: function(other, absolute, calculate) {\n            var points = this.getCoords(absolute, calculate), otherCoords = absolute ? other.aCoords : other.lineCoords, i = 0, lines = other._getImageLines(otherCoords);\n            for(; i < 4; i++){\n                if (!other.containsPoint(points[i], lines)) {\n                    return false;\n                }\n            }\n            return true;\n        },\n        /**\n     * Checks if object is fully contained within area formed by 2 points\n     * @param {Object} pointTL top-left point of area\n     * @param {Object} pointBR bottom-right point of area\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if object is fully contained within area formed by 2 points\n     */ isContainedWithinRect: function(pointTL, pointBR, absolute, calculate) {\n            var boundingRect = this.getBoundingRect(absolute, calculate);\n            return boundingRect.left >= pointTL.x && boundingRect.left + boundingRect.width <= pointBR.x && boundingRect.top >= pointTL.y && boundingRect.top + boundingRect.height <= pointBR.y;\n        },\n        /**\n     * Checks if point is inside the object\n     * @param {fabric.Point} point Point to check against\n     * @param {Object} [lines] object returned from @method _getImageLines\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if point is inside the object\n     */ containsPoint: function(point, lines, absolute, calculate) {\n            var coords = this._getCoords(absolute, calculate), lines = lines || this._getImageLines(coords), xPoints = this._findCrossPoints(point, lines);\n            // if xPoints is odd then point is inside the object\n            return xPoints !== 0 && xPoints % 2 === 1;\n        },\n        /**\n     * Checks if object is contained within the canvas with current viewportTransform\n     * the check is done stopping at first point that appears on screen\n     * @param {Boolean} [calculate] use coordinates of current position instead of .aCoords\n     * @return {Boolean} true if object is fully or partially contained within canvas\n     */ isOnScreen: function(calculate) {\n            if (!this.canvas) {\n                return false;\n            }\n            var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;\n            var points = this.getCoords(true, calculate);\n            // if some point is on screen, the object is on screen.\n            if (points.some(function(point) {\n                return point.x <= pointBR.x && point.x >= pointTL.x && point.y <= pointBR.y && point.y >= pointTL.y;\n            })) {\n                return true;\n            }\n            // no points on screen, check intersection with absolute coordinates\n            if (this.intersectsWithRect(pointTL, pointBR, true, calculate)) {\n                return true;\n            }\n            return this._containsCenterOfCanvas(pointTL, pointBR, calculate);\n        },\n        /**\n     * Checks if the object contains the midpoint between canvas extremities\n     * Does not make sense outside the context of isOnScreen and isPartiallyOnScreen\n     * @private\n     * @param {Fabric.Point} pointTL Top Left point\n     * @param {Fabric.Point} pointBR Top Right point\n     * @param {Boolean} calculate use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if the object contains the point\n     */ _containsCenterOfCanvas: function(pointTL, pointBR, calculate) {\n            // worst case scenario the object is so big that contains the screen\n            var centerPoint = {\n                x: (pointTL.x + pointBR.x) / 2,\n                y: (pointTL.y + pointBR.y) / 2\n            };\n            if (this.containsPoint(centerPoint, null, true, calculate)) {\n                return true;\n            }\n            return false;\n        },\n        /**\n     * Checks if object is partially contained within the canvas with current viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords\n     * @return {Boolean} true if object is partially contained within canvas\n     */ isPartiallyOnScreen: function(calculate) {\n            if (!this.canvas) {\n                return false;\n            }\n            var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;\n            if (this.intersectsWithRect(pointTL, pointBR, true, calculate)) {\n                return true;\n            }\n            var allPointsAreOutside = this.getCoords(true, calculate).every(function(point) {\n                return (point.x >= pointBR.x || point.x <= pointTL.x) && (point.y >= pointBR.y || point.y <= pointTL.y);\n            });\n            return allPointsAreOutside && this._containsCenterOfCanvas(pointTL, pointBR, calculate);\n        },\n        /**\n     * Method that returns an object with the object edges in it, given the coordinates of the corners\n     * @private\n     * @param {Object} oCoords Coordinates of the object corners\n     */ _getImageLines: function(oCoords) {\n            var lines = {\n                topline: {\n                    o: oCoords.tl,\n                    d: oCoords.tr\n                },\n                rightline: {\n                    o: oCoords.tr,\n                    d: oCoords.br\n                },\n                bottomline: {\n                    o: oCoords.br,\n                    d: oCoords.bl\n                },\n                leftline: {\n                    o: oCoords.bl,\n                    d: oCoords.tl\n                }\n            };\n            // // debugging\n            // if (this.canvas.contextTop) {\n            //   this.canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);\n            //   this.canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);\n            //\n            //   this.canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);\n            //   this.canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);\n            //\n            //   this.canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);\n            //   this.canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);\n            //\n            //   this.canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);\n            //   this.canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);\n            // }\n            return lines;\n        },\n        /**\n     * Helper method to determine how many cross points are between the 4 object edges\n     * and the horizontal line determined by a point on canvas\n     * @private\n     * @param {fabric.Point} point Point to check\n     * @param {Object} lines Coordinates of the object being evaluated\n     */ // remove yi, not used but left code here just in case.\n        _findCrossPoints: function(point, lines) {\n            var b1, b2, a1, a2, xi, xcount = 0, iLine;\n            for(var lineKey in lines){\n                iLine = lines[lineKey];\n                // optimisation 1: line below point. no cross\n                if (iLine.o.y < point.y && iLine.d.y < point.y) {\n                    continue;\n                }\n                // optimisation 2: line above point. no cross\n                if (iLine.o.y >= point.y && iLine.d.y >= point.y) {\n                    continue;\n                }\n                // optimisation 3: vertical line case\n                if (iLine.o.x === iLine.d.x && iLine.o.x >= point.x) {\n                    xi = iLine.o.x;\n                // yi = point.y;\n                } else {\n                    b1 = 0;\n                    b2 = (iLine.d.y - iLine.o.y) / (iLine.d.x - iLine.o.x);\n                    a1 = point.y - b1 * point.x;\n                    a2 = iLine.o.y - b2 * iLine.o.x;\n                    xi = -(a1 - a2) / (b1 - b2);\n                // yi = a1 + b1 * xi;\n                }\n                // dont count xi < point.x cases\n                if (xi >= point.x) {\n                    xcount += 1;\n                }\n                // optimisation 4: specific for square images\n                if (xcount === 2) {\n                    break;\n                }\n            }\n            return xcount;\n        },\n        /**\n     * Returns coordinates of object's bounding rectangle (left, top, width, height)\n     * the box is intended as aligned to axis of canvas.\n     * @param {Boolean} [absolute] use coordinates without viewportTransform\n     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords / .aCoords\n     * @return {Object} Object with left, top, width, height properties\n     */ getBoundingRect: function(absolute, calculate) {\n            var coords = this.getCoords(absolute, calculate);\n            return util.makeBoundingBoxFromPoints(coords);\n        },\n        /**\n     * Returns width of an object's bounding box counting transformations\n     * before 2.0 it was named getWidth();\n     * @return {Number} width value\n     */ getScaledWidth: function() {\n            return this._getTransformedDimensions().x;\n        },\n        /**\n     * Returns height of an object bounding box counting transformations\n     * before 2.0 it was named getHeight();\n     * @return {Number} height value\n     */ getScaledHeight: function() {\n            return this._getTransformedDimensions().y;\n        },\n        /**\n     * Makes sure the scale is valid and modifies it if necessary\n     * @private\n     * @param {Number} value\n     * @return {Number}\n     */ _constrainScale: function(value) {\n            if (Math.abs(value) < this.minScaleLimit) {\n                if (value < 0) {\n                    return -this.minScaleLimit;\n                } else {\n                    return this.minScaleLimit;\n                }\n            } else if (value === 0) {\n                return 0.0001;\n            }\n            return value;\n        },\n        /**\n     * Scales an object (equally by x and y)\n     * @param {Number} value Scale factor\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ scale: function(value) {\n            this._set(\"scaleX\", value);\n            this._set(\"scaleY\", value);\n            return this.setCoords();\n        },\n        /**\n     * Scales an object to a given width, with respect to bounding box (scaling by x/y equally)\n     * @param {Number} value New width value\n     * @param {Boolean} absolute ignore viewport\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ scaleToWidth: function(value, absolute) {\n            // adjust to bounding rect factor so that rotated shapes would fit as well\n            var boundingRectFactor = this.getBoundingRect(absolute).width / this.getScaledWidth();\n            return this.scale(value / this.width / boundingRectFactor);\n        },\n        /**\n     * Scales an object to a given height, with respect to bounding box (scaling by x/y equally)\n     * @param {Number} value New height value\n     * @param {Boolean} absolute ignore viewport\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ scaleToHeight: function(value, absolute) {\n            // adjust to bounding rect factor so that rotated shapes would fit as well\n            var boundingRectFactor = this.getBoundingRect(absolute).height / this.getScaledHeight();\n            return this.scale(value / this.height / boundingRectFactor);\n        },\n        calcLineCoords: function() {\n            var vpt = this.getViewportTransform(), padding = this.padding, angle = degreesToRadians(this.angle), cos = util.cos(angle), sin = util.sin(angle), cosP = cos * padding, sinP = sin * padding, cosPSinP = cosP + sinP, cosPMinusSinP = cosP - sinP, aCoords = this.calcACoords();\n            var lineCoords = {\n                tl: transformPoint(aCoords.tl, vpt),\n                tr: transformPoint(aCoords.tr, vpt),\n                bl: transformPoint(aCoords.bl, vpt),\n                br: transformPoint(aCoords.br, vpt)\n            };\n            if (padding) {\n                lineCoords.tl.x -= cosPMinusSinP;\n                lineCoords.tl.y -= cosPSinP;\n                lineCoords.tr.x += cosPSinP;\n                lineCoords.tr.y -= cosPMinusSinP;\n                lineCoords.bl.x -= cosPSinP;\n                lineCoords.bl.y += cosPMinusSinP;\n                lineCoords.br.x += cosPMinusSinP;\n                lineCoords.br.y += cosPSinP;\n            }\n            return lineCoords;\n        },\n        calcOCoords: function() {\n            var rotateMatrix = this._calcRotateMatrix(), translateMatrix = this._calcTranslateMatrix(), vpt = this.getViewportTransform(), startMatrix = multiplyMatrices(vpt, translateMatrix), finalMatrix = multiplyMatrices(startMatrix, rotateMatrix), finalMatrix = multiplyMatrices(finalMatrix, [\n                1 / vpt[0],\n                0,\n                0,\n                1 / vpt[3],\n                0,\n                0\n            ]), dim = this._calculateCurrentDimensions(), coords = {};\n            this.forEachControl(function(control, key, fabricObject) {\n                coords[key] = control.positionHandler(dim, finalMatrix, fabricObject);\n            });\n            // debug code\n            // var canvas = this.canvas;\n            // setTimeout(function() {\n            //   canvas.contextTop.clearRect(0, 0, 700, 700);\n            //   canvas.contextTop.fillStyle = 'green';\n            //   Object.keys(coords).forEach(function(key) {\n            //     var control = coords[key];\n            //     canvas.contextTop.fillRect(control.x, control.y, 3, 3);\n            //   });\n            // }, 50);\n            return coords;\n        },\n        calcACoords: function() {\n            var rotateMatrix = this._calcRotateMatrix(), translateMatrix = this._calcTranslateMatrix(), finalMatrix = multiplyMatrices(translateMatrix, rotateMatrix), dim = this._getTransformedDimensions(), w = dim.x / 2, h = dim.y / 2;\n            return {\n                // corners\n                tl: transformPoint({\n                    x: -w,\n                    y: -h\n                }, finalMatrix),\n                tr: transformPoint({\n                    x: w,\n                    y: -h\n                }, finalMatrix),\n                bl: transformPoint({\n                    x: -w,\n                    y: h\n                }, finalMatrix),\n                br: transformPoint({\n                    x: w,\n                    y: h\n                }, finalMatrix)\n            };\n        },\n        /**\n     * Sets corner and controls position coordinates based on current angle, width and height, left and top.\n     * oCoords are used to find the corners\n     * aCoords are used to quickly find an object on the canvas\n     * lineCoords are used to quickly find object during pointer events.\n     * See {@link https://github.com/fabricjs/fabric.js/wiki/When-to-call-setCoords} and {@link http://fabricjs.com/fabric-gotchas}\n     *\n     * @param {Boolean} [skipCorners] skip calculation of oCoords.\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ setCoords: function(skipCorners) {\n            this.aCoords = this.calcACoords();\n            // in case we are in a group, for how the inner group target check works,\n            // lineCoords are exactly aCoords. Since the vpt gets absorbed by the normalized pointer.\n            this.lineCoords = this.group ? this.aCoords : this.calcLineCoords();\n            if (skipCorners) {\n                return this;\n            }\n            // set coordinates of the draggable boxes in the corners used to scale/rotate the image\n            this.oCoords = this.calcOCoords();\n            this._setCornerCoords && this._setCornerCoords();\n            return this;\n        },\n        /**\n     * calculate rotation matrix of an object\n     * @return {Array} rotation matrix for the object\n     */ _calcRotateMatrix: function() {\n            return util.calcRotateMatrix(this);\n        },\n        /**\n     * calculate the translation matrix for an object transform\n     * @return {Array} rotation matrix for the object\n     */ _calcTranslateMatrix: function() {\n            var center = this.getCenterPoint();\n            return [\n                1,\n                0,\n                0,\n                1,\n                center.x,\n                center.y\n            ];\n        },\n        transformMatrixKey: function(skipGroup) {\n            var sep = \"_\", prefix = \"\";\n            if (!skipGroup && this.group) {\n                prefix = this.group.transformMatrixKey(skipGroup) + sep;\n            }\n            ;\n            return prefix + this.top + sep + this.left + sep + this.scaleX + sep + this.scaleY + sep + this.skewX + sep + this.skewY + sep + this.angle + sep + this.originX + sep + this.originY + sep + this.width + sep + this.height + sep + this.strokeWidth + this.flipX + this.flipY;\n        },\n        /**\n     * calculate transform matrix that represents the current transformations from the\n     * object's properties.\n     * @param {Boolean} [skipGroup] return transform matrix for object not counting parent transformations\n     * There are some situation in which this is useful to avoid the fake rotation.\n     * @return {Array} transform matrix for the object\n     */ calcTransformMatrix: function(skipGroup) {\n            var matrix = this.calcOwnMatrix();\n            if (skipGroup || !this.group) {\n                return matrix;\n            }\n            var key = this.transformMatrixKey(skipGroup), cache = this.matrixCache || (this.matrixCache = {});\n            if (cache.key === key) {\n                return cache.value;\n            }\n            if (this.group) {\n                matrix = multiplyMatrices(this.group.calcTransformMatrix(false), matrix);\n            }\n            cache.key = key;\n            cache.value = matrix;\n            return matrix;\n        },\n        /**\n     * calculate transform matrix that represents the current transformations from the\n     * object's properties, this matrix does not include the group transformation\n     * @return {Array} transform matrix for the object\n     */ calcOwnMatrix: function() {\n            var key = this.transformMatrixKey(true), cache = this.ownMatrixCache || (this.ownMatrixCache = {});\n            if (cache.key === key) {\n                return cache.value;\n            }\n            var tMatrix = this._calcTranslateMatrix(), options = {\n                angle: this.angle,\n                translateX: tMatrix[4],\n                translateY: tMatrix[5],\n                scaleX: this.scaleX,\n                scaleY: this.scaleY,\n                skewX: this.skewX,\n                skewY: this.skewY,\n                flipX: this.flipX,\n                flipY: this.flipY\n            };\n            cache.key = key;\n            cache.value = util.composeMatrix(options);\n            return cache.value;\n        },\n        /*\n     * Calculate object dimensions from its properties\n     * @private\n     * @return {Object} .x width dimension\n     * @return {Object} .y height dimension\n     */ _getNonTransformedDimensions: function() {\n            var strokeWidth = this.strokeWidth, w = this.width + strokeWidth, h = this.height + strokeWidth;\n            return {\n                x: w,\n                y: h\n            };\n        },\n        /*\n     * Calculate object bounding box dimensions from its properties scale, skew.\n     * @param {Number} skewX, a value to override current skewX\n     * @param {Number} skewY, a value to override current skewY\n     * @private\n     * @return {Object} .x width dimension\n     * @return {Object} .y height dimension\n     */ _getTransformedDimensions: function(skewX, skewY) {\n            if (typeof skewX === \"undefined\") {\n                skewX = this.skewX;\n            }\n            if (typeof skewY === \"undefined\") {\n                skewY = this.skewY;\n            }\n            var dimensions, dimX, dimY, noSkew = skewX === 0 && skewY === 0;\n            if (this.strokeUniform) {\n                dimX = this.width;\n                dimY = this.height;\n            } else {\n                dimensions = this._getNonTransformedDimensions();\n                dimX = dimensions.x;\n                dimY = dimensions.y;\n            }\n            if (noSkew) {\n                return this._finalizeDimensions(dimX * this.scaleX, dimY * this.scaleY);\n            }\n            var bbox = util.sizeAfterTransform(dimX, dimY, {\n                scaleX: this.scaleX,\n                scaleY: this.scaleY,\n                skewX: skewX,\n                skewY: skewY\n            });\n            return this._finalizeDimensions(bbox.x, bbox.y);\n        },\n        /*\n     * Calculate object bounding box dimensions from its properties scale, skew.\n     * @param Number width width of the bbox\n     * @param Number height height of the bbox\n     * @private\n     * @return {Object} .x finalized width dimension\n     * @return {Object} .y finalized height dimension\n     */ _finalizeDimensions: function(width, height) {\n            return this.strokeUniform ? {\n                x: width + this.strokeWidth,\n                y: height + this.strokeWidth\n            } : {\n                x: width,\n                y: height\n            };\n        },\n        /*\n     * Calculate object dimensions for controls box, including padding and canvas zoom.\n     * and active selection\n     * private\n     */ _calculateCurrentDimensions: function() {\n            var vpt = this.getViewportTransform(), dim = this._getTransformedDimensions(), p = transformPoint(dim, vpt, true);\n            return p.scalarAdd(2 * this.padding);\n        }\n    });\n})();\nfabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n    /**\n   * Moves an object to the bottom of the stack of drawn objects\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ sendToBack: function() {\n        if (this.group) {\n            fabric.StaticCanvas.prototype.sendToBack.call(this.group, this);\n        } else if (this.canvas) {\n            this.canvas.sendToBack(this);\n        }\n        return this;\n    },\n    /**\n   * Moves an object to the top of the stack of drawn objects\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ bringToFront: function() {\n        if (this.group) {\n            fabric.StaticCanvas.prototype.bringToFront.call(this.group, this);\n        } else if (this.canvas) {\n            this.canvas.bringToFront(this);\n        }\n        return this;\n    },\n    /**\n   * Moves an object down in stack of drawn objects\n   * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ sendBackwards: function(intersecting) {\n        if (this.group) {\n            fabric.StaticCanvas.prototype.sendBackwards.call(this.group, this, intersecting);\n        } else if (this.canvas) {\n            this.canvas.sendBackwards(this, intersecting);\n        }\n        return this;\n    },\n    /**\n   * Moves an object up in stack of drawn objects\n   * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ bringForward: function(intersecting) {\n        if (this.group) {\n            fabric.StaticCanvas.prototype.bringForward.call(this.group, this, intersecting);\n        } else if (this.canvas) {\n            this.canvas.bringForward(this, intersecting);\n        }\n        return this;\n    },\n    /**\n   * Moves an object to specified level in stack of drawn objects\n   * @param {Number} index New position of object\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ moveTo: function(index) {\n        if (this.group && this.group.type !== \"activeSelection\") {\n            fabric.StaticCanvas.prototype.moveTo.call(this.group, this, index);\n        } else if (this.canvas) {\n            this.canvas.moveTo(this, index);\n        }\n        return this;\n    }\n});\n/* _TO_SVG_START_ */ (function() {\n    function getSvgColorString(prop, value) {\n        if (!value) {\n            return prop + \": none; \";\n        } else if (value.toLive) {\n            return prop + \": url(#SVGID_\" + value.id + \"); \";\n        } else {\n            var color = new fabric.Color(value), str = prop + \": \" + color.toRgb() + \"; \", opacity = color.getAlpha();\n            if (opacity !== 1) {\n                //change the color in rgb + opacity\n                str += prop + \"-opacity: \" + opacity.toString() + \"; \";\n            }\n            return str;\n        }\n    }\n    var toFixed = fabric.util.toFixed;\n    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n        /**\n     * Returns styles-string for svg-export\n     * @param {Boolean} skipShadow a boolean to skip shadow filter output\n     * @return {String}\n     */ getSvgStyles: function(skipShadow) {\n            var fillRule = this.fillRule ? this.fillRule : \"nonzero\", strokeWidth = this.strokeWidth ? this.strokeWidth : \"0\", strokeDashArray = this.strokeDashArray ? this.strokeDashArray.join(\" \") : \"none\", strokeDashOffset = this.strokeDashOffset ? this.strokeDashOffset : \"0\", strokeLineCap = this.strokeLineCap ? this.strokeLineCap : \"butt\", strokeLineJoin = this.strokeLineJoin ? this.strokeLineJoin : \"miter\", strokeMiterLimit = this.strokeMiterLimit ? this.strokeMiterLimit : \"4\", opacity = typeof this.opacity !== \"undefined\" ? this.opacity : \"1\", visibility = this.visible ? \"\" : \" visibility: hidden;\", filter = skipShadow ? \"\" : this.getSvgFilter(), fill = getSvgColorString(\"fill\", this.fill), stroke = getSvgColorString(\"stroke\", this.stroke);\n            return [\n                stroke,\n                \"stroke-width: \",\n                strokeWidth,\n                \"; \",\n                \"stroke-dasharray: \",\n                strokeDashArray,\n                \"; \",\n                \"stroke-linecap: \",\n                strokeLineCap,\n                \"; \",\n                \"stroke-dashoffset: \",\n                strokeDashOffset,\n                \"; \",\n                \"stroke-linejoin: \",\n                strokeLineJoin,\n                \"; \",\n                \"stroke-miterlimit: \",\n                strokeMiterLimit,\n                \"; \",\n                fill,\n                \"fill-rule: \",\n                fillRule,\n                \"; \",\n                \"opacity: \",\n                opacity,\n                \";\",\n                filter,\n                visibility\n            ].join(\"\");\n        },\n        /**\n     * Returns styles-string for svg-export\n     * @param {Object} style the object from which to retrieve style properties\n     * @param {Boolean} useWhiteSpace a boolean to include an additional attribute in the style.\n     * @return {String}\n     */ getSvgSpanStyles: function(style, useWhiteSpace) {\n            var term = \"; \";\n            var fontFamily = style.fontFamily ? \"font-family: \" + (style.fontFamily.indexOf(\"'\") === -1 && style.fontFamily.indexOf('\"') === -1 ? \"'\" + style.fontFamily + \"'\" : style.fontFamily) + term : \"\";\n            var strokeWidth = style.strokeWidth ? \"stroke-width: \" + style.strokeWidth + term : \"\", fontFamily = fontFamily, fontSize = style.fontSize ? \"font-size: \" + style.fontSize + \"px\" + term : \"\", fontStyle = style.fontStyle ? \"font-style: \" + style.fontStyle + term : \"\", fontWeight = style.fontWeight ? \"font-weight: \" + style.fontWeight + term : \"\", fill = style.fill ? getSvgColorString(\"fill\", style.fill) : \"\", stroke = style.stroke ? getSvgColorString(\"stroke\", style.stroke) : \"\", textDecoration = this.getSvgTextDecoration(style), deltaY = style.deltaY ? \"baseline-shift: \" + -style.deltaY + \"; \" : \"\";\n            if (textDecoration) {\n                textDecoration = \"text-decoration: \" + textDecoration + term;\n            }\n            return [\n                stroke,\n                strokeWidth,\n                fontFamily,\n                fontSize,\n                fontStyle,\n                fontWeight,\n                textDecoration,\n                fill,\n                deltaY,\n                useWhiteSpace ? \"white-space: pre; \" : \"\"\n            ].join(\"\");\n        },\n        /**\n     * Returns text-decoration property for svg-export\n     * @param {Object} style the object from which to retrieve style properties\n     * @return {String}\n     */ getSvgTextDecoration: function(style) {\n            return [\n                \"overline\",\n                \"underline\",\n                \"line-through\"\n            ].filter(function(decoration) {\n                return style[decoration.replace(\"-\", \"\")];\n            }).join(\" \");\n        },\n        /**\n     * Returns filter for svg shadow\n     * @return {String}\n     */ getSvgFilter: function() {\n            return this.shadow ? \"filter: url(#SVGID_\" + this.shadow.id + \");\" : \"\";\n        },\n        /**\n     * Returns id attribute for svg output\n     * @return {String}\n     */ getSvgCommons: function() {\n            return [\n                this.id ? 'id=\"' + this.id + '\" ' : \"\",\n                this.clipPath ? 'clip-path=\"url(#' + this.clipPath.clipPathId + ')\" ' : \"\"\n            ].join(\"\");\n        },\n        /**\n     * Returns transform-string for svg-export\n     * @param {Boolean} use the full transform or the single object one.\n     * @return {String}\n     */ getSvgTransform: function(full, additionalTransform) {\n            var transform = full ? this.calcTransformMatrix() : this.calcOwnMatrix(), svgTransform = 'transform=\"' + fabric.util.matrixToSVG(transform);\n            return svgTransform + (additionalTransform || \"\") + '\" ';\n        },\n        _setSVGBg: function(textBgRects) {\n            if (this.backgroundColor) {\n                var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;\n                textBgRects.push(\"\t\t<rect \", this._getFillAttributes(this.backgroundColor), ' x=\"', toFixed(-this.width / 2, NUM_FRACTION_DIGITS), '\" y=\"', toFixed(-this.height / 2, NUM_FRACTION_DIGITS), '\" width=\"', toFixed(this.width, NUM_FRACTION_DIGITS), '\" height=\"', toFixed(this.height, NUM_FRACTION_DIGITS), '\"></rect>\\n');\n            }\n        },\n        /**\n     * Returns svg representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ toSVG: function(reviver) {\n            return this._createBaseSVGMarkup(this._toSVG(reviver), {\n                reviver: reviver\n            });\n        },\n        /**\n     * Returns svg clipPath representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ toClipPathSVG: function(reviver) {\n            return \"\t\" + this._createBaseClipPathSVGMarkup(this._toSVG(reviver), {\n                reviver: reviver\n            });\n        },\n        /**\n     * @private\n     */ _createBaseClipPathSVGMarkup: function(objectMarkup, options) {\n            options = options || {};\n            var reviver = options.reviver, additionalTransform = options.additionalTransform || \"\", commonPieces = [\n                this.getSvgTransform(true, additionalTransform),\n                this.getSvgCommons()\n            ].join(\"\"), // insert commons in the markup, style and svgCommons\n            index = objectMarkup.indexOf(\"COMMON_PARTS\");\n            objectMarkup[index] = commonPieces;\n            return reviver ? reviver(objectMarkup.join(\"\")) : objectMarkup.join(\"\");\n        },\n        /**\n     * @private\n     */ _createBaseSVGMarkup: function(objectMarkup, options) {\n            options = options || {};\n            var noStyle = options.noStyle, reviver = options.reviver, styleInfo = noStyle ? \"\" : 'style=\"' + this.getSvgStyles() + '\" ', shadowInfo = options.withShadow ? 'style=\"' + this.getSvgFilter() + '\" ' : \"\", clipPath = this.clipPath, vectorEffect = this.strokeUniform ? 'vector-effect=\"non-scaling-stroke\" ' : \"\", absoluteClipPath = clipPath && clipPath.absolutePositioned, stroke = this.stroke, fill = this.fill, shadow = this.shadow, commonPieces, markup = [], clipPathMarkup, // insert commons in the markup, style and svgCommons\n            index = objectMarkup.indexOf(\"COMMON_PARTS\"), additionalTransform = options.additionalTransform;\n            if (clipPath) {\n                clipPath.clipPathId = \"CLIPPATH_\" + fabric.Object.__uid++;\n                clipPathMarkup = '<clipPath id=\"' + clipPath.clipPathId + '\" >\\n' + clipPath.toClipPathSVG(reviver) + \"</clipPath>\\n\";\n            }\n            if (absoluteClipPath) {\n                markup.push(\"<g \", shadowInfo, this.getSvgCommons(), \" >\\n\");\n            }\n            markup.push(\"<g \", this.getSvgTransform(false), !absoluteClipPath ? shadowInfo + this.getSvgCommons() : \"\", \" >\\n\");\n            commonPieces = [\n                styleInfo,\n                vectorEffect,\n                noStyle ? \"\" : this.addPaintOrder(),\n                \" \",\n                additionalTransform ? 'transform=\"' + additionalTransform + '\" ' : \"\"\n            ].join(\"\");\n            objectMarkup[index] = commonPieces;\n            if (fill && fill.toLive) {\n                markup.push(fill.toSVG(this));\n            }\n            if (stroke && stroke.toLive) {\n                markup.push(stroke.toSVG(this));\n            }\n            if (shadow) {\n                markup.push(shadow.toSVG(this));\n            }\n            if (clipPath) {\n                markup.push(clipPathMarkup);\n            }\n            markup.push(objectMarkup.join(\"\"));\n            markup.push(\"</g>\\n\");\n            absoluteClipPath && markup.push(\"</g>\\n\");\n            return reviver ? reviver(markup.join(\"\")) : markup.join(\"\");\n        },\n        addPaintOrder: function() {\n            return this.paintFirst !== \"fill\" ? ' paint-order=\"' + this.paintFirst + '\" ' : \"\";\n        }\n    });\n})();\n/* _TO_SVG_END_ */ (function() {\n    var extend = fabric.util.object.extend, originalSet = \"stateProperties\";\n    /*\n    Depends on `stateProperties`\n  */ function saveProps(origin, destination, props) {\n        var tmpObj = {}, deep = true;\n        props.forEach(function(prop) {\n            tmpObj[prop] = origin[prop];\n        });\n        extend(origin[destination], tmpObj, deep);\n    }\n    function _isEqual(origValue, currentValue, firstPass) {\n        if (origValue === currentValue) {\n            // if the objects are identical, return\n            return true;\n        } else if (Array.isArray(origValue)) {\n            if (!Array.isArray(currentValue) || origValue.length !== currentValue.length) {\n                return false;\n            }\n            for(var i = 0, len = origValue.length; i < len; i++){\n                if (!_isEqual(origValue[i], currentValue[i])) {\n                    return false;\n                }\n            }\n            return true;\n        } else if (origValue && typeof origValue === \"object\") {\n            var keys = Object.keys(origValue), key;\n            if (!currentValue || typeof currentValue !== \"object\" || !firstPass && keys.length !== Object.keys(currentValue).length) {\n                return false;\n            }\n            for(var i = 0, len = keys.length; i < len; i++){\n                key = keys[i];\n                // since clipPath is in the statefull cache list and the clipPath objects\n                // would be iterated as an object, this would lead to possible infinite recursion\n                // we do not want to compare those.\n                if (key === \"canvas\" || key === \"group\") {\n                    continue;\n                }\n                if (!_isEqual(origValue[key], currentValue[key])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n        /**\n     * Returns true if object state (one of its state properties) was changed\n     * @param {String} [propertySet] optional name for the set of property we want to save\n     * @return {Boolean} true if instance' state has changed since `{@link fabric.Object#saveState}` was called\n     */ hasStateChanged: function(propertySet) {\n            propertySet = propertySet || originalSet;\n            var dashedPropertySet = \"_\" + propertySet;\n            if (Object.keys(this[dashedPropertySet]).length < this[propertySet].length) {\n                return true;\n            }\n            return !_isEqual(this[dashedPropertySet], this, true);\n        },\n        /**\n     * Saves state of an object\n     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state\n     * @return {fabric.Object} thisArg\n     */ saveState: function(options) {\n            var propertySet = options && options.propertySet || originalSet, destination = \"_\" + propertySet;\n            if (!this[destination]) {\n                return this.setupState(options);\n            }\n            saveProps(this, destination, this[propertySet]);\n            if (options && options.stateProperties) {\n                saveProps(this, destination, options.stateProperties);\n            }\n            return this;\n        },\n        /**\n     * Setups state of an object\n     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state\n     * @return {fabric.Object} thisArg\n     */ setupState: function(options) {\n            options = options || {};\n            var propertySet = options.propertySet || originalSet;\n            options.propertySet = propertySet;\n            this[\"_\" + propertySet] = {};\n            this.saveState(options);\n            return this;\n        }\n    });\n})();\n(function() {\n    var degreesToRadians = fabric.util.degreesToRadians;\n    fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n        /**\n     * Determines which corner has been clicked\n     * @private\n     * @param {Object} pointer The pointer indicating the mouse position\n     * @return {String|Boolean} corner code (tl, tr, bl, br, etc.), or false if nothing is found\n     */ _findTargetCorner: function(pointer, forTouch) {\n            // objects in group, anykind, are not self modificable,\n            // must not return an hovered corner.\n            if (!this.hasControls || this.group || !this.canvas || this.canvas._activeObject !== this) {\n                return false;\n            }\n            var ex = pointer.x, ey = pointer.y, xPoints, lines, keys = Object.keys(this.oCoords), j = keys.length - 1, i;\n            this.__corner = 0;\n            // cycle in reverse order so we pick first the one on top\n            for(; j >= 0; j--){\n                i = keys[j];\n                if (!this.isControlVisible(i)) {\n                    continue;\n                }\n                lines = this._getImageLines(forTouch ? this.oCoords[i].touchCorner : this.oCoords[i].corner);\n                // // debugging\n                //\n                // this.canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);\n                // this.canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);\n                //\n                // this.canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);\n                // this.canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);\n                //\n                // this.canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);\n                // this.canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);\n                //\n                // this.canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);\n                // this.canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);\n                xPoints = this._findCrossPoints({\n                    x: ex,\n                    y: ey\n                }, lines);\n                if (xPoints !== 0 && xPoints % 2 === 1) {\n                    this.__corner = i;\n                    return i;\n                }\n            }\n            return false;\n        },\n        /**\n     * Calls a function for each control. The function gets called,\n     * with the control, the object that is calling the iterator and the control's key\n     * @param {Function} fn function to iterate over the controls over\n     */ forEachControl: function(fn) {\n            for(var i in this.controls){\n                fn(this.controls[i], i, this);\n            }\n            ;\n        },\n        /**\n     * Sets the coordinates of the draggable boxes in the corners of\n     * the image used to scale/rotate it.\n     * note: if we would switch to ROUND corner area, all of this would disappear.\n     * everything would resolve to a single point and a pythagorean theorem for the distance\n     * @private\n     */ _setCornerCoords: function() {\n            var coords = this.oCoords;\n            for(var control in coords){\n                var controlObject = this.controls[control];\n                coords[control].corner = controlObject.calcCornerCoords(this.angle, this.cornerSize, coords[control].x, coords[control].y, false);\n                coords[control].touchCorner = controlObject.calcCornerCoords(this.angle, this.touchCornerSize, coords[control].x, coords[control].y, true);\n            }\n        },\n        /**\n     * Draws a colored layer behind the object, inside its selection borders.\n     * Requires public options: padding, selectionBackgroundColor\n     * this function is called when the context is transformed\n     * has checks to be skipped when the object is on a staticCanvas\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ drawSelectionBackground: function(ctx) {\n            if (!this.selectionBackgroundColor || this.canvas && !this.canvas.interactive || this.canvas && this.canvas._activeObject !== this) {\n                return this;\n            }\n            ctx.save();\n            var center = this.getCenterPoint(), wh = this._calculateCurrentDimensions(), vpt = this.canvas.viewportTransform;\n            ctx.translate(center.x, center.y);\n            ctx.scale(1 / vpt[0], 1 / vpt[3]);\n            ctx.rotate(degreesToRadians(this.angle));\n            ctx.fillStyle = this.selectionBackgroundColor;\n            ctx.fillRect(-wh.x / 2, -wh.y / 2, wh.x, wh.y);\n            ctx.restore();\n            return this;\n        },\n        /**\n     * Draws borders of an object's bounding box.\n     * Requires public properties: width, height\n     * Requires public options: padding, borderColor\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\n     * @param {Object} styleOverride object to override the object style\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ drawBorders: function(ctx, styleOverride) {\n            styleOverride = styleOverride || {};\n            var wh = this._calculateCurrentDimensions(), strokeWidth = this.borderScaleFactor, width = wh.x + strokeWidth, height = wh.y + strokeWidth, hasControls = typeof styleOverride.hasControls !== \"undefined\" ? styleOverride.hasControls : this.hasControls, shouldStroke = false;\n            ctx.save();\n            ctx.strokeStyle = styleOverride.borderColor || this.borderColor;\n            this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray);\n            ctx.strokeRect(-width / 2, -height / 2, width, height);\n            if (hasControls) {\n                ctx.beginPath();\n                this.forEachControl(function(control, key, fabricObject) {\n                    // in this moment, the ctx is centered on the object.\n                    // width and height of the above function are the size of the bbox.\n                    if (control.withConnection && control.getVisibility(fabricObject, key)) {\n                        // reset movement for each control\n                        shouldStroke = true;\n                        ctx.moveTo(control.x * width, control.y * height);\n                        ctx.lineTo(control.x * width + control.offsetX, control.y * height + control.offsetY);\n                    }\n                });\n                if (shouldStroke) {\n                    ctx.stroke();\n                }\n            }\n            ctx.restore();\n            return this;\n        },\n        /**\n     * Draws borders of an object's bounding box when it is inside a group.\n     * Requires public properties: width, height\n     * Requires public options: padding, borderColor\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\n     * @param {object} options object representing current object parameters\n     * @param {Object} styleOverride object to override the object style\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ drawBordersInGroup: function(ctx, options, styleOverride) {\n            styleOverride = styleOverride || {};\n            var bbox = fabric.util.sizeAfterTransform(this.width, this.height, options), strokeWidth = this.strokeWidth, strokeUniform = this.strokeUniform, borderScaleFactor = this.borderScaleFactor, width = bbox.x + strokeWidth * (strokeUniform ? this.canvas.getZoom() : options.scaleX) + borderScaleFactor, height = bbox.y + strokeWidth * (strokeUniform ? this.canvas.getZoom() : options.scaleY) + borderScaleFactor;\n            ctx.save();\n            this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray);\n            ctx.strokeStyle = styleOverride.borderColor || this.borderColor;\n            ctx.strokeRect(-width / 2, -height / 2, width, height);\n            ctx.restore();\n            return this;\n        },\n        /**\n     * Draws corners of an object's bounding box.\n     * Requires public properties: width, height\n     * Requires public options: cornerSize, padding\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\n     * @param {Object} styleOverride object to override the object style\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ drawControls: function(ctx, styleOverride) {\n            styleOverride = styleOverride || {};\n            ctx.save();\n            var retinaScaling = 1, matrix, p;\n            if (this.canvas) {\n                retinaScaling = this.canvas.getRetinaScaling();\n            }\n            ctx.setTransform(retinaScaling, 0, 0, retinaScaling, 0, 0);\n            ctx.strokeStyle = ctx.fillStyle = styleOverride.cornerColor || this.cornerColor;\n            if (!this.transparentCorners) {\n                ctx.strokeStyle = styleOverride.cornerStrokeColor || this.cornerStrokeColor;\n            }\n            this._setLineDash(ctx, styleOverride.cornerDashArray || this.cornerDashArray);\n            this.setCoords();\n            if (this.group) {\n                // fabricJS does not really support drawing controls inside groups,\n                // this piece of code here helps having at least the control in places.\n                // If an application needs to show some objects as selected because of some UI state\n                // can still call Object._renderControls() on any object they desire, independently of groups.\n                // using no padding, circular controls and hiding the rotating cursor is higly suggested,\n                matrix = this.group.calcTransformMatrix();\n            }\n            this.forEachControl(function(control, key, fabricObject) {\n                p = fabricObject.oCoords[key];\n                if (control.getVisibility(fabricObject, key)) {\n                    if (matrix) {\n                        p = fabric.util.transformPoint(p, matrix);\n                    }\n                    control.render(ctx, p.x, p.y, styleOverride, fabricObject);\n                }\n            });\n            ctx.restore();\n            return this;\n        },\n        /**\n     * Returns true if the specified control is visible, false otherwise.\n     * @param {String} controlKey The key of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.\n     * @returns {Boolean} true if the specified control is visible, false otherwise\n     */ isControlVisible: function(controlKey) {\n            return this.controls[controlKey] && this.controls[controlKey].getVisibility(this, controlKey);\n        },\n        /**\n     * Sets the visibility of the specified control.\n     * @param {String} controlKey The key of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.\n     * @param {Boolean} visible true to set the specified control visible, false otherwise\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ setControlVisible: function(controlKey, visible) {\n            if (!this._controlsVisibility) {\n                this._controlsVisibility = {};\n            }\n            this._controlsVisibility[controlKey] = visible;\n            return this;\n        },\n        /**\n     * Sets the visibility state of object controls.\n     * @param {Object} [options] Options object\n     * @param {Boolean} [options.bl] true to enable the bottom-left control, false to disable it\n     * @param {Boolean} [options.br] true to enable the bottom-right control, false to disable it\n     * @param {Boolean} [options.mb] true to enable the middle-bottom control, false to disable it\n     * @param {Boolean} [options.ml] true to enable the middle-left control, false to disable it\n     * @param {Boolean} [options.mr] true to enable the middle-right control, false to disable it\n     * @param {Boolean} [options.mt] true to enable the middle-top control, false to disable it\n     * @param {Boolean} [options.tl] true to enable the top-left control, false to disable it\n     * @param {Boolean} [options.tr] true to enable the top-right control, false to disable it\n     * @param {Boolean} [options.mtr] true to enable the middle-top-rotate control, false to disable it\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ setControlsVisibility: function(options) {\n            options || (options = {});\n            for(var p in options){\n                this.setControlVisible(p, options[p]);\n            }\n            return this;\n        },\n        /**\n     * This callback function is called every time _discardActiveObject or _setActiveObject\n     * try to to deselect this object. If the function returns true, the process is cancelled\n     * @param {Object} [options] options sent from the upper functions\n     * @param {Event} [options.e] event if the process is generated by an event\n     */ onDeselect: function() {\n        // implemented by sub-classes, as needed.\n        },\n        /**\n     * This callback function is called every time _discardActiveObject or _setActiveObject\n     * try to to select this object. If the function returns true, the process is cancelled\n     * @param {Object} [options] options sent from the upper functions\n     * @param {Event} [options.e] event if the process is generated by an event\n     */ onSelect: function() {\n        // implemented by sub-classes, as needed.\n        }\n    });\n})();\nfabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\n    /**\n   * Animation duration (in ms) for fx* methods\n   * @type Number\n   * @default\n   */ FX_DURATION: 500,\n    /**\n   * Centers object horizontally with animation.\n   * @param {fabric.Object} object Object to center\n   * @param {Object} [callbacks] Callbacks object with optional \"onComplete\" and/or \"onChange\" properties\n   * @param {Function} [callbacks.onComplete] Invoked on completion\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\n   * @return {fabric.AnimationContext} context\n   */ fxCenterObjectH: function(object, callbacks) {\n        callbacks = callbacks || {};\n        var empty = function() {}, onComplete = callbacks.onComplete || empty, onChange = callbacks.onChange || empty, _this = this;\n        return fabric.util.animate({\n            target: this,\n            startValue: object.left,\n            endValue: this.getCenterPoint().x,\n            duration: this.FX_DURATION,\n            onChange: function(value) {\n                object.set(\"left\", value);\n                _this.requestRenderAll();\n                onChange();\n            },\n            onComplete: function() {\n                object.setCoords();\n                onComplete();\n            }\n        });\n    },\n    /**\n   * Centers object vertically with animation.\n   * @param {fabric.Object} object Object to center\n   * @param {Object} [callbacks] Callbacks object with optional \"onComplete\" and/or \"onChange\" properties\n   * @param {Function} [callbacks.onComplete] Invoked on completion\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\n   * @return {fabric.AnimationContext} context\n   */ fxCenterObjectV: function(object, callbacks) {\n        callbacks = callbacks || {};\n        var empty = function() {}, onComplete = callbacks.onComplete || empty, onChange = callbacks.onChange || empty, _this = this;\n        return fabric.util.animate({\n            target: this,\n            startValue: object.top,\n            endValue: this.getCenterPoint().y,\n            duration: this.FX_DURATION,\n            onChange: function(value) {\n                object.set(\"top\", value);\n                _this.requestRenderAll();\n                onChange();\n            },\n            onComplete: function() {\n                object.setCoords();\n                onComplete();\n            }\n        });\n    },\n    /**\n   * Same as `fabric.Canvas#remove` but animated\n   * @param {fabric.Object} object Object to remove\n   * @param {Object} [callbacks] Callbacks object with optional \"onComplete\" and/or \"onChange\" properties\n   * @param {Function} [callbacks.onComplete] Invoked on completion\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\n   * @return {fabric.AnimationContext} context\n   */ fxRemove: function(object, callbacks) {\n        callbacks = callbacks || {};\n        var empty = function() {}, onComplete = callbacks.onComplete || empty, onChange = callbacks.onChange || empty, _this = this;\n        return fabric.util.animate({\n            target: this,\n            startValue: object.opacity,\n            endValue: 0,\n            duration: this.FX_DURATION,\n            onChange: function(value) {\n                object.set(\"opacity\", value);\n                _this.requestRenderAll();\n                onChange();\n            },\n            onComplete: function() {\n                _this.remove(object);\n                onComplete();\n            }\n        });\n    }\n});\nfabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n    /**\n   * Animates object's properties\n   * @param {String|Object} property Property to animate (if string) or properties to animate (if object)\n   * @param {Number|Object} value Value to animate property to (if string was given first) or options object\n   * @return {fabric.Object} thisArg\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#animation}\n   * @return {fabric.AnimationContext | fabric.AnimationContext[]} animation context (or an array if passed multiple properties)\n   *\n   * As object — multiple properties\n   *\n   * object.animate({ left: ..., top: ... });\n   * object.animate({ left: ..., top: ... }, { duration: ... });\n   *\n   * As string — one property\n   *\n   * object.animate('left', ...);\n   * object.animate('left', { duration: ... });\n   *\n   */ animate: function() {\n        if (arguments[0] && typeof arguments[0] === \"object\") {\n            var propsToAnimate = [], prop, skipCallbacks, out = [];\n            for(prop in arguments[0]){\n                propsToAnimate.push(prop);\n            }\n            for(var i = 0, len = propsToAnimate.length; i < len; i++){\n                prop = propsToAnimate[i];\n                skipCallbacks = i !== len - 1;\n                out.push(this._animate(prop, arguments[0][prop], arguments[1], skipCallbacks));\n            }\n            return out;\n        } else {\n            return this._animate.apply(this, arguments);\n        }\n    },\n    /**\n   * @private\n   * @param {String} property Property to animate\n   * @param {String} to Value to animate to\n   * @param {Object} [options] Options object\n   * @param {Boolean} [skipCallbacks] When true, callbacks like onchange and oncomplete are not invoked\n   */ _animate: function(property, to, options, skipCallbacks) {\n        var _this = this, propPair;\n        to = to.toString();\n        if (!options) {\n            options = {};\n        } else {\n            options = fabric.util.object.clone(options);\n        }\n        if (~property.indexOf(\".\")) {\n            propPair = property.split(\".\");\n        }\n        var propIsColor = _this.colorProperties.indexOf(property) > -1 || propPair && _this.colorProperties.indexOf(propPair[1]) > -1;\n        var currentValue = propPair ? this.get(propPair[0])[propPair[1]] : this.get(property);\n        if (!(\"from\" in options)) {\n            options.from = currentValue;\n        }\n        if (!propIsColor) {\n            if (~to.indexOf(\"=\")) {\n                to = currentValue + parseFloat(to.replace(\"=\", \"\"));\n            } else {\n                to = parseFloat(to);\n            }\n        }\n        var _options = {\n            target: this,\n            startValue: options.from,\n            endValue: to,\n            byValue: options.by,\n            easing: options.easing,\n            duration: options.duration,\n            abort: options.abort && function(value, valueProgress, timeProgress) {\n                return options.abort.call(_this, value, valueProgress, timeProgress);\n            },\n            onChange: function(value, valueProgress, timeProgress) {\n                if (propPair) {\n                    _this[propPair[0]][propPair[1]] = value;\n                } else {\n                    _this.set(property, value);\n                }\n                if (skipCallbacks) {\n                    return;\n                }\n                options.onChange && options.onChange(value, valueProgress, timeProgress);\n            },\n            onComplete: function(value, valueProgress, timeProgress) {\n                if (skipCallbacks) {\n                    return;\n                }\n                _this.setCoords();\n                options.onComplete && options.onComplete(value, valueProgress, timeProgress);\n            }\n        };\n        if (propIsColor) {\n            return fabric.util.animateColor(_options.startValue, _options.endValue, _options.duration, _options);\n        } else {\n            return fabric.util.animate(_options);\n        }\n    }\n});\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, clone = fabric.util.object.clone, coordProps = {\n        x1: 1,\n        x2: 1,\n        y1: 1,\n        y2: 1\n    };\n    if (fabric.Line) {\n        fabric.warn(\"fabric.Line is already defined\");\n        return;\n    }\n    /**\n   * Line class\n   * @class fabric.Line\n   * @extends fabric.Object\n   * @see {@link fabric.Line#initialize} for constructor definition\n   */ fabric.Line = fabric.util.createClass(fabric.Object, /** @lends fabric.Line.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"line\",\n        /**\n     * x value or first line edge\n     * @type Number\n     * @default\n     */ x1: 0,\n        /**\n     * y value or first line edge\n     * @type Number\n     * @default\n     */ y1: 0,\n        /**\n     * x value or second line edge\n     * @type Number\n     * @default\n     */ x2: 0,\n        /**\n     * y value or second line edge\n     * @type Number\n     * @default\n     */ y2: 0,\n        cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"x1\", \"x2\", \"y1\", \"y2\"),\n        /**\n     * Constructor\n     * @param {Array} [points] Array of points\n     * @param {Object} [options] Options object\n     * @return {fabric.Line} thisArg\n     */ initialize: function(points, options) {\n            if (!points) {\n                points = [\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n            }\n            this.callSuper(\"initialize\", options);\n            this.set(\"x1\", points[0]);\n            this.set(\"y1\", points[1]);\n            this.set(\"x2\", points[2]);\n            this.set(\"y2\", points[3]);\n            this._setWidthHeight(options);\n        },\n        /**\n     * @private\n     * @param {Object} [options] Options\n     */ _setWidthHeight: function(options) {\n            options || (options = {});\n            this.width = Math.abs(this.x2 - this.x1);\n            this.height = Math.abs(this.y2 - this.y1);\n            this.left = \"left\" in options ? options.left : this._getLeftToOriginX();\n            this.top = \"top\" in options ? options.top : this._getTopToOriginY();\n        },\n        /**\n     * @private\n     * @param {String} key\n     * @param {*} value\n     */ _set: function(key, value) {\n            this.callSuper(\"_set\", key, value);\n            if (typeof coordProps[key] !== \"undefined\") {\n                this._setWidthHeight();\n            }\n            return this;\n        },\n        /**\n     * @private\n     * @return {Number} leftToOriginX Distance from left edge of canvas to originX of Line.\n     */ _getLeftToOriginX: makeEdgeToOriginGetter({\n            origin: \"originX\",\n            axis1: \"x1\",\n            axis2: \"x2\",\n            dimension: \"width\"\n        }, {\n            nearest: \"left\",\n            center: \"center\",\n            farthest: \"right\"\n        }),\n        /**\n     * @private\n     * @return {Number} topToOriginY Distance from top edge of canvas to originY of Line.\n     */ _getTopToOriginY: makeEdgeToOriginGetter({\n            origin: \"originY\",\n            axis1: \"y1\",\n            axis2: \"y2\",\n            dimension: \"height\"\n        }, {\n            nearest: \"top\",\n            center: \"center\",\n            farthest: \"bottom\"\n        }),\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            ctx.beginPath();\n            var p = this.calcLinePoints();\n            ctx.moveTo(p.x1, p.y1);\n            ctx.lineTo(p.x2, p.y2);\n            ctx.lineWidth = this.strokeWidth;\n            // TODO: test this\n            // make sure setting \"fill\" changes color of a line\n            // (by copying fillStyle to strokeStyle, since line is stroked, not filled)\n            var origStrokeStyle = ctx.strokeStyle;\n            ctx.strokeStyle = this.stroke || ctx.fillStyle;\n            this.stroke && this._renderStroke(ctx);\n            ctx.strokeStyle = origStrokeStyle;\n        },\n        /**\n     * This function is an helper for svg import. it returns the center of the object in the svg\n     * untransformed coordinates\n     * @private\n     * @return {Object} center point from element coordinates\n     */ _findCenterFromElement: function() {\n            return {\n                x: (this.x1 + this.x2) / 2,\n                y: (this.y1 + this.y2) / 2\n            };\n        },\n        /**\n     * Returns object representation of an instance\n     * @method toObject\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return extend(this.callSuper(\"toObject\", propertiesToInclude), this.calcLinePoints());\n        },\n        /*\n     * Calculate object dimensions from its properties\n     * @private\n     */ _getNonTransformedDimensions: function() {\n            var dim = this.callSuper(\"_getNonTransformedDimensions\");\n            if (this.strokeLineCap === \"butt\") {\n                if (this.width === 0) {\n                    dim.y -= this.strokeWidth;\n                }\n                if (this.height === 0) {\n                    dim.x -= this.strokeWidth;\n                }\n            }\n            return dim;\n        },\n        /**\n     * Recalculates line points given width and height\n     * @private\n     */ calcLinePoints: function() {\n            var xMult = this.x1 <= this.x2 ? -1 : 1, yMult = this.y1 <= this.y2 ? -1 : 1, x1 = xMult * this.width * 0.5, y1 = yMult * this.height * 0.5, x2 = xMult * this.width * -0.5, y2 = yMult * this.height * -0.5;\n            return {\n                x1: x1,\n                x2: x2,\n                y1: y1,\n                y2: y2\n            };\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var p = this.calcLinePoints();\n            return [\n                \"<line \",\n                \"COMMON_PARTS\",\n                'x1=\"',\n                p.x1,\n                '\" y1=\"',\n                p.y1,\n                '\" x2=\"',\n                p.x2,\n                '\" y2=\"',\n                p.y2,\n                '\" />\\n'\n            ];\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Line.fromElement})\n   * @static\n   * @memberOf fabric.Line\n   * @see http://www.w3.org/TR/SVG/shapes.html#LineElement\n   */ fabric.Line.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\"x1 y1 x2 y2\".split(\" \"));\n    /**\n   * Returns fabric.Line instance from an SVG element\n   * @static\n   * @memberOf fabric.Line\n   * @param {SVGElement} element Element to parse\n   * @param {Object} [options] Options object\n   * @param {Function} [callback] callback function invoked after parsing\n   */ fabric.Line.fromElement = function(element, callback, options) {\n        options = options || {};\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Line.ATTRIBUTE_NAMES), points = [\n            parsedAttributes.x1 || 0,\n            parsedAttributes.y1 || 0,\n            parsedAttributes.x2 || 0,\n            parsedAttributes.y2 || 0\n        ];\n        callback(new fabric.Line(points, extend(parsedAttributes, options)));\n    };\n    /* _FROM_SVG_END_ */ /**\n   * Returns fabric.Line instance from an object representation\n   * @static\n   * @memberOf fabric.Line\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] invoked with new instance as first argument\n   */ fabric.Line.fromObject = function(object, callback) {\n        function _callback(instance) {\n            delete instance.points;\n            callback && callback(instance);\n        }\n        ;\n        var options = clone(object, true);\n        options.points = [\n            object.x1,\n            object.y1,\n            object.x2,\n            object.y2\n        ];\n        fabric.Object._fromObject(\"Line\", options, _callback, \"points\");\n    };\n    /**\n   * Produces a function that calculates distance from canvas edge to Line origin.\n   */ function makeEdgeToOriginGetter(propertyNames, originValues) {\n        var origin = propertyNames.origin, axis1 = propertyNames.axis1, axis2 = propertyNames.axis2, dimension = propertyNames.dimension, nearest = originValues.nearest, center = originValues.center, farthest = originValues.farthest;\n        return function() {\n            switch(this.get(origin)){\n                case nearest:\n                    return Math.min(this.get(axis1), this.get(axis2));\n                case center:\n                    return Math.min(this.get(axis1), this.get(axis2)) + 0.5 * this.get(dimension);\n                case farthest:\n                    return Math.max(this.get(axis1), this.get(axis2));\n            }\n        };\n    }\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), degreesToRadians = fabric.util.degreesToRadians;\n    if (fabric.Circle) {\n        fabric.warn(\"fabric.Circle is already defined.\");\n        return;\n    }\n    /**\n   * Circle class\n   * @class fabric.Circle\n   * @extends fabric.Object\n   * @see {@link fabric.Circle#initialize} for constructor definition\n   */ fabric.Circle = fabric.util.createClass(fabric.Object, /** @lends fabric.Circle.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"circle\",\n        /**\n     * Radius of this circle\n     * @type Number\n     * @default\n     */ radius: 0,\n        /**\n     * degrees of start of the circle.\n     * probably will change to degrees in next major version\n     * @type Number 0 - 359\n     * @default 0\n     */ startAngle: 0,\n        /**\n     * End angle of the circle\n     * probably will change to degrees in next major version\n     * @type Number 1 - 360\n     * @default 360\n     */ endAngle: 360,\n        cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"radius\", \"startAngle\", \"endAngle\"),\n        /**\n     * @private\n     * @param {String} key\n     * @param {*} value\n     * @return {fabric.Circle} thisArg\n     */ _set: function(key, value) {\n            this.callSuper(\"_set\", key, value);\n            if (key === \"radius\") {\n                this.setRadius(value);\n            }\n            return this;\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return this.callSuper(\"toObject\", [\n                \"radius\",\n                \"startAngle\",\n                \"endAngle\"\n            ].concat(propertiesToInclude));\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var svgString, x = 0, y = 0, angle = (this.endAngle - this.startAngle) % 360;\n            if (angle === 0) {\n                svgString = [\n                    \"<circle \",\n                    \"COMMON_PARTS\",\n                    'cx=\"' + x + '\" cy=\"' + y + '\" ',\n                    'r=\"',\n                    this.radius,\n                    '\" />\\n'\n                ];\n            } else {\n                var start = degreesToRadians(this.startAngle), end = degreesToRadians(this.endAngle), radius = this.radius, startX = fabric.util.cos(start) * radius, startY = fabric.util.sin(start) * radius, endX = fabric.util.cos(end) * radius, endY = fabric.util.sin(end) * radius, largeFlag = angle > 180 ? \"1\" : \"0\";\n                svgString = [\n                    '<path d=\"M ' + startX + \" \" + startY,\n                    \" A \" + radius + \" \" + radius,\n                    \" 0 \",\n                    +largeFlag + \" 1\",\n                    \" \" + endX + \" \" + endY,\n                    '\" ',\n                    \"COMMON_PARTS\",\n                    \" />\\n\"\n                ];\n            }\n            return svgString;\n        },\n        /* _TO_SVG_END_ */ /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx context to render on\n     */ _render: function(ctx) {\n            ctx.beginPath();\n            ctx.arc(0, 0, this.radius, degreesToRadians(this.startAngle), degreesToRadians(this.endAngle), false);\n            this._renderPaintInOrder(ctx);\n        },\n        /**\n     * Returns horizontal radius of an object (according to how an object is scaled)\n     * @return {Number}\n     */ getRadiusX: function() {\n            return this.get(\"radius\") * this.get(\"scaleX\");\n        },\n        /**\n     * Returns vertical radius of an object (according to how an object is scaled)\n     * @return {Number}\n     */ getRadiusY: function() {\n            return this.get(\"radius\") * this.get(\"scaleY\");\n        },\n        /**\n     * Sets radius of an object (and updates width accordingly)\n     * @return {fabric.Circle} thisArg\n     */ setRadius: function(value) {\n            this.radius = value;\n            return this.set(\"width\", value * 2).set(\"height\", value * 2);\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Circle.fromElement})\n   * @static\n   * @memberOf fabric.Circle\n   * @see: http://www.w3.org/TR/SVG/shapes.html#CircleElement\n   */ fabric.Circle.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\"cx cy r\".split(\" \"));\n    /**\n   * Returns {@link fabric.Circle} instance from an SVG element\n   * @static\n   * @memberOf fabric.Circle\n   * @param {SVGElement} element Element to parse\n   * @param {Function} [callback] Options callback invoked after parsing is finished\n   * @param {Object} [options] Options object\n   * @throws {Error} If value of `r` attribute is missing or invalid\n   */ fabric.Circle.fromElement = function(element, callback) {\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Circle.ATTRIBUTE_NAMES);\n        if (!isValidRadius(parsedAttributes)) {\n            throw new Error(\"value of `r` attribute is required and can not be negative\");\n        }\n        parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.radius;\n        parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.radius;\n        callback(new fabric.Circle(parsedAttributes));\n    };\n    /**\n   * @private\n   */ function isValidRadius(attributes) {\n        return \"radius\" in attributes && attributes.radius >= 0;\n    }\n    /* _FROM_SVG_END_ */ /**\n   * Returns {@link fabric.Circle} instance from an object representation\n   * @static\n   * @memberOf fabric.Circle\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] invoked with new instance as first argument\n   * @return {void}\n   */ fabric.Circle.fromObject = function(object, callback) {\n        fabric.Object._fromObject(\"Circle\", object, callback);\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {});\n    if (fabric.Triangle) {\n        fabric.warn(\"fabric.Triangle is already defined\");\n        return;\n    }\n    /**\n   * Triangle class\n   * @class fabric.Triangle\n   * @extends fabric.Object\n   * @return {fabric.Triangle} thisArg\n   * @see {@link fabric.Triangle#initialize} for constructor definition\n   */ fabric.Triangle = fabric.util.createClass(fabric.Object, /** @lends fabric.Triangle.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"triangle\",\n        /**\n     * Width is set to 100 to compensate the old initialize code that was setting it to 100\n     * @type Number\n     * @default\n     */ width: 100,\n        /**\n     * Height is set to 100 to compensate the old initialize code that was setting it to 100\n     * @type Number\n     * @default\n     */ height: 100,\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            var widthBy2 = this.width / 2, heightBy2 = this.height / 2;\n            ctx.beginPath();\n            ctx.moveTo(-widthBy2, heightBy2);\n            ctx.lineTo(0, -heightBy2);\n            ctx.lineTo(widthBy2, heightBy2);\n            ctx.closePath();\n            this._renderPaintInOrder(ctx);\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var widthBy2 = this.width / 2, heightBy2 = this.height / 2, points = [\n                -widthBy2 + \" \" + heightBy2,\n                \"0 \" + -heightBy2,\n                widthBy2 + \" \" + heightBy2\n            ].join(\",\");\n            return [\n                \"<polygon \",\n                \"COMMON_PARTS\",\n                'points=\"',\n                points,\n                '\" />'\n            ];\n        }\n    });\n    /**\n   * Returns {@link fabric.Triangle} instance from an object representation\n   * @static\n   * @memberOf fabric.Triangle\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] invoked with new instance as first argument\n   */ fabric.Triangle.fromObject = function(object, callback) {\n        return fabric.Object._fromObject(\"Triangle\", object, callback);\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), piBy2 = Math.PI * 2;\n    if (fabric.Ellipse) {\n        fabric.warn(\"fabric.Ellipse is already defined.\");\n        return;\n    }\n    /**\n   * Ellipse class\n   * @class fabric.Ellipse\n   * @extends fabric.Object\n   * @return {fabric.Ellipse} thisArg\n   * @see {@link fabric.Ellipse#initialize} for constructor definition\n   */ fabric.Ellipse = fabric.util.createClass(fabric.Object, /** @lends fabric.Ellipse.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"ellipse\",\n        /**\n     * Horizontal radius\n     * @type Number\n     * @default\n     */ rx: 0,\n        /**\n     * Vertical radius\n     * @type Number\n     * @default\n     */ ry: 0,\n        cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"rx\", \"ry\"),\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     * @return {fabric.Ellipse} thisArg\n     */ initialize: function(options) {\n            this.callSuper(\"initialize\", options);\n            this.set(\"rx\", options && options.rx || 0);\n            this.set(\"ry\", options && options.ry || 0);\n        },\n        /**\n     * @private\n     * @param {String} key\n     * @param {*} value\n     * @return {fabric.Ellipse} thisArg\n     */ _set: function(key, value) {\n            this.callSuper(\"_set\", key, value);\n            switch(key){\n                case \"rx\":\n                    this.rx = value;\n                    this.set(\"width\", value * 2);\n                    break;\n                case \"ry\":\n                    this.ry = value;\n                    this.set(\"height\", value * 2);\n                    break;\n            }\n            return this;\n        },\n        /**\n     * Returns horizontal radius of an object (according to how an object is scaled)\n     * @return {Number}\n     */ getRx: function() {\n            return this.get(\"rx\") * this.get(\"scaleX\");\n        },\n        /**\n     * Returns Vertical radius of an object (according to how an object is scaled)\n     * @return {Number}\n     */ getRy: function() {\n            return this.get(\"ry\") * this.get(\"scaleY\");\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return this.callSuper(\"toObject\", [\n                \"rx\",\n                \"ry\"\n            ].concat(propertiesToInclude));\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            return [\n                \"<ellipse \",\n                \"COMMON_PARTS\",\n                'cx=\"0\" cy=\"0\" ',\n                'rx=\"',\n                this.rx,\n                '\" ry=\"',\n                this.ry,\n                '\" />\\n'\n            ];\n        },\n        /* _TO_SVG_END_ */ /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx context to render on\n     */ _render: function(ctx) {\n            ctx.beginPath();\n            ctx.save();\n            ctx.transform(1, 0, 0, this.ry / this.rx, 0, 0);\n            ctx.arc(0, 0, this.rx, 0, piBy2, false);\n            ctx.restore();\n            this._renderPaintInOrder(ctx);\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Ellipse.fromElement})\n   * @static\n   * @memberOf fabric.Ellipse\n   * @see http://www.w3.org/TR/SVG/shapes.html#EllipseElement\n   */ fabric.Ellipse.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\"cx cy rx ry\".split(\" \"));\n    /**\n   * Returns {@link fabric.Ellipse} instance from an SVG element\n   * @static\n   * @memberOf fabric.Ellipse\n   * @param {SVGElement} element Element to parse\n   * @param {Function} [callback] Options callback invoked after parsing is finished\n   * @return {fabric.Ellipse}\n   */ fabric.Ellipse.fromElement = function(element, callback) {\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Ellipse.ATTRIBUTE_NAMES);\n        parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.rx;\n        parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.ry;\n        callback(new fabric.Ellipse(parsedAttributes));\n    };\n    /* _FROM_SVG_END_ */ /**\n   * Returns {@link fabric.Ellipse} instance from an object representation\n   * @static\n   * @memberOf fabric.Ellipse\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] invoked with new instance as first argument\n   * @return {void}\n   */ fabric.Ellipse.fromObject = function(object, callback) {\n        fabric.Object._fromObject(\"Ellipse\", object, callback);\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend;\n    if (fabric.Rect) {\n        fabric.warn(\"fabric.Rect is already defined\");\n        return;\n    }\n    /**\n   * Rectangle class\n   * @class fabric.Rect\n   * @extends fabric.Object\n   * @return {fabric.Rect} thisArg\n   * @see {@link fabric.Rect#initialize} for constructor definition\n   */ fabric.Rect = fabric.util.createClass(fabric.Object, /** @lends fabric.Rect.prototype */ {\n        /**\n     * List of properties to consider when checking if state of an object is changed ({@link fabric.Object#hasStateChanged})\n     * as well as for history (undo/redo) purposes\n     * @type Array\n     */ stateProperties: fabric.Object.prototype.stateProperties.concat(\"rx\", \"ry\"),\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"rect\",\n        /**\n     * Horizontal border radius\n     * @type Number\n     * @default\n     */ rx: 0,\n        /**\n     * Vertical border radius\n     * @type Number\n     * @default\n     */ ry: 0,\n        cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"rx\", \"ry\"),\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     * @return {Object} thisArg\n     */ initialize: function(options) {\n            this.callSuper(\"initialize\", options);\n            this._initRxRy();\n        },\n        /**\n     * Initializes rx/ry attributes\n     * @private\n     */ _initRxRy: function() {\n            if (this.rx && !this.ry) {\n                this.ry = this.rx;\n            } else if (this.ry && !this.rx) {\n                this.rx = this.ry;\n            }\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            // 1x1 case (used in spray brush) optimization was removed because\n            // with caching and higher zoom level this makes more damage than help\n            var rx = this.rx ? Math.min(this.rx, this.width / 2) : 0, ry = this.ry ? Math.min(this.ry, this.height / 2) : 0, w = this.width, h = this.height, x = -this.width / 2, y = -this.height / 2, isRounded = rx !== 0 || ry !== 0, /* \"magic number\" for bezier approximations of arcs (http://itc.ktu.lt/itc354/Riskus354.pdf) */ k = 1 - 0.5522847498;\n            ctx.beginPath();\n            ctx.moveTo(x + rx, y);\n            ctx.lineTo(x + w - rx, y);\n            isRounded && ctx.bezierCurveTo(x + w - k * rx, y, x + w, y + k * ry, x + w, y + ry);\n            ctx.lineTo(x + w, y + h - ry);\n            isRounded && ctx.bezierCurveTo(x + w, y + h - k * ry, x + w - k * rx, y + h, x + w - rx, y + h);\n            ctx.lineTo(x + rx, y + h);\n            isRounded && ctx.bezierCurveTo(x + k * rx, y + h, x, y + h - k * ry, x, y + h - ry);\n            ctx.lineTo(x, y + ry);\n            isRounded && ctx.bezierCurveTo(x, y + k * ry, x + k * rx, y, x + rx, y);\n            ctx.closePath();\n            this._renderPaintInOrder(ctx);\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return this.callSuper(\"toObject\", [\n                \"rx\",\n                \"ry\"\n            ].concat(propertiesToInclude));\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var x = -this.width / 2, y = -this.height / 2;\n            return [\n                \"<rect \",\n                \"COMMON_PARTS\",\n                'x=\"',\n                x,\n                '\" y=\"',\n                y,\n                '\" rx=\"',\n                this.rx,\n                '\" ry=\"',\n                this.ry,\n                '\" width=\"',\n                this.width,\n                '\" height=\"',\n                this.height,\n                '\" />\\n'\n            ];\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by `fabric.Rect.fromElement`)\n   * @static\n   * @memberOf fabric.Rect\n   * @see: http://www.w3.org/TR/SVG/shapes.html#RectElement\n   */ fabric.Rect.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\"x y rx ry width height\".split(\" \"));\n    /**\n   * Returns {@link fabric.Rect} instance from an SVG element\n   * @static\n   * @memberOf fabric.Rect\n   * @param {SVGElement} element Element to parse\n   * @param {Function} callback callback function invoked after parsing\n   * @param {Object} [options] Options object\n   */ fabric.Rect.fromElement = function(element, callback, options) {\n        if (!element) {\n            return callback(null);\n        }\n        options = options || {};\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Rect.ATTRIBUTE_NAMES);\n        parsedAttributes.left = parsedAttributes.left || 0;\n        parsedAttributes.top = parsedAttributes.top || 0;\n        parsedAttributes.height = parsedAttributes.height || 0;\n        parsedAttributes.width = parsedAttributes.width || 0;\n        var rect = new fabric.Rect(extend(options ? fabric.util.object.clone(options) : {}, parsedAttributes));\n        rect.visible = rect.visible && rect.width > 0 && rect.height > 0;\n        callback(rect);\n    };\n    /* _FROM_SVG_END_ */ /**\n   * Returns {@link fabric.Rect} instance from an object representation\n   * @static\n   * @memberOf fabric.Rect\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] Callback to invoke when an fabric.Rect instance is created\n   */ fabric.Rect.fromObject = function(object, callback) {\n        return fabric.Object._fromObject(\"Rect\", object, callback);\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, min = fabric.util.array.min, max = fabric.util.array.max, toFixed = fabric.util.toFixed, projectStrokeOnPoints = fabric.util.projectStrokeOnPoints;\n    if (fabric.Polyline) {\n        fabric.warn(\"fabric.Polyline is already defined\");\n        return;\n    }\n    /**\n   * Polyline class\n   * @class fabric.Polyline\n   * @extends fabric.Object\n   * @see {@link fabric.Polyline#initialize} for constructor definition\n   */ fabric.Polyline = fabric.util.createClass(fabric.Object, /** @lends fabric.Polyline.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"polyline\",\n        /**\n     * Points array\n     * @type Array\n     * @default\n     */ points: null,\n        /**\n     * WARNING: Feature in progress\n     * Calculate the exact bounding box taking in account strokeWidth on acute angles\n     * this will be turned to true by default on fabric 6.0\n     * maybe will be left in as an optimization since calculations may be slow\n     * @deprecated\n     * @type Boolean\n     * @default false\n     */ exactBoundingBox: false,\n        cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"points\"),\n        /**\n     * Constructor\n     * @param {Array} points Array of points (where each point is an object with x and y)\n     * @param {Object} [options] Options object\n     * @return {fabric.Polyline} thisArg\n     * @example\n     * var poly = new fabric.Polyline([\n     *     { x: 10, y: 10 },\n     *     { x: 50, y: 30 },\n     *     { x: 40, y: 70 },\n     *     { x: 60, y: 50 },\n     *     { x: 100, y: 150 },\n     *     { x: 40, y: 100 }\n     *   ], {\n     *   stroke: 'red',\n     *   left: 100,\n     *   top: 100\n     * });\n     */ initialize: function(points, options) {\n            options = options || {};\n            this.points = points || [];\n            this.callSuper(\"initialize\", options);\n            this._setPositionDimensions(options);\n        },\n        /**\n     * @private\n     */ _projectStrokeOnPoints: function() {\n            return projectStrokeOnPoints(this.points, this, true);\n        },\n        _setPositionDimensions: function(options) {\n            var calcDim = this._calcDimensions(options), correctLeftTop, correctSize = this.exactBoundingBox ? this.strokeWidth : 0;\n            this.width = calcDim.width - correctSize;\n            this.height = calcDim.height - correctSize;\n            if (!options.fromSVG) {\n                correctLeftTop = this.translateToGivenOrigin({\n                    // this looks bad, but is one way to keep it optional for now.\n                    x: calcDim.left - this.strokeWidth / 2 + correctSize / 2,\n                    y: calcDim.top - this.strokeWidth / 2 + correctSize / 2\n                }, \"left\", \"top\", this.originX, this.originY);\n            }\n            if (typeof options.left === \"undefined\") {\n                this.left = options.fromSVG ? calcDim.left : correctLeftTop.x;\n            }\n            if (typeof options.top === \"undefined\") {\n                this.top = options.fromSVG ? calcDim.top : correctLeftTop.y;\n            }\n            this.pathOffset = {\n                x: calcDim.left + this.width / 2 + correctSize / 2,\n                y: calcDim.top + this.height / 2 + correctSize / 2\n            };\n        },\n        /**\n     * Calculate the polygon min and max point from points array,\n     * returning an object with left, top, width, height to measure the\n     * polygon size\n     * @return {Object} object.left X coordinate of the polygon leftmost point\n     * @return {Object} object.top Y coordinate of the polygon topmost point\n     * @return {Object} object.width distance between X coordinates of the polygon leftmost and rightmost point\n     * @return {Object} object.height distance between Y coordinates of the polygon topmost and bottommost point\n     * @private\n     */ _calcDimensions: function() {\n            var points = this.exactBoundingBox ? this._projectStrokeOnPoints() : this.points, minX = min(points, \"x\") || 0, minY = min(points, \"y\") || 0, maxX = max(points, \"x\") || 0, maxY = max(points, \"y\") || 0, width = maxX - minX, height = maxY - minY;\n            return {\n                left: minX,\n                top: minY,\n                width: width,\n                height: height\n            };\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return extend(this.callSuper(\"toObject\", propertiesToInclude), {\n                points: this.points.concat()\n            });\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var points = [], diffX = this.pathOffset.x, diffY = this.pathOffset.y, NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;\n            for(var i = 0, len = this.points.length; i < len; i++){\n                points.push(toFixed(this.points[i].x - diffX, NUM_FRACTION_DIGITS), \",\", toFixed(this.points[i].y - diffY, NUM_FRACTION_DIGITS), \" \");\n            }\n            return [\n                \"<\" + this.type + \" \",\n                \"COMMON_PARTS\",\n                'points=\"',\n                points.join(\"\"),\n                '\" />\\n'\n            ];\n        },\n        /* _TO_SVG_END_ */ /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ commonRender: function(ctx) {\n            var point, len = this.points.length, x = this.pathOffset.x, y = this.pathOffset.y;\n            if (!len || isNaN(this.points[len - 1].y)) {\n                // do not draw if no points or odd points\n                // NaN comes from parseFloat of a empty string in parser\n                return false;\n            }\n            ctx.beginPath();\n            ctx.moveTo(this.points[0].x - x, this.points[0].y - y);\n            for(var i = 0; i < len; i++){\n                point = this.points[i];\n                ctx.lineTo(point.x - x, point.y - y);\n            }\n            return true;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            if (!this.commonRender(ctx)) {\n                return;\n            }\n            this._renderPaintInOrder(ctx);\n        },\n        /**\n     * Returns complexity of an instance\n     * @return {Number} complexity of this instance\n     */ complexity: function() {\n            return this.get(\"points\").length;\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Polyline.fromElement})\n   * @static\n   * @memberOf fabric.Polyline\n   * @see: http://www.w3.org/TR/SVG/shapes.html#PolylineElement\n   */ fabric.Polyline.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();\n    /**\n   * Returns fabric.Polyline instance from an SVG element\n   * @static\n   * @memberOf fabric.Polyline\n   * @param {SVGElement} element Element to parser\n   * @param {Function} callback callback function invoked after parsing\n   * @param {Object} [options] Options object\n   */ fabric.Polyline.fromElementGenerator = function(_class) {\n        return function(element, callback, options) {\n            if (!element) {\n                return callback(null);\n            }\n            options || (options = {});\n            var points = fabric.parsePointsAttribute(element.getAttribute(\"points\")), parsedAttributes = fabric.parseAttributes(element, fabric[_class].ATTRIBUTE_NAMES);\n            parsedAttributes.fromSVG = true;\n            callback(new fabric[_class](points, extend(parsedAttributes, options)));\n        };\n    };\n    fabric.Polyline.fromElement = fabric.Polyline.fromElementGenerator(\"Polyline\");\n    /* _FROM_SVG_END_ */ /**\n   * Returns fabric.Polyline instance from an object representation\n   * @static\n   * @memberOf fabric.Polyline\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created\n   */ fabric.Polyline.fromObject = function(object, callback) {\n        return fabric.Object._fromObject(\"Polyline\", object, callback, \"points\");\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), projectStrokeOnPoints = fabric.util.projectStrokeOnPoints;\n    if (fabric.Polygon) {\n        fabric.warn(\"fabric.Polygon is already defined\");\n        return;\n    }\n    /**\n   * Polygon class\n   * @class fabric.Polygon\n   * @extends fabric.Polyline\n   * @see {@link fabric.Polygon#initialize} for constructor definition\n   */ fabric.Polygon = fabric.util.createClass(fabric.Polyline, /** @lends fabric.Polygon.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"polygon\",\n        /**\n     * @private\n     */ _projectStrokeOnPoints: function() {\n            return projectStrokeOnPoints(this.points, this);\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            if (!this.commonRender(ctx)) {\n                return;\n            }\n            ctx.closePath();\n            this._renderPaintInOrder(ctx);\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by `fabric.Polygon.fromElement`)\n   * @static\n   * @memberOf fabric.Polygon\n   * @see: http://www.w3.org/TR/SVG/shapes.html#PolygonElement\n   */ fabric.Polygon.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();\n    /**\n   * Returns {@link fabric.Polygon} instance from an SVG element\n   * @static\n   * @memberOf fabric.Polygon\n   * @param {SVGElement} element Element to parse\n   * @param {Function} callback callback function invoked after parsing\n   * @param {Object} [options] Options object\n   */ fabric.Polygon.fromElement = fabric.Polyline.fromElementGenerator(\"Polygon\");\n    /* _FROM_SVG_END_ */ /**\n   * Returns fabric.Polygon instance from an object representation\n   * @static\n   * @memberOf fabric.Polygon\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created\n   * @return {void}\n   */ fabric.Polygon.fromObject = function(object, callback) {\n        fabric.Object._fromObject(\"Polygon\", object, callback, \"points\");\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), min = fabric.util.array.min, max = fabric.util.array.max, extend = fabric.util.object.extend, clone = fabric.util.object.clone, toFixed = fabric.util.toFixed;\n    if (fabric.Path) {\n        fabric.warn(\"fabric.Path is already defined\");\n        return;\n    }\n    /**\n   * Path class\n   * @class fabric.Path\n   * @extends fabric.Object\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#path_and_pathgroup}\n   * @see {@link fabric.Path#initialize} for constructor definition\n   */ fabric.Path = fabric.util.createClass(fabric.Object, /** @lends fabric.Path.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"path\",\n        /**\n     * Array of path points\n     * @type Array\n     * @default\n     */ path: null,\n        cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"path\", \"fillRule\"),\n        stateProperties: fabric.Object.prototype.stateProperties.concat(\"path\"),\n        /**\n     * Constructor\n     * @param {Array|String} path Path data (sequence of coordinates and corresponding \"command\" tokens)\n     * @param {Object} [options] Options object\n     * @return {fabric.Path} thisArg\n     */ initialize: function(path, options) {\n            options = clone(options || {});\n            delete options.path;\n            this.callSuper(\"initialize\", options);\n            this._setPath(path || [], options);\n        },\n        /**\n    * @private\n    * @param {Array|String} path Path data (sequence of coordinates and corresponding \"command\" tokens)\n    * @param {Object} [options] Options object\n    */ _setPath: function(path, options) {\n            this.path = fabric.util.makePathSimpler(Array.isArray(path) ? path : fabric.util.parsePath(path));\n            fabric.Polyline.prototype._setPositionDimensions.call(this, options || {});\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx context to render path on\n     */ _renderPathCommands: function(ctx) {\n            var current, subpathStartX = 0, subpathStartY = 0, x = 0, y = 0, controlX = 0, controlY = 0, l = -this.pathOffset.x, t = -this.pathOffset.y;\n            ctx.beginPath();\n            for(var i = 0, len = this.path.length; i < len; ++i){\n                current = this.path[i];\n                switch(current[0]){\n                    case \"L\":\n                        x = current[1];\n                        y = current[2];\n                        ctx.lineTo(x + l, y + t);\n                        break;\n                    case \"M\":\n                        x = current[1];\n                        y = current[2];\n                        subpathStartX = x;\n                        subpathStartY = y;\n                        ctx.moveTo(x + l, y + t);\n                        break;\n                    case \"C\":\n                        x = current[5];\n                        y = current[6];\n                        controlX = current[3];\n                        controlY = current[4];\n                        ctx.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);\n                        break;\n                    case \"Q\":\n                        ctx.quadraticCurveTo(current[1] + l, current[2] + t, current[3] + l, current[4] + t);\n                        x = current[3];\n                        y = current[4];\n                        controlX = current[1];\n                        controlY = current[2];\n                        break;\n                    case \"z\":\n                    case \"Z\":\n                        x = subpathStartX;\n                        y = subpathStartY;\n                        ctx.closePath();\n                        break;\n                }\n            }\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx context to render path on\n     */ _render: function(ctx) {\n            this._renderPathCommands(ctx);\n            this._renderPaintInOrder(ctx);\n        },\n        /**\n     * Returns string representation of an instance\n     * @return {String} string representation of an instance\n     */ toString: function() {\n            return \"#<fabric.Path (\" + this.complexity() + '): { \"top\": ' + this.top + ', \"left\": ' + this.left + \" }>\";\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return extend(this.callSuper(\"toObject\", propertiesToInclude), {\n                path: this.path.map(function(item) {\n                    return item.slice();\n                })\n            });\n        },\n        /**\n     * Returns dataless object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toDatalessObject: function(propertiesToInclude) {\n            var o = this.toObject([\n                \"sourcePath\"\n            ].concat(propertiesToInclude));\n            if (o.sourcePath) {\n                delete o.path;\n            }\n            return o;\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var path = fabric.util.joinPath(this.path);\n            return [\n                \"<path \",\n                \"COMMON_PARTS\",\n                'd=\"',\n                path,\n                '\" stroke-linecap=\"round\" ',\n                \"/>\\n\"\n            ];\n        },\n        _getOffsetTransform: function() {\n            var digits = fabric.Object.NUM_FRACTION_DIGITS;\n            return \" translate(\" + toFixed(-this.pathOffset.x, digits) + \", \" + toFixed(-this.pathOffset.y, digits) + \")\";\n        },\n        /**\n     * Returns svg clipPath representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ toClipPathSVG: function(reviver) {\n            var additionalTransform = this._getOffsetTransform();\n            return \"\t\" + this._createBaseClipPathSVGMarkup(this._toSVG(), {\n                reviver: reviver,\n                additionalTransform: additionalTransform\n            });\n        },\n        /**\n     * Returns svg representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ toSVG: function(reviver) {\n            var additionalTransform = this._getOffsetTransform();\n            return this._createBaseSVGMarkup(this._toSVG(), {\n                reviver: reviver,\n                additionalTransform: additionalTransform\n            });\n        },\n        /* _TO_SVG_END_ */ /**\n     * Returns number representation of an instance complexity\n     * @return {Number} complexity of this instance\n     */ complexity: function() {\n            return this.path.length;\n        },\n        /**\n     * @private\n     */ _calcDimensions: function() {\n            var aX = [], aY = [], current, subpathStartX = 0, subpathStartY = 0, x = 0, y = 0, bounds;\n            for(var i = 0, len = this.path.length; i < len; ++i){\n                current = this.path[i];\n                switch(current[0]){\n                    case \"L\":\n                        x = current[1];\n                        y = current[2];\n                        bounds = [];\n                        break;\n                    case \"M\":\n                        x = current[1];\n                        y = current[2];\n                        subpathStartX = x;\n                        subpathStartY = y;\n                        bounds = [];\n                        break;\n                    case \"C\":\n                        bounds = fabric.util.getBoundsOfCurve(x, y, current[1], current[2], current[3], current[4], current[5], current[6]);\n                        x = current[5];\n                        y = current[6];\n                        break;\n                    case \"Q\":\n                        bounds = fabric.util.getBoundsOfCurve(x, y, current[1], current[2], current[1], current[2], current[3], current[4]);\n                        x = current[3];\n                        y = current[4];\n                        break;\n                    case \"z\":\n                    case \"Z\":\n                        x = subpathStartX;\n                        y = subpathStartY;\n                        break;\n                }\n                bounds.forEach(function(point) {\n                    aX.push(point.x);\n                    aY.push(point.y);\n                });\n                aX.push(x);\n                aY.push(y);\n            }\n            var minX = min(aX) || 0, minY = min(aY) || 0, maxX = max(aX) || 0, maxY = max(aY) || 0, deltaX = maxX - minX, deltaY = maxY - minY;\n            return {\n                left: minX,\n                top: minY,\n                width: deltaX,\n                height: deltaY\n            };\n        }\n    });\n    /**\n   * Creates an instance of fabric.Path from an object\n   * @static\n   * @memberOf fabric.Path\n   * @param {Object} object\n   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created\n   */ fabric.Path.fromObject = function(object, callback) {\n        if (typeof object.sourcePath === \"string\") {\n            var pathUrl = object.sourcePath;\n            fabric.loadSVGFromURL(pathUrl, function(elements) {\n                var path = elements[0];\n                path.setOptions(object);\n                if (object.clipPath) {\n                    fabric.util.enlivenObjects([\n                        object.clipPath\n                    ], function(elivenedObjects) {\n                        path.clipPath = elivenedObjects[0];\n                        callback && callback(path);\n                    });\n                } else {\n                    callback && callback(path);\n                }\n            });\n        } else {\n            fabric.Object._fromObject(\"Path\", object, callback, \"path\");\n        }\n    };\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by `fabric.Path.fromElement`)\n   * @static\n   * @memberOf fabric.Path\n   * @see http://www.w3.org/TR/SVG/paths.html#PathElement\n   */ fabric.Path.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat([\n        \"d\"\n    ]);\n    /**\n   * Creates an instance of fabric.Path from an SVG <path> element\n   * @static\n   * @memberOf fabric.Path\n   * @param {SVGElement} element to parse\n   * @param {Function} callback Callback to invoke when an fabric.Path instance is created\n   * @param {Object} [options] Options object\n   * @param {Function} [callback] Options callback invoked after parsing is finished\n   */ fabric.Path.fromElement = function(element, callback, options) {\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Path.ATTRIBUTE_NAMES);\n        parsedAttributes.fromSVG = true;\n        callback(new fabric.Path(parsedAttributes.d, extend(parsedAttributes, options)));\n    };\n/* _FROM_SVG_END_ */ })( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), min = fabric.util.array.min, max = fabric.util.array.max;\n    if (fabric.Group) {\n        return;\n    }\n    /**\n   * Group class\n   * @class fabric.Group\n   * @extends fabric.Object\n   * @mixes fabric.Collection\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}\n   * @see {@link fabric.Group#initialize} for constructor definition\n   */ fabric.Group = fabric.util.createClass(fabric.Object, fabric.Collection, /** @lends fabric.Group.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"group\",\n        /**\n     * Width of stroke\n     * @type Number\n     * @default\n     */ strokeWidth: 0,\n        /**\n     * Indicates if click, mouseover, mouseout events & hoverCursor should also check for subtargets\n     * @type Boolean\n     * @default\n     */ subTargetCheck: false,\n        /**\n     * Groups are container, do not render anything on theyr own, ence no cache properties\n     * @type Array\n     * @default\n     */ cacheProperties: [],\n        /**\n     * setOnGroup is a method used for TextBox that is no more used since 2.0.0 The behavior is still\n     * available setting this boolean to true.\n     * @type Boolean\n     * @since 2.0.0\n     * @default\n     */ useSetOnGroup: false,\n        /**\n     * Constructor\n     * @param {Object} objects Group objects\n     * @param {Object} [options] Options object\n     * @param {Boolean} [isAlreadyGrouped] if true, objects have been grouped already.\n     * @return {Object} thisArg\n     */ initialize: function(objects, options, isAlreadyGrouped) {\n            options = options || {};\n            this._objects = [];\n            // if objects enclosed in a group have been grouped already,\n            // we cannot change properties of objects.\n            // Thus we need to set options to group without objects,\n            isAlreadyGrouped && this.callSuper(\"initialize\", options);\n            this._objects = objects || [];\n            for(var i = this._objects.length; i--;){\n                this._objects[i].group = this;\n            }\n            if (!isAlreadyGrouped) {\n                var center = options && options.centerPoint;\n                // we want to set origins before calculating the bounding box.\n                // so that the topleft can be set with that in mind.\n                // if specific top and left are passed, are overwritten later\n                // with the callSuper('initialize', options)\n                if (options.originX !== undefined) {\n                    this.originX = options.originX;\n                }\n                if (options.originY !== undefined) {\n                    this.originY = options.originY;\n                }\n                // if coming from svg i do not want to calc bounds.\n                // i assume width and height are passed along options\n                center || this._calcBounds();\n                this._updateObjectsCoords(center);\n                delete options.centerPoint;\n                this.callSuper(\"initialize\", options);\n            } else {\n                this._updateObjectsACoords();\n            }\n            this.setCoords();\n        },\n        /**\n     * @private\n     */ _updateObjectsACoords: function() {\n            var skipControls = true;\n            for(var i = this._objects.length; i--;){\n                this._objects[i].setCoords(skipControls);\n            }\n        },\n        /**\n     * @private\n     * @param {Boolean} [skipCoordsChange] if true, coordinates of objects enclosed in a group do not change\n     */ _updateObjectsCoords: function(center) {\n            var center = center || this.getCenterPoint();\n            for(var i = this._objects.length; i--;){\n                this._updateObjectCoords(this._objects[i], center);\n            }\n        },\n        /**\n     * @private\n     * @param {Object} object\n     * @param {fabric.Point} center, current center of group.\n     */ _updateObjectCoords: function(object, center) {\n            var objectLeft = object.left, objectTop = object.top, skipControls = true;\n            object.set({\n                left: objectLeft - center.x,\n                top: objectTop - center.y\n            });\n            object.group = this;\n            object.setCoords(skipControls);\n        },\n        /**\n     * Returns string represenation of a group\n     * @return {String}\n     */ toString: function() {\n            return \"#<fabric.Group: (\" + this.complexity() + \")>\";\n        },\n        /**\n     * Adds an object to a group; Then recalculates group's dimension, position.\n     * @param {Object} object\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ addWithUpdate: function(object) {\n            var nested = !!this.group;\n            this._restoreObjectsState();\n            fabric.util.resetObjectTransform(this);\n            if (object) {\n                if (nested) {\n                    // if this group is inside another group, we need to pre transform the object\n                    fabric.util.removeTransformFromObject(object, this.group.calcTransformMatrix());\n                }\n                this._objects.push(object);\n                object.group = this;\n                object._set(\"canvas\", this.canvas);\n            }\n            this._calcBounds();\n            this._updateObjectsCoords();\n            this.dirty = true;\n            if (nested) {\n                this.group.addWithUpdate();\n            } else {\n                this.setCoords();\n            }\n            return this;\n        },\n        /**\n     * Removes an object from a group; Then recalculates group's dimension, position.\n     * @param {Object} object\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ removeWithUpdate: function(object) {\n            this._restoreObjectsState();\n            fabric.util.resetObjectTransform(this);\n            this.remove(object);\n            this._calcBounds();\n            this._updateObjectsCoords();\n            this.setCoords();\n            this.dirty = true;\n            return this;\n        },\n        /**\n     * @private\n     */ _onObjectAdded: function(object) {\n            this.dirty = true;\n            object.group = this;\n            object._set(\"canvas\", this.canvas);\n        },\n        /**\n     * @private\n     */ _onObjectRemoved: function(object) {\n            this.dirty = true;\n            delete object.group;\n        },\n        /**\n     * @private\n     */ _set: function(key, value) {\n            var i = this._objects.length;\n            if (this.useSetOnGroup) {\n                while(i--){\n                    this._objects[i].setOnGroup(key, value);\n                }\n            }\n            if (key === \"canvas\") {\n                while(i--){\n                    this._objects[i]._set(key, value);\n                }\n            }\n            fabric.Object.prototype._set.call(this, key, value);\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            var _includeDefaultValues = this.includeDefaultValues;\n            var objsToObject = this._objects.filter(function(obj) {\n                return !obj.excludeFromExport;\n            }).map(function(obj) {\n                var originalDefaults = obj.includeDefaultValues;\n                obj.includeDefaultValues = _includeDefaultValues;\n                var _obj = obj.toObject(propertiesToInclude);\n                obj.includeDefaultValues = originalDefaults;\n                return _obj;\n            });\n            var obj = fabric.Object.prototype.toObject.call(this, propertiesToInclude);\n            obj.objects = objsToObject;\n            return obj;\n        },\n        /**\n     * Returns object representation of an instance, in dataless mode.\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toDatalessObject: function(propertiesToInclude) {\n            var objsToObject, sourcePath = this.sourcePath;\n            if (sourcePath) {\n                objsToObject = sourcePath;\n            } else {\n                var _includeDefaultValues = this.includeDefaultValues;\n                objsToObject = this._objects.map(function(obj) {\n                    var originalDefaults = obj.includeDefaultValues;\n                    obj.includeDefaultValues = _includeDefaultValues;\n                    var _obj = obj.toDatalessObject(propertiesToInclude);\n                    obj.includeDefaultValues = originalDefaults;\n                    return _obj;\n                });\n            }\n            var obj = fabric.Object.prototype.toDatalessObject.call(this, propertiesToInclude);\n            obj.objects = objsToObject;\n            return obj;\n        },\n        /**\n     * Renders instance on a given context\n     * @param {CanvasRenderingContext2D} ctx context to render instance on\n     */ render: function(ctx) {\n            this._transformDone = true;\n            this.callSuper(\"render\", ctx);\n            this._transformDone = false;\n        },\n        /**\n     * Decide if the object should cache or not. Create its own cache level\n     * needsItsOwnCache should be used when the object drawing method requires\n     * a cache step. None of the fabric classes requires it.\n     * Generally you do not cache objects in groups because the group is already cached.\n     * @return {Boolean}\n     */ shouldCache: function() {\n            var ownCache = fabric.Object.prototype.shouldCache.call(this);\n            if (ownCache) {\n                for(var i = 0, len = this._objects.length; i < len; i++){\n                    if (this._objects[i].willDrawShadow()) {\n                        this.ownCaching = false;\n                        return false;\n                    }\n                }\n            }\n            return ownCache;\n        },\n        /**\n     * Check if this object or a child object will cast a shadow\n     * @return {Boolean}\n     */ willDrawShadow: function() {\n            if (fabric.Object.prototype.willDrawShadow.call(this)) {\n                return true;\n            }\n            for(var i = 0, len = this._objects.length; i < len; i++){\n                if (this._objects[i].willDrawShadow()) {\n                    return true;\n                }\n            }\n            return false;\n        },\n        /**\n     * Check if this group or its parent group are caching, recursively up\n     * @return {Boolean}\n     */ isOnACache: function() {\n            return this.ownCaching || this.group && this.group.isOnACache();\n        },\n        /**\n     * Execute the drawing operation for an object on a specified context\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ drawObject: function(ctx) {\n            for(var i = 0, len = this._objects.length; i < len; i++){\n                this._objects[i].render(ctx);\n            }\n            this._drawClipPath(ctx, this.clipPath);\n        },\n        /**\n     * Check if cache is dirty\n     */ isCacheDirty: function(skipCanvas) {\n            if (this.callSuper(\"isCacheDirty\", skipCanvas)) {\n                return true;\n            }\n            if (!this.statefullCache) {\n                return false;\n            }\n            for(var i = 0, len = this._objects.length; i < len; i++){\n                if (this._objects[i].isCacheDirty(true)) {\n                    if (this._cacheCanvas) {\n                        // if this group has not a cache canvas there is nothing to clean\n                        var x = this.cacheWidth / this.zoomX, y = this.cacheHeight / this.zoomY;\n                        this._cacheContext.clearRect(-x / 2, -y / 2, x, y);\n                    }\n                    return true;\n                }\n            }\n            return false;\n        },\n        /**\n     * Restores original state of each of group objects (original state is that which was before group was created).\n     * if the nested boolean is true, the original state will be restored just for the\n     * first group and not for all the group chain\n     * @private\n     * @param {Boolean} nested tell the function to restore object state up to the parent group and not more\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ _restoreObjectsState: function() {\n            var groupMatrix = this.calcOwnMatrix();\n            this._objects.forEach(function(object) {\n                // instead of using _this = this;\n                fabric.util.addTransformToObject(object, groupMatrix);\n                delete object.group;\n                object.setCoords();\n            });\n            return this;\n        },\n        /**\n     * Destroys a group (restoring state of its objects)\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ destroy: function() {\n            // when group is destroyed objects needs to get a repaint to be eventually\n            // displayed on canvas.\n            this._objects.forEach(function(object) {\n                object.set(\"dirty\", true);\n            });\n            return this._restoreObjectsState();\n        },\n        dispose: function() {\n            this.callSuper(\"dispose\");\n            this.forEachObject(function(object) {\n                object.dispose && object.dispose();\n            });\n            this._objects = [];\n        },\n        /**\n     * make a group an active selection, remove the group from canvas\n     * the group has to be on canvas for this to work.\n     * @return {fabric.ActiveSelection} thisArg\n     * @chainable\n     */ toActiveSelection: function() {\n            if (!this.canvas) {\n                return;\n            }\n            var objects = this._objects, canvas = this.canvas;\n            this._objects = [];\n            var options = this.toObject();\n            delete options.objects;\n            var activeSelection = new fabric.ActiveSelection([]);\n            activeSelection.set(options);\n            activeSelection.type = \"activeSelection\";\n            canvas.remove(this);\n            objects.forEach(function(object) {\n                object.group = activeSelection;\n                object.dirty = true;\n                canvas.add(object);\n            });\n            activeSelection.canvas = canvas;\n            activeSelection._objects = objects;\n            canvas._activeObject = activeSelection;\n            activeSelection.setCoords();\n            return activeSelection;\n        },\n        /**\n     * Destroys a group (restoring state of its objects)\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ ungroupOnCanvas: function() {\n            return this._restoreObjectsState();\n        },\n        /**\n     * Sets coordinates of all objects inside group\n     * @return {fabric.Group} thisArg\n     * @chainable\n     */ setObjectsCoords: function() {\n            var skipControls = true;\n            this.forEachObject(function(object) {\n                object.setCoords(skipControls);\n            });\n            return this;\n        },\n        /**\n     * @private\n     */ _calcBounds: function(onlyWidthHeight) {\n            var aX = [], aY = [], o, prop, coords, props = [\n                \"tr\",\n                \"br\",\n                \"bl\",\n                \"tl\"\n            ], i = 0, iLen = this._objects.length, j, jLen = props.length;\n            for(; i < iLen; ++i){\n                o = this._objects[i];\n                coords = o.calcACoords();\n                for(j = 0; j < jLen; j++){\n                    prop = props[j];\n                    aX.push(coords[prop].x);\n                    aY.push(coords[prop].y);\n                }\n                o.aCoords = coords;\n            }\n            this._getBounds(aX, aY, onlyWidthHeight);\n        },\n        /**\n     * @private\n     */ _getBounds: function(aX, aY, onlyWidthHeight) {\n            var minXY = new fabric.Point(min(aX), min(aY)), maxXY = new fabric.Point(max(aX), max(aY)), top = minXY.y || 0, left = minXY.x || 0, width = maxXY.x - minXY.x || 0, height = maxXY.y - minXY.y || 0;\n            this.width = width;\n            this.height = height;\n            if (!onlyWidthHeight) {\n                // the bounding box always finds the topleft most corner.\n                // whatever is the group origin, we set up here the left/top position.\n                this.setPositionByOrigin({\n                    x: left,\n                    y: top\n                }, \"left\", \"top\");\n            }\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ _toSVG: function(reviver) {\n            var svgString = [\n                \"<g \",\n                \"COMMON_PARTS\",\n                \" >\\n\"\n            ];\n            for(var i = 0, len = this._objects.length; i < len; i++){\n                svgString.push(\"\t\t\", this._objects[i].toSVG(reviver));\n            }\n            svgString.push(\"</g>\\n\");\n            return svgString;\n        },\n        /**\n     * Returns styles-string for svg-export, specific version for group\n     * @return {String}\n     */ getSvgStyles: function() {\n            var opacity = typeof this.opacity !== \"undefined\" && this.opacity !== 1 ? \"opacity: \" + this.opacity + \";\" : \"\", visibility = this.visible ? \"\" : \" visibility: hidden;\";\n            return [\n                opacity,\n                this.getSvgFilter(),\n                visibility\n            ].join(\"\");\n        },\n        /**\n     * Returns svg clipPath representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ toClipPathSVG: function(reviver) {\n            var svgString = [];\n            for(var i = 0, len = this._objects.length; i < len; i++){\n                svgString.push(\"\t\", this._objects[i].toClipPathSVG(reviver));\n            }\n            return this._createBaseClipPathSVGMarkup(svgString, {\n                reviver: reviver\n            });\n        }\n    });\n    /**\n   * Returns {@link fabric.Group} instance from an object representation\n   * @static\n   * @memberOf fabric.Group\n   * @param {Object} object Object to create a group from\n   * @param {Function} [callback] Callback to invoke when an group instance is created\n   */ fabric.Group.fromObject = function(object, callback) {\n        var objects = object.objects, options = fabric.util.object.clone(object, true);\n        delete options.objects;\n        if (typeof objects === \"string\") {\n            // it has to be an url or something went wrong.\n            fabric.loadSVGFromURL(objects, function(elements) {\n                var group = fabric.util.groupSVGElements(elements, object, objects);\n                var clipPath = options.clipPath;\n                delete options.clipPath;\n                group.set(options);\n                if (clipPath) {\n                    fabric.util.enlivenObjects([\n                        clipPath\n                    ], function(elivenedObjects) {\n                        group.clipPath = elivenedObjects[0];\n                        callback && callback(group);\n                    });\n                } else {\n                    callback && callback(group);\n                }\n            });\n            return;\n        }\n        fabric.util.enlivenObjects(objects, function(enlivenedObjects) {\n            fabric.util.enlivenObjectEnlivables(object, options, function() {\n                callback && callback(new fabric.Group(enlivenedObjects, options, true));\n            });\n        });\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {});\n    if (fabric.ActiveSelection) {\n        return;\n    }\n    /**\n   * Group class\n   * @class fabric.ActiveSelection\n   * @extends fabric.Group\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}\n   * @see {@link fabric.ActiveSelection#initialize} for constructor definition\n   */ fabric.ActiveSelection = fabric.util.createClass(fabric.Group, /** @lends fabric.ActiveSelection.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"activeSelection\",\n        /**\n     * Constructor\n     * @param {Object} objects ActiveSelection objects\n     * @param {Object} [options] Options object\n     * @return {Object} thisArg\n     */ initialize: function(objects, options) {\n            options = options || {};\n            this._objects = objects || [];\n            for(var i = this._objects.length; i--;){\n                this._objects[i].group = this;\n            }\n            if (options.originX) {\n                this.originX = options.originX;\n            }\n            if (options.originY) {\n                this.originY = options.originY;\n            }\n            this._calcBounds();\n            this._updateObjectsCoords();\n            fabric.Object.prototype.initialize.call(this, options);\n            this.setCoords();\n        },\n        /**\n     * Change te activeSelection to a normal group,\n     * High level function that automatically adds it to canvas as\n     * active object. no events fired.\n     * @since 2.0.0\n     * @return {fabric.Group}\n     */ toGroup: function() {\n            var objects = this._objects.concat();\n            this._objects = [];\n            var options = fabric.Object.prototype.toObject.call(this);\n            var newGroup = new fabric.Group([]);\n            delete options.type;\n            newGroup.set(options);\n            objects.forEach(function(object) {\n                object.canvas.remove(object);\n                object.group = newGroup;\n            });\n            newGroup._objects = objects;\n            if (!this.canvas) {\n                return newGroup;\n            }\n            var canvas = this.canvas;\n            canvas.add(newGroup);\n            canvas._activeObject = newGroup;\n            newGroup.setCoords();\n            return newGroup;\n        },\n        /**\n     * If returns true, deselection is cancelled.\n     * @since 2.0.0\n     * @return {Boolean} [cancel]\n     */ onDeselect: function() {\n            this.destroy();\n            return false;\n        },\n        /**\n     * Returns string representation of a group\n     * @return {String}\n     */ toString: function() {\n            return \"#<fabric.ActiveSelection: (\" + this.complexity() + \")>\";\n        },\n        /**\n     * Decide if the object should cache or not. Create its own cache level\n     * objectCaching is a global flag, wins over everything\n     * needsItsOwnCache should be used when the object drawing method requires\n     * a cache step. None of the fabric classes requires it.\n     * Generally you do not cache objects in groups because the group outside is cached.\n     * @return {Boolean}\n     */ shouldCache: function() {\n            return false;\n        },\n        /**\n     * Check if this group or its parent group are caching, recursively up\n     * @return {Boolean}\n     */ isOnACache: function() {\n            return false;\n        },\n        /**\n     * Renders controls and borders for the object\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Object} [styleOverride] properties to override the object style\n     * @param {Object} [childrenOverride] properties to override the children overrides\n     */ _renderControls: function(ctx, styleOverride, childrenOverride) {\n            ctx.save();\n            ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;\n            childrenOverride = childrenOverride || {};\n            if (typeof childrenOverride.hasControls === \"undefined\") {\n                childrenOverride.hasControls = false;\n            }\n            childrenOverride.forActiveSelection = true;\n            for(var i = 0, len = this._objects.length; i < len; i++){\n                this._objects[i]._renderControls(ctx, childrenOverride);\n            }\n            this.callSuper(\"_renderControls\", ctx, styleOverride);\n            ctx.restore();\n        }\n    });\n    /**\n   * Returns {@link fabric.ActiveSelection} instance from an object representation\n   * @static\n   * @memberOf fabric.ActiveSelection\n   * @param {Object} object Object to create a group from\n   * @param {Function} [callback] Callback to invoke when an ActiveSelection instance is created\n   */ fabric.ActiveSelection.fromObject = function(object, callback) {\n        fabric.util.enlivenObjects(object.objects, function(enlivenedObjects) {\n            delete object.objects;\n            callback && callback(new fabric.ActiveSelection(enlivenedObjects, object, true));\n        });\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var extend = fabric.util.object.extend;\n    if (!global.fabric) {\n        global.fabric = {};\n    }\n    if (global.fabric.Image) {\n        fabric.warn(\"fabric.Image is already defined.\");\n        return;\n    }\n    /**\n   * Image class\n   * @class fabric.Image\n   * @extends fabric.Object\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#images}\n   * @see {@link fabric.Image#initialize} for constructor definition\n   */ fabric.Image = fabric.util.createClass(fabric.Object, /** @lends fabric.Image.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"image\",\n        /**\n     * Width of a stroke.\n     * For image quality a stroke multiple of 2 gives better results.\n     * @type Number\n     * @default\n     */ strokeWidth: 0,\n        /**\n     * When calling {@link fabric.Image.getSrc}, return value from element src with `element.getAttribute('src')`.\n     * This allows for relative urls as image src.\n     * @since 2.7.0\n     * @type Boolean\n     * @default\n     */ srcFromAttribute: false,\n        /**\n     * private\n     * contains last value of scaleX to detect\n     * if the Image got resized after the last Render\n     * @type Number\n     */ _lastScaleX: 1,\n        /**\n     * private\n     * contains last value of scaleY to detect\n     * if the Image got resized after the last Render\n     * @type Number\n     */ _lastScaleY: 1,\n        /**\n     * private\n     * contains last value of scaling applied by the apply filter chain\n     * @type Number\n     */ _filterScalingX: 1,\n        /**\n     * private\n     * contains last value of scaling applied by the apply filter chain\n     * @type Number\n     */ _filterScalingY: 1,\n        /**\n     * minimum scale factor under which any resizeFilter is triggered to resize the image\n     * 0 will disable the automatic resize. 1 will trigger automatically always.\n     * number bigger than 1 are not implemented yet.\n     * @type Number\n     */ minimumScaleTrigger: 0.5,\n        /**\n     * List of properties to consider when checking if\n     * state of an object is changed ({@link fabric.Object#hasStateChanged})\n     * as well as for history (undo/redo) purposes\n     * @type Array\n     */ stateProperties: fabric.Object.prototype.stateProperties.concat(\"cropX\", \"cropY\"),\n        /**\n     * List of properties to consider when checking if cache needs refresh\n     * Those properties are checked by statefullCache ON ( or lazy mode if we want ) or from single\n     * calls to Object.set(key, value). If the key is in this list, the object is marked as dirty\n     * and refreshed at the next render\n     * @type Array\n     */ cacheProperties: fabric.Object.prototype.cacheProperties.concat(\"cropX\", \"cropY\"),\n        /**\n     * key used to retrieve the texture representing this image\n     * @since 2.0.0\n     * @type String\n     * @default\n     */ cacheKey: \"\",\n        /**\n     * Image crop in pixels from original image size.\n     * @since 2.0.0\n     * @type Number\n     * @default\n     */ cropX: 0,\n        /**\n     * Image crop in pixels from original image size.\n     * @since 2.0.0\n     * @type Number\n     * @default\n     */ cropY: 0,\n        /**\n     * Indicates whether this canvas will use image smoothing when painting this image.\n     * Also influence if the cacheCanvas for this image uses imageSmoothing\n     * @since 4.0.0-beta.11\n     * @type Boolean\n     * @default\n     */ imageSmoothing: true,\n        /**\n     * Constructor\n     * Image can be initialized with any canvas drawable or a string.\n     * The string should be a url and will be loaded as an image.\n     * Canvas and Image element work out of the box, while videos require extra code to work.\n     * Please check video element events for seeking.\n     * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | String} element Image element\n     * @param {Object} [options] Options object\n     * @param {function} [callback] callback function to call after eventual filters applied.\n     * @return {fabric.Image} thisArg\n     */ initialize: function(element, options) {\n            options || (options = {});\n            this.filters = [];\n            this.cacheKey = \"texture\" + fabric.Object.__uid++;\n            this.callSuper(\"initialize\", options);\n            this._initElement(element, options);\n        },\n        /**\n     * Returns image element which this instance if based on\n     * @return {HTMLImageElement} Image element\n     */ getElement: function() {\n            return this._element || {};\n        },\n        /**\n     * Sets image element for this instance to a specified one.\n     * If filters defined they are applied to new image.\n     * You might need to call `canvas.renderAll` and `object.setCoords` after replacing, to render new image and update controls area.\n     * @param {HTMLImageElement} element\n     * @param {Object} [options] Options object\n     * @return {fabric.Image} thisArg\n     * @chainable\n     */ setElement: function(element, options) {\n            this.removeTexture(this.cacheKey);\n            this.removeTexture(this.cacheKey + \"_filtered\");\n            this._element = element;\n            this._originalElement = element;\n            this._initConfig(options);\n            if (this.filters.length !== 0) {\n                this.applyFilters();\n            }\n            // resizeFilters work on the already filtered copy.\n            // we need to apply resizeFilters AFTER normal filters.\n            // applyResizeFilters is run more often than normal filters\n            // and is triggered by user interactions rather than dev code\n            if (this.resizeFilter) {\n                this.applyResizeFilters();\n            }\n            return this;\n        },\n        /**\n     * Delete a single texture if in webgl mode\n     */ removeTexture: function(key) {\n            var backend = fabric.filterBackend;\n            if (backend && backend.evictCachesForKey) {\n                backend.evictCachesForKey(key);\n            }\n        },\n        /**\n     * Delete textures, reference to elements and eventually JSDOM cleanup\n     */ dispose: function() {\n            this.callSuper(\"dispose\");\n            this.removeTexture(this.cacheKey);\n            this.removeTexture(this.cacheKey + \"_filtered\");\n            this._cacheContext = undefined;\n            [\n                \"_originalElement\",\n                \"_element\",\n                \"_filteredEl\",\n                \"_cacheCanvas\"\n            ].forEach((function(element) {\n                fabric.util.cleanUpJsdomNode(this[element]);\n                this[element] = undefined;\n            }).bind(this));\n        },\n        /**\n     * Get the crossOrigin value (of the corresponding image element)\n     */ getCrossOrigin: function() {\n            return this._originalElement && (this._originalElement.crossOrigin || null);\n        },\n        /**\n     * Returns original size of an image\n     * @return {Object} Object with \"width\" and \"height\" properties\n     */ getOriginalSize: function() {\n            var element = this.getElement();\n            return {\n                width: element.naturalWidth || element.width,\n                height: element.naturalHeight || element.height\n            };\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _stroke: function(ctx) {\n            if (!this.stroke || this.strokeWidth === 0) {\n                return;\n            }\n            var w = this.width / 2, h = this.height / 2;\n            ctx.beginPath();\n            ctx.moveTo(-w, -h);\n            ctx.lineTo(w, -h);\n            ctx.lineTo(w, h);\n            ctx.lineTo(-w, h);\n            ctx.lineTo(-w, -h);\n            ctx.closePath();\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            var filters = [];\n            this.filters.forEach(function(filterObj) {\n                if (filterObj) {\n                    filters.push(filterObj.toObject());\n                }\n            });\n            var object = extend(this.callSuper(\"toObject\", [\n                \"cropX\",\n                \"cropY\"\n            ].concat(propertiesToInclude)), {\n                src: this.getSrc(),\n                crossOrigin: this.getCrossOrigin(),\n                filters: filters\n            });\n            if (this.resizeFilter) {\n                object.resizeFilter = this.resizeFilter.toObject();\n            }\n            return object;\n        },\n        /**\n     * Returns true if an image has crop applied, inspecting values of cropX,cropY,width,height.\n     * @return {Boolean}\n     */ hasCrop: function() {\n            return this.cropX || this.cropY || this.width < this._element.width || this.height < this._element.height;\n        },\n        /* _TO_SVG_START_ */ /**\n     * Returns svg representation of an instance\n     * @return {Array} an array of strings with the specific svg representation\n     * of the instance\n     */ _toSVG: function() {\n            var svgString = [], imageMarkup = [], strokeSvg, element = this._element, x = -this.width / 2, y = -this.height / 2, clipPath = \"\", imageRendering = \"\";\n            if (!element) {\n                return [];\n            }\n            if (this.hasCrop()) {\n                var clipPathId = fabric.Object.__uid++;\n                svgString.push('<clipPath id=\"imageCrop_' + clipPathId + '\">\\n', '\t<rect x=\"' + x + '\" y=\"' + y + '\" width=\"' + this.width + '\" height=\"' + this.height + '\" />\\n', \"</clipPath>\\n\");\n                clipPath = ' clip-path=\"url(#imageCrop_' + clipPathId + ')\" ';\n            }\n            if (!this.imageSmoothing) {\n                imageRendering = '\" image-rendering=\"optimizeSpeed';\n            }\n            imageMarkup.push(\"\t<image \", \"COMMON_PARTS\", 'xlink:href=\"', this.getSvgSrc(true), '\" x=\"', x - this.cropX, '\" y=\"', y - this.cropY, // we're essentially moving origin of transformation from top/left corner to the center of the shape\n            // by wrapping it in container <g> element with actual transformation, then offsetting object to the top/left\n            // so that object's center aligns with container's left/top\n            '\" width=\"', element.width || element.naturalWidth, '\" height=\"', element.height || element.height, imageRendering, '\"', clipPath, \"></image>\\n\");\n            if (this.stroke || this.strokeDashArray) {\n                var origFill = this.fill;\n                this.fill = null;\n                strokeSvg = [\n                    \"\t<rect \",\n                    'x=\"',\n                    x,\n                    '\" y=\"',\n                    y,\n                    '\" width=\"',\n                    this.width,\n                    '\" height=\"',\n                    this.height,\n                    '\" style=\"',\n                    this.getSvgStyles(),\n                    '\"/>\\n'\n                ];\n                this.fill = origFill;\n            }\n            if (this.paintFirst !== \"fill\") {\n                svgString = svgString.concat(strokeSvg, imageMarkup);\n            } else {\n                svgString = svgString.concat(imageMarkup, strokeSvg);\n            }\n            return svgString;\n        },\n        /* _TO_SVG_END_ */ /**\n     * Returns source of an image\n     * @param {Boolean} filtered indicates if the src is needed for svg\n     * @return {String} Source of an image\n     */ getSrc: function(filtered) {\n            var element = filtered ? this._element : this._originalElement;\n            if (element) {\n                if (element.toDataURL) {\n                    return element.toDataURL();\n                }\n                if (this.srcFromAttribute) {\n                    return element.getAttribute(\"src\");\n                } else {\n                    return element.src;\n                }\n            } else {\n                return this.src || \"\";\n            }\n        },\n        /**\n     * Sets source of an image\n     * @param {String} src Source string (URL)\n     * @param {Function} [callback] Callback is invoked when image has been loaded (and all filters have been applied)\n     * @param {Object} [options] Options object\n     * @param {String} [options.crossOrigin] crossOrigin value (one of \"\", \"anonymous\", \"use-credentials\")\n     * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes\n     * @return {fabric.Image} thisArg\n     * @chainable\n     */ setSrc: function(src, callback, options) {\n            fabric.util.loadImage(src, function(img, isError) {\n                this.setElement(img, options);\n                this._setWidthHeight();\n                callback && callback(this, isError);\n            }, this, options && options.crossOrigin);\n            return this;\n        },\n        /**\n     * Returns string representation of an instance\n     * @return {String} String representation of an instance\n     */ toString: function() {\n            return '#<fabric.Image: { src: \"' + this.getSrc() + '\" }>';\n        },\n        applyResizeFilters: function() {\n            var filter = this.resizeFilter, minimumScale = this.minimumScaleTrigger, objectScale = this.getTotalObjectScaling(), scaleX = objectScale.scaleX, scaleY = objectScale.scaleY, elementToFilter = this._filteredEl || this._originalElement;\n            if (this.group) {\n                this.set(\"dirty\", true);\n            }\n            if (!filter || scaleX > minimumScale && scaleY > minimumScale) {\n                this._element = elementToFilter;\n                this._filterScalingX = 1;\n                this._filterScalingY = 1;\n                this._lastScaleX = scaleX;\n                this._lastScaleY = scaleY;\n                return;\n            }\n            if (!fabric.filterBackend) {\n                fabric.filterBackend = fabric.initFilterBackend();\n            }\n            var canvasEl = fabric.util.createCanvasElement(), cacheKey = this._filteredEl ? this.cacheKey + \"_filtered\" : this.cacheKey, sourceWidth = elementToFilter.width, sourceHeight = elementToFilter.height;\n            canvasEl.width = sourceWidth;\n            canvasEl.height = sourceHeight;\n            this._element = canvasEl;\n            this._lastScaleX = filter.scaleX = scaleX;\n            this._lastScaleY = filter.scaleY = scaleY;\n            fabric.filterBackend.applyFilters([\n                filter\n            ], elementToFilter, sourceWidth, sourceHeight, this._element, cacheKey);\n            this._filterScalingX = canvasEl.width / this._originalElement.width;\n            this._filterScalingY = canvasEl.height / this._originalElement.height;\n        },\n        /**\n     * Applies filters assigned to this image (from \"filters\" array) or from filter param\n     * @method applyFilters\n     * @param {Array} filters to be applied\n     * @param {Boolean} forResizing specify if the filter operation is a resize operation\n     * @return {thisArg} return the fabric.Image object\n     * @chainable\n     */ applyFilters: function(filters) {\n            filters = filters || this.filters || [];\n            filters = filters.filter(function(filter) {\n                return filter && !filter.isNeutralState();\n            });\n            this.set(\"dirty\", true);\n            // needs to clear out or WEBGL will not resize correctly\n            this.removeTexture(this.cacheKey + \"_filtered\");\n            if (filters.length === 0) {\n                this._element = this._originalElement;\n                this._filteredEl = null;\n                this._filterScalingX = 1;\n                this._filterScalingY = 1;\n                return this;\n            }\n            var imgElement = this._originalElement, sourceWidth = imgElement.naturalWidth || imgElement.width, sourceHeight = imgElement.naturalHeight || imgElement.height;\n            if (this._element === this._originalElement) {\n                // if the element is the same we need to create a new element\n                var canvasEl = fabric.util.createCanvasElement();\n                canvasEl.width = sourceWidth;\n                canvasEl.height = sourceHeight;\n                this._element = canvasEl;\n                this._filteredEl = canvasEl;\n            } else {\n                // clear the existing element to get new filter data\n                // also dereference the eventual resized _element\n                this._element = this._filteredEl;\n                this._filteredEl.getContext(\"2d\").clearRect(0, 0, sourceWidth, sourceHeight);\n                // we also need to resize again at next renderAll, so remove saved _lastScaleX/Y\n                this._lastScaleX = 1;\n                this._lastScaleY = 1;\n            }\n            if (!fabric.filterBackend) {\n                fabric.filterBackend = fabric.initFilterBackend();\n            }\n            fabric.filterBackend.applyFilters(filters, this._originalElement, sourceWidth, sourceHeight, this._element, this.cacheKey);\n            if (this._originalElement.width !== this._element.width || this._originalElement.height !== this._element.height) {\n                this._filterScalingX = this._element.width / this._originalElement.width;\n                this._filterScalingY = this._element.height / this._originalElement.height;\n            }\n            return this;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            fabric.util.setImageSmoothing(ctx, this.imageSmoothing);\n            if (this.isMoving !== true && this.resizeFilter && this._needsResize()) {\n                this.applyResizeFilters();\n            }\n            this._stroke(ctx);\n            this._renderPaintInOrder(ctx);\n        },\n        /**\n     * Paint the cached copy of the object on the target context.\n     * it will set the imageSmoothing for the draw operation\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ drawCacheOnCanvas: function(ctx) {\n            fabric.util.setImageSmoothing(ctx, this.imageSmoothing);\n            fabric.Object.prototype.drawCacheOnCanvas.call(this, ctx);\n        },\n        /**\n     * Decide if the object should cache or not. Create its own cache level\n     * needsItsOwnCache should be used when the object drawing method requires\n     * a cache step. None of the fabric classes requires it.\n     * Generally you do not cache objects in groups because the group outside is cached.\n     * This is the special image version where we would like to avoid caching where possible.\n     * Essentially images do not benefit from caching. They may require caching, and in that\n     * case we do it. Also caching an image usually ends in a loss of details.\n     * A full performance audit should be done.\n     * @return {Boolean}\n     */ shouldCache: function() {\n            return this.needsItsOwnCache();\n        },\n        _renderFill: function(ctx) {\n            var elementToDraw = this._element;\n            if (!elementToDraw) {\n                return;\n            }\n            var scaleX = this._filterScalingX, scaleY = this._filterScalingY, w = this.width, h = this.height, min = Math.min, max = Math.max, // crop values cannot be lesser than 0.\n            cropX = max(this.cropX, 0), cropY = max(this.cropY, 0), elWidth = elementToDraw.naturalWidth || elementToDraw.width, elHeight = elementToDraw.naturalHeight || elementToDraw.height, sX = cropX * scaleX, sY = cropY * scaleY, // the width height cannot exceed element width/height, starting from the crop offset.\n            sW = min(w * scaleX, elWidth - sX), sH = min(h * scaleY, elHeight - sY), x = -w / 2, y = -h / 2, maxDestW = min(w, elWidth / scaleX - cropX), maxDestH = min(h, elHeight / scaleY - cropY);\n            elementToDraw && ctx.drawImage(elementToDraw, sX, sY, sW, sH, x, y, maxDestW, maxDestH);\n        },\n        /**\n     * needed to check if image needs resize\n     * @private\n     */ _needsResize: function() {\n            var scale = this.getTotalObjectScaling();\n            return scale.scaleX !== this._lastScaleX || scale.scaleY !== this._lastScaleY;\n        },\n        /**\n     * @private\n     */ _resetWidthHeight: function() {\n            this.set(this.getOriginalSize());\n        },\n        /**\n     * The Image class's initialization method. This method is automatically\n     * called by the constructor.\n     * @private\n     * @param {HTMLImageElement|String} element The element representing the image\n     * @param {Object} [options] Options object\n     */ _initElement: function(element, options) {\n            this.setElement(fabric.util.getById(element), options);\n            fabric.util.addClass(this.getElement(), fabric.Image.CSS_CANVAS);\n        },\n        /**\n     * @private\n     * @param {Object} [options] Options object\n     */ _initConfig: function(options) {\n            options || (options = {});\n            this.setOptions(options);\n            this._setWidthHeight(options);\n        },\n        /**\n     * @private\n     * @param {Array} filters to be initialized\n     * @param {Function} callback Callback to invoke when all fabric.Image.filters instances are created\n     */ _initFilters: function(filters, callback) {\n            if (filters && filters.length) {\n                fabric.util.enlivenObjects(filters, function(enlivenedObjects) {\n                    callback && callback(enlivenedObjects);\n                }, \"fabric.Image.filters\");\n            } else {\n                callback && callback();\n            }\n        },\n        /**\n     * @private\n     * Set the width and the height of the image object, using the element or the\n     * options.\n     * @param {Object} [options] Object with width/height properties\n     */ _setWidthHeight: function(options) {\n            options || (options = {});\n            var el = this.getElement();\n            this.width = options.width || el.naturalWidth || el.width || 0;\n            this.height = options.height || el.naturalHeight || el.height || 0;\n        },\n        /**\n     * Calculate offset for center and scale factor for the image in order to respect\n     * the preserveAspectRatio attribute\n     * @private\n     * @return {Object}\n     */ parsePreserveAspectRatioAttribute: function() {\n            var pAR = fabric.util.parsePreserveAspectRatioAttribute(this.preserveAspectRatio || \"\"), rWidth = this._element.width, rHeight = this._element.height, scaleX = 1, scaleY = 1, offsetLeft = 0, offsetTop = 0, cropX = 0, cropY = 0, offset, pWidth = this.width, pHeight = this.height, parsedAttributes = {\n                width: pWidth,\n                height: pHeight\n            };\n            if (pAR && (pAR.alignX !== \"none\" || pAR.alignY !== \"none\")) {\n                if (pAR.meetOrSlice === \"meet\") {\n                    scaleX = scaleY = fabric.util.findScaleToFit(this._element, parsedAttributes);\n                    offset = (pWidth - rWidth * scaleX) / 2;\n                    if (pAR.alignX === \"Min\") {\n                        offsetLeft = -offset;\n                    }\n                    if (pAR.alignX === \"Max\") {\n                        offsetLeft = offset;\n                    }\n                    offset = (pHeight - rHeight * scaleY) / 2;\n                    if (pAR.alignY === \"Min\") {\n                        offsetTop = -offset;\n                    }\n                    if (pAR.alignY === \"Max\") {\n                        offsetTop = offset;\n                    }\n                }\n                if (pAR.meetOrSlice === \"slice\") {\n                    scaleX = scaleY = fabric.util.findScaleToCover(this._element, parsedAttributes);\n                    offset = rWidth - pWidth / scaleX;\n                    if (pAR.alignX === \"Mid\") {\n                        cropX = offset / 2;\n                    }\n                    if (pAR.alignX === \"Max\") {\n                        cropX = offset;\n                    }\n                    offset = rHeight - pHeight / scaleY;\n                    if (pAR.alignY === \"Mid\") {\n                        cropY = offset / 2;\n                    }\n                    if (pAR.alignY === \"Max\") {\n                        cropY = offset;\n                    }\n                    rWidth = pWidth / scaleX;\n                    rHeight = pHeight / scaleY;\n                }\n            } else {\n                scaleX = pWidth / rWidth;\n                scaleY = pHeight / rHeight;\n            }\n            return {\n                width: rWidth,\n                height: rHeight,\n                scaleX: scaleX,\n                scaleY: scaleY,\n                offsetLeft: offsetLeft,\n                offsetTop: offsetTop,\n                cropX: cropX,\n                cropY: cropY\n            };\n        }\n    });\n    /**\n   * Default CSS class name for canvas\n   * @static\n   * @type String\n   * @default\n   */ fabric.Image.CSS_CANVAS = \"canvas-img\";\n    /**\n   * Alias for getSrc\n   * @static\n   */ fabric.Image.prototype.getSvgSrc = fabric.Image.prototype.getSrc;\n    /**\n   * Creates an instance of fabric.Image from its object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} callback Callback to invoke when an image instance is created\n   */ fabric.Image.fromObject = function(_object, callback) {\n        var object = fabric.util.object.clone(_object);\n        fabric.util.loadImage(object.src, function(img, isError) {\n            if (isError) {\n                callback && callback(null, true);\n                return;\n            }\n            fabric.Image.prototype._initFilters.call(object, object.filters, function(filters) {\n                object.filters = filters || [];\n                fabric.Image.prototype._initFilters.call(object, [\n                    object.resizeFilter\n                ], function(resizeFilters) {\n                    object.resizeFilter = resizeFilters[0];\n                    fabric.util.enlivenObjectEnlivables(object, object, function() {\n                        var image = new fabric.Image(img, object);\n                        callback(image, false);\n                    });\n                });\n            });\n        }, null, object.crossOrigin);\n    };\n    /**\n   * Creates an instance of fabric.Image from an URL string\n   * @static\n   * @param {String} url URL to create an image from\n   * @param {Function} [callback] Callback to invoke when image is created (newly created image is passed as a first argument). Second argument is a boolean indicating if an error occurred or not.\n   * @param {Object} [imgOptions] Options object\n   */ fabric.Image.fromURL = function(url, callback, imgOptions) {\n        fabric.util.loadImage(url, function(img, isError) {\n            callback && callback(new fabric.Image(img, imgOptions), isError);\n        }, null, imgOptions && imgOptions.crossOrigin);\n    };\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Image.fromElement})\n   * @static\n   * @see {@link http://www.w3.org/TR/SVG/struct.html#ImageElement}\n   */ fabric.Image.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\"x y width height preserveAspectRatio xlink:href crossOrigin image-rendering\".split(\" \"));\n    /**\n   * Returns {@link fabric.Image} instance from an SVG element\n   * @static\n   * @param {SVGElement} element Element to parse\n   * @param {Object} [options] Options object\n   * @param {Function} callback Callback to execute when fabric.Image object is created\n   * @return {fabric.Image} Instance of fabric.Image\n   */ fabric.Image.fromElement = function(element, callback, options) {\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Image.ATTRIBUTE_NAMES);\n        fabric.Image.fromURL(parsedAttributes[\"xlink:href\"], callback, extend(options ? fabric.util.object.clone(options) : {}, parsedAttributes));\n    };\n/* _FROM_SVG_END_ */ })( true ? exports : 0);\nfabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\n    /**\n   * @private\n   * @return {Number} angle value\n   */ _getAngleValueForStraighten: function() {\n        var angle = this.angle % 360;\n        if (angle > 0) {\n            return Math.round((angle - 1) / 90) * 90;\n        }\n        return Math.round(angle / 90) * 90;\n    },\n    /**\n   * Straightens an object (rotating it from current angle to one of 0, 90, 180, 270, etc. depending on which is closer)\n   * @return {fabric.Object} thisArg\n   * @chainable\n   */ straighten: function() {\n        return this.rotate(this._getAngleValueForStraighten());\n    },\n    /**\n   * Same as {@link fabric.Object.prototype.straighten} but with animation\n   * @param {Object} callbacks Object with callback functions\n   * @param {Function} [callbacks.onComplete] Invoked on completion\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\n   * @return {fabric.Object} thisArg\n   */ fxStraighten: function(callbacks) {\n        callbacks = callbacks || {};\n        var empty = function() {}, onComplete = callbacks.onComplete || empty, onChange = callbacks.onChange || empty, _this = this;\n        return fabric.util.animate({\n            target: this,\n            startValue: this.get(\"angle\"),\n            endValue: this._getAngleValueForStraighten(),\n            duration: this.FX_DURATION,\n            onChange: function(value) {\n                _this.rotate(value);\n                onChange();\n            },\n            onComplete: function() {\n                _this.setCoords();\n                onComplete();\n            }\n        });\n    }\n});\nfabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\n    /**\n   * Straightens object, then rerenders canvas\n   * @param {fabric.Object} object Object to straighten\n   * @return {fabric.Canvas} thisArg\n   * @chainable\n   */ straightenObject: function(object) {\n        object.straighten();\n        this.requestRenderAll();\n        return this;\n    },\n    /**\n   * Same as {@link fabric.Canvas.prototype.straightenObject}, but animated\n   * @param {fabric.Object} object Object to straighten\n   * @return {fabric.Canvas} thisArg\n   */ fxStraightenObject: function(object) {\n        return object.fxStraighten({\n            onChange: this.requestRenderAllBound\n        });\n    }\n});\n(function() {\n    \"use strict\";\n    /**\n   * Tests if webgl supports certain precision\n   * @param {WebGL} Canvas WebGL context to test on\n   * @param {String} Precision to test can be any of following: 'lowp', 'mediump', 'highp'\n   * @returns {Boolean} Whether the user's browser WebGL supports given precision.\n   */ function testPrecision(gl, precision) {\n        var fragmentSource = \"precision \" + precision + \" float;\\nvoid main(){}\";\n        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n        gl.shaderSource(fragmentShader, fragmentSource);\n        gl.compileShader(fragmentShader);\n        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n   * Indicate whether this filtering backend is supported by the user's browser.\n   * @param {Number} tileSize check if the tileSize is supported\n   * @returns {Boolean} Whether the user's browser supports WebGL.\n   */ fabric.isWebglSupported = function(tileSize) {\n        if (fabric.isLikelyNode) {\n            return false;\n        }\n        tileSize = tileSize || fabric.WebglFilterBackend.prototype.tileSize;\n        var canvas = document.createElement(\"canvas\");\n        var gl = canvas.getContext(\"webgl\") || canvas.getContext(\"experimental-webgl\");\n        var isSupported = false;\n        // eslint-disable-next-line\n        if (gl) {\n            fabric.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n            isSupported = fabric.maxTextureSize >= tileSize;\n            var precisions = [\n                \"highp\",\n                \"mediump\",\n                \"lowp\"\n            ];\n            for(var i = 0; i < 3; i++){\n                if (testPrecision(gl, precisions[i])) {\n                    fabric.webGlPrecision = precisions[i];\n                    break;\n                }\n                ;\n            }\n        }\n        this.isSupported = isSupported;\n        return isSupported;\n    };\n    fabric.WebglFilterBackend = WebglFilterBackend;\n    /**\n   * WebGL filter backend.\n   */ function WebglFilterBackend(options) {\n        if (options && options.tileSize) {\n            this.tileSize = options.tileSize;\n        }\n        this.setupGLContext(this.tileSize, this.tileSize);\n        this.captureGPUInfo();\n    }\n    ;\n    WebglFilterBackend.prototype = /** @lends fabric.WebglFilterBackend.prototype */ {\n        tileSize: 2048,\n        /**\n     * Experimental. This object is a sort of repository of help layers used to avoid\n     * of recreating them during frequent filtering. If you are previewing a filter with\n     * a slider you probably do not want to create help layers every filter step.\n     * in this object there will be appended some canvases, created once, resized sometimes\n     * cleared never. Clearing is left to the developer.\n     **/ resources: {},\n        /**\n     * Setup a WebGL context suitable for filtering, and bind any needed event handlers.\n     */ setupGLContext: function(width, height) {\n            this.dispose();\n            this.createWebGLCanvas(width, height);\n            // eslint-disable-next-line\n            this.aPosition = new Float32Array([\n                0,\n                0,\n                0,\n                1,\n                1,\n                0,\n                1,\n                1\n            ]);\n            this.chooseFastestCopyGLTo2DMethod(width, height);\n        },\n        /**\n     * Pick a method to copy data from GL context to 2d canvas.  In some browsers using\n     * putImageData is faster than drawImage for that specific operation.\n     */ chooseFastestCopyGLTo2DMethod: function(width, height) {\n            var canMeasurePerf = typeof window.performance !== \"undefined\", canUseImageData;\n            try {\n                new ImageData(1, 1);\n                canUseImageData = true;\n            } catch (e) {\n                canUseImageData = false;\n            }\n            // eslint-disable-next-line no-undef\n            var canUseArrayBuffer = typeof ArrayBuffer !== \"undefined\";\n            // eslint-disable-next-line no-undef\n            var canUseUint8Clamped = typeof Uint8ClampedArray !== \"undefined\";\n            if (!(canMeasurePerf && canUseImageData && canUseArrayBuffer && canUseUint8Clamped)) {\n                return;\n            }\n            var targetCanvas = fabric.util.createCanvasElement();\n            // eslint-disable-next-line no-undef\n            var imageBuffer = new ArrayBuffer(width * height * 4);\n            if (fabric.forceGLPutImageData) {\n                this.imageBuffer = imageBuffer;\n                this.copyGLTo2D = copyGLTo2DPutImageData;\n                return;\n            }\n            var testContext = {\n                imageBuffer: imageBuffer,\n                destinationWidth: width,\n                destinationHeight: height,\n                targetCanvas: targetCanvas\n            };\n            var startTime, drawImageTime, putImageDataTime;\n            targetCanvas.width = width;\n            targetCanvas.height = height;\n            startTime = window.performance.now();\n            copyGLTo2DDrawImage.call(testContext, this.gl, testContext);\n            drawImageTime = window.performance.now() - startTime;\n            startTime = window.performance.now();\n            copyGLTo2DPutImageData.call(testContext, this.gl, testContext);\n            putImageDataTime = window.performance.now() - startTime;\n            if (drawImageTime > putImageDataTime) {\n                this.imageBuffer = imageBuffer;\n                this.copyGLTo2D = copyGLTo2DPutImageData;\n            } else {\n                this.copyGLTo2D = copyGLTo2DDrawImage;\n            }\n        },\n        /**\n     * Create a canvas element and associated WebGL context and attaches them as\n     * class properties to the GLFilterBackend class.\n     */ createWebGLCanvas: function(width, height) {\n            var canvas = fabric.util.createCanvasElement();\n            canvas.width = width;\n            canvas.height = height;\n            var glOptions = {\n                alpha: true,\n                premultipliedAlpha: false,\n                depth: false,\n                stencil: false,\n                antialias: false\n            }, gl = canvas.getContext(\"webgl\", glOptions);\n            if (!gl) {\n                gl = canvas.getContext(\"experimental-webgl\", glOptions);\n            }\n            if (!gl) {\n                return;\n            }\n            gl.clearColor(0, 0, 0, 0);\n            // this canvas can fire webglcontextlost and webglcontextrestored\n            this.canvas = canvas;\n            this.gl = gl;\n        },\n        /**\n     * Attempts to apply the requested filters to the source provided, drawing the filtered output\n     * to the provided target canvas.\n     *\n     * @param {Array} filters The filters to apply.\n     * @param {HTMLImageElement|HTMLCanvasElement} source The source to be filtered.\n     * @param {Number} width The width of the source input.\n     * @param {Number} height The height of the source input.\n     * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.\n     * @param {String|undefined} cacheKey A key used to cache resources related to the source. If\n     * omitted, caching will be skipped.\n     */ applyFilters: function(filters, source, width, height, targetCanvas, cacheKey) {\n            var gl = this.gl;\n            var cachedTexture;\n            if (cacheKey) {\n                cachedTexture = this.getCachedTexture(cacheKey, source);\n            }\n            var pipelineState = {\n                originalWidth: source.width || source.originalWidth,\n                originalHeight: source.height || source.originalHeight,\n                sourceWidth: width,\n                sourceHeight: height,\n                destinationWidth: width,\n                destinationHeight: height,\n                context: gl,\n                sourceTexture: this.createTexture(gl, width, height, !cachedTexture && source),\n                targetTexture: this.createTexture(gl, width, height),\n                originalTexture: cachedTexture || this.createTexture(gl, width, height, !cachedTexture && source),\n                passes: filters.length,\n                webgl: true,\n                aPosition: this.aPosition,\n                programCache: this.programCache,\n                pass: 0,\n                filterBackend: this,\n                targetCanvas: targetCanvas\n            };\n            var tempFbo = gl.createFramebuffer();\n            gl.bindFramebuffer(gl.FRAMEBUFFER, tempFbo);\n            filters.forEach(function(filter) {\n                filter && filter.applyTo(pipelineState);\n            });\n            resizeCanvasIfNeeded(pipelineState);\n            this.copyGLTo2D(gl, pipelineState);\n            gl.bindTexture(gl.TEXTURE_2D, null);\n            gl.deleteTexture(pipelineState.sourceTexture);\n            gl.deleteTexture(pipelineState.targetTexture);\n            gl.deleteFramebuffer(tempFbo);\n            targetCanvas.getContext(\"2d\").setTransform(1, 0, 0, 1, 0, 0);\n            return pipelineState;\n        },\n        /**\n     * Detach event listeners, remove references, and clean up caches.\n     */ dispose: function() {\n            if (this.canvas) {\n                this.canvas = null;\n                this.gl = null;\n            }\n            this.clearWebGLCaches();\n        },\n        /**\n     * Wipe out WebGL-related caches.\n     */ clearWebGLCaches: function() {\n            this.programCache = {};\n            this.textureCache = {};\n        },\n        /**\n     * Create a WebGL texture object.\n     *\n     * Accepts specific dimensions to initialize the texture to or a source image.\n     *\n     * @param {WebGLRenderingContext} gl The GL context to use for creating the texture.\n     * @param {Number} width The width to initialize the texture at.\n     * @param {Number} height The height to initialize the texture.\n     * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source for the texture data.\n     * @param {Number} filterType gl.NEAREST or gl.LINEAR usually, webgl numeri constants\n     * @returns {WebGLTexture}\n     */ createTexture: function(gl, width, height, textureImageSource, filterType) {\n            var texture = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filterType || gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filterType || gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            if (textureImageSource) {\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImageSource);\n            } else {\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n            }\n            return texture;\n        },\n        /**\n     * Can be optionally used to get a texture from the cache array\n     *\n     * If an existing texture is not found, a new texture is created and cached.\n     *\n     * @param {String} uniqueId A cache key to use to find an existing texture.\n     * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source to use to create the\n     * texture cache entry if one does not already exist.\n     */ getCachedTexture: function(uniqueId, textureImageSource) {\n            if (this.textureCache[uniqueId]) {\n                return this.textureCache[uniqueId];\n            } else {\n                var texture = this.createTexture(this.gl, textureImageSource.width, textureImageSource.height, textureImageSource);\n                this.textureCache[uniqueId] = texture;\n                return texture;\n            }\n        },\n        /**\n     * Clear out cached resources related to a source image that has been\n     * filtered previously.\n     *\n     * @param {String} cacheKey The cache key provided when the source image was filtered.\n     */ evictCachesForKey: function(cacheKey) {\n            if (this.textureCache[cacheKey]) {\n                this.gl.deleteTexture(this.textureCache[cacheKey]);\n                delete this.textureCache[cacheKey];\n            }\n        },\n        copyGLTo2D: copyGLTo2DDrawImage,\n        /**\n     * Attempt to extract GPU information strings from a WebGL context.\n     *\n     * Useful information when debugging or blacklisting specific GPUs.\n     *\n     * @returns {Object} A GPU info object with renderer and vendor strings.\n     */ captureGPUInfo: function() {\n            if (this.gpuInfo) {\n                return this.gpuInfo;\n            }\n            var gl = this.gl, gpuInfo = {\n                renderer: \"\",\n                vendor: \"\"\n            };\n            if (!gl) {\n                return gpuInfo;\n            }\n            var ext = gl.getExtension(\"WEBGL_debug_renderer_info\");\n            if (ext) {\n                var renderer = gl.getParameter(ext.UNMASKED_RENDERER_WEBGL);\n                var vendor = gl.getParameter(ext.UNMASKED_VENDOR_WEBGL);\n                if (renderer) {\n                    gpuInfo.renderer = renderer.toLowerCase();\n                }\n                if (vendor) {\n                    gpuInfo.vendor = vendor.toLowerCase();\n                }\n            }\n            this.gpuInfo = gpuInfo;\n            return gpuInfo;\n        }\n    };\n})();\nfunction resizeCanvasIfNeeded(pipelineState) {\n    var targetCanvas = pipelineState.targetCanvas, width = targetCanvas.width, height = targetCanvas.height, dWidth = pipelineState.destinationWidth, dHeight = pipelineState.destinationHeight;\n    if (width !== dWidth || height !== dHeight) {\n        targetCanvas.width = dWidth;\n        targetCanvas.height = dHeight;\n    }\n}\n/**\n * Copy an input WebGL canvas on to an output 2D canvas.\n *\n * The WebGL canvas is assumed to be upside down, with the top-left pixel of the\n * desired output image appearing in the bottom-left corner of the WebGL canvas.\n *\n * @param {WebGLRenderingContext} sourceContext The WebGL context to copy from.\n * @param {HTMLCanvasElement} targetCanvas The 2D target canvas to copy on to.\n * @param {Object} pipelineState The 2D target canvas to copy on to.\n */ function copyGLTo2DDrawImage(gl, pipelineState) {\n    var glCanvas = gl.canvas, targetCanvas = pipelineState.targetCanvas, ctx = targetCanvas.getContext(\"2d\");\n    ctx.translate(0, targetCanvas.height); // move it down again\n    ctx.scale(1, -1); // vertical flip\n    // where is my image on the big glcanvas?\n    var sourceY = glCanvas.height - targetCanvas.height;\n    ctx.drawImage(glCanvas, 0, sourceY, targetCanvas.width, targetCanvas.height, 0, 0, targetCanvas.width, targetCanvas.height);\n}\n/**\n * Copy an input WebGL canvas on to an output 2D canvas using 2d canvas' putImageData\n * API. Measurably faster than using ctx.drawImage in Firefox (version 54 on OSX Sierra).\n *\n * @param {WebGLRenderingContext} sourceContext The WebGL context to copy from.\n * @param {HTMLCanvasElement} targetCanvas The 2D target canvas to copy on to.\n * @param {Object} pipelineState The 2D target canvas to copy on to.\n */ function copyGLTo2DPutImageData(gl, pipelineState) {\n    var targetCanvas = pipelineState.targetCanvas, ctx = targetCanvas.getContext(\"2d\"), dWidth = pipelineState.destinationWidth, dHeight = pipelineState.destinationHeight, numBytes = dWidth * dHeight * 4;\n    // eslint-disable-next-line no-undef\n    var u8 = new Uint8Array(this.imageBuffer, 0, numBytes);\n    // eslint-disable-next-line no-undef\n    var u8Clamped = new Uint8ClampedArray(this.imageBuffer, 0, numBytes);\n    gl.readPixels(0, 0, dWidth, dHeight, gl.RGBA, gl.UNSIGNED_BYTE, u8);\n    var imgData = new ImageData(u8Clamped, dWidth, dHeight);\n    ctx.putImageData(imgData, 0, 0);\n}\n(function() {\n    \"use strict\";\n    var noop = function() {};\n    fabric.Canvas2dFilterBackend = Canvas2dFilterBackend;\n    /**\n   * Canvas 2D filter backend.\n   */ function Canvas2dFilterBackend() {}\n    ;\n    Canvas2dFilterBackend.prototype = /** @lends fabric.Canvas2dFilterBackend.prototype */ {\n        evictCachesForKey: noop,\n        dispose: noop,\n        clearWebGLCaches: noop,\n        /**\n     * Experimental. This object is a sort of repository of help layers used to avoid\n     * of recreating them during frequent filtering. If you are previewing a filter with\n     * a slider you probably do not want to create help layers every filter step.\n     * in this object there will be appended some canvases, created once, resized sometimes\n     * cleared never. Clearing is left to the developer.\n     **/ resources: {},\n        /**\n     * Apply a set of filters against a source image and draw the filtered output\n     * to the provided destination canvas.\n     *\n     * @param {EnhancedFilter} filters The filter to apply.\n     * @param {HTMLImageElement|HTMLCanvasElement} sourceElement The source to be filtered.\n     * @param {Number} sourceWidth The width of the source input.\n     * @param {Number} sourceHeight The height of the source input.\n     * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.\n     */ applyFilters: function(filters, sourceElement, sourceWidth, sourceHeight, targetCanvas) {\n            var ctx = targetCanvas.getContext(\"2d\");\n            ctx.drawImage(sourceElement, 0, 0, sourceWidth, sourceHeight);\n            var imageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);\n            var originalImageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);\n            var pipelineState = {\n                sourceWidth: sourceWidth,\n                sourceHeight: sourceHeight,\n                imageData: imageData,\n                originalEl: sourceElement,\n                originalImageData: originalImageData,\n                canvasEl: targetCanvas,\n                ctx: ctx,\n                filterBackend: this\n            };\n            filters.forEach(function(filter) {\n                filter.applyTo(pipelineState);\n            });\n            if (pipelineState.imageData.width !== sourceWidth || pipelineState.imageData.height !== sourceHeight) {\n                targetCanvas.width = pipelineState.imageData.width;\n                targetCanvas.height = pipelineState.imageData.height;\n            }\n            ctx.putImageData(pipelineState.imageData, 0, 0);\n            return pipelineState;\n        }\n    };\n})();\n/**\n * @namespace fabric.Image.filters\n * @memberOf fabric.Image\n * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#image_filters}\n * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n */ fabric.Image = fabric.Image || {};\nfabric.Image.filters = fabric.Image.filters || {};\n/**\n * Root filter class from which all filter classes inherit from\n * @class fabric.Image.filters.BaseFilter\n * @memberOf fabric.Image.filters\n */ fabric.Image.filters.BaseFilter = fabric.util.createClass(/** @lends fabric.Image.filters.BaseFilter.prototype */ {\n    /**\n   * Filter type\n   * @param {String} type\n   * @default\n   */ type: \"BaseFilter\",\n    /**\n   * Array of attributes to send with buffers. do not modify\n   * @private\n   */ vertexSource: \"attribute vec2 aPosition;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vTexCoord = aPosition;\\n\" + \"gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\\n\" + \"}\",\n    fragmentSource: \"precision highp float;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"void main() {\\n\" + \"gl_FragColor = texture2D(uTexture, vTexCoord);\\n\" + \"}\",\n    /**\n   * Constructor\n   * @param {Object} [options] Options object\n   */ initialize: function(options) {\n        if (options) {\n            this.setOptions(options);\n        }\n    },\n    /**\n   * Sets filter's properties from options\n   * @param {Object} [options] Options object\n   */ setOptions: function(options) {\n        for(var prop in options){\n            this[prop] = options[prop];\n        }\n    },\n    /**\n   * Compile this filter's shader program.\n   *\n   * @param {WebGLRenderingContext} gl The GL canvas context to use for shader compilation.\n   * @param {String} fragmentSource fragmentShader source for compilation\n   * @param {String} vertexSource vertexShader source for compilation\n   */ createProgram: function(gl, fragmentSource, vertexSource) {\n        fragmentSource = fragmentSource || this.fragmentSource;\n        vertexSource = vertexSource || this.vertexSource;\n        if (fabric.webGlPrecision !== \"highp\") {\n            fragmentSource = fragmentSource.replace(/precision highp float/g, \"precision \" + fabric.webGlPrecision + \" float\");\n        }\n        var vertexShader = gl.createShader(gl.VERTEX_SHADER);\n        gl.shaderSource(vertexShader, vertexSource);\n        gl.compileShader(vertexShader);\n        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n            throw new Error(// eslint-disable-next-line prefer-template\n            \"Vertex shader compile error for \" + this.type + \": \" + gl.getShaderInfoLog(vertexShader));\n        }\n        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n        gl.shaderSource(fragmentShader, fragmentSource);\n        gl.compileShader(fragmentShader);\n        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n            throw new Error(// eslint-disable-next-line prefer-template\n            \"Fragment shader compile error for \" + this.type + \": \" + gl.getShaderInfoLog(fragmentShader));\n        }\n        var program = gl.createProgram();\n        gl.attachShader(program, vertexShader);\n        gl.attachShader(program, fragmentShader);\n        gl.linkProgram(program);\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n            throw new Error(// eslint-disable-next-line prefer-template\n            'Shader link error for \"${this.type}\" ' + gl.getProgramInfoLog(program));\n        }\n        var attributeLocations = this.getAttributeLocations(gl, program);\n        var uniformLocations = this.getUniformLocations(gl, program) || {};\n        uniformLocations.uStepW = gl.getUniformLocation(program, \"uStepW\");\n        uniformLocations.uStepH = gl.getUniformLocation(program, \"uStepH\");\n        return {\n            program: program,\n            attributeLocations: attributeLocations,\n            uniformLocations: uniformLocations\n        };\n    },\n    /**\n   * Return a map of attribute names to WebGLAttributeLocation objects.\n   *\n   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.\n   * @param {WebGLShaderProgram} program The shader program from which to take attribute locations.\n   * @returns {Object} A map of attribute names to attribute locations.\n   */ getAttributeLocations: function(gl, program) {\n        return {\n            aPosition: gl.getAttribLocation(program, \"aPosition\")\n        };\n    },\n    /**\n   * Return a map of uniform names to WebGLUniformLocation objects.\n   *\n   * Intended to be overridden by subclasses.\n   *\n   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.\n   * @param {WebGLShaderProgram} program The shader program from which to take uniform locations.\n   * @returns {Object} A map of uniform names to uniform locations.\n   */ getUniformLocations: function() {\n        // in case i do not need any special uniform i need to return an empty object\n        return {};\n    },\n    /**\n   * Send attribute data from this filter to its shader program on the GPU.\n   *\n   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.\n   * @param {Object} attributeLocations A map of shader attribute names to their locations.\n   */ sendAttributeData: function(gl, attributeLocations, aPositionData) {\n        var attributeLocation = attributeLocations.aPosition;\n        var buffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n        gl.enableVertexAttribArray(attributeLocation);\n        gl.vertexAttribPointer(attributeLocation, 2, gl.FLOAT, false, 0, 0);\n        gl.bufferData(gl.ARRAY_BUFFER, aPositionData, gl.STATIC_DRAW);\n    },\n    _setupFrameBuffer: function(options) {\n        var gl = options.context, width, height;\n        if (options.passes > 1) {\n            width = options.destinationWidth;\n            height = options.destinationHeight;\n            if (options.sourceWidth !== width || options.sourceHeight !== height) {\n                gl.deleteTexture(options.targetTexture);\n                options.targetTexture = options.filterBackend.createTexture(gl, width, height);\n            }\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, options.targetTexture, 0);\n        } else {\n            // draw last filter on canvas and not to framebuffer.\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n            gl.finish();\n        }\n    },\n    _swapTextures: function(options) {\n        options.passes--;\n        options.pass++;\n        var temp = options.targetTexture;\n        options.targetTexture = options.sourceTexture;\n        options.sourceTexture = temp;\n    },\n    /**\n   * Generic isNeutral implementation for one parameter based filters.\n   * Used only in image applyFilters to discard filters that will not have an effect\n   * on the image\n   * Other filters may need their own version ( ColorMatrix, HueRotation, gamma, ComposedFilter )\n   * @param {Object} options\n   **/ isNeutralState: function() {\n        var main = this.mainParameter, _class = fabric.Image.filters[this.type].prototype;\n        if (main) {\n            if (Array.isArray(_class[main])) {\n                for(var i = _class[main].length; i--;){\n                    if (this[main][i] !== _class[main][i]) {\n                        return false;\n                    }\n                }\n                return true;\n            } else {\n                return _class[main] === this[main];\n            }\n        } else {\n            return false;\n        }\n    },\n    /**\n   * Apply this filter to the input image data provided.\n   *\n   * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.\n   *\n   * @param {Object} options\n   * @param {Number} options.passes The number of filters remaining to be executed\n   * @param {Boolean} options.webgl Whether to use webgl to render the filter.\n   * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.\n   * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.\n   * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n   */ applyTo: function(options) {\n        if (options.webgl) {\n            this._setupFrameBuffer(options);\n            this.applyToWebGL(options);\n            this._swapTextures(options);\n        } else {\n            this.applyTo2d(options);\n        }\n    },\n    /**\n   * Retrieves the cached shader.\n   * @param {Object} options\n   * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n   */ retrieveShader: function(options) {\n        if (!options.programCache.hasOwnProperty(this.type)) {\n            options.programCache[this.type] = this.createProgram(options.context);\n        }\n        return options.programCache[this.type];\n    },\n    /**\n   * Apply this filter using webgl.\n   *\n   * @param {Object} options\n   * @param {Number} options.passes The number of filters remaining to be executed\n   * @param {Boolean} options.webgl Whether to use webgl to render the filter.\n   * @param {WebGLTexture} options.originalTexture The texture of the original input image.\n   * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.\n   * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.\n   * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n   */ applyToWebGL: function(options) {\n        var gl = options.context;\n        var shader = this.retrieveShader(options);\n        if (options.pass === 0 && options.originalTexture) {\n            gl.bindTexture(gl.TEXTURE_2D, options.originalTexture);\n        } else {\n            gl.bindTexture(gl.TEXTURE_2D, options.sourceTexture);\n        }\n        gl.useProgram(shader.program);\n        this.sendAttributeData(gl, shader.attributeLocations, options.aPosition);\n        gl.uniform1f(shader.uniformLocations.uStepW, 1 / options.sourceWidth);\n        gl.uniform1f(shader.uniformLocations.uStepH, 1 / options.sourceHeight);\n        this.sendUniformData(gl, shader.uniformLocations);\n        gl.viewport(0, 0, options.destinationWidth, options.destinationHeight);\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n    },\n    bindAdditionalTexture: function(gl, texture, textureUnit) {\n        gl.activeTexture(textureUnit);\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        // reset active texture to 0 as usual\n        gl.activeTexture(gl.TEXTURE0);\n    },\n    unbindAdditionalTexture: function(gl, textureUnit) {\n        gl.activeTexture(textureUnit);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        gl.activeTexture(gl.TEXTURE0);\n    },\n    getMainParameter: function() {\n        return this[this.mainParameter];\n    },\n    setMainParameter: function(value) {\n        this[this.mainParameter] = value;\n    },\n    /**\n   * Send uniform data from this filter to its shader program on the GPU.\n   *\n   * Intended to be overridden by subclasses.\n   *\n   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.\n   * @param {Object} uniformLocations A map of shader uniform names to their locations.\n   */ sendUniformData: function() {\n    // Intentionally left blank.  Override me in subclasses.\n    },\n    /**\n   * If needed by a 2d filter, this functions can create an helper canvas to be used\n   * remember that options.targetCanvas is available for use till end of chain.\n   */ createHelpLayer: function(options) {\n        if (!options.helpLayer) {\n            var helpLayer = document.createElement(\"canvas\");\n            helpLayer.width = options.sourceWidth;\n            helpLayer.height = options.sourceHeight;\n            options.helpLayer = helpLayer;\n        }\n    },\n    /**\n   * Returns object representation of an instance\n   * @return {Object} Object representation of an instance\n   */ toObject: function() {\n        var object = {\n            type: this.type\n        }, mainP = this.mainParameter;\n        if (mainP) {\n            object[mainP] = this[mainP];\n        }\n        return object;\n    },\n    /**\n   * Returns a JSON representation of an instance\n   * @return {Object} JSON\n   */ toJSON: function() {\n        // delegate, not alias\n        return this.toObject();\n    }\n});\nfabric.Image.filters.BaseFilter.fromObject = function(object, callback) {\n    var filter = new fabric.Image.filters[object.type](object);\n    callback && callback(filter);\n    return filter;\n};\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Color Matrix filter class\n   * @class fabric.Image.filters.ColorMatrix\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.ColorMatrix#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @see {@Link http://www.webwasp.co.uk/tutorials/219/Color_Matrix_Filter.php}\n   * @see {@Link http://phoboslab.org/log/2013/11/fast-image-filters-with-webgl}\n   * @example <caption>Kodachrome filter</caption>\n   * var filter = new fabric.Image.filters.ColorMatrix({\n   *  matrix: [\n       1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502,\n       -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203,\n       -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946,\n       0, 0, 0, 1, 0\n      ]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.ColorMatrix = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.ColorMatrix.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"ColorMatrix\",\n        fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"uniform mat4 uColorMatrix;\\n\" + \"uniform vec4 uConstants;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"color *= uColorMatrix;\\n\" + \"color += uConstants;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * Colormatrix for pixels.\n     * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning\n     * outside the -1, 1 range.\n     * 0.0039215686 is the part of 1 that get translated to 1 in 2d\n     * @param {Array} matrix array of 20 numbers.\n     * @default\n     */ matrix: [\n            1,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        mainParameter: \"matrix\",\n        /**\n     * Lock the colormatrix on the color part, skipping alpha, mainly for non webgl scenario\n     * to save some calculation\n     * @type Boolean\n     * @default true\n     */ colorsOnly: true,\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     */ initialize: function(options) {\n            this.callSuper(\"initialize\", options);\n            // create a new array instead mutating the prototype with push\n            this.matrix = this.matrix.slice(0);\n        },\n        /**\n     * Apply the ColorMatrix operation to a Uint8Array representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8Array to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, iLen = data.length, m = this.matrix, r, g, b, a, i, colorsOnly = this.colorsOnly;\n            for(i = 0; i < iLen; i += 4){\n                r = data[i];\n                g = data[i + 1];\n                b = data[i + 2];\n                if (colorsOnly) {\n                    data[i] = r * m[0] + g * m[1] + b * m[2] + m[4] * 255;\n                    data[i + 1] = r * m[5] + g * m[6] + b * m[7] + m[9] * 255;\n                    data[i + 2] = r * m[10] + g * m[11] + b * m[12] + m[14] * 255;\n                } else {\n                    a = data[i + 3];\n                    data[i] = r * m[0] + g * m[1] + b * m[2] + a * m[3] + m[4] * 255;\n                    data[i + 1] = r * m[5] + g * m[6] + b * m[7] + a * m[8] + m[9] * 255;\n                    data[i + 2] = r * m[10] + g * m[11] + b * m[12] + a * m[13] + m[14] * 255;\n                    data[i + 3] = r * m[15] + g * m[16] + b * m[17] + a * m[18] + m[19] * 255;\n                }\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uColorMatrix: gl.getUniformLocation(program, \"uColorMatrix\"),\n                uConstants: gl.getUniformLocation(program, \"uConstants\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            var m = this.matrix, matrix = [\n                m[0],\n                m[1],\n                m[2],\n                m[3],\n                m[5],\n                m[6],\n                m[7],\n                m[8],\n                m[10],\n                m[11],\n                m[12],\n                m[13],\n                m[15],\n                m[16],\n                m[17],\n                m[18]\n            ], constants = [\n                m[4],\n                m[9],\n                m[14],\n                m[19]\n            ];\n            gl.uniformMatrix4fv(uniformLocations.uColorMatrix, false, matrix);\n            gl.uniform4fv(uniformLocations.uConstants, constants);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] function to invoke after filter creation\n   * @return {fabric.Image.filters.ColorMatrix} Instance of fabric.Image.filters.ColorMatrix\n   */ fabric.Image.filters.ColorMatrix.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Brightness filter class\n   * @class fabric.Image.filters.Brightness\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Brightness#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Brightness({\n   *   brightness: 0.05\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Brightness = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Brightness.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Brightness\",\n        /**\n     * Fragment source for the brightness program\n     */ fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uBrightness;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"color.rgb += uBrightness;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * Brightness value, from -1 to 1.\n     * translated to -255 to 255 for 2d\n     * 0.0039215686 is the part of 1 that get translated to 1 in 2d\n     * @param {Number} brightness\n     * @default\n     */ brightness: 0,\n        /**\n     * Describe the property that is the filter parameter\n     * @param {String} m\n     * @default\n     */ mainParameter: \"brightness\",\n        /**\n    * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.\n    *\n    * @param {Object} options\n    * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n    */ applyTo2d: function(options) {\n            if (this.brightness === 0) {\n                return;\n            }\n            var imageData = options.imageData, data = imageData.data, i, len = data.length, brightness = Math.round(this.brightness * 255);\n            for(i = 0; i < len; i += 4){\n                data[i] = data[i] + brightness;\n                data[i + 1] = data[i + 1] + brightness;\n                data[i + 2] = data[i + 2] + brightness;\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uBrightness: gl.getUniformLocation(program, \"uBrightness\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1f(uniformLocations.uBrightness, this.brightness);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Brightness} Instance of fabric.Image.filters.Brightness\n   */ fabric.Image.filters.Brightness.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Adapted from <a href=\"http://www.html5rocks.com/en/tutorials/canvas/imagefilters/\">html5rocks article</a>\n   * @class fabric.Image.filters.Convolute\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Convolute#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example <caption>Sharpen filter</caption>\n   * var filter = new fabric.Image.filters.Convolute({\n   *   matrix: [ 0, -1,  0,\n   *            -1,  5, -1,\n   *             0, -1,  0 ]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   * @example <caption>Blur filter</caption>\n   * var filter = new fabric.Image.filters.Convolute({\n   *   matrix: [ 1/9, 1/9, 1/9,\n   *             1/9, 1/9, 1/9,\n   *             1/9, 1/9, 1/9 ]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   * @example <caption>Emboss filter</caption>\n   * var filter = new fabric.Image.filters.Convolute({\n   *   matrix: [ 1,   1,  1,\n   *             1, 0.7, -1,\n   *            -1,  -1, -1 ]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   * @example <caption>Emboss filter with opaqueness</caption>\n   * var filter = new fabric.Image.filters.Convolute({\n   *   opaque: true,\n   *   matrix: [ 1,   1,  1,\n   *             1, 0.7, -1,\n   *            -1,  -1, -1 ]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */ filters.Convolute = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Convolute.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Convolute\",\n        /*\n     * Opaque value (true/false)\n     */ opaque: false,\n        /*\n     * matrix for the filter, max 9x9\n     */ matrix: [\n            0,\n            0,\n            0,\n            0,\n            1,\n            0,\n            0,\n            0,\n            0\n        ],\n        /**\n     * Fragment source for the brightness program\n     */ fragmentSource: {\n            Convolute_3_1: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[9];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 0);\\n\" + \"for (float h = 0.0; h < 3.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 3.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));\\n\" + \"color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n            Convolute_3_0: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[9];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 1);\\n\" + \"for (float h = 0.0; h < 3.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 3.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));\\n\" + \"color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"float alpha = texture2D(uTexture, vTexCoord).a;\\n\" + \"gl_FragColor = color;\\n\" + \"gl_FragColor.a = alpha;\\n\" + \"}\",\n            Convolute_5_1: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[25];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 0);\\n\" + \"for (float h = 0.0; h < 5.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 5.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\\n\" + \"color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n            Convolute_5_0: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[25];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 1);\\n\" + \"for (float h = 0.0; h < 5.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 5.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\\n\" + \"color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"float alpha = texture2D(uTexture, vTexCoord).a;\\n\" + \"gl_FragColor = color;\\n\" + \"gl_FragColor.a = alpha;\\n\" + \"}\",\n            Convolute_7_1: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[49];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 0);\\n\" + \"for (float h = 0.0; h < 7.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 7.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\\n\" + \"color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n            Convolute_7_0: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[49];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 1);\\n\" + \"for (float h = 0.0; h < 7.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 7.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\\n\" + \"color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"float alpha = texture2D(uTexture, vTexCoord).a;\\n\" + \"gl_FragColor = color;\\n\" + \"gl_FragColor.a = alpha;\\n\" + \"}\",\n            Convolute_9_1: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[81];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 0);\\n\" + \"for (float h = 0.0; h < 9.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 9.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\\n\" + \"color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n            Convolute_9_0: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uMatrix[81];\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0, 0, 0, 1);\\n\" + \"for (float h = 0.0; h < 9.0; h+=1.0) {\\n\" + \"for (float w = 0.0; w < 9.0; w+=1.0) {\\n\" + \"vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\\n\" + \"color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];\\n\" + \"}\\n\" + \"}\\n\" + \"float alpha = texture2D(uTexture, vTexCoord).a;\\n\" + \"gl_FragColor = color;\\n\" + \"gl_FragColor.a = alpha;\\n\" + \"}\"\n        },\n        /**\n     * Constructor\n     * @memberOf fabric.Image.filters.Convolute.prototype\n     * @param {Object} [options] Options object\n     * @param {Boolean} [options.opaque=false] Opaque value (true/false)\n     * @param {Array} [options.matrix] Filter matrix\n     */ /**\n    * Retrieves the cached shader.\n    * @param {Object} options\n    * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n    * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n    */ retrieveShader: function(options) {\n            var size = Math.sqrt(this.matrix.length);\n            var cacheKey = this.type + \"_\" + size + \"_\" + (this.opaque ? 1 : 0);\n            var shaderSource = this.fragmentSource[cacheKey];\n            if (!options.programCache.hasOwnProperty(cacheKey)) {\n                options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);\n            }\n            return options.programCache[cacheKey];\n        },\n        /**\n     * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, weights = this.matrix, side = Math.round(Math.sqrt(weights.length)), halfSide = Math.floor(side / 2), sw = imageData.width, sh = imageData.height, output = options.ctx.createImageData(sw, sh), dst = output.data, // go through the destination image pixels\n            alphaFac = this.opaque ? 1 : 0, r, g, b, a, dstOff, scx, scy, srcOff, wt, x, y, cx, cy;\n            for(y = 0; y < sh; y++){\n                for(x = 0; x < sw; x++){\n                    dstOff = (y * sw + x) * 4;\n                    // calculate the weighed sum of the source image pixels that\n                    // fall under the convolution matrix\n                    r = 0;\n                    g = 0;\n                    b = 0;\n                    a = 0;\n                    for(cy = 0; cy < side; cy++){\n                        for(cx = 0; cx < side; cx++){\n                            scy = y + cy - halfSide;\n                            scx = x + cx - halfSide;\n                            // eslint-disable-next-line max-depth\n                            if (scy < 0 || scy >= sh || scx < 0 || scx >= sw) {\n                                continue;\n                            }\n                            srcOff = (scy * sw + scx) * 4;\n                            wt = weights[cy * side + cx];\n                            r += data[srcOff] * wt;\n                            g += data[srcOff + 1] * wt;\n                            b += data[srcOff + 2] * wt;\n                            // eslint-disable-next-line max-depth\n                            if (!alphaFac) {\n                                a += data[srcOff + 3] * wt;\n                            }\n                        }\n                    }\n                    dst[dstOff] = r;\n                    dst[dstOff + 1] = g;\n                    dst[dstOff + 2] = b;\n                    if (!alphaFac) {\n                        dst[dstOff + 3] = a;\n                    } else {\n                        dst[dstOff + 3] = data[dstOff + 3];\n                    }\n                }\n            }\n            options.imageData = output;\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uMatrix: gl.getUniformLocation(program, \"uMatrix\"),\n                uOpaque: gl.getUniformLocation(program, \"uOpaque\"),\n                uHalfSize: gl.getUniformLocation(program, \"uHalfSize\"),\n                uSize: gl.getUniformLocation(program, \"uSize\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1fv(uniformLocations.uMatrix, this.matrix);\n        },\n        /**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */ toObject: function() {\n            return extend(this.callSuper(\"toObject\"), {\n                opaque: this.opaque,\n                matrix: this.matrix\n            });\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Convolute} Instance of fabric.Image.filters.Convolute\n   */ fabric.Image.filters.Convolute.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Grayscale image filter class\n   * @class fabric.Image.filters.Grayscale\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Grayscale();\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Grayscale = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Grayscale.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Grayscale\",\n        fragmentSource: {\n            average: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"float average = (color.r + color.b + color.g) / 3.0;\\n\" + \"gl_FragColor = vec4(average, average, average, color.a);\\n\" + \"}\",\n            lightness: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform int uMode;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 col = texture2D(uTexture, vTexCoord);\\n\" + \"float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;\\n\" + \"gl_FragColor = vec4(average, average, average, col.a);\\n\" + \"}\",\n            luminosity: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform int uMode;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 col = texture2D(uTexture, vTexCoord);\\n\" + \"float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;\\n\" + \"gl_FragColor = vec4(average, average, average, col.a);\\n\" + \"}\"\n        },\n        /**\n     * Grayscale mode, between 'average', 'lightness', 'luminosity'\n     * @param {String} type\n     * @default\n     */ mode: \"average\",\n        mainParameter: \"mode\",\n        /**\n     * Apply the Grayscale operation to a Uint8Array representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8Array to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, i, len = data.length, value, mode = this.mode;\n            for(i = 0; i < len; i += 4){\n                if (mode === \"average\") {\n                    value = (data[i] + data[i + 1] + data[i + 2]) / 3;\n                } else if (mode === \"lightness\") {\n                    value = (Math.min(data[i], data[i + 1], data[i + 2]) + Math.max(data[i], data[i + 1], data[i + 2])) / 2;\n                } else if (mode === \"luminosity\") {\n                    value = 0.21 * data[i] + 0.72 * data[i + 1] + 0.07 * data[i + 2];\n                }\n                data[i] = value;\n                data[i + 1] = value;\n                data[i + 2] = value;\n            }\n        },\n        /**\n     * Retrieves the cached shader.\n     * @param {Object} options\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ retrieveShader: function(options) {\n            var cacheKey = this.type + \"_\" + this.mode;\n            if (!options.programCache.hasOwnProperty(cacheKey)) {\n                var shaderSource = this.fragmentSource[this.mode];\n                options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);\n            }\n            return options.programCache[cacheKey];\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uMode: gl.getUniformLocation(program, \"uMode\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            // default average mode.\n            var mode = 1;\n            gl.uniform1i(uniformLocations.uMode, mode);\n        },\n        /**\n     * Grayscale filter isNeutralState implementation\n     * The filter is never neutral\n     * on the image\n     **/ isNeutralState: function() {\n            return false;\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Grayscale} Instance of fabric.Image.filters.Grayscale\n   */ fabric.Image.filters.Grayscale.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Invert filter class\n   * @class fabric.Image.filters.Invert\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Invert();\n   * object.filters.push(filter);\n   * object.applyFilters(canvas.renderAll.bind(canvas));\n   */ filters.Invert = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Invert.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Invert\",\n        fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform int uInvert;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"if (uInvert == 1) {\\n\" + \"gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);\\n\" + \"} else {\\n\" + \"gl_FragColor = color;\\n\" + \"}\\n\" + \"}\",\n        /**\n     * Filter invert. if false, does nothing\n     * @param {Boolean} invert\n     * @default\n     */ invert: true,\n        mainParameter: \"invert\",\n        /**\n     * Apply the Invert operation to a Uint8Array representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8Array to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, i, len = data.length;\n            for(i = 0; i < len; i += 4){\n                data[i] = 255 - data[i];\n                data[i + 1] = 255 - data[i + 1];\n                data[i + 2] = 255 - data[i + 2];\n            }\n        },\n        /**\n     * Invert filter isNeutralState implementation\n     * Used only in image applyFilters to discard filters that will not have an effect\n     * on the image\n     * @param {Object} options\n     **/ isNeutralState: function() {\n            return !this.invert;\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uInvert: gl.getUniformLocation(program, \"uInvert\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1i(uniformLocations.uInvert, this.invert);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Invert} Instance of fabric.Image.filters.Invert\n   */ fabric.Image.filters.Invert.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Noise filter class\n   * @class fabric.Image.filters.Noise\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Noise#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Noise({\n   *   noise: 700\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */ filters.Noise = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Noise.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Noise\",\n        /**\n     * Fragment source for the noise program\n     */ fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uStepH;\\n\" + \"uniform float uNoise;\\n\" + \"uniform float uSeed;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"float rand(vec2 co, float seed, float vScale) {\\n\" + \"return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);\\n\" + \"}\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * Describe the property that is the filter parameter\n     * @param {String} m\n     * @default\n     */ mainParameter: \"noise\",\n        /**\n     * Noise value, from\n     * @param {Number} noise\n     * @default\n     */ noise: 0,\n        /**\n     * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            if (this.noise === 0) {\n                return;\n            }\n            var imageData = options.imageData, data = imageData.data, i, len = data.length, noise = this.noise, rand;\n            for(i = 0, len = data.length; i < len; i += 4){\n                rand = (0.5 - Math.random()) * noise;\n                data[i] += rand;\n                data[i + 1] += rand;\n                data[i + 2] += rand;\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uNoise: gl.getUniformLocation(program, \"uNoise\"),\n                uSeed: gl.getUniformLocation(program, \"uSeed\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1f(uniformLocations.uNoise, this.noise / 255);\n            gl.uniform1f(uniformLocations.uSeed, Math.random());\n        },\n        /**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */ toObject: function() {\n            return extend(this.callSuper(\"toObject\"), {\n                noise: this.noise\n            });\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Noise} Instance of fabric.Image.filters.Noise\n   */ fabric.Image.filters.Noise.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Pixelate filter class\n   * @class fabric.Image.filters.Pixelate\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Pixelate#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Pixelate({\n   *   blocksize: 8\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Pixelate = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Pixelate.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Pixelate\",\n        blocksize: 4,\n        mainParameter: \"blocksize\",\n        /**\n     * Fragment source for the Pixelate program\n     */ fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uBlocksize;\\n\" + \"uniform float uStepW;\\n\" + \"uniform float uStepH;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"float blockW = uBlocksize * uStepW;\\n\" + \"float blockH = uBlocksize * uStepW;\\n\" + \"int posX = int(vTexCoord.x / blockW);\\n\" + \"int posY = int(vTexCoord.y / blockH);\\n\" + \"float fposX = float(posX);\\n\" + \"float fposY = float(posY);\\n\" + \"vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);\\n\" + \"vec4 color = texture2D(uTexture, squareCoords);\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * Apply the Pixelate operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, iLen = imageData.height, jLen = imageData.width, index, i, j, r, g, b, a, _i, _j, _iLen, _jLen;\n            for(i = 0; i < iLen; i += this.blocksize){\n                for(j = 0; j < jLen; j += this.blocksize){\n                    index = i * 4 * jLen + j * 4;\n                    r = data[index];\n                    g = data[index + 1];\n                    b = data[index + 2];\n                    a = data[index + 3];\n                    _iLen = Math.min(i + this.blocksize, iLen);\n                    _jLen = Math.min(j + this.blocksize, jLen);\n                    for(_i = i; _i < _iLen; _i++){\n                        for(_j = j; _j < _jLen; _j++){\n                            index = _i * 4 * jLen + _j * 4;\n                            data[index] = r;\n                            data[index + 1] = g;\n                            data[index + 2] = b;\n                            data[index + 3] = a;\n                        }\n                    }\n                }\n            }\n        },\n        /**\n     * Indicate when the filter is not gonna apply changes to the image\n     **/ isNeutralState: function() {\n            return this.blocksize === 1;\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uBlocksize: gl.getUniformLocation(program, \"uBlocksize\"),\n                uStepW: gl.getUniformLocation(program, \"uStepW\"),\n                uStepH: gl.getUniformLocation(program, \"uStepH\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1f(uniformLocations.uBlocksize, this.blocksize);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Pixelate} Instance of fabric.Image.filters.Pixelate\n   */ fabric.Image.filters.Pixelate.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), extend = fabric.util.object.extend, filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Remove white filter class\n   * @class fabric.Image.filters.RemoveColor\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.RemoveColor#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.RemoveColor({\n   *   threshold: 0.2,\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */ filters.RemoveColor = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.RemoveColor.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"RemoveColor\",\n        /**\n     * Color to remove, in any format understood by fabric.Color.\n     * @param {String} type\n     * @default\n     */ color: \"#FFFFFF\",\n        /**\n     * Fragment source for the brightness program\n     */ fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform vec4 uLow;\\n\" + \"uniform vec4 uHigh;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"gl_FragColor = texture2D(uTexture, vTexCoord);\\n\" + \"if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {\\n\" + \"gl_FragColor.a = 0.0;\\n\" + \"}\\n\" + \"}\",\n        /**\n     * distance to actual color, as value up or down from each r,g,b\n     * between 0 and 1\n     **/ distance: 0.02,\n        /**\n     * For color to remove inside distance, use alpha channel for a smoother deletion\n     * NOT IMPLEMENTED YET\n     **/ useAlpha: false,\n        /**\n     * Constructor\n     * @memberOf fabric.Image.filters.RemoveWhite.prototype\n     * @param {Object} [options] Options object\n     * @param {Number} [options.color=#RRGGBB] Threshold value\n     * @param {Number} [options.distance=10] Distance value\n     */ /**\n     * Applies filter to canvas element\n     * @param {Object} canvasEl Canvas element to apply filter to\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, i, distance = this.distance * 255, r, g, b, source = new fabric.Color(this.color).getSource(), lowC = [\n                source[0] - distance,\n                source[1] - distance,\n                source[2] - distance\n            ], highC = [\n                source[0] + distance,\n                source[1] + distance,\n                source[2] + distance\n            ];\n            for(i = 0; i < data.length; i += 4){\n                r = data[i];\n                g = data[i + 1];\n                b = data[i + 2];\n                if (r > lowC[0] && g > lowC[1] && b > lowC[2] && r < highC[0] && g < highC[1] && b < highC[2]) {\n                    data[i + 3] = 0;\n                }\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uLow: gl.getUniformLocation(program, \"uLow\"),\n                uHigh: gl.getUniformLocation(program, \"uHigh\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            var source = new fabric.Color(this.color).getSource(), distance = parseFloat(this.distance), lowC = [\n                0 + source[0] / 255 - distance,\n                0 + source[1] / 255 - distance,\n                0 + source[2] / 255 - distance,\n                1\n            ], highC = [\n                source[0] / 255 + distance,\n                source[1] / 255 + distance,\n                source[2] / 255 + distance,\n                1\n            ];\n            gl.uniform4fv(uniformLocations.uLow, lowC);\n            gl.uniform4fv(uniformLocations.uHigh, highC);\n        },\n        /**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */ toObject: function() {\n            return extend(this.callSuper(\"toObject\"), {\n                color: this.color,\n                distance: this.distance\n            });\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.RemoveColor} Instance of fabric.Image.filters.RemoveWhite\n   */ fabric.Image.filters.RemoveColor.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    var matrices = {\n        Brownie: [\n            0.59970,\n            0.34553,\n            -0.27082,\n            0,\n            0.186,\n            -0.03770,\n            0.86095,\n            0.15059,\n            0,\n            -0.1449,\n            0.24113,\n            -0.07441,\n            0.44972,\n            0,\n            -0.02965,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        Vintage: [\n            0.62793,\n            0.32021,\n            -0.03965,\n            0,\n            0.03784,\n            0.02578,\n            0.64411,\n            0.03259,\n            0,\n            0.02926,\n            0.04660,\n            -0.08512,\n            0.52416,\n            0,\n            0.02023,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        Kodachrome: [\n            1.12855,\n            -0.39673,\n            -0.03992,\n            0,\n            0.24991,\n            -0.16404,\n            1.08352,\n            -0.05498,\n            0,\n            0.09698,\n            -0.16786,\n            -0.56034,\n            1.60148,\n            0,\n            0.13972,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        Technicolor: [\n            1.91252,\n            -0.85453,\n            -0.09155,\n            0,\n            0.04624,\n            -0.30878,\n            1.76589,\n            -0.10601,\n            0,\n            -0.27589,\n            -0.23110,\n            -0.75018,\n            1.84759,\n            0,\n            0.12137,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        Polaroid: [\n            1.438,\n            -0.062,\n            -0.062,\n            0,\n            0,\n            -0.122,\n            1.378,\n            -0.122,\n            0,\n            0,\n            -0.016,\n            -0.016,\n            1.483,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        Sepia: [\n            0.393,\n            0.769,\n            0.189,\n            0,\n            0,\n            0.349,\n            0.686,\n            0.168,\n            0,\n            0,\n            0.272,\n            0.534,\n            0.131,\n            0,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0\n        ],\n        BlackWhite: [\n            1.5,\n            1.5,\n            1.5,\n            0,\n            -1,\n            1.5,\n            1.5,\n            1.5,\n            0,\n            -1,\n            1.5,\n            1.5,\n            1.5,\n            0,\n            -1,\n            0,\n            0,\n            0,\n            1,\n            0\n        ]\n    };\n    for(var key in matrices){\n        filters[key] = createClass(filters.ColorMatrix, /** @lends fabric.Image.filters.Sepia.prototype */ {\n            /**\n       * Filter type\n       * @param {String} type\n       * @default\n       */ type: key,\n            /**\n       * Colormatrix for the effect\n       * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning\n       * outside the -1, 1 range.\n       * @param {Array} matrix array of 20 numbers.\n       * @default\n       */ matrix: matrices[key],\n            /**\n       * Lock the matrix export for this kind of static, parameter less filters.\n       */ mainParameter: false,\n            /**\n       * Lock the colormatrix on the color part, skipping alpha\n       */ colorsOnly: true\n        });\n        fabric.Image.filters[key].fromObject = fabric.Image.filters.BaseFilter.fromObject;\n    }\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric, filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Color Blend filter class\n   * @class fabric.Image.filter.BlendColor\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @example\n   * var filter = new fabric.Image.filters.BlendColor({\n   *  color: '#000',\n   *  mode: 'multiply'\n   * });\n   *\n   * var filter = new fabric.Image.filters.BlendImage({\n   *  image: fabricImageObject,\n   *  mode: 'multiply',\n   *  alpha: 0.5\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */ filters.BlendColor = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blend.prototype */ {\n        type: \"BlendColor\",\n        /**\n     * Color to make the blend operation with. default to a reddish color since black or white\n     * gives always strong result.\n     * @type String\n     * @default\n     **/ color: \"#F95C63\",\n        /**\n     * Blend mode for the filter: one of multiply, add, diff, screen, subtract,\n     * darken, lighten, overlay, exclusion, tint.\n     * @type String\n     * @default\n     **/ mode: \"multiply\",\n        /**\n     * alpha value. represent the strength of the blend color operation.\n     * @type Number\n     * @default\n     **/ alpha: 1,\n        /**\n     * Fragment source for the Multiply program\n     */ fragmentSource: {\n            multiply: \"gl_FragColor.rgb *= uColor.rgb;\\n\",\n            screen: \"gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);\\n\",\n            add: \"gl_FragColor.rgb += uColor.rgb;\\n\",\n            diff: \"gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);\\n\",\n            subtract: \"gl_FragColor.rgb -= uColor.rgb;\\n\",\n            lighten: \"gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);\\n\",\n            darken: \"gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);\\n\",\n            exclusion: \"gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);\\n\",\n            overlay: \"if (uColor.r < 0.5) {\\n\" + \"gl_FragColor.r *= 2.0 * uColor.r;\\n\" + \"} else {\\n\" + \"gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);\\n\" + \"}\\n\" + \"if (uColor.g < 0.5) {\\n\" + \"gl_FragColor.g *= 2.0 * uColor.g;\\n\" + \"} else {\\n\" + \"gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);\\n\" + \"}\\n\" + \"if (uColor.b < 0.5) {\\n\" + \"gl_FragColor.b *= 2.0 * uColor.b;\\n\" + \"} else {\\n\" + \"gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);\\n\" + \"}\\n\",\n            tint: \"gl_FragColor.rgb *= (1.0 - uColor.a);\\n\" + \"gl_FragColor.rgb += uColor.rgb;\\n\"\n        },\n        /**\n     * build the fragment source for the filters, joining the common part with\n     * the specific one.\n     * @param {String} mode the mode of the filter, a key of this.fragmentSource\n     * @return {String} the source to be compiled\n     * @private\n     */ buildSource: function(mode) {\n            return \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform vec4 uColor;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"gl_FragColor = color;\\n\" + \"if (color.a > 0.0) {\\n\" + this.fragmentSource[mode] + \"}\\n\" + \"}\";\n        },\n        /**\n     * Retrieves the cached shader.\n     * @param {Object} options\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ retrieveShader: function(options) {\n            var cacheKey = this.type + \"_\" + this.mode, shaderSource;\n            if (!options.programCache.hasOwnProperty(cacheKey)) {\n                shaderSource = this.buildSource(this.mode);\n                options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);\n            }\n            return options.programCache[cacheKey];\n        },\n        /**\n     * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, iLen = data.length, tr, tg, tb, r, g, b, source, alpha1 = 1 - this.alpha;\n            source = new fabric.Color(this.color).getSource();\n            tr = source[0] * this.alpha;\n            tg = source[1] * this.alpha;\n            tb = source[2] * this.alpha;\n            for(var i = 0; i < iLen; i += 4){\n                r = data[i];\n                g = data[i + 1];\n                b = data[i + 2];\n                switch(this.mode){\n                    case \"multiply\":\n                        data[i] = r * tr / 255;\n                        data[i + 1] = g * tg / 255;\n                        data[i + 2] = b * tb / 255;\n                        break;\n                    case \"screen\":\n                        data[i] = 255 - (255 - r) * (255 - tr) / 255;\n                        data[i + 1] = 255 - (255 - g) * (255 - tg) / 255;\n                        data[i + 2] = 255 - (255 - b) * (255 - tb) / 255;\n                        break;\n                    case \"add\":\n                        data[i] = r + tr;\n                        data[i + 1] = g + tg;\n                        data[i + 2] = b + tb;\n                        break;\n                    case \"diff\":\n                    case \"difference\":\n                        data[i] = Math.abs(r - tr);\n                        data[i + 1] = Math.abs(g - tg);\n                        data[i + 2] = Math.abs(b - tb);\n                        break;\n                    case \"subtract\":\n                        data[i] = r - tr;\n                        data[i + 1] = g - tg;\n                        data[i + 2] = b - tb;\n                        break;\n                    case \"darken\":\n                        data[i] = Math.min(r, tr);\n                        data[i + 1] = Math.min(g, tg);\n                        data[i + 2] = Math.min(b, tb);\n                        break;\n                    case \"lighten\":\n                        data[i] = Math.max(r, tr);\n                        data[i + 1] = Math.max(g, tg);\n                        data[i + 2] = Math.max(b, tb);\n                        break;\n                    case \"overlay\":\n                        data[i] = tr < 128 ? 2 * r * tr / 255 : 255 - 2 * (255 - r) * (255 - tr) / 255;\n                        data[i + 1] = tg < 128 ? 2 * g * tg / 255 : 255 - 2 * (255 - g) * (255 - tg) / 255;\n                        data[i + 2] = tb < 128 ? 2 * b * tb / 255 : 255 - 2 * (255 - b) * (255 - tb) / 255;\n                        break;\n                    case \"exclusion\":\n                        data[i] = tr + r - 2 * tr * r / 255;\n                        data[i + 1] = tg + g - 2 * tg * g / 255;\n                        data[i + 2] = tb + b - 2 * tb * b / 255;\n                        break;\n                    case \"tint\":\n                        data[i] = tr + r * alpha1;\n                        data[i + 1] = tg + g * alpha1;\n                        data[i + 2] = tb + b * alpha1;\n                }\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uColor: gl.getUniformLocation(program, \"uColor\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            var source = new fabric.Color(this.color).getSource();\n            source[0] = this.alpha * source[0] / 255;\n            source[1] = this.alpha * source[1] / 255;\n            source[2] = this.alpha * source[2] / 255;\n            source[3] = this.alpha;\n            gl.uniform4fv(uniformLocations.uColor, source);\n        },\n        /**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */ toObject: function() {\n            return {\n                type: this.type,\n                color: this.color,\n                mode: this.mode,\n                alpha: this.alpha\n            };\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.BlendColor} Instance of fabric.Image.filters.BlendColor\n   */ fabric.Image.filters.BlendColor.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric, filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Image Blend filter class\n   * @class fabric.Image.filter.BlendImage\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @example\n   * var filter = new fabric.Image.filters.BlendColor({\n   *  color: '#000',\n   *  mode: 'multiply'\n   * });\n   *\n   * var filter = new fabric.Image.filters.BlendImage({\n   *  image: fabricImageObject,\n   *  mode: 'multiply',\n   *  alpha: 0.5\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */ filters.BlendImage = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.BlendImage.prototype */ {\n        type: \"BlendImage\",\n        /**\n     * Color to make the blend operation with. default to a reddish color since black or white\n     * gives always strong result.\n     **/ image: null,\n        /**\n     * Blend mode for the filter (one of \"multiply\", \"mask\")\n     * @type String\n     * @default\n     **/ mode: \"multiply\",\n        /**\n     * alpha value. represent the strength of the blend image operation.\n     * not implemented.\n     **/ alpha: 1,\n        vertexSource: \"attribute vec2 aPosition;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"varying vec2 vTexCoord2;\\n\" + \"uniform mat3 uTransformMatrix;\\n\" + \"void main() {\\n\" + \"vTexCoord = aPosition;\\n\" + \"vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;\\n\" + \"gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\\n\" + \"}\",\n        /**\n     * Fragment source for the Multiply program\n     */ fragmentSource: {\n            multiply: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform sampler2D uImage;\\n\" + \"uniform vec4 uColor;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"varying vec2 vTexCoord2;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"vec4 color2 = texture2D(uImage, vTexCoord2);\\n\" + \"color.rgba *= color2.rgba;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n            mask: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform sampler2D uImage;\\n\" + \"uniform vec4 uColor;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"varying vec2 vTexCoord2;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"vec4 color2 = texture2D(uImage, vTexCoord2);\\n\" + \"color.a = color2.a;\\n\" + \"gl_FragColor = color;\\n\" + \"}\"\n        },\n        /**\n     * Retrieves the cached shader.\n     * @param {Object} options\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ retrieveShader: function(options) {\n            var cacheKey = this.type + \"_\" + this.mode;\n            var shaderSource = this.fragmentSource[this.mode];\n            if (!options.programCache.hasOwnProperty(cacheKey)) {\n                options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);\n            }\n            return options.programCache[cacheKey];\n        },\n        applyToWebGL: function(options) {\n            // load texture to blend.\n            var gl = options.context, texture = this.createTexture(options.filterBackend, this.image);\n            this.bindAdditionalTexture(gl, texture, gl.TEXTURE1);\n            this.callSuper(\"applyToWebGL\", options);\n            this.unbindAdditionalTexture(gl, gl.TEXTURE1);\n        },\n        createTexture: function(backend, image) {\n            return backend.getCachedTexture(image.cacheKey, image._element);\n        },\n        /**\n     * Calculate a transformMatrix to adapt the image to blend over\n     * @param {Object} options\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ calculateMatrix: function() {\n            var image = this.image, width = image._element.width, height = image._element.height;\n            return [\n                1 / image.scaleX,\n                0,\n                0,\n                0,\n                1 / image.scaleY,\n                0,\n                -image.left / width,\n                -image.top / height,\n                1\n            ];\n        },\n        /**\n     * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, resources = options.filterBackend.resources, data = imageData.data, iLen = data.length, width = imageData.width, height = imageData.height, tr, tg, tb, ta, r, g, b, a, canvas1, context, image = this.image, blendData;\n            if (!resources.blendImage) {\n                resources.blendImage = fabric.util.createCanvasElement();\n            }\n            canvas1 = resources.blendImage;\n            context = canvas1.getContext(\"2d\");\n            if (canvas1.width !== width || canvas1.height !== height) {\n                canvas1.width = width;\n                canvas1.height = height;\n            } else {\n                context.clearRect(0, 0, width, height);\n            }\n            context.setTransform(image.scaleX, 0, 0, image.scaleY, image.left, image.top);\n            context.drawImage(image._element, 0, 0, width, height);\n            blendData = context.getImageData(0, 0, width, height).data;\n            for(var i = 0; i < iLen; i += 4){\n                r = data[i];\n                g = data[i + 1];\n                b = data[i + 2];\n                a = data[i + 3];\n                tr = blendData[i];\n                tg = blendData[i + 1];\n                tb = blendData[i + 2];\n                ta = blendData[i + 3];\n                switch(this.mode){\n                    case \"multiply\":\n                        data[i] = r * tr / 255;\n                        data[i + 1] = g * tg / 255;\n                        data[i + 2] = b * tb / 255;\n                        data[i + 3] = a * ta / 255;\n                        break;\n                    case \"mask\":\n                        data[i + 3] = ta;\n                        break;\n                }\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uTransformMatrix: gl.getUniformLocation(program, \"uTransformMatrix\"),\n                uImage: gl.getUniformLocation(program, \"uImage\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            var matrix = this.calculateMatrix();\n            gl.uniform1i(uniformLocations.uImage, 1); // texture unit 1.\n            gl.uniformMatrix3fv(uniformLocations.uTransformMatrix, false, matrix);\n        },\n        /**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */ toObject: function() {\n            return {\n                type: this.type,\n                image: this.image && this.image.toObject(),\n                mode: this.mode,\n                alpha: this.alpha\n            };\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} callback to be invoked after filter creation\n   * @return {fabric.Image.filters.BlendImage} Instance of fabric.Image.filters.BlendImage\n   */ fabric.Image.filters.BlendImage.fromObject = function(object, callback) {\n        fabric.Image.fromObject(object.image, function(image) {\n            var options = fabric.util.object.clone(object);\n            options.image = image;\n            callback(new fabric.Image.filters.BlendImage(options));\n        });\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), pow = Math.pow, floor = Math.floor, sqrt = Math.sqrt, abs = Math.abs, round = Math.round, sin = Math.sin, ceil = Math.ceil, filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Resize image filter class\n   * @class fabric.Image.filters.Resize\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Resize();\n   * object.filters.push(filter);\n   * object.applyFilters(canvas.renderAll.bind(canvas));\n   */ filters.Resize = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Resize.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Resize\",\n        /**\n     * Resize type\n     * for webgl resizeType is just lanczos, for canvas2d can be:\n     * bilinear, hermite, sliceHack, lanczos.\n     * @param {String} resizeType\n     * @default\n     */ resizeType: \"hermite\",\n        /**\n     * Scale factor for resizing, x axis\n     * @param {Number} scaleX\n     * @default\n     */ scaleX: 1,\n        /**\n     * Scale factor for resizing, y axis\n     * @param {Number} scaleY\n     * @default\n     */ scaleY: 1,\n        /**\n     * LanczosLobes parameter for lanczos filter, valid for resizeType lanczos\n     * @param {Number} lanczosLobes\n     * @default\n     */ lanczosLobes: 3,\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uDelta: gl.getUniformLocation(program, \"uDelta\"),\n                uTaps: gl.getUniformLocation(program, \"uTaps\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform2fv(uniformLocations.uDelta, this.horizontal ? [\n                1 / this.width,\n                0\n            ] : [\n                0,\n                1 / this.height\n            ]);\n            gl.uniform1fv(uniformLocations.uTaps, this.taps);\n        },\n        /**\n     * Retrieves the cached shader.\n     * @param {Object} options\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ retrieveShader: function(options) {\n            var filterWindow = this.getFilterWindow(), cacheKey = this.type + \"_\" + filterWindow;\n            if (!options.programCache.hasOwnProperty(cacheKey)) {\n                var fragmentShader = this.generateShader(filterWindow);\n                options.programCache[cacheKey] = this.createProgram(options.context, fragmentShader);\n            }\n            return options.programCache[cacheKey];\n        },\n        getFilterWindow: function() {\n            var scale = this.tempScale;\n            return Math.ceil(this.lanczosLobes / scale);\n        },\n        getTaps: function() {\n            var lobeFunction = this.lanczosCreate(this.lanczosLobes), scale = this.tempScale, filterWindow = this.getFilterWindow(), taps = new Array(filterWindow);\n            for(var i = 1; i <= filterWindow; i++){\n                taps[i - 1] = lobeFunction(i * scale);\n            }\n            return taps;\n        },\n        /**\n     * Generate vertex and shader sources from the necessary steps numbers\n     * @param {Number} filterWindow\n     */ generateShader: function(filterWindow) {\n            var offsets = new Array(filterWindow), fragmentShader = this.fragmentSourceTOP, filterWindow;\n            for(var i = 1; i <= filterWindow; i++){\n                offsets[i - 1] = i + \".0 * uDelta\";\n            }\n            fragmentShader += \"uniform float uTaps[\" + filterWindow + \"];\\n\";\n            fragmentShader += \"void main() {\\n\";\n            fragmentShader += \"  vec4 color = texture2D(uTexture, vTexCoord);\\n\";\n            fragmentShader += \"  float sum = 1.0;\\n\";\n            offsets.forEach(function(offset, i) {\n                fragmentShader += \"  color += texture2D(uTexture, vTexCoord + \" + offset + \") * uTaps[\" + i + \"];\\n\";\n                fragmentShader += \"  color += texture2D(uTexture, vTexCoord - \" + offset + \") * uTaps[\" + i + \"];\\n\";\n                fragmentShader += \"  sum += 2.0 * uTaps[\" + i + \"];\\n\";\n            });\n            fragmentShader += \"  gl_FragColor = color / sum;\\n\";\n            fragmentShader += \"}\";\n            return fragmentShader;\n        },\n        fragmentSourceTOP: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform vec2 uDelta;\\n\" + \"varying vec2 vTexCoord;\\n\",\n        /**\n     * Apply the resize filter to the image\n     * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.\n     *\n     * @param {Object} options\n     * @param {Number} options.passes The number of filters remaining to be executed\n     * @param {Boolean} options.webgl Whether to use webgl to render the filter.\n     * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.\n     * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ applyTo: function(options) {\n            if (options.webgl) {\n                options.passes++;\n                this.width = options.sourceWidth;\n                this.horizontal = true;\n                this.dW = Math.round(this.width * this.scaleX);\n                this.dH = options.sourceHeight;\n                this.tempScale = this.dW / this.width;\n                this.taps = this.getTaps();\n                options.destinationWidth = this.dW;\n                this._setupFrameBuffer(options);\n                this.applyToWebGL(options);\n                this._swapTextures(options);\n                options.sourceWidth = options.destinationWidth;\n                this.height = options.sourceHeight;\n                this.horizontal = false;\n                this.dH = Math.round(this.height * this.scaleY);\n                this.tempScale = this.dH / this.height;\n                this.taps = this.getTaps();\n                options.destinationHeight = this.dH;\n                this._setupFrameBuffer(options);\n                this.applyToWebGL(options);\n                this._swapTextures(options);\n                options.sourceHeight = options.destinationHeight;\n            } else {\n                this.applyTo2d(options);\n            }\n        },\n        isNeutralState: function() {\n            return this.scaleX === 1 && this.scaleY === 1;\n        },\n        lanczosCreate: function(lobes) {\n            return function(x) {\n                if (x >= lobes || x <= -lobes) {\n                    return 0.0;\n                }\n                if (x < 1.19209290E-07 && x > -1.19209290E-07) {\n                    return 1.0;\n                }\n                x *= Math.PI;\n                var xx = x / lobes;\n                return sin(x) / x * sin(xx) / xx;\n            };\n        },\n        /**\n     * Applies filter to canvas element\n     * @memberOf fabric.Image.filters.Resize.prototype\n     * @param {Object} canvasEl Canvas element to apply filter to\n     * @param {Number} scaleX\n     * @param {Number} scaleY\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, scaleX = this.scaleX, scaleY = this.scaleY;\n            this.rcpScaleX = 1 / scaleX;\n            this.rcpScaleY = 1 / scaleY;\n            var oW = imageData.width, oH = imageData.height, dW = round(oW * scaleX), dH = round(oH * scaleY), newData;\n            if (this.resizeType === \"sliceHack\") {\n                newData = this.sliceByTwo(options, oW, oH, dW, dH);\n            } else if (this.resizeType === \"hermite\") {\n                newData = this.hermiteFastResize(options, oW, oH, dW, dH);\n            } else if (this.resizeType === \"bilinear\") {\n                newData = this.bilinearFiltering(options, oW, oH, dW, dH);\n            } else if (this.resizeType === \"lanczos\") {\n                newData = this.lanczosResize(options, oW, oH, dW, dH);\n            }\n            options.imageData = newData;\n        },\n        /**\n     * Filter sliceByTwo\n     * @param {Object} canvasEl Canvas element to apply filter to\n     * @param {Number} oW Original Width\n     * @param {Number} oH Original Height\n     * @param {Number} dW Destination Width\n     * @param {Number} dH Destination Height\n     * @returns {ImageData}\n     */ sliceByTwo: function(options, oW, oH, dW, dH) {\n            var imageData = options.imageData, mult = 0.5, doneW = false, doneH = false, stepW = oW * mult, stepH = oH * mult, resources = fabric.filterBackend.resources, tmpCanvas, ctx, sX = 0, sY = 0, dX = oW, dY = 0;\n            if (!resources.sliceByTwo) {\n                resources.sliceByTwo = document.createElement(\"canvas\");\n            }\n            tmpCanvas = resources.sliceByTwo;\n            if (tmpCanvas.width < oW * 1.5 || tmpCanvas.height < oH) {\n                tmpCanvas.width = oW * 1.5;\n                tmpCanvas.height = oH;\n            }\n            ctx = tmpCanvas.getContext(\"2d\");\n            ctx.clearRect(0, 0, oW * 1.5, oH);\n            ctx.putImageData(imageData, 0, 0);\n            dW = floor(dW);\n            dH = floor(dH);\n            while(!doneW || !doneH){\n                oW = stepW;\n                oH = stepH;\n                if (dW < floor(stepW * mult)) {\n                    stepW = floor(stepW * mult);\n                } else {\n                    stepW = dW;\n                    doneW = true;\n                }\n                if (dH < floor(stepH * mult)) {\n                    stepH = floor(stepH * mult);\n                } else {\n                    stepH = dH;\n                    doneH = true;\n                }\n                ctx.drawImage(tmpCanvas, sX, sY, oW, oH, dX, dY, stepW, stepH);\n                sX = dX;\n                sY = dY;\n                dY += stepH;\n            }\n            return ctx.getImageData(sX, sY, dW, dH);\n        },\n        /**\n     * Filter lanczosResize\n     * @param {Object} canvasEl Canvas element to apply filter to\n     * @param {Number} oW Original Width\n     * @param {Number} oH Original Height\n     * @param {Number} dW Destination Width\n     * @param {Number} dH Destination Height\n     * @returns {ImageData}\n     */ lanczosResize: function(options, oW, oH, dW, dH) {\n            function process(u) {\n                var v, i, weight, idx, a, red, green, blue, alpha, fX, fY;\n                center.x = (u + 0.5) * ratioX;\n                icenter.x = floor(center.x);\n                for(v = 0; v < dH; v++){\n                    center.y = (v + 0.5) * ratioY;\n                    icenter.y = floor(center.y);\n                    a = 0;\n                    red = 0;\n                    green = 0;\n                    blue = 0;\n                    alpha = 0;\n                    for(i = icenter.x - range2X; i <= icenter.x + range2X; i++){\n                        if (i < 0 || i >= oW) {\n                            continue;\n                        }\n                        fX = floor(1000 * abs(i - center.x));\n                        if (!cacheLanc[fX]) {\n                            cacheLanc[fX] = {};\n                        }\n                        for(var j = icenter.y - range2Y; j <= icenter.y + range2Y; j++){\n                            if (j < 0 || j >= oH) {\n                                continue;\n                            }\n                            fY = floor(1000 * abs(j - center.y));\n                            if (!cacheLanc[fX][fY]) {\n                                cacheLanc[fX][fY] = lanczos(sqrt(pow(fX * rcpRatioX, 2) + pow(fY * rcpRatioY, 2)) / 1000);\n                            }\n                            weight = cacheLanc[fX][fY];\n                            if (weight > 0) {\n                                idx = (j * oW + i) * 4;\n                                a += weight;\n                                red += weight * srcData[idx];\n                                green += weight * srcData[idx + 1];\n                                blue += weight * srcData[idx + 2];\n                                alpha += weight * srcData[idx + 3];\n                            }\n                        }\n                    }\n                    idx = (v * dW + u) * 4;\n                    destData[idx] = red / a;\n                    destData[idx + 1] = green / a;\n                    destData[idx + 2] = blue / a;\n                    destData[idx + 3] = alpha / a;\n                }\n                if (++u < dW) {\n                    return process(u);\n                } else {\n                    return destImg;\n                }\n            }\n            var srcData = options.imageData.data, destImg = options.ctx.createImageData(dW, dH), destData = destImg.data, lanczos = this.lanczosCreate(this.lanczosLobes), ratioX = this.rcpScaleX, ratioY = this.rcpScaleY, rcpRatioX = 2 / this.rcpScaleX, rcpRatioY = 2 / this.rcpScaleY, range2X = ceil(ratioX * this.lanczosLobes / 2), range2Y = ceil(ratioY * this.lanczosLobes / 2), cacheLanc = {}, center = {}, icenter = {};\n            return process(0);\n        },\n        /**\n     * bilinearFiltering\n     * @param {Object} canvasEl Canvas element to apply filter to\n     * @param {Number} oW Original Width\n     * @param {Number} oH Original Height\n     * @param {Number} dW Destination Width\n     * @param {Number} dH Destination Height\n     * @returns {ImageData}\n     */ bilinearFiltering: function(options, oW, oH, dW, dH) {\n            var a, b, c, d, x, y, i, j, xDiff, yDiff, chnl, color, offset = 0, origPix, ratioX = this.rcpScaleX, ratioY = this.rcpScaleY, w4 = 4 * (oW - 1), img = options.imageData, pixels = img.data, destImage = options.ctx.createImageData(dW, dH), destPixels = destImage.data;\n            for(i = 0; i < dH; i++){\n                for(j = 0; j < dW; j++){\n                    x = floor(ratioX * j);\n                    y = floor(ratioY * i);\n                    xDiff = ratioX * j - x;\n                    yDiff = ratioY * i - y;\n                    origPix = 4 * (y * oW + x);\n                    for(chnl = 0; chnl < 4; chnl++){\n                        a = pixels[origPix + chnl];\n                        b = pixels[origPix + 4 + chnl];\n                        c = pixels[origPix + w4 + chnl];\n                        d = pixels[origPix + w4 + 4 + chnl];\n                        color = a * (1 - xDiff) * (1 - yDiff) + b * xDiff * (1 - yDiff) + c * yDiff * (1 - xDiff) + d * xDiff * yDiff;\n                        destPixels[offset++] = color;\n                    }\n                }\n            }\n            return destImage;\n        },\n        /**\n     * hermiteFastResize\n     * @param {Object} canvasEl Canvas element to apply filter to\n     * @param {Number} oW Original Width\n     * @param {Number} oH Original Height\n     * @param {Number} dW Destination Width\n     * @param {Number} dH Destination Height\n     * @returns {ImageData}\n     */ hermiteFastResize: function(options, oW, oH, dW, dH) {\n            var ratioW = this.rcpScaleX, ratioH = this.rcpScaleY, ratioWHalf = ceil(ratioW / 2), ratioHHalf = ceil(ratioH / 2), img = options.imageData, data = img.data, img2 = options.ctx.createImageData(dW, dH), data2 = img2.data;\n            for(var j = 0; j < dH; j++){\n                for(var i = 0; i < dW; i++){\n                    var x2 = (i + j * dW) * 4, weight = 0, weights = 0, weightsAlpha = 0, gxR = 0, gxG = 0, gxB = 0, gxA = 0, centerY = (j + 0.5) * ratioH;\n                    for(var yy = floor(j * ratioH); yy < (j + 1) * ratioH; yy++){\n                        var dy = abs(centerY - (yy + 0.5)) / ratioHHalf, centerX = (i + 0.5) * ratioW, w0 = dy * dy;\n                        for(var xx = floor(i * ratioW); xx < (i + 1) * ratioW; xx++){\n                            var dx = abs(centerX - (xx + 0.5)) / ratioWHalf, w = sqrt(w0 + dx * dx);\n                            /* eslint-disable max-depth */ if (w > 1 && w < -1) {\n                                continue;\n                            }\n                            //hermite filter\n                            weight = 2 * w * w * w - 3 * w * w + 1;\n                            if (weight > 0) {\n                                dx = 4 * (xx + yy * oW);\n                                //alpha\n                                gxA += weight * data[dx + 3];\n                                weightsAlpha += weight;\n                                //colors\n                                if (data[dx + 3] < 255) {\n                                    weight = weight * data[dx + 3] / 250;\n                                }\n                                gxR += weight * data[dx];\n                                gxG += weight * data[dx + 1];\n                                gxB += weight * data[dx + 2];\n                                weights += weight;\n                            }\n                        /* eslint-enable max-depth */ }\n                    }\n                    data2[x2] = gxR / weights;\n                    data2[x2 + 1] = gxG / weights;\n                    data2[x2 + 2] = gxB / weights;\n                    data2[x2 + 3] = gxA / weightsAlpha;\n                }\n            }\n            return img2;\n        },\n        /**\n     * Returns object representation of an instance\n     * @return {Object} Object representation of an instance\n     */ toObject: function() {\n            return {\n                type: this.type,\n                scaleX: this.scaleX,\n                scaleY: this.scaleY,\n                resizeType: this.resizeType,\n                lanczosLobes: this.lanczosLobes\n            };\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Resize} Instance of fabric.Image.filters.Resize\n   */ fabric.Image.filters.Resize.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Contrast filter class\n   * @class fabric.Image.filters.Contrast\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Contrast#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Contrast({\n   *   contrast: 0.25\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Contrast = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Contrast.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Contrast\",\n        fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uContrast;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));\\n\" + \"color.rgb = contrastF * (color.rgb - 0.5) + 0.5;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * contrast value, range from -1 to 1.\n     * @param {Number} contrast\n     * @default 0\n     */ contrast: 0,\n        mainParameter: \"contrast\",\n        /**\n     * Constructor\n     * @memberOf fabric.Image.filters.Contrast.prototype\n     * @param {Object} [options] Options object\n     * @param {Number} [options.contrast=0] Value to contrast the image up (-1...1)\n     */ /**\n      * Apply the Contrast operation to a Uint8Array representing the pixels of an image.\n      *\n      * @param {Object} options\n      * @param {ImageData} options.imageData The Uint8Array to be filtered.\n      */ applyTo2d: function(options) {\n            if (this.contrast === 0) {\n                return;\n            }\n            var imageData = options.imageData, i, len, data = imageData.data, len = data.length, contrast = Math.floor(this.contrast * 255), contrastF = 259 * (contrast + 255) / (255 * (259 - contrast));\n            for(i = 0; i < len; i += 4){\n                data[i] = contrastF * (data[i] - 128) + 128;\n                data[i + 1] = contrastF * (data[i + 1] - 128) + 128;\n                data[i + 2] = contrastF * (data[i + 2] - 128) + 128;\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uContrast: gl.getUniformLocation(program, \"uContrast\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1f(uniformLocations.uContrast, this.contrast);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Contrast} Instance of fabric.Image.filters.Contrast\n   */ fabric.Image.filters.Contrast.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Saturate filter class\n   * @class fabric.Image.filters.Saturation\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Saturation#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Saturation({\n   *   saturation: 1\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Saturation = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Saturation.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Saturation\",\n        fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uSaturation;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"float rgMax = max(color.r, color.g);\\n\" + \"float rgbMax = max(rgMax, color.b);\\n\" + \"color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;\\n\" + \"color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;\\n\" + \"color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * Saturation value, from -1 to 1.\n     * Increases/decreases the color saturation.\n     * A value of 0 has no effect.\n     * \n     * @param {Number} saturation\n     * @default\n     */ saturation: 0,\n        mainParameter: \"saturation\",\n        /**\n     * Constructor\n     * @memberOf fabric.Image.filters.Saturate.prototype\n     * @param {Object} [options] Options object\n     * @param {Number} [options.saturate=0] Value to saturate the image (-1...1)\n     */ /**\n     * Apply the Saturation operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            if (this.saturation === 0) {\n                return;\n            }\n            var imageData = options.imageData, data = imageData.data, len = data.length, adjust = -this.saturation, i, max;\n            for(i = 0; i < len; i += 4){\n                max = Math.max(data[i], data[i + 1], data[i + 2]);\n                data[i] += max !== data[i] ? (max - data[i]) * adjust : 0;\n                data[i + 1] += max !== data[i + 1] ? (max - data[i + 1]) * adjust : 0;\n                data[i + 2] += max !== data[i + 2] ? (max - data[i + 2]) * adjust : 0;\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uSaturation: gl.getUniformLocation(program, \"uSaturation\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1f(uniformLocations.uSaturation, -this.saturation);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Saturation} Instance of fabric.Image.filters.Saturate\n   */ fabric.Image.filters.Saturation.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Vibrance filter class\n   * @class fabric.Image.filters.Vibrance\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Vibrance#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Vibrance({\n   *   vibrance: 1\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Vibrance = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Vibrance.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Vibrance\",\n        fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform float uVibrance;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"float max = max(color.r, max(color.g, color.b));\\n\" + \"float avg = (color.r + color.g + color.b) / 3.0;\\n\" + \"float amt = (abs(max - avg) * 2.0) * uVibrance;\\n\" + \"color.r += max != color.r ? (max - color.r) * amt : 0.00;\\n\" + \"color.g += max != color.g ? (max - color.g) * amt : 0.00;\\n\" + \"color.b += max != color.b ? (max - color.b) * amt : 0.00;\\n\" + \"gl_FragColor = color;\\n\" + \"}\",\n        /**\n     * Vibrance value, from -1 to 1.\n     * Increases/decreases the saturation of more muted colors with less effect on saturated colors.\n     * A value of 0 has no effect.\n     * \n     * @param {Number} vibrance\n     * @default\n     */ vibrance: 0,\n        mainParameter: \"vibrance\",\n        /**\n     * Constructor\n     * @memberOf fabric.Image.filters.Vibrance.prototype\n     * @param {Object} [options] Options object\n     * @param {Number} [options.vibrance=0] Vibrance value for the image (between -1 and 1)\n     */ /**\n     * Apply the Vibrance operation to a Uint8ClampedArray representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n     */ applyTo2d: function(options) {\n            if (this.vibrance === 0) {\n                return;\n            }\n            var imageData = options.imageData, data = imageData.data, len = data.length, adjust = -this.vibrance, i, max, avg, amt;\n            for(i = 0; i < len; i += 4){\n                max = Math.max(data[i], data[i + 1], data[i + 2]);\n                avg = (data[i] + data[i + 1] + data[i + 2]) / 3;\n                amt = Math.abs(max - avg) * 2 / 255 * adjust;\n                data[i] += max !== data[i] ? (max - data[i]) * amt : 0;\n                data[i + 1] += max !== data[i + 1] ? (max - data[i + 1]) * amt : 0;\n                data[i + 2] += max !== data[i + 2] ? (max - data[i + 2]) * amt : 0;\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uVibrance: gl.getUniformLocation(program, \"uVibrance\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform1f(uniformLocations.uVibrance, -this.vibrance);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Vibrance} Instance of fabric.Image.filters.Vibrance\n   */ fabric.Image.filters.Vibrance.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Blur filter class\n   * @class fabric.Image.filters.Blur\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Blur#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Blur({\n   *   blur: 0.5\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   * canvas.renderAll();\n   */ filters.Blur = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blur.prototype */ {\n        type: \"Blur\",\n        /*\n'gl_FragColor = vec4(0.0);',\n'gl_FragColor += texture2D(texture, vTexCoord + -7 * uDelta)*0.0044299121055113265;',\n'gl_FragColor += texture2D(texture, vTexCoord + -6 * uDelta)*0.00895781211794;',\n'gl_FragColor += texture2D(texture, vTexCoord + -5 * uDelta)*0.0215963866053;',\n'gl_FragColor += texture2D(texture, vTexCoord + -4 * uDelta)*0.0443683338718;',\n'gl_FragColor += texture2D(texture, vTexCoord + -3 * uDelta)*0.0776744219933;',\n'gl_FragColor += texture2D(texture, vTexCoord + -2 * uDelta)*0.115876621105;',\n'gl_FragColor += texture2D(texture, vTexCoord + -1 * uDelta)*0.147308056121;',\n'gl_FragColor += texture2D(texture, vTexCoord              )*0.159576912161;',\n'gl_FragColor += texture2D(texture, vTexCoord + 1 * uDelta)*0.147308056121;',\n'gl_FragColor += texture2D(texture, vTexCoord + 2 * uDelta)*0.115876621105;',\n'gl_FragColor += texture2D(texture, vTexCoord + 3 * uDelta)*0.0776744219933;',\n'gl_FragColor += texture2D(texture, vTexCoord + 4 * uDelta)*0.0443683338718;',\n'gl_FragColor += texture2D(texture, vTexCoord + 5 * uDelta)*0.0215963866053;',\n'gl_FragColor += texture2D(texture, vTexCoord + 6 * uDelta)*0.00895781211794;',\n'gl_FragColor += texture2D(texture, vTexCoord + 7 * uDelta)*0.0044299121055113265;',\n*/ /* eslint-disable max-len */ fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform vec2 uDelta;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"const float nSamples = 15.0;\\n\" + \"vec3 v3offset = vec3(12.9898, 78.233, 151.7182);\\n\" + \"float random(vec3 scale) {\\n\" + /* use the fragment position for a different seed per-pixel */ \"return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);\\n\" + \"}\\n\" + \"void main() {\\n\" + \"vec4 color = vec4(0.0);\\n\" + \"float total = 0.0;\\n\" + \"float offset = random(v3offset);\\n\" + \"for (float t = -nSamples; t <= nSamples; t++) {\\n\" + \"float percent = (t + offset - 0.5) / nSamples;\\n\" + \"float weight = 1.0 - abs(percent);\\n\" + \"color += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;\\n\" + \"total += weight;\\n\" + \"}\\n\" + \"gl_FragColor = color / total;\\n\" + \"}\",\n        /* eslint-enable max-len */ /**\n     * blur value, in percentage of image dimensions.\n     * specific to keep the image blur constant at different resolutions\n     * range between 0 and 1.\n     * @type Number\n     * @default\n     */ blur: 0,\n        mainParameter: \"blur\",\n        applyTo: function(options) {\n            if (options.webgl) {\n                // this aspectRatio is used to give the same blur to vertical and horizontal\n                this.aspectRatio = options.sourceWidth / options.sourceHeight;\n                options.passes++;\n                this._setupFrameBuffer(options);\n                this.horizontal = true;\n                this.applyToWebGL(options);\n                this._swapTextures(options);\n                this._setupFrameBuffer(options);\n                this.horizontal = false;\n                this.applyToWebGL(options);\n                this._swapTextures(options);\n            } else {\n                this.applyTo2d(options);\n            }\n        },\n        applyTo2d: function(options) {\n            // paint canvasEl with current image data.\n            //options.ctx.putImageData(options.imageData, 0, 0);\n            options.imageData = this.simpleBlur(options);\n        },\n        simpleBlur: function(options) {\n            var resources = options.filterBackend.resources, canvas1, canvas2, width = options.imageData.width, height = options.imageData.height;\n            if (!resources.blurLayer1) {\n                resources.blurLayer1 = fabric.util.createCanvasElement();\n                resources.blurLayer2 = fabric.util.createCanvasElement();\n            }\n            canvas1 = resources.blurLayer1;\n            canvas2 = resources.blurLayer2;\n            if (canvas1.width !== width || canvas1.height !== height) {\n                canvas2.width = canvas1.width = width;\n                canvas2.height = canvas1.height = height;\n            }\n            var ctx1 = canvas1.getContext(\"2d\"), ctx2 = canvas2.getContext(\"2d\"), nSamples = 15, random, percent, j, i, blur = this.blur * 0.06 * 0.5;\n            // load first canvas\n            ctx1.putImageData(options.imageData, 0, 0);\n            ctx2.clearRect(0, 0, width, height);\n            for(i = -nSamples; i <= nSamples; i++){\n                random = (Math.random() - 0.5) / 4;\n                percent = i / nSamples;\n                j = blur * percent * width + random;\n                ctx2.globalAlpha = 1 - Math.abs(percent);\n                ctx2.drawImage(canvas1, j, random);\n                ctx1.drawImage(canvas2, 0, 0);\n                ctx2.globalAlpha = 1;\n                ctx2.clearRect(0, 0, canvas2.width, canvas2.height);\n            }\n            for(i = -nSamples; i <= nSamples; i++){\n                random = (Math.random() - 0.5) / 4;\n                percent = i / nSamples;\n                j = blur * percent * height + random;\n                ctx2.globalAlpha = 1 - Math.abs(percent);\n                ctx2.drawImage(canvas1, random, j);\n                ctx1.drawImage(canvas2, 0, 0);\n                ctx2.globalAlpha = 1;\n                ctx2.clearRect(0, 0, canvas2.width, canvas2.height);\n            }\n            options.ctx.drawImage(canvas1, 0, 0);\n            var newImageData = options.ctx.getImageData(0, 0, canvas1.width, canvas1.height);\n            ctx1.globalAlpha = 1;\n            ctx1.clearRect(0, 0, canvas1.width, canvas1.height);\n            return newImageData;\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                delta: gl.getUniformLocation(program, \"uDelta\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            var delta = this.chooseRightDelta();\n            gl.uniform2fv(uniformLocations.delta, delta);\n        },\n        /**\n     * choose right value of image percentage to blur with\n     * @returns {Array} a numeric array with delta values\n     */ chooseRightDelta: function() {\n            var blurScale = 1, delta = [\n                0,\n                0\n            ], blur;\n            if (this.horizontal) {\n                if (this.aspectRatio > 1) {\n                    // image is wide, i want to shrink radius horizontal\n                    blurScale = 1 / this.aspectRatio;\n                }\n            } else {\n                if (this.aspectRatio < 1) {\n                    // image is tall, i want to shrink radius vertical\n                    blurScale = this.aspectRatio;\n                }\n            }\n            blur = blurScale * this.blur * 0.12;\n            if (this.horizontal) {\n                delta[0] = blur;\n            } else {\n                delta[1] = blur;\n            }\n            return delta;\n        }\n    });\n    /**\n   * Deserialize a JSON definition of a BlurFilter into a concrete instance.\n   */ filters.Blur.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * Gamma filter class\n   * @class fabric.Image.filters.Gamma\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.Gamma#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.Gamma({\n   *   gamma: [1, 0.5, 2.1]\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.Gamma = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Gamma.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"Gamma\",\n        fragmentSource: \"precision highp float;\\n\" + \"uniform sampler2D uTexture;\\n\" + \"uniform vec3 uGamma;\\n\" + \"varying vec2 vTexCoord;\\n\" + \"void main() {\\n\" + \"vec4 color = texture2D(uTexture, vTexCoord);\\n\" + \"vec3 correction = (1.0 / uGamma);\\n\" + \"color.r = pow(color.r, correction.r);\\n\" + \"color.g = pow(color.g, correction.g);\\n\" + \"color.b = pow(color.b, correction.b);\\n\" + \"gl_FragColor = color;\\n\" + \"gl_FragColor.rgb *= color.a;\\n\" + \"}\",\n        /**\n     * Gamma array value, from 0.01 to 2.2.\n     * @param {Array} gamma\n     * @default\n     */ gamma: [\n            1,\n            1,\n            1\n        ],\n        /**\n     * Describe the property that is the filter parameter\n     * @param {String} m\n     * @default\n     */ mainParameter: \"gamma\",\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     */ initialize: function(options) {\n            this.gamma = [\n                1,\n                1,\n                1\n            ];\n            filters.BaseFilter.prototype.initialize.call(this, options);\n        },\n        /**\n     * Apply the Gamma operation to a Uint8Array representing the pixels of an image.\n     *\n     * @param {Object} options\n     * @param {ImageData} options.imageData The Uint8Array to be filtered.\n     */ applyTo2d: function(options) {\n            var imageData = options.imageData, data = imageData.data, gamma = this.gamma, len = data.length, rInv = 1 / gamma[0], gInv = 1 / gamma[1], bInv = 1 / gamma[2], i;\n            if (!this.rVals) {\n                // eslint-disable-next-line\n                this.rVals = new Uint8Array(256);\n                // eslint-disable-next-line\n                this.gVals = new Uint8Array(256);\n                // eslint-disable-next-line\n                this.bVals = new Uint8Array(256);\n            }\n            // This is an optimization - pre-compute a look-up table for each color channel\n            // instead of performing these pow calls for each pixel in the image.\n            for(i = 0, len = 256; i < len; i++){\n                this.rVals[i] = Math.pow(i / 255, rInv) * 255;\n                this.gVals[i] = Math.pow(i / 255, gInv) * 255;\n                this.bVals[i] = Math.pow(i / 255, bInv) * 255;\n            }\n            for(i = 0, len = data.length; i < len; i += 4){\n                data[i] = this.rVals[data[i]];\n                data[i + 1] = this.gVals[data[i + 1]];\n                data[i + 2] = this.bVals[data[i + 2]];\n            }\n        },\n        /**\n     * Return WebGL uniform locations for this filter's shader.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {WebGLShaderProgram} program This filter's compiled shader program.\n     */ getUniformLocations: function(gl, program) {\n            return {\n                uGamma: gl.getUniformLocation(program, \"uGamma\")\n            };\n        },\n        /**\n     * Send data from this filter to its shader program's uniforms.\n     *\n     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n     */ sendUniformData: function(gl, uniformLocations) {\n            gl.uniform3fv(uniformLocations.uGamma, this.gamma);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.Gamma} Instance of fabric.Image.filters.Gamma\n   */ fabric.Image.filters.Gamma.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * A container class that knows how to apply a sequence of filters to an input image.\n   */ filters.Composed = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Composed.prototype */ {\n        type: \"Composed\",\n        /**\n     * A non sparse array of filters to apply\n     */ subFilters: [],\n        /**\n     * Constructor\n     * @param {Object} [options] Options object\n     */ initialize: function(options) {\n            this.callSuper(\"initialize\", options);\n            // create a new array instead mutating the prototype with push\n            this.subFilters = this.subFilters.slice(0);\n        },\n        /**\n     * Apply this container's filters to the input image provided.\n     *\n     * @param {Object} options\n     * @param {Number} options.passes The number of filters remaining to be applied.\n     */ applyTo: function(options) {\n            options.passes += this.subFilters.length - 1;\n            this.subFilters.forEach(function(filter) {\n                filter.applyTo(options);\n            });\n        },\n        /**\n     * Serialize this filter into JSON.\n     *\n     * @returns {Object} A JSON representation of this filter.\n     */ toObject: function() {\n            return fabric.util.object.extend(this.callSuper(\"toObject\"), {\n                subFilters: this.subFilters.map(function(filter) {\n                    return filter.toObject();\n                })\n            });\n        },\n        isNeutralState: function() {\n            return !this.subFilters.some(function(filter) {\n                return !filter.isNeutralState();\n            });\n        }\n    });\n    /**\n   * Deserialize a JSON definition of a ComposedFilter into a concrete instance.\n   */ fabric.Image.filters.Composed.fromObject = function(object, callback) {\n        var filters = object.subFilters || [], subFilters = filters.map(function(filter) {\n            return new fabric.Image.filters[filter.type](filter);\n        }), instance = new fabric.Image.filters.Composed({\n            subFilters: subFilters\n        });\n        callback && callback(instance);\n        return instance;\n    };\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), filters = fabric.Image.filters, createClass = fabric.util.createClass;\n    /**\n   * HueRotation filter class\n   * @class fabric.Image.filters.HueRotation\n   * @memberOf fabric.Image.filters\n   * @extends fabric.Image.filters.BaseFilter\n   * @see {@link fabric.Image.filters.HueRotation#initialize} for constructor definition\n   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}\n   * @example\n   * var filter = new fabric.Image.filters.HueRotation({\n   *   rotation: -0.5\n   * });\n   * object.filters.push(filter);\n   * object.applyFilters();\n   */ filters.HueRotation = createClass(filters.ColorMatrix, /** @lends fabric.Image.filters.HueRotation.prototype */ {\n        /**\n     * Filter type\n     * @param {String} type\n     * @default\n     */ type: \"HueRotation\",\n        /**\n     * HueRotation value, from -1 to 1.\n     * the unit is radians\n     * @param {Number} myParameter\n     * @default\n     */ rotation: 0,\n        /**\n     * Describe the property that is the filter parameter\n     * @param {String} m\n     * @default\n     */ mainParameter: \"rotation\",\n        calculateMatrix: function() {\n            var rad = this.rotation * Math.PI, cos = fabric.util.cos(rad), sin = fabric.util.sin(rad), aThird = 1 / 3, aThirdSqtSin = Math.sqrt(aThird) * sin, OneMinusCos = 1 - cos;\n            this.matrix = [\n                1,\n                0,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0,\n                0,\n                0,\n                0,\n                0,\n                1,\n                0\n            ];\n            this.matrix[0] = cos + OneMinusCos / 3;\n            this.matrix[1] = aThird * OneMinusCos - aThirdSqtSin;\n            this.matrix[2] = aThird * OneMinusCos + aThirdSqtSin;\n            this.matrix[5] = aThird * OneMinusCos + aThirdSqtSin;\n            this.matrix[6] = cos + aThird * OneMinusCos;\n            this.matrix[7] = aThird * OneMinusCos - aThirdSqtSin;\n            this.matrix[10] = aThird * OneMinusCos - aThirdSqtSin;\n            this.matrix[11] = aThird * OneMinusCos + aThirdSqtSin;\n            this.matrix[12] = cos + aThird * OneMinusCos;\n        },\n        /**\n     * HueRotation isNeutralState implementation\n     * Used only in image applyFilters to discard filters that will not have an effect\n     * on the image\n     * @param {Object} options\n     **/ isNeutralState: function(options) {\n            this.calculateMatrix();\n            return filters.BaseFilter.prototype.isNeutralState.call(this, options);\n        },\n        /**\n     * Apply this filter to the input image data provided.\n     *\n     * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.\n     *\n     * @param {Object} options\n     * @param {Number} options.passes The number of filters remaining to be executed\n     * @param {Boolean} options.webgl Whether to use webgl to render the filter.\n     * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.\n     * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.\n     * @param {WebGLRenderingContext} options.context The GL context used for rendering.\n     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.\n     */ applyTo: function(options) {\n            this.calculateMatrix();\n            filters.BaseFilter.prototype.applyTo.call(this, options);\n        }\n    });\n    /**\n   * Returns filter instance from an object representation\n   * @static\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] to be invoked after filter creation\n   * @return {fabric.Image.filters.HueRotation} Instance of fabric.Image.filters.HueRotation\n   */ fabric.Image.filters.HueRotation.fromObject = fabric.Image.filters.BaseFilter.fromObject;\n})( true ? exports : 0);\n(function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {}), clone = fabric.util.object.clone;\n    if (fabric.Text) {\n        fabric.warn(\"fabric.Text is already defined\");\n        return;\n    }\n    var additionalProps = (\"fontFamily fontWeight fontSize text underline overline linethrough\" + \" textAlign fontStyle lineHeight textBackgroundColor charSpacing styles\" + \" direction path pathStartOffset pathSide pathAlign\").split(\" \");\n    /**\n   * Text class\n   * @class fabric.Text\n   * @extends fabric.Object\n   * @return {fabric.Text} thisArg\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#text}\n   * @see {@link fabric.Text#initialize} for constructor definition\n   */ fabric.Text = fabric.util.createClass(fabric.Object, /** @lends fabric.Text.prototype */ {\n        /**\n     * Properties which when set cause object to change dimensions\n     * @type Array\n     * @private\n     */ _dimensionAffectingProps: [\n            \"fontSize\",\n            \"fontWeight\",\n            \"fontFamily\",\n            \"fontStyle\",\n            \"lineHeight\",\n            \"text\",\n            \"charSpacing\",\n            \"textAlign\",\n            \"styles\",\n            \"path\",\n            \"pathStartOffset\",\n            \"pathSide\",\n            \"pathAlign\"\n        ],\n        /**\n     * @private\n     */ _reNewline: /\\r?\\n/,\n        /**\n     * Use this regular expression to filter for whitespaces that is not a new line.\n     * Mostly used when text is 'justify' aligned.\n     * @private\n     */ _reSpacesAndTabs: /[ \\t\\r]/g,\n        /**\n     * Use this regular expression to filter for whitespace that is not a new line.\n     * Mostly used when text is 'justify' aligned.\n     * @private\n     */ _reSpaceAndTab: /[ \\t\\r]/,\n        /**\n     * Use this regular expression to filter consecutive groups of non spaces.\n     * Mostly used when text is 'justify' aligned.\n     * @private\n     */ _reWords: /\\S+/g,\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"text\",\n        /**\n     * Font size (in pixels)\n     * @type Number\n     * @default\n     */ fontSize: 40,\n        /**\n     * Font weight (e.g. bold, normal, 400, 600, 800)\n     * @type {(Number|String)}\n     * @default\n     */ fontWeight: \"normal\",\n        /**\n     * Font family\n     * @type String\n     * @default\n     */ fontFamily: \"Times New Roman\",\n        /**\n     * Text decoration underline.\n     * @type Boolean\n     * @default\n     */ underline: false,\n        /**\n     * Text decoration overline.\n     * @type Boolean\n     * @default\n     */ overline: false,\n        /**\n     * Text decoration linethrough.\n     * @type Boolean\n     * @default\n     */ linethrough: false,\n        /**\n     * Text alignment. Possible values: \"left\", \"center\", \"right\", \"justify\",\n     * \"justify-left\", \"justify-center\" or \"justify-right\".\n     * @type String\n     * @default\n     */ textAlign: \"left\",\n        /**\n     * Font style . Possible values: \"\", \"normal\", \"italic\" or \"oblique\".\n     * @type String\n     * @default\n     */ fontStyle: \"normal\",\n        /**\n     * Line height\n     * @type Number\n     * @default\n     */ lineHeight: 1.16,\n        /**\n     * Superscript schema object (minimum overlap)\n     * @type {Object}\n     * @default\n     */ superscript: {\n            size: 0.60,\n            baseline: -0.35 // baseline-shift factor (upwards)\n        },\n        /**\n     * Subscript schema object (minimum overlap)\n     * @type {Object}\n     * @default\n     */ subscript: {\n            size: 0.60,\n            baseline: 0.11 // baseline-shift factor (downwards)\n        },\n        /**\n     * Background color of text lines\n     * @type String\n     * @default\n     */ textBackgroundColor: \"\",\n        /**\n     * List of properties to consider when checking if\n     * state of an object is changed ({@link fabric.Object#hasStateChanged})\n     * as well as for history (undo/redo) purposes\n     * @type Array\n     */ stateProperties: fabric.Object.prototype.stateProperties.concat(additionalProps),\n        /**\n     * List of properties to consider when checking if cache needs refresh\n     * @type Array\n     */ cacheProperties: fabric.Object.prototype.cacheProperties.concat(additionalProps),\n        /**\n     * When defined, an object is rendered via stroke and this property specifies its color.\n     * <b>Backwards incompatibility note:</b> This property was named \"strokeStyle\" until v1.1.6\n     * @type String\n     * @default\n     */ stroke: null,\n        /**\n     * Shadow object representing shadow of this shape.\n     * <b>Backwards incompatibility note:</b> This property was named \"textShadow\" (String) until v1.2.11\n     * @type fabric.Shadow\n     * @default\n     */ shadow: null,\n        /**\n     * fabric.Path that the text should follow.\n     * since 4.6.0 the path will be drawn automatically.\n     * if you want to make the path visible, give it a stroke and strokeWidth or fill value\n     * if you want it to be hidden, assign visible = false to the path.\n     * This feature is in BETA, and SVG import/export is not yet supported.\n     * @type fabric.Path\n     * @example\n     * var textPath = new fabric.Text('Text on a path', {\n     *     top: 150,\n     *     left: 150,\n     *     textAlign: 'center',\n     *     charSpacing: -50,\n     *     path: new fabric.Path('M 0 0 C 50 -100 150 -100 200 0', {\n     *         strokeWidth: 1,\n     *         visible: false\n     *     }),\n     *     pathSide: 'left',\n     *     pathStartOffset: 0\n     * });\n     * @default\n     */ path: null,\n        /**\n     * Offset amount for text path starting position\n     * Only used when text has a path\n     * @type Number\n     * @default\n     */ pathStartOffset: 0,\n        /**\n     * Which side of the path the text should be drawn on.\n     * Only used when text has a path\n     * @type {String} 'left|right'\n     * @default\n     */ pathSide: \"left\",\n        /**\n     * How text is aligned to the path. This property determines\n     * the perpendicular position of each character relative to the path.\n     * (one of \"baseline\", \"center\", \"ascender\", \"descender\")\n     * This feature is in BETA, and its behavior may change\n     * @type String\n     * @default\n     */ pathAlign: \"baseline\",\n        /**\n     * @private\n     */ _fontSizeFraction: 0.222,\n        /**\n     * @private\n     */ offsets: {\n            underline: 0.10,\n            linethrough: -0.315,\n            overline: -0.88\n        },\n        /**\n     * Text Line proportion to font Size (in pixels)\n     * @type Number\n     * @default\n     */ _fontSizeMult: 1.13,\n        /**\n     * additional space between characters\n     * expressed in thousands of em unit\n     * @type Number\n     * @default\n     */ charSpacing: 0,\n        /**\n     * Object containing character styles - top-level properties -> line numbers,\n     * 2nd-level properties - character numbers\n     * @type Object\n     * @default\n     */ styles: null,\n        /**\n     * Reference to a context to measure text char or couple of chars\n     * the cacheContext of the canvas will be used or a freshly created one if the object is not on canvas\n     * once created it will be referenced on fabric._measuringContext to avoid creating a canvas for every\n     * text object created.\n     * @type {CanvasRenderingContext2D}\n     * @default\n     */ _measuringContext: null,\n        /**\n     * Baseline shift, styles only, keep at 0 for the main text object\n     * @type {Number}\n     * @default\n     */ deltaY: 0,\n        /**\n     * WARNING: EXPERIMENTAL. NOT SUPPORTED YET\n     * determine the direction of the text.\n     * This has to be set manually together with textAlign and originX for proper\n     * experience.\n     * some interesting link for the future\n     * https://www.w3.org/International/questions/qa-bidi-unicode-controls\n     * @since 4.5.0\n     * @type {String} 'ltr|rtl'\n     * @default\n     */ direction: \"ltr\",\n        /**\n     * Array of properties that define a style unit (of 'styles').\n     * @type {Array}\n     * @default\n     */ _styleProperties: [\n            \"stroke\",\n            \"strokeWidth\",\n            \"fill\",\n            \"fontFamily\",\n            \"fontSize\",\n            \"fontWeight\",\n            \"fontStyle\",\n            \"underline\",\n            \"overline\",\n            \"linethrough\",\n            \"deltaY\",\n            \"textBackgroundColor\"\n        ],\n        /**\n     * contains characters bounding boxes\n     */ __charBounds: [],\n        /**\n     * use this size when measuring text. To avoid IE11 rounding errors\n     * @type {Number}\n     * @default\n     * @readonly\n     * @private\n     */ CACHE_FONT_SIZE: 400,\n        /**\n     * contains the min text width to avoid getting 0\n     * @type {Number}\n     * @default\n     */ MIN_TEXT_WIDTH: 2,\n        /**\n     * Constructor\n     * @param {String} text Text string\n     * @param {Object} [options] Options object\n     * @return {fabric.Text} thisArg\n     */ initialize: function(text, options) {\n            this.styles = options ? options.styles || {} : {};\n            this.text = text;\n            this.__skipDimension = true;\n            this.callSuper(\"initialize\", options);\n            if (this.path) {\n                this.setPathInfo();\n            }\n            this.__skipDimension = false;\n            this.initDimensions();\n            this.setCoords();\n            this.setupState({\n                propertySet: \"_dimensionAffectingProps\"\n            });\n        },\n        /**\n     * If text has a path, it will add the extra information needed\n     * for path and text calculations\n     * @return {fabric.Text} thisArg\n     */ setPathInfo: function() {\n            var path = this.path;\n            if (path) {\n                path.segmentsInfo = fabric.util.getPathSegmentsInfo(path.path);\n            }\n        },\n        /**\n     * Return a context for measurement of text string.\n     * if created it gets stored for reuse\n     * this is for internal use, please do not use it\n     * @private\n     * @param {String} text Text string\n     * @param {Object} [options] Options object\n     * @return {fabric.Text} thisArg\n     */ getMeasuringContext: function() {\n            // if we did not return we have to measure something.\n            if (!fabric._measuringContext) {\n                fabric._measuringContext = this.canvas && this.canvas.contextCache || fabric.util.createCanvasElement().getContext(\"2d\");\n            }\n            return fabric._measuringContext;\n        },\n        /**\n     * @private\n     * Divides text into lines of text and lines of graphemes.\n     */ _splitText: function() {\n            var newLines = this._splitTextIntoLines(this.text);\n            this.textLines = newLines.lines;\n            this._textLines = newLines.graphemeLines;\n            this._unwrappedTextLines = newLines._unwrappedLines;\n            this._text = newLines.graphemeText;\n            return newLines;\n        },\n        /**\n     * Initialize or update text dimensions.\n     * Updates this.width and this.height with the proper values.\n     * Does not return dimensions.\n     */ initDimensions: function() {\n            if (this.__skipDimension) {\n                return;\n            }\n            this._splitText();\n            this._clearCache();\n            if (this.path) {\n                // Add the space of a line around the path. This is an approximation\n                var additionalWidth = this.getHeightOfLine(0) * 1.1;\n                this.width = this.path.width + additionalWidth;\n                this.height = this.path.height + additionalWidth;\n            } else {\n                this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH;\n                this.height = this.calcTextHeight();\n            }\n            if (this.textAlign.indexOf(\"justify\") !== -1) {\n                // once text is measured we need to make space fatter to make justified text.\n                this.enlargeSpaces();\n            }\n            this.saveState({\n                propertySet: \"_dimensionAffectingProps\"\n            });\n        },\n        /**\n     * Enlarge space boxes and shift the others\n     */ enlargeSpaces: function() {\n            var diffSpace, currentLineWidth, numberOfSpaces, accumulatedSpace, line, charBound, spaces;\n            for(var i = 0, len = this._textLines.length; i < len; i++){\n                if (this.textAlign !== \"justify\" && (i === len - 1 || this.isEndOfWrapping(i))) {\n                    continue;\n                }\n                accumulatedSpace = 0;\n                line = this._textLines[i];\n                currentLineWidth = this.getLineWidth(i);\n                if (currentLineWidth < this.width && (spaces = this.textLines[i].match(this._reSpacesAndTabs))) {\n                    numberOfSpaces = spaces.length;\n                    diffSpace = (this.width - currentLineWidth) / numberOfSpaces;\n                    for(var j = 0, jlen = line.length; j <= jlen; j++){\n                        charBound = this.__charBounds[i][j];\n                        if (this._reSpaceAndTab.test(line[j])) {\n                            charBound.width += diffSpace;\n                            charBound.kernedWidth += diffSpace;\n                            charBound.left += accumulatedSpace;\n                            accumulatedSpace += diffSpace;\n                        } else {\n                            charBound.left += accumulatedSpace;\n                        }\n                    }\n                }\n            }\n        },\n        /**\n     * Detect if the text line is ended with an hard break\n     * text and itext do not have wrapping, return false\n     * @return {Boolean}\n     */ isEndOfWrapping: function(lineIndex) {\n            return lineIndex === this._textLines.length - 1;\n        },\n        /**\n     * Detect if a line has a linebreak and so we need to account for it when moving\n     * and counting style.\n     * It return always for text and Itext.\n     * @return Number\n     */ missingNewlineOffset: function() {\n            return 1;\n        },\n        /**\n     * Returns string representation of an instance\n     * @return {String} String representation of text object\n     */ toString: function() {\n            return \"#<fabric.Text (\" + this.complexity() + '): { \"text\": \"' + this.text + '\", \"fontFamily\": \"' + this.fontFamily + '\" }>';\n        },\n        /**\n     * Return the dimension and the zoom level needed to create a cache canvas\n     * big enough to host the object to be cached.\n     * @private\n     * @param {Object} dim.x width of object to be cached\n     * @param {Object} dim.y height of object to be cached\n     * @return {Object}.width width of canvas\n     * @return {Object}.height height of canvas\n     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache\n     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache\n     */ _getCacheCanvasDimensions: function() {\n            var dims = this.callSuper(\"_getCacheCanvasDimensions\");\n            var fontSize = this.fontSize;\n            dims.width += fontSize * dims.zoomX;\n            dims.height += fontSize * dims.zoomY;\n            return dims;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            var path = this.path;\n            path && !path.isNotVisible() && path._render(ctx);\n            this._setTextStyles(ctx);\n            this._renderTextLinesBackground(ctx);\n            this._renderTextDecoration(ctx, \"underline\");\n            this._renderText(ctx);\n            this._renderTextDecoration(ctx, \"overline\");\n            this._renderTextDecoration(ctx, \"linethrough\");\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderText: function(ctx) {\n            if (this.paintFirst === \"stroke\") {\n                this._renderTextStroke(ctx);\n                this._renderTextFill(ctx);\n            } else {\n                this._renderTextFill(ctx);\n                this._renderTextStroke(ctx);\n            }\n        },\n        /**\n     * Set the font parameter of the context with the object properties or with charStyle\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Object} [charStyle] object with font style properties\n     * @param {String} [charStyle.fontFamily] Font Family\n     * @param {Number} [charStyle.fontSize] Font size in pixels. ( without px suffix )\n     * @param {String} [charStyle.fontWeight] Font weight\n     * @param {String} [charStyle.fontStyle] Font style (italic|normal)\n     */ _setTextStyles: function(ctx, charStyle, forMeasuring) {\n            ctx.textBaseline = \"alphabetic\";\n            if (this.path) {\n                switch(this.pathAlign){\n                    case \"center\":\n                        ctx.textBaseline = \"middle\";\n                        break;\n                    case \"ascender\":\n                        ctx.textBaseline = \"top\";\n                        break;\n                    case \"descender\":\n                        ctx.textBaseline = \"bottom\";\n                        break;\n                }\n            }\n            ctx.font = this._getFontDeclaration(charStyle, forMeasuring);\n        },\n        /**\n     * calculate and return the text Width measuring each line.\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @return {Number} Maximum width of fabric.Text object\n     */ calcTextWidth: function() {\n            var maxWidth = this.getLineWidth(0);\n            for(var i = 1, len = this._textLines.length; i < len; i++){\n                var currentLineWidth = this.getLineWidth(i);\n                if (currentLineWidth > maxWidth) {\n                    maxWidth = currentLineWidth;\n                }\n            }\n            return maxWidth;\n        },\n        /**\n     * @private\n     * @param {String} method Method name (\"fillText\" or \"strokeText\")\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {String} line Text to render\n     * @param {Number} left Left position of text\n     * @param {Number} top Top position of text\n     * @param {Number} lineIndex Index of a line in a text\n     */ _renderTextLine: function(method, ctx, line, left, top, lineIndex) {\n            this._renderChars(method, ctx, line, left, top, lineIndex);\n        },\n        /**\n     * Renders the text background for lines, taking care of style\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderTextLinesBackground: function(ctx) {\n            if (!this.textBackgroundColor && !this.styleHas(\"textBackgroundColor\")) {\n                return;\n            }\n            var heightOfLine, lineLeftOffset, originalFill = ctx.fillStyle, line, lastColor, leftOffset = this._getLeftOffset(), lineTopOffset = this._getTopOffset(), boxStart = 0, boxWidth = 0, charBox, currentColor, path = this.path, drawStart;\n            for(var i = 0, len = this._textLines.length; i < len; i++){\n                heightOfLine = this.getHeightOfLine(i);\n                if (!this.textBackgroundColor && !this.styleHas(\"textBackgroundColor\", i)) {\n                    lineTopOffset += heightOfLine;\n                    continue;\n                }\n                line = this._textLines[i];\n                lineLeftOffset = this._getLineLeftOffset(i);\n                boxWidth = 0;\n                boxStart = 0;\n                lastColor = this.getValueOfPropertyAt(i, 0, \"textBackgroundColor\");\n                for(var j = 0, jlen = line.length; j < jlen; j++){\n                    charBox = this.__charBounds[i][j];\n                    currentColor = this.getValueOfPropertyAt(i, j, \"textBackgroundColor\");\n                    if (path) {\n                        ctx.save();\n                        ctx.translate(charBox.renderLeft, charBox.renderTop);\n                        ctx.rotate(charBox.angle);\n                        ctx.fillStyle = currentColor;\n                        currentColor && ctx.fillRect(-charBox.width / 2, -heightOfLine / this.lineHeight * (1 - this._fontSizeFraction), charBox.width, heightOfLine / this.lineHeight);\n                        ctx.restore();\n                    } else if (currentColor !== lastColor) {\n                        drawStart = leftOffset + lineLeftOffset + boxStart;\n                        if (this.direction === \"rtl\") {\n                            drawStart = this.width - drawStart - boxWidth;\n                        }\n                        ctx.fillStyle = lastColor;\n                        lastColor && ctx.fillRect(drawStart, lineTopOffset, boxWidth, heightOfLine / this.lineHeight);\n                        boxStart = charBox.left;\n                        boxWidth = charBox.width;\n                        lastColor = currentColor;\n                    } else {\n                        boxWidth += charBox.kernedWidth;\n                    }\n                }\n                if (currentColor && !path) {\n                    drawStart = leftOffset + lineLeftOffset + boxStart;\n                    if (this.direction === \"rtl\") {\n                        drawStart = this.width - drawStart - boxWidth;\n                    }\n                    ctx.fillStyle = currentColor;\n                    ctx.fillRect(drawStart, lineTopOffset, boxWidth, heightOfLine / this.lineHeight);\n                }\n                lineTopOffset += heightOfLine;\n            }\n            ctx.fillStyle = originalFill;\n            // if there is text background color no\n            // other shadows should be casted\n            this._removeShadow(ctx);\n        },\n        /**\n     * @private\n     * @param {Object} decl style declaration for cache\n     * @param {String} decl.fontFamily fontFamily\n     * @param {String} decl.fontStyle fontStyle\n     * @param {String} decl.fontWeight fontWeight\n     * @return {Object} reference to cache\n     */ getFontCache: function(decl) {\n            var fontFamily = decl.fontFamily.toLowerCase();\n            if (!fabric.charWidthsCache[fontFamily]) {\n                fabric.charWidthsCache[fontFamily] = {};\n            }\n            var cache = fabric.charWidthsCache[fontFamily], cacheProp = decl.fontStyle.toLowerCase() + \"_\" + (decl.fontWeight + \"\").toLowerCase();\n            if (!cache[cacheProp]) {\n                cache[cacheProp] = {};\n            }\n            return cache[cacheProp];\n        },\n        /**\n     * measure and return the width of a single character.\n     * possibly overridden to accommodate different measure logic or\n     * to hook some external lib for character measurement\n     * @private\n     * @param {String} _char, char to be measured\n     * @param {Object} charStyle style of char to be measured\n     * @param {String} [previousChar] previous char\n     * @param {Object} [prevCharStyle] style of previous char\n     */ _measureChar: function(_char, charStyle, previousChar, prevCharStyle) {\n            // first i try to return from cache\n            var fontCache = this.getFontCache(charStyle), fontDeclaration = this._getFontDeclaration(charStyle), previousFontDeclaration = this._getFontDeclaration(prevCharStyle), couple = previousChar + _char, stylesAreEqual = fontDeclaration === previousFontDeclaration, width, coupleWidth, previousWidth, fontMultiplier = charStyle.fontSize / this.CACHE_FONT_SIZE, kernedWidth;\n            if (previousChar && fontCache[previousChar] !== undefined) {\n                previousWidth = fontCache[previousChar];\n            }\n            if (fontCache[_char] !== undefined) {\n                kernedWidth = width = fontCache[_char];\n            }\n            if (stylesAreEqual && fontCache[couple] !== undefined) {\n                coupleWidth = fontCache[couple];\n                kernedWidth = coupleWidth - previousWidth;\n            }\n            if (width === undefined || previousWidth === undefined || coupleWidth === undefined) {\n                var ctx = this.getMeasuringContext();\n                // send a TRUE to specify measuring font size CACHE_FONT_SIZE\n                this._setTextStyles(ctx, charStyle, true);\n            }\n            if (width === undefined) {\n                kernedWidth = width = ctx.measureText(_char).width;\n                fontCache[_char] = width;\n            }\n            if (previousWidth === undefined && stylesAreEqual && previousChar) {\n                previousWidth = ctx.measureText(previousChar).width;\n                fontCache[previousChar] = previousWidth;\n            }\n            if (stylesAreEqual && coupleWidth === undefined) {\n                // we can measure the kerning couple and subtract the width of the previous character\n                coupleWidth = ctx.measureText(couple).width;\n                fontCache[couple] = coupleWidth;\n                kernedWidth = coupleWidth - previousWidth;\n            }\n            return {\n                width: width * fontMultiplier,\n                kernedWidth: kernedWidth * fontMultiplier\n            };\n        },\n        /**\n     * Computes height of character at given position\n     * @param {Number} line the line index number\n     * @param {Number} _char the character index number\n     * @return {Number} fontSize of the character\n     */ getHeightOfChar: function(line, _char) {\n            return this.getValueOfPropertyAt(line, _char, \"fontSize\");\n        },\n        /**\n     * measure a text line measuring all characters.\n     * @param {Number} lineIndex line number\n     * @return {Number} Line width\n     */ measureLine: function(lineIndex) {\n            var lineInfo = this._measureLine(lineIndex);\n            if (this.charSpacing !== 0) {\n                lineInfo.width -= this._getWidthOfCharSpacing();\n            }\n            if (lineInfo.width < 0) {\n                lineInfo.width = 0;\n            }\n            return lineInfo;\n        },\n        /**\n     * measure every grapheme of a line, populating __charBounds\n     * @param {Number} lineIndex\n     * @return {Object} object.width total width of characters\n     * @return {Object} object.widthOfSpaces length of chars that match this._reSpacesAndTabs\n     */ _measureLine: function(lineIndex) {\n            var width = 0, i, grapheme, line = this._textLines[lineIndex], prevGrapheme, graphemeInfo, numOfSpaces = 0, lineBounds = new Array(line.length), positionInPath = 0, startingPoint, totalPathLength, path = this.path, reverse = this.pathSide === \"right\";\n            this.__charBounds[lineIndex] = lineBounds;\n            for(i = 0; i < line.length; i++){\n                grapheme = line[i];\n                graphemeInfo = this._getGraphemeBox(grapheme, lineIndex, i, prevGrapheme);\n                lineBounds[i] = graphemeInfo;\n                width += graphemeInfo.kernedWidth;\n                prevGrapheme = grapheme;\n            }\n            // this latest bound box represent the last character of the line\n            // to simplify cursor handling in interactive mode.\n            lineBounds[i] = {\n                left: graphemeInfo ? graphemeInfo.left + graphemeInfo.width : 0,\n                width: 0,\n                kernedWidth: 0,\n                height: this.fontSize\n            };\n            if (path) {\n                totalPathLength = path.segmentsInfo[path.segmentsInfo.length - 1].length;\n                startingPoint = fabric.util.getPointOnPath(path.path, 0, path.segmentsInfo);\n                startingPoint.x += path.pathOffset.x;\n                startingPoint.y += path.pathOffset.y;\n                switch(this.textAlign){\n                    case \"left\":\n                        positionInPath = reverse ? totalPathLength - width : 0;\n                        break;\n                    case \"center\":\n                        positionInPath = (totalPathLength - width) / 2;\n                        break;\n                    case \"right\":\n                        positionInPath = reverse ? 0 : totalPathLength - width;\n                        break;\n                }\n                positionInPath += this.pathStartOffset * (reverse ? -1 : 1);\n                for(i = reverse ? line.length - 1 : 0; reverse ? i >= 0 : i < line.length; reverse ? i-- : i++){\n                    graphemeInfo = lineBounds[i];\n                    if (positionInPath > totalPathLength) {\n                        positionInPath %= totalPathLength;\n                    } else if (positionInPath < 0) {\n                        positionInPath += totalPathLength;\n                    }\n                    // it would probably much faster to send all the grapheme position for a line\n                    // and calculate path position/angle at once.\n                    this._setGraphemeOnPath(positionInPath, graphemeInfo, startingPoint);\n                    positionInPath += graphemeInfo.kernedWidth;\n                }\n            }\n            return {\n                width: width,\n                numOfSpaces: numOfSpaces\n            };\n        },\n        /**\n     * Calculate the angle  and the left,top position of the char that follow a path.\n     * It appends it to graphemeInfo to be reused later at rendering\n     * @private\n     * @param {Number} positionInPath to be measured\n     * @param {Object} graphemeInfo current grapheme box information\n     * @param {Object} startingPoint position of the point\n     */ _setGraphemeOnPath: function(positionInPath, graphemeInfo, startingPoint) {\n            var centerPosition = positionInPath + graphemeInfo.kernedWidth / 2, path = this.path;\n            // we are at currentPositionOnPath. we want to know what point on the path is.\n            var info = fabric.util.getPointOnPath(path.path, centerPosition, path.segmentsInfo);\n            graphemeInfo.renderLeft = info.x - startingPoint.x;\n            graphemeInfo.renderTop = info.y - startingPoint.y;\n            graphemeInfo.angle = info.angle + (this.pathSide === \"right\" ? Math.PI : 0);\n        },\n        /**\n     * Measure and return the info of a single grapheme.\n     * needs the the info of previous graphemes already filled\n     * @private\n     * @param {String} grapheme to be measured\n     * @param {Number} lineIndex index of the line where the char is\n     * @param {Number} charIndex position in the line\n     * @param {String} [prevGrapheme] character preceding the one to be measured\n     */ _getGraphemeBox: function(grapheme, lineIndex, charIndex, prevGrapheme, skipLeft) {\n            var style = this.getCompleteStyleDeclaration(lineIndex, charIndex), prevStyle = prevGrapheme ? this.getCompleteStyleDeclaration(lineIndex, charIndex - 1) : {}, info = this._measureChar(grapheme, style, prevGrapheme, prevStyle), kernedWidth = info.kernedWidth, width = info.width, charSpacing;\n            if (this.charSpacing !== 0) {\n                charSpacing = this._getWidthOfCharSpacing();\n                width += charSpacing;\n                kernedWidth += charSpacing;\n            }\n            var box = {\n                width: width,\n                left: 0,\n                height: style.fontSize,\n                kernedWidth: kernedWidth,\n                deltaY: style.deltaY\n            };\n            if (charIndex > 0 && !skipLeft) {\n                var previousBox = this.__charBounds[lineIndex][charIndex - 1];\n                box.left = previousBox.left + previousBox.width + info.kernedWidth - info.width;\n            }\n            return box;\n        },\n        /**\n     * Calculate height of line at 'lineIndex'\n     * @param {Number} lineIndex index of line to calculate\n     * @return {Number}\n     */ getHeightOfLine: function(lineIndex) {\n            if (this.__lineHeights[lineIndex]) {\n                return this.__lineHeights[lineIndex];\n            }\n            var line = this._textLines[lineIndex], // char 0 is measured before the line cycle because it nneds to char\n            // emptylines\n            maxHeight = this.getHeightOfChar(lineIndex, 0);\n            for(var i = 1, len = line.length; i < len; i++){\n                maxHeight = Math.max(this.getHeightOfChar(lineIndex, i), maxHeight);\n            }\n            return this.__lineHeights[lineIndex] = maxHeight * this.lineHeight * this._fontSizeMult;\n        },\n        /**\n     * Calculate text box height\n     */ calcTextHeight: function() {\n            var lineHeight, height = 0;\n            for(var i = 0, len = this._textLines.length; i < len; i++){\n                lineHeight = this.getHeightOfLine(i);\n                height += i === len - 1 ? lineHeight / this.lineHeight : lineHeight;\n            }\n            return height;\n        },\n        /**\n     * @private\n     * @return {Number} Left offset\n     */ _getLeftOffset: function() {\n            return this.direction === \"ltr\" ? -this.width / 2 : this.width / 2;\n        },\n        /**\n     * @private\n     * @return {Number} Top offset\n     */ _getTopOffset: function() {\n            return -this.height / 2;\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {String} method Method name (\"fillText\" or \"strokeText\")\n     */ _renderTextCommon: function(ctx, method) {\n            ctx.save();\n            var lineHeights = 0, left = this._getLeftOffset(), top = this._getTopOffset();\n            for(var i = 0, len = this._textLines.length; i < len; i++){\n                var heightOfLine = this.getHeightOfLine(i), maxHeight = heightOfLine / this.lineHeight, leftOffset = this._getLineLeftOffset(i);\n                this._renderTextLine(method, ctx, this._textLines[i], left + leftOffset, top + lineHeights + maxHeight, i);\n                lineHeights += heightOfLine;\n            }\n            ctx.restore();\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderTextFill: function(ctx) {\n            if (!this.fill && !this.styleHas(\"fill\")) {\n                return;\n            }\n            this._renderTextCommon(ctx, \"fillText\");\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderTextStroke: function(ctx) {\n            if ((!this.stroke || this.strokeWidth === 0) && this.isEmptyStyles()) {\n                return;\n            }\n            if (this.shadow && !this.shadow.affectStroke) {\n                this._removeShadow(ctx);\n            }\n            ctx.save();\n            this._setLineDash(ctx, this.strokeDashArray);\n            ctx.beginPath();\n            this._renderTextCommon(ctx, \"strokeText\");\n            ctx.closePath();\n            ctx.restore();\n        },\n        /**\n     * @private\n     * @param {String} method fillText or strokeText.\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Array} line Content of the line, splitted in an array by grapheme\n     * @param {Number} left\n     * @param {Number} top\n     * @param {Number} lineIndex\n     */ _renderChars: function(method, ctx, line, left, top, lineIndex) {\n            // set proper line offset\n            var lineHeight = this.getHeightOfLine(lineIndex), isJustify = this.textAlign.indexOf(\"justify\") !== -1, actualStyle, nextStyle, charsToRender = \"\", charBox, boxWidth = 0, timeToRender, path = this.path, shortCut = !isJustify && this.charSpacing === 0 && this.isEmptyStyles(lineIndex) && !path, isLtr = this.direction === \"ltr\", sign = this.direction === \"ltr\" ? 1 : -1, drawingLeft, currentDirection = ctx.canvas.getAttribute(\"dir\");\n            ctx.save();\n            if (currentDirection !== this.direction) {\n                ctx.canvas.setAttribute(\"dir\", isLtr ? \"ltr\" : \"rtl\");\n                ctx.direction = isLtr ? \"ltr\" : \"rtl\";\n                ctx.textAlign = isLtr ? \"left\" : \"right\";\n            }\n            top -= lineHeight * this._fontSizeFraction / this.lineHeight;\n            if (shortCut) {\n                // render all the line in one pass without checking\n                // drawingLeft = isLtr ? left : left - this.getLineWidth(lineIndex);\n                this._renderChar(method, ctx, lineIndex, 0, line.join(\"\"), left, top, lineHeight);\n                ctx.restore();\n                return;\n            }\n            for(var i = 0, len = line.length - 1; i <= len; i++){\n                timeToRender = i === len || this.charSpacing || path;\n                charsToRender += line[i];\n                charBox = this.__charBounds[lineIndex][i];\n                if (boxWidth === 0) {\n                    left += sign * (charBox.kernedWidth - charBox.width);\n                    boxWidth += charBox.width;\n                } else {\n                    boxWidth += charBox.kernedWidth;\n                }\n                if (isJustify && !timeToRender) {\n                    if (this._reSpaceAndTab.test(line[i])) {\n                        timeToRender = true;\n                    }\n                }\n                if (!timeToRender) {\n                    // if we have charSpacing, we render char by char\n                    actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);\n                    nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);\n                    timeToRender = fabric.util.hasStyleChanged(actualStyle, nextStyle, false);\n                }\n                if (timeToRender) {\n                    if (path) {\n                        ctx.save();\n                        ctx.translate(charBox.renderLeft, charBox.renderTop);\n                        ctx.rotate(charBox.angle);\n                        this._renderChar(method, ctx, lineIndex, i, charsToRender, -boxWidth / 2, 0, lineHeight);\n                        ctx.restore();\n                    } else {\n                        drawingLeft = left;\n                        this._renderChar(method, ctx, lineIndex, i, charsToRender, drawingLeft, top, lineHeight);\n                    }\n                    charsToRender = \"\";\n                    actualStyle = nextStyle;\n                    left += sign * boxWidth;\n                    boxWidth = 0;\n                }\n            }\n            ctx.restore();\n        },\n        /**\n     * This function try to patch the missing gradientTransform on canvas gradients.\n     * transforming a context to transform the gradient, is going to transform the stroke too.\n     * we want to transform the gradient but not the stroke operation, so we create\n     * a transformed gradient on a pattern and then we use the pattern instead of the gradient.\n     * this method has drawbacks: is slow, is in low resolution, needs a patch for when the size\n     * is limited.\n     * @private\n     * @param {fabric.Gradient} filler a fabric gradient instance\n     * @return {CanvasPattern} a pattern to use as fill/stroke style\n     */ _applyPatternGradientTransformText: function(filler) {\n            var pCanvas = fabric.util.createCanvasElement(), pCtx, // TODO: verify compatibility with strokeUniform\n            width = this.width + this.strokeWidth, height = this.height + this.strokeWidth;\n            pCanvas.width = width;\n            pCanvas.height = height;\n            pCtx = pCanvas.getContext(\"2d\");\n            pCtx.beginPath();\n            pCtx.moveTo(0, 0);\n            pCtx.lineTo(width, 0);\n            pCtx.lineTo(width, height);\n            pCtx.lineTo(0, height);\n            pCtx.closePath();\n            pCtx.translate(width / 2, height / 2);\n            pCtx.fillStyle = filler.toLive(pCtx);\n            this._applyPatternGradientTransform(pCtx, filler);\n            pCtx.fill();\n            return pCtx.createPattern(pCanvas, \"no-repeat\");\n        },\n        handleFiller: function(ctx, property, filler) {\n            var offsetX, offsetY;\n            if (filler.toLive) {\n                if (filler.gradientUnits === \"percentage\" || filler.gradientTransform || filler.patternTransform) {\n                    // need to transform gradient in a pattern.\n                    // this is a slow process. If you are hitting this codepath, and the object\n                    // is not using caching, you should consider switching it on.\n                    // we need a canvas as big as the current object caching canvas.\n                    offsetX = -this.width / 2;\n                    offsetY = -this.height / 2;\n                    ctx.translate(offsetX, offsetY);\n                    ctx[property] = this._applyPatternGradientTransformText(filler);\n                    return {\n                        offsetX: offsetX,\n                        offsetY: offsetY\n                    };\n                } else {\n                    // is a simple gradient or pattern\n                    ctx[property] = filler.toLive(ctx, this);\n                    return this._applyPatternGradientTransform(ctx, filler);\n                }\n            } else {\n                // is a color\n                ctx[property] = filler;\n            }\n            return {\n                offsetX: 0,\n                offsetY: 0\n            };\n        },\n        _setStrokeStyles: function(ctx, decl) {\n            ctx.lineWidth = decl.strokeWidth;\n            ctx.lineCap = this.strokeLineCap;\n            ctx.lineDashOffset = this.strokeDashOffset;\n            ctx.lineJoin = this.strokeLineJoin;\n            ctx.miterLimit = this.strokeMiterLimit;\n            return this.handleFiller(ctx, \"strokeStyle\", decl.stroke);\n        },\n        _setFillStyles: function(ctx, decl) {\n            return this.handleFiller(ctx, \"fillStyle\", decl.fill);\n        },\n        /**\n     * @private\n     * @param {String} method\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @param {String} _char\n     * @param {Number} left Left coordinate\n     * @param {Number} top Top coordinate\n     * @param {Number} lineHeight Height of the line\n     */ _renderChar: function(method, ctx, lineIndex, charIndex, _char, left, top) {\n            var decl = this._getStyleDeclaration(lineIndex, charIndex), fullDecl = this.getCompleteStyleDeclaration(lineIndex, charIndex), shouldFill = method === \"fillText\" && fullDecl.fill, shouldStroke = method === \"strokeText\" && fullDecl.stroke && fullDecl.strokeWidth, fillOffsets, strokeOffsets;\n            if (!shouldStroke && !shouldFill) {\n                return;\n            }\n            ctx.save();\n            shouldFill && (fillOffsets = this._setFillStyles(ctx, fullDecl));\n            shouldStroke && (strokeOffsets = this._setStrokeStyles(ctx, fullDecl));\n            ctx.font = this._getFontDeclaration(fullDecl);\n            if (decl && decl.textBackgroundColor) {\n                this._removeShadow(ctx);\n            }\n            if (decl && decl.deltaY) {\n                top += decl.deltaY;\n            }\n            shouldFill && ctx.fillText(_char, left - fillOffsets.offsetX, top - fillOffsets.offsetY);\n            shouldStroke && ctx.strokeText(_char, left - strokeOffsets.offsetX, top - strokeOffsets.offsetY);\n            ctx.restore();\n        },\n        /**\n     * Turns the character into a 'superior figure' (i.e. 'superscript')\n     * @param {Number} start selection start\n     * @param {Number} end selection end\n     * @returns {fabric.Text} thisArg\n     * @chainable\n     */ setSuperscript: function(start, end) {\n            return this._setScript(start, end, this.superscript);\n        },\n        /**\n     * Turns the character into an 'inferior figure' (i.e. 'subscript')\n     * @param {Number} start selection start\n     * @param {Number} end selection end\n     * @returns {fabric.Text} thisArg\n     * @chainable\n     */ setSubscript: function(start, end) {\n            return this._setScript(start, end, this.subscript);\n        },\n        /**\n     * Applies 'schema' at given position\n     * @private\n     * @param {Number} start selection start\n     * @param {Number} end selection end\n     * @param {Number} schema\n     * @returns {fabric.Text} thisArg\n     * @chainable\n     */ _setScript: function(start, end, schema) {\n            var loc = this.get2DCursorLocation(start, true), fontSize = this.getValueOfPropertyAt(loc.lineIndex, loc.charIndex, \"fontSize\"), dy = this.getValueOfPropertyAt(loc.lineIndex, loc.charIndex, \"deltaY\"), style = {\n                fontSize: fontSize * schema.size,\n                deltaY: dy + fontSize * schema.baseline\n            };\n            this.setSelectionStyles(style, start, end);\n            return this;\n        },\n        /**\n     * @private\n     * @param {Number} lineIndex index text line\n     * @return {Number} Line left offset\n     */ _getLineLeftOffset: function(lineIndex) {\n            var lineWidth = this.getLineWidth(lineIndex), lineDiff = this.width - lineWidth, textAlign = this.textAlign, direction = this.direction, isEndOfWrapping, leftOffset = 0, isEndOfWrapping = this.isEndOfWrapping(lineIndex);\n            if (textAlign === \"justify\" || textAlign === \"justify-center\" && !isEndOfWrapping || textAlign === \"justify-right\" && !isEndOfWrapping || textAlign === \"justify-left\" && !isEndOfWrapping) {\n                return 0;\n            }\n            if (textAlign === \"center\") {\n                leftOffset = lineDiff / 2;\n            }\n            if (textAlign === \"right\") {\n                leftOffset = lineDiff;\n            }\n            if (textAlign === \"justify-center\") {\n                leftOffset = lineDiff / 2;\n            }\n            if (textAlign === \"justify-right\") {\n                leftOffset = lineDiff;\n            }\n            if (direction === \"rtl\") {\n                leftOffset -= lineDiff;\n            }\n            return leftOffset;\n        },\n        /**\n     * @private\n     */ _clearCache: function() {\n            this.__lineWidths = [];\n            this.__lineHeights = [];\n            this.__charBounds = [];\n        },\n        /**\n     * @private\n     */ _shouldClearDimensionCache: function() {\n            var shouldClear = this._forceClearCache;\n            shouldClear || (shouldClear = this.hasStateChanged(\"_dimensionAffectingProps\"));\n            if (shouldClear) {\n                this.dirty = true;\n                this._forceClearCache = false;\n            }\n            return shouldClear;\n        },\n        /**\n     * Measure a single line given its index. Used to calculate the initial\n     * text bounding box. The values are calculated and stored in __lineWidths cache.\n     * @private\n     * @param {Number} lineIndex line number\n     * @return {Number} Line width\n     */ getLineWidth: function(lineIndex) {\n            if (this.__lineWidths[lineIndex] !== undefined) {\n                return this.__lineWidths[lineIndex];\n            }\n            var lineInfo = this.measureLine(lineIndex);\n            var width = lineInfo.width;\n            this.__lineWidths[lineIndex] = width;\n            return width;\n        },\n        _getWidthOfCharSpacing: function() {\n            if (this.charSpacing !== 0) {\n                return this.fontSize * this.charSpacing / 1000;\n            }\n            return 0;\n        },\n        /**\n     * Retrieves the value of property at given character position\n     * @param {Number} lineIndex the line number\n     * @param {Number} charIndex the character number\n     * @param {String} property the property name\n     * @returns the value of 'property'\n     */ getValueOfPropertyAt: function(lineIndex, charIndex, property) {\n            var charStyle = this._getStyleDeclaration(lineIndex, charIndex);\n            if (charStyle && typeof charStyle[property] !== \"undefined\") {\n                return charStyle[property];\n            }\n            return this[property];\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _renderTextDecoration: function(ctx, type) {\n            if (!this[type] && !this.styleHas(type)) {\n                return;\n            }\n            ctx.save();\n            // if type is overline or linethrough we shouldn't cast shadow\n            if (type === \"overline\" || type === \"linethrough\") {\n                this._removeShadow(ctx);\n            }\n            var heightOfLine, size, _size, lineLeftOffset, dy, _dy, line, lastDecoration, leftOffset = this._getLeftOffset(), topOffset = this._getTopOffset(), top, boxStart, boxWidth, charBox, currentDecoration, maxHeight, currentFill, lastFill, path = this.path, charSpacing = this._getWidthOfCharSpacing(), offsetY = this.offsets[type];\n            for(var i = 0, len = this._textLines.length; i < len; i++){\n                heightOfLine = this.getHeightOfLine(i);\n                if (!this[type] && !this.styleHas(type, i)) {\n                    topOffset += heightOfLine;\n                    continue;\n                }\n                line = this._textLines[i];\n                maxHeight = heightOfLine / this.lineHeight;\n                lineLeftOffset = this._getLineLeftOffset(i);\n                boxStart = 0;\n                boxWidth = 0;\n                lastDecoration = this.getValueOfPropertyAt(i, 0, type);\n                lastFill = this.getValueOfPropertyAt(i, 0, \"fill\");\n                top = topOffset + maxHeight * (1 - this._fontSizeFraction);\n                size = this.getHeightOfChar(i, 0);\n                dy = this.getValueOfPropertyAt(i, 0, \"deltaY\");\n                for(var j = 0, jlen = line.length; j < jlen; j++){\n                    charBox = this.__charBounds[i][j];\n                    currentDecoration = this.getValueOfPropertyAt(i, j, type);\n                    currentFill = this.getValueOfPropertyAt(i, j, \"fill\");\n                    _size = this.getHeightOfChar(i, j);\n                    _dy = this.getValueOfPropertyAt(i, j, \"deltaY\");\n                    if (path && currentDecoration && currentFill) {\n                        ctx.save();\n                        ctx.fillStyle = lastFill;\n                        ctx.translate(charBox.renderLeft, charBox.renderTop);\n                        ctx.rotate(charBox.angle);\n                        ctx.fillRect(-charBox.kernedWidth / 2, offsetY * _size + _dy, charBox.kernedWidth, this.fontSize / 15);\n                        ctx.restore();\n                    } else if ((currentDecoration !== lastDecoration || currentFill !== lastFill || _size !== size || _dy !== dy) && boxWidth > 0) {\n                        var drawStart = leftOffset + lineLeftOffset + boxStart;\n                        if (this.direction === \"rtl\") {\n                            drawStart = this.width - drawStart - boxWidth;\n                        }\n                        if (lastDecoration && lastFill) {\n                            ctx.fillStyle = lastFill;\n                            ctx.fillRect(drawStart, top + offsetY * size + dy, boxWidth, this.fontSize / 15);\n                        }\n                        boxStart = charBox.left;\n                        boxWidth = charBox.width;\n                        lastDecoration = currentDecoration;\n                        lastFill = currentFill;\n                        size = _size;\n                        dy = _dy;\n                    } else {\n                        boxWidth += charBox.kernedWidth;\n                    }\n                }\n                var drawStart = leftOffset + lineLeftOffset + boxStart;\n                if (this.direction === \"rtl\") {\n                    drawStart = this.width - drawStart - boxWidth;\n                }\n                ctx.fillStyle = currentFill;\n                currentDecoration && currentFill && ctx.fillRect(drawStart, top + offsetY * size + dy, boxWidth - charSpacing, this.fontSize / 15);\n                topOffset += heightOfLine;\n            }\n            ctx.restore();\n        },\n        /**\n     * return font declaration string for canvas context\n     * @param {Object} [styleObject] object\n     * @returns {String} font declaration formatted for canvas context.\n     */ _getFontDeclaration: function(styleObject, forMeasuring) {\n            var style = styleObject || this, family = this.fontFamily, fontIsGeneric = fabric.Text.genericFonts.indexOf(family.toLowerCase()) > -1;\n            var fontFamily = family === undefined || family.indexOf(\"'\") > -1 || family.indexOf(\",\") > -1 || family.indexOf('\"') > -1 || fontIsGeneric ? style.fontFamily : '\"' + style.fontFamily + '\"';\n            return [\n                // node-canvas needs \"weight style\", while browsers need \"style weight\"\n                // verify if this can be fixed in JSDOM\n                fabric.isLikelyNode ? style.fontWeight : style.fontStyle,\n                fabric.isLikelyNode ? style.fontStyle : style.fontWeight,\n                forMeasuring ? this.CACHE_FONT_SIZE + \"px\" : style.fontSize + \"px\",\n                fontFamily\n            ].join(\" \");\n        },\n        /**\n     * Renders text instance on a specified context\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ render: function(ctx) {\n            // do not render if object is not visible\n            if (!this.visible) {\n                return;\n            }\n            if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {\n                return;\n            }\n            if (this._shouldClearDimensionCache()) {\n                this.initDimensions();\n            }\n            this.callSuper(\"render\", ctx);\n        },\n        /**\n     * Returns the text as an array of lines.\n     * @param {String} text text to split\n     * @returns {Array} Lines in the text\n     */ _splitTextIntoLines: function(text) {\n            var lines = text.split(this._reNewline), newLines = new Array(lines.length), newLine = [\n                \"\\n\"\n            ], newText = [];\n            for(var i = 0; i < lines.length; i++){\n                newLines[i] = fabric.util.string.graphemeSplit(lines[i]);\n                newText = newText.concat(newLines[i], newLine);\n            }\n            newText.pop();\n            return {\n                _unwrappedLines: newLines,\n                lines: lines,\n                graphemeText: newText,\n                graphemeLines: newLines\n            };\n        },\n        /**\n     * Returns object representation of an instance\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} Object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            var allProperties = additionalProps.concat(propertiesToInclude);\n            var obj = this.callSuper(\"toObject\", allProperties);\n            obj.styles = fabric.util.stylesToArray(this.styles, this.text);\n            if (obj.path) {\n                obj.path = this.path.toObject();\n            }\n            return obj;\n        },\n        /**\n     * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.\n     * @param {String|Object} key Property name or object (if object, iterate over the object properties)\n     * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)\n     * @return {fabric.Object} thisArg\n     * @chainable\n     */ set: function(key, value) {\n            this.callSuper(\"set\", key, value);\n            var needsDims = false;\n            var isAddingPath = false;\n            if (typeof key === \"object\") {\n                for(var _key in key){\n                    if (_key === \"path\") {\n                        this.setPathInfo();\n                    }\n                    needsDims = needsDims || this._dimensionAffectingProps.indexOf(_key) !== -1;\n                    isAddingPath = isAddingPath || _key === \"path\";\n                }\n            } else {\n                needsDims = this._dimensionAffectingProps.indexOf(key) !== -1;\n                isAddingPath = key === \"path\";\n            }\n            if (isAddingPath) {\n                this.setPathInfo();\n            }\n            if (needsDims) {\n                this.initDimensions();\n                this.setCoords();\n            }\n            return this;\n        },\n        /**\n     * Returns complexity of an instance\n     * @return {Number} complexity\n     */ complexity: function() {\n            return 1;\n        }\n    });\n    /* _FROM_SVG_START_ */ /**\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Text.fromElement})\n   * @static\n   * @memberOf fabric.Text\n   * @see: http://www.w3.org/TR/SVG/text.html#TextElement\n   */ fabric.Text.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\"x y dx dy font-family font-style font-weight font-size letter-spacing text-decoration text-anchor\".split(\" \"));\n    /**\n   * Default SVG font size\n   * @static\n   * @memberOf fabric.Text\n   */ fabric.Text.DEFAULT_SVG_FONT_SIZE = 16;\n    /**\n   * Returns fabric.Text instance from an SVG element (<b>not yet implemented</b>)\n   * @static\n   * @memberOf fabric.Text\n   * @param {SVGElement} element Element to parse\n   * @param {Function} callback callback function invoked after parsing\n   * @param {Object} [options] Options object\n   */ fabric.Text.fromElement = function(element, callback, options) {\n        if (!element) {\n            return callback(null);\n        }\n        var parsedAttributes = fabric.parseAttributes(element, fabric.Text.ATTRIBUTE_NAMES), parsedAnchor = parsedAttributes.textAnchor || \"left\";\n        options = fabric.util.object.extend(options ? clone(options) : {}, parsedAttributes);\n        options.top = options.top || 0;\n        options.left = options.left || 0;\n        if (parsedAttributes.textDecoration) {\n            var textDecoration = parsedAttributes.textDecoration;\n            if (textDecoration.indexOf(\"underline\") !== -1) {\n                options.underline = true;\n            }\n            if (textDecoration.indexOf(\"overline\") !== -1) {\n                options.overline = true;\n            }\n            if (textDecoration.indexOf(\"line-through\") !== -1) {\n                options.linethrough = true;\n            }\n            delete options.textDecoration;\n        }\n        if (\"dx\" in parsedAttributes) {\n            options.left += parsedAttributes.dx;\n        }\n        if (\"dy\" in parsedAttributes) {\n            options.top += parsedAttributes.dy;\n        }\n        if (!(\"fontSize\" in options)) {\n            options.fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;\n        }\n        var textContent = \"\";\n        // The XML is not properly parsed in IE9 so a workaround to get\n        // textContent is through firstChild.data. Another workaround would be\n        // to convert XML loaded from a file to be converted using DOMParser (same way loadSVGFromString() does)\n        if (!(\"textContent\" in element)) {\n            if (\"firstChild\" in element && element.firstChild !== null) {\n                if (\"data\" in element.firstChild && element.firstChild.data !== null) {\n                    textContent = element.firstChild.data;\n                }\n            }\n        } else {\n            textContent = element.textContent;\n        }\n        textContent = textContent.replace(/^\\s+|\\s+$|\\n+/g, \"\").replace(/\\s+/g, \" \");\n        var originalStrokeWidth = options.strokeWidth;\n        options.strokeWidth = 0;\n        var text = new fabric.Text(textContent, options), textHeightScaleFactor = text.getScaledHeight() / text.height, lineHeightDiff = (text.height + text.strokeWidth) * text.lineHeight - text.height, scaledDiff = lineHeightDiff * textHeightScaleFactor, textHeight = text.getScaledHeight() + scaledDiff, offX = 0;\n        /*\n      Adjust positioning:\n        x/y attributes in SVG correspond to the bottom-left corner of text bounding box\n        fabric output by default at top, left.\n    */ if (parsedAnchor === \"center\") {\n            offX = text.getScaledWidth() / 2;\n        }\n        if (parsedAnchor === \"right\") {\n            offX = text.getScaledWidth();\n        }\n        text.set({\n            left: text.left - offX,\n            top: text.top - (textHeight - text.fontSize * (0.07 + text._fontSizeFraction)) / text.lineHeight,\n            strokeWidth: typeof originalStrokeWidth !== \"undefined\" ? originalStrokeWidth : 1\n        });\n        callback(text);\n    };\n    /* _FROM_SVG_END_ */ /**\n   * Returns fabric.Text instance from an object representation\n   * @static\n   * @memberOf fabric.Text\n   * @param {Object} object plain js Object to create an instance from\n   * @param {Function} [callback] Callback to invoke when an fabric.Text instance is created\n   */ fabric.Text.fromObject = function(object, callback) {\n        var objectCopy = clone(object), path = object.path;\n        delete objectCopy.path;\n        return fabric.Object._fromObject(\"Text\", objectCopy, function(textInstance) {\n            textInstance.styles = fabric.util.stylesFromArray(object.styles, object.text);\n            if (path) {\n                fabric.Object._fromObject(\"Path\", path, function(pathInstance) {\n                    textInstance.set(\"path\", pathInstance);\n                    callback(textInstance);\n                }, \"path\");\n            } else {\n                callback(textInstance);\n            }\n        }, \"text\");\n    };\n    fabric.Text.genericFonts = [\n        \"sans-serif\",\n        \"serif\",\n        \"cursive\",\n        \"fantasy\",\n        \"monospace\"\n    ];\n    fabric.util.createAccessors && fabric.util.createAccessors(fabric.Text);\n})( true ? exports : 0);\n(function() {\n    fabric.util.object.extend(fabric.Text.prototype, /** @lends fabric.Text.prototype */ {\n        /**\n     * Returns true if object has no styling or no styling in a line\n     * @param {Number} lineIndex , lineIndex is on wrapped lines.\n     * @return {Boolean}\n     */ isEmptyStyles: function(lineIndex) {\n            if (!this.styles) {\n                return true;\n            }\n            if (typeof lineIndex !== \"undefined\" && !this.styles[lineIndex]) {\n                return true;\n            }\n            var obj = typeof lineIndex === \"undefined\" ? this.styles : {\n                line: this.styles[lineIndex]\n            };\n            for(var p1 in obj){\n                for(var p2 in obj[p1]){\n                    // eslint-disable-next-line no-unused-vars\n                    for(var p3 in obj[p1][p2]){\n                        return false;\n                    }\n                }\n            }\n            return true;\n        },\n        /**\n     * Returns true if object has a style property or has it ina specified line\n     * This function is used to detect if a text will use a particular property or not.\n     * @param {String} property to check for\n     * @param {Number} lineIndex to check the style on\n     * @return {Boolean}\n     */ styleHas: function(property, lineIndex) {\n            if (!this.styles || !property || property === \"\") {\n                return false;\n            }\n            if (typeof lineIndex !== \"undefined\" && !this.styles[lineIndex]) {\n                return false;\n            }\n            var obj = typeof lineIndex === \"undefined\" ? this.styles : {\n                0: this.styles[lineIndex]\n            };\n            // eslint-disable-next-line\n            for(var p1 in obj){\n                // eslint-disable-next-line\n                for(var p2 in obj[p1]){\n                    if (typeof obj[p1][p2][property] !== \"undefined\") {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        },\n        /**\n     * Check if characters in a text have a value for a property\n     * whose value matches the textbox's value for that property.  If so,\n     * the character-level property is deleted.  If the character\n     * has no other properties, then it is also deleted.  Finally,\n     * if the line containing that character has no other characters\n     * then it also is deleted.\n     *\n     * @param {string} property The property to compare between characters and text.\n     */ cleanStyle: function(property) {\n            if (!this.styles || !property || property === \"\") {\n                return false;\n            }\n            var obj = this.styles, stylesCount = 0, letterCount, stylePropertyValue, allStyleObjectPropertiesMatch = true, graphemeCount = 0, styleObject;\n            // eslint-disable-next-line\n            for(var p1 in obj){\n                letterCount = 0;\n                // eslint-disable-next-line\n                for(var p2 in obj[p1]){\n                    var styleObject = obj[p1][p2], stylePropertyHasBeenSet = styleObject.hasOwnProperty(property);\n                    stylesCount++;\n                    if (stylePropertyHasBeenSet) {\n                        if (!stylePropertyValue) {\n                            stylePropertyValue = styleObject[property];\n                        } else if (styleObject[property] !== stylePropertyValue) {\n                            allStyleObjectPropertiesMatch = false;\n                        }\n                        if (styleObject[property] === this[property]) {\n                            delete styleObject[property];\n                        }\n                    } else {\n                        allStyleObjectPropertiesMatch = false;\n                    }\n                    if (Object.keys(styleObject).length !== 0) {\n                        letterCount++;\n                    } else {\n                        delete obj[p1][p2];\n                    }\n                }\n                if (letterCount === 0) {\n                    delete obj[p1];\n                }\n            }\n            // if every grapheme has the same style set then\n            // delete those styles and set it on the parent\n            for(var i = 0; i < this._textLines.length; i++){\n                graphemeCount += this._textLines[i].length;\n            }\n            if (allStyleObjectPropertiesMatch && stylesCount === graphemeCount) {\n                this[property] = stylePropertyValue;\n                this.removeStyle(property);\n            }\n        },\n        /**\n     * Remove a style property or properties from all individual character styles\n     * in a text object.  Deletes the character style object if it contains no other style\n     * props.  Deletes a line style object if it contains no other character styles.\n     *\n     * @param {String} props The property to remove from character styles.\n     */ removeStyle: function(property) {\n            if (!this.styles || !property || property === \"\") {\n                return;\n            }\n            var obj = this.styles, line, lineNum, charNum;\n            for(lineNum in obj){\n                line = obj[lineNum];\n                for(charNum in line){\n                    delete line[charNum][property];\n                    if (Object.keys(line[charNum]).length === 0) {\n                        delete line[charNum];\n                    }\n                }\n                if (Object.keys(line).length === 0) {\n                    delete obj[lineNum];\n                }\n            }\n        },\n        /**\n     * @private\n     */ _extendStyles: function(index, styles) {\n            var loc = this.get2DCursorLocation(index);\n            if (!this._getLineStyle(loc.lineIndex)) {\n                this._setLineStyle(loc.lineIndex);\n            }\n            if (!this._getStyleDeclaration(loc.lineIndex, loc.charIndex)) {\n                this._setStyleDeclaration(loc.lineIndex, loc.charIndex, {});\n            }\n            fabric.util.object.extend(this._getStyleDeclaration(loc.lineIndex, loc.charIndex), styles);\n        },\n        /**\n     * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start)\n     * @param {Number} [selectionStart] Optional index. When not given, current selectionStart is used.\n     * @param {Boolean} [skipWrapping] consider the location for unwrapped lines. useful to manage styles.\n     */ get2DCursorLocation: function(selectionStart, skipWrapping) {\n            if (typeof selectionStart === \"undefined\") {\n                selectionStart = this.selectionStart;\n            }\n            var lines = skipWrapping ? this._unwrappedTextLines : this._textLines, len = lines.length;\n            for(var i = 0; i < len; i++){\n                if (selectionStart <= lines[i].length) {\n                    return {\n                        lineIndex: i,\n                        charIndex: selectionStart\n                    };\n                }\n                selectionStart -= lines[i].length + this.missingNewlineOffset(i, skipWrapping);\n            }\n            return {\n                lineIndex: i - 1,\n                charIndex: lines[i - 1].length < selectionStart ? lines[i - 1].length : selectionStart\n            };\n        },\n        /**\n     * Gets style of a current selection/cursor (at the start position)\n     * if startIndex or endIndex are not provided, selectionStart or selectionEnd will be used.\n     * @param {Number} [startIndex] Start index to get styles at\n     * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1\n     * @param {Boolean} [complete] get full style or not\n     * @return {Array} styles an array with one, zero or more Style objects\n     */ getSelectionStyles: function(startIndex, endIndex, complete) {\n            if (typeof startIndex === \"undefined\") {\n                startIndex = this.selectionStart || 0;\n            }\n            if (typeof endIndex === \"undefined\") {\n                endIndex = this.selectionEnd || startIndex;\n            }\n            var styles = [];\n            for(var i = startIndex; i < endIndex; i++){\n                styles.push(this.getStyleAtPosition(i, complete));\n            }\n            return styles;\n        },\n        /**\n     * Gets style of a current selection/cursor position\n     * @param {Number} position  to get styles at\n     * @param {Boolean} [complete] full style if true\n     * @return {Object} style Style object at a specified index\n     * @private\n     */ getStyleAtPosition: function(position, complete) {\n            var loc = this.get2DCursorLocation(position), style = complete ? this.getCompleteStyleDeclaration(loc.lineIndex, loc.charIndex) : this._getStyleDeclaration(loc.lineIndex, loc.charIndex);\n            return style || {};\n        },\n        /**\n     * Sets style of a current selection, if no selection exist, do not set anything.\n     * @param {Object} [styles] Styles object\n     * @param {Number} [startIndex] Start index to get styles at\n     * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1\n     * @return {fabric.IText} thisArg\n     * @chainable\n     */ setSelectionStyles: function(styles, startIndex, endIndex) {\n            if (typeof startIndex === \"undefined\") {\n                startIndex = this.selectionStart || 0;\n            }\n            if (typeof endIndex === \"undefined\") {\n                endIndex = this.selectionEnd || startIndex;\n            }\n            for(var i = startIndex; i < endIndex; i++){\n                this._extendStyles(i, styles);\n            }\n            /* not included in _extendStyles to avoid clearing cache more than once */ this._forceClearCache = true;\n            return this;\n        },\n        /**\n     * get the reference, not a clone, of the style object for a given character\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @return {Object} style object\n     */ _getStyleDeclaration: function(lineIndex, charIndex) {\n            var lineStyle = this.styles && this.styles[lineIndex];\n            if (!lineStyle) {\n                return null;\n            }\n            return lineStyle[charIndex];\n        },\n        /**\n     * return a new object that contains all the style property for a character\n     * the object returned is newly created\n     * @param {Number} lineIndex of the line where the character is\n     * @param {Number} charIndex position of the character on the line\n     * @return {Object} style object\n     */ getCompleteStyleDeclaration: function(lineIndex, charIndex) {\n            var style = this._getStyleDeclaration(lineIndex, charIndex) || {}, styleObject = {}, prop;\n            for(var i = 0; i < this._styleProperties.length; i++){\n                prop = this._styleProperties[i];\n                styleObject[prop] = typeof style[prop] === \"undefined\" ? this[prop] : style[prop];\n            }\n            return styleObject;\n        },\n        /**\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @param {Object} style\n     * @private\n     */ _setStyleDeclaration: function(lineIndex, charIndex, style) {\n            this.styles[lineIndex][charIndex] = style;\n        },\n        /**\n     *\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @private\n     */ _deleteStyleDeclaration: function(lineIndex, charIndex) {\n            delete this.styles[lineIndex][charIndex];\n        },\n        /**\n     * @param {Number} lineIndex\n     * @return {Boolean} if the line exists or not\n     * @private\n     */ _getLineStyle: function(lineIndex) {\n            return !!this.styles[lineIndex];\n        },\n        /**\n     * Set the line style to an empty object so that is initialized\n     * @param {Number} lineIndex\n     * @private\n     */ _setLineStyle: function(lineIndex) {\n            this.styles[lineIndex] = {};\n        },\n        /**\n     * @param {Number} lineIndex\n     * @private\n     */ _deleteLineStyle: function(lineIndex) {\n            delete this.styles[lineIndex];\n        }\n    });\n})();\n(function() {\n    function parseDecoration(object) {\n        if (object.textDecoration) {\n            object.textDecoration.indexOf(\"underline\") > -1 && (object.underline = true);\n            object.textDecoration.indexOf(\"line-through\") > -1 && (object.linethrough = true);\n            object.textDecoration.indexOf(\"overline\") > -1 && (object.overline = true);\n            delete object.textDecoration;\n        }\n    }\n    /**\n   * IText class (introduced in <b>v1.4</b>) Events are also fired with \"text:\"\n   * prefix when observing canvas.\n   * @class fabric.IText\n   * @extends fabric.Text\n   * @mixes fabric.Observable\n   *\n   * @fires changed\n   * @fires selection:changed\n   * @fires editing:entered\n   * @fires editing:exited\n   *\n   * @return {fabric.IText} thisArg\n   * @see {@link fabric.IText#initialize} for constructor definition\n   *\n   * <p>Supported key combinations:</p>\n   * <pre>\n   *   Move cursor:                    left, right, up, down\n   *   Select character:               shift + left, shift + right\n   *   Select text vertically:         shift + up, shift + down\n   *   Move cursor by word:            alt + left, alt + right\n   *   Select words:                   shift + alt + left, shift + alt + right\n   *   Move cursor to line start/end:  cmd + left, cmd + right or home, end\n   *   Select till start/end of line:  cmd + shift + left, cmd + shift + right or shift + home, shift + end\n   *   Jump to start/end of text:      cmd + up, cmd + down\n   *   Select till start/end of text:  cmd + shift + up, cmd + shift + down or shift + pgUp, shift + pgDown\n   *   Delete character:               backspace\n   *   Delete word:                    alt + backspace\n   *   Delete line:                    cmd + backspace\n   *   Forward delete:                 delete\n   *   Copy text:                      ctrl/cmd + c\n   *   Paste text:                     ctrl/cmd + v\n   *   Cut text:                       ctrl/cmd + x\n   *   Select entire text:             ctrl/cmd + a\n   *   Quit editing                    tab or esc\n   * </pre>\n   *\n   * <p>Supported mouse/touch combination</p>\n   * <pre>\n   *   Position cursor:                click/touch\n   *   Create selection:               click/touch & drag\n   *   Create selection:               click & shift + click\n   *   Select word:                    double click\n   *   Select line:                    triple click\n   * </pre>\n   */ fabric.IText = fabric.util.createClass(fabric.Text, fabric.Observable, /** @lends fabric.IText.prototype */ {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"i-text\",\n        /**\n     * Index where text selection starts (or where cursor is when there is no selection)\n     * @type Number\n     * @default\n     */ selectionStart: 0,\n        /**\n     * Index where text selection ends\n     * @type Number\n     * @default\n     */ selectionEnd: 0,\n        /**\n     * Color of text selection\n     * @type String\n     * @default\n     */ selectionColor: \"rgba(17,119,255,0.3)\",\n        /**\n     * Indicates whether text is in editing mode\n     * @type Boolean\n     * @default\n     */ isEditing: false,\n        /**\n     * Indicates whether a text can be edited\n     * @type Boolean\n     * @default\n     */ editable: true,\n        /**\n     * Border color of text object while it's in editing mode\n     * @type String\n     * @default\n     */ editingBorderColor: \"rgba(102,153,255,0.25)\",\n        /**\n     * Width of cursor (in px)\n     * @type Number\n     * @default\n     */ cursorWidth: 2,\n        /**\n     * Color of text cursor color in editing mode.\n     * if not set (default) will take color from the text.\n     * if set to a color value that fabric can understand, it will\n     * be used instead of the color of the text at the current position.\n     * @type String\n     * @default\n     */ cursorColor: \"\",\n        /**\n     * Delay between cursor blink (in ms)\n     * @type Number\n     * @default\n     */ cursorDelay: 1000,\n        /**\n     * Duration of cursor fadein (in ms)\n     * @type Number\n     * @default\n     */ cursorDuration: 600,\n        /**\n     * Indicates whether internal text char widths can be cached\n     * @type Boolean\n     * @default\n     */ caching: true,\n        /**\n     * DOM container to append the hiddenTextarea.\n     * An alternative to attaching to the document.body.\n     * Useful to reduce laggish redraw of the full document.body tree and\n     * also with modals event capturing that won't let the textarea take focus.\n     * @type HTMLElement\n     * @default\n     */ hiddenTextareaContainer: null,\n        /**\n     * @private\n     */ _reSpace: /\\s|\\n/,\n        /**\n     * @private\n     */ _currentCursorOpacity: 0,\n        /**\n     * @private\n     */ _selectionDirection: null,\n        /**\n     * @private\n     */ _abortCursorAnimation: false,\n        /**\n     * @private\n     */ __widthOfSpace: [],\n        /**\n     * Helps determining when the text is in composition, so that the cursor\n     * rendering is altered.\n     */ inCompositionMode: false,\n        /**\n     * Constructor\n     * @param {String} text Text string\n     * @param {Object} [options] Options object\n     * @return {fabric.IText} thisArg\n     */ initialize: function(text, options) {\n            this.callSuper(\"initialize\", text, options);\n            this.initBehavior();\n        },\n        /**\n     * Sets selection start (left boundary of a selection)\n     * @param {Number} index Index to set selection start to\n     */ setSelectionStart: function(index) {\n            index = Math.max(index, 0);\n            this._updateAndFire(\"selectionStart\", index);\n        },\n        /**\n     * Sets selection end (right boundary of a selection)\n     * @param {Number} index Index to set selection end to\n     */ setSelectionEnd: function(index) {\n            index = Math.min(index, this.text.length);\n            this._updateAndFire(\"selectionEnd\", index);\n        },\n        /**\n     * @private\n     * @param {String} property 'selectionStart' or 'selectionEnd'\n     * @param {Number} index new position of property\n     */ _updateAndFire: function(property, index) {\n            if (this[property] !== index) {\n                this._fireSelectionChanged();\n                this[property] = index;\n            }\n            this._updateTextarea();\n        },\n        /**\n     * Fires the even of selection changed\n     * @private\n     */ _fireSelectionChanged: function() {\n            this.fire(\"selection:changed\");\n            this.canvas && this.canvas.fire(\"text:selection:changed\", {\n                target: this\n            });\n        },\n        /**\n     * Initialize text dimensions. Render all text on given context\n     * or on a offscreen canvas to get the text width with measureText.\n     * Updates this.width and this.height with the proper values.\n     * Does not return dimensions.\n     * @private\n     */ initDimensions: function() {\n            this.isEditing && this.initDelayedCursor();\n            this.clearContextTop();\n            this.callSuper(\"initDimensions\");\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ render: function(ctx) {\n            this.clearContextTop();\n            this.callSuper(\"render\", ctx);\n            // clear the cursorOffsetCache, so we ensure to calculate once per renderCursor\n            // the correct position but not at every cursor animation.\n            this.cursorOffsetCache = {};\n            this.renderCursorOrSelection();\n        },\n        /**\n     * @private\n     * @param {CanvasRenderingContext2D} ctx Context to render on\n     */ _render: function(ctx) {\n            this.callSuper(\"_render\", ctx);\n        },\n        /**\n     * Prepare and clean the contextTop\n     */ clearContextTop: function(skipRestore) {\n            if (!this.isEditing || !this.canvas || !this.canvas.contextTop) {\n                return;\n            }\n            var ctx = this.canvas.contextTop, v = this.canvas.viewportTransform;\n            ctx.save();\n            ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n            this.transform(ctx);\n            this._clearTextArea(ctx);\n            skipRestore || ctx.restore();\n        },\n        /**\n     * Renders cursor or selection (depending on what exists)\n     * it does on the contextTop. If contextTop is not available, do nothing.\n     */ renderCursorOrSelection: function() {\n            if (!this.isEditing || !this.canvas || !this.canvas.contextTop) {\n                return;\n            }\n            var boundaries = this._getCursorBoundaries(), ctx = this.canvas.contextTop;\n            this.clearContextTop(true);\n            if (this.selectionStart === this.selectionEnd) {\n                this.renderCursor(boundaries, ctx);\n            } else {\n                this.renderSelection(boundaries, ctx);\n            }\n            ctx.restore();\n        },\n        _clearTextArea: function(ctx) {\n            // we add 4 pixel, to be sure to do not leave any pixel out\n            var width = this.width + 4, height = this.height + 4;\n            ctx.clearRect(-width / 2, -height / 2, width, height);\n        },\n        /**\n     * Returns cursor boundaries (left, top, leftOffset, topOffset)\n     * @private\n     * @param {Array} chars Array of characters\n     * @param {String} typeOfBoundaries\n     */ _getCursorBoundaries: function(position) {\n            // left/top are left/top of entire text box\n            // leftOffset/topOffset are offset from that left/top point of a text box\n            if (typeof position === \"undefined\") {\n                position = this.selectionStart;\n            }\n            var left = this._getLeftOffset(), top = this._getTopOffset(), offsets = this._getCursorBoundariesOffsets(position);\n            return {\n                left: left,\n                top: top,\n                leftOffset: offsets.left,\n                topOffset: offsets.top\n            };\n        },\n        /**\n     * @private\n     */ _getCursorBoundariesOffsets: function(position) {\n            if (this.cursorOffsetCache && \"top\" in this.cursorOffsetCache) {\n                return this.cursorOffsetCache;\n            }\n            var lineLeftOffset, lineIndex, charIndex, topOffset = 0, leftOffset = 0, boundaries, cursorPosition = this.get2DCursorLocation(position);\n            charIndex = cursorPosition.charIndex;\n            lineIndex = cursorPosition.lineIndex;\n            for(var i = 0; i < lineIndex; i++){\n                topOffset += this.getHeightOfLine(i);\n            }\n            lineLeftOffset = this._getLineLeftOffset(lineIndex);\n            var bound = this.__charBounds[lineIndex][charIndex];\n            bound && (leftOffset = bound.left);\n            if (this.charSpacing !== 0 && charIndex === this._textLines[lineIndex].length) {\n                leftOffset -= this._getWidthOfCharSpacing();\n            }\n            boundaries = {\n                top: topOffset,\n                left: lineLeftOffset + (leftOffset > 0 ? leftOffset : 0)\n            };\n            if (this.direction === \"rtl\") {\n                boundaries.left *= -1;\n            }\n            this.cursorOffsetCache = boundaries;\n            return this.cursorOffsetCache;\n        },\n        /**\n     * Renders cursor\n     * @param {Object} boundaries\n     * @param {CanvasRenderingContext2D} ctx transformed context to draw on\n     */ renderCursor: function(boundaries, ctx) {\n            var cursorLocation = this.get2DCursorLocation(), lineIndex = cursorLocation.lineIndex, charIndex = cursorLocation.charIndex > 0 ? cursorLocation.charIndex - 1 : 0, charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, \"fontSize\"), multiplier = this.scaleX * this.canvas.getZoom(), cursorWidth = this.cursorWidth / multiplier, topOffset = boundaries.topOffset, dy = this.getValueOfPropertyAt(lineIndex, charIndex, \"deltaY\");\n            topOffset += (1 - this._fontSizeFraction) * this.getHeightOfLine(lineIndex) / this.lineHeight - charHeight * (1 - this._fontSizeFraction);\n            if (this.inCompositionMode) {\n                this.renderSelection(boundaries, ctx);\n            }\n            ctx.fillStyle = this.cursorColor || this.getValueOfPropertyAt(lineIndex, charIndex, \"fill\");\n            ctx.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity;\n            ctx.fillRect(boundaries.left + boundaries.leftOffset - cursorWidth / 2, topOffset + boundaries.top + dy, cursorWidth, charHeight);\n        },\n        /**\n     * Renders text selection\n     * @param {Object} boundaries Object with left/top/leftOffset/topOffset\n     * @param {CanvasRenderingContext2D} ctx transformed context to draw on\n     */ renderSelection: function(boundaries, ctx) {\n            var selectionStart = this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart, selectionEnd = this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd, isJustify = this.textAlign.indexOf(\"justify\") !== -1, start = this.get2DCursorLocation(selectionStart), end = this.get2DCursorLocation(selectionEnd), startLine = start.lineIndex, endLine = end.lineIndex, startChar = start.charIndex < 0 ? 0 : start.charIndex, endChar = end.charIndex < 0 ? 0 : end.charIndex;\n            for(var i = startLine; i <= endLine; i++){\n                var lineOffset = this._getLineLeftOffset(i) || 0, lineHeight = this.getHeightOfLine(i), realLineHeight = 0, boxStart = 0, boxEnd = 0;\n                if (i === startLine) {\n                    boxStart = this.__charBounds[startLine][startChar].left;\n                }\n                if (i >= startLine && i < endLine) {\n                    boxEnd = isJustify && !this.isEndOfWrapping(i) ? this.width : this.getLineWidth(i) || 5; // WTF is this 5?\n                } else if (i === endLine) {\n                    if (endChar === 0) {\n                        boxEnd = this.__charBounds[endLine][endChar].left;\n                    } else {\n                        var charSpacing = this._getWidthOfCharSpacing();\n                        boxEnd = this.__charBounds[endLine][endChar - 1].left + this.__charBounds[endLine][endChar - 1].width - charSpacing;\n                    }\n                }\n                realLineHeight = lineHeight;\n                if (this.lineHeight < 1 || i === endLine && this.lineHeight > 1) {\n                    lineHeight /= this.lineHeight;\n                }\n                var drawStart = boundaries.left + lineOffset + boxStart, drawWidth = boxEnd - boxStart, drawHeight = lineHeight, extraTop = 0;\n                if (this.inCompositionMode) {\n                    ctx.fillStyle = this.compositionColor || \"black\";\n                    drawHeight = 1;\n                    extraTop = lineHeight;\n                } else {\n                    ctx.fillStyle = this.selectionColor;\n                }\n                if (this.direction === \"rtl\") {\n                    drawStart = this.width - drawStart - drawWidth;\n                }\n                ctx.fillRect(drawStart, boundaries.top + boundaries.topOffset + extraTop, drawWidth, drawHeight);\n                boundaries.topOffset += realLineHeight;\n            }\n        },\n        /**\n     * High level function to know the height of the cursor.\n     * the currentChar is the one that precedes the cursor\n     * Returns fontSize of char at the current cursor\n     * Unused from the library, is for the end user\n     * @return {Number} Character font size\n     */ getCurrentCharFontSize: function() {\n            var cp = this._getCurrentCharIndex();\n            return this.getValueOfPropertyAt(cp.l, cp.c, \"fontSize\");\n        },\n        /**\n     * High level function to know the color of the cursor.\n     * the currentChar is the one that precedes the cursor\n     * Returns color (fill) of char at the current cursor\n     * if the text object has a pattern or gradient for filler, it will return that.\n     * Unused by the library, is for the end user\n     * @return {String | fabric.Gradient | fabric.Pattern} Character color (fill)\n     */ getCurrentCharColor: function() {\n            var cp = this._getCurrentCharIndex();\n            return this.getValueOfPropertyAt(cp.l, cp.c, \"fill\");\n        },\n        /**\n     * Returns the cursor position for the getCurrent.. functions\n     * @private\n     */ _getCurrentCharIndex: function() {\n            var cursorPosition = this.get2DCursorLocation(this.selectionStart, true), charIndex = cursorPosition.charIndex > 0 ? cursorPosition.charIndex - 1 : 0;\n            return {\n                l: cursorPosition.lineIndex,\n                c: charIndex\n            };\n        }\n    });\n    /**\n   * Returns fabric.IText instance from an object representation\n   * @static\n   * @memberOf fabric.IText\n   * @param {Object} object Object to create an instance from\n   * @param {function} [callback] invoked with new instance as argument\n   */ fabric.IText.fromObject = function(object, callback) {\n        var styles = fabric.util.stylesFromArray(object.styles, object.text);\n        //copy object to prevent mutation\n        var objCopy = Object.assign({}, object, {\n            styles: styles\n        });\n        delete objCopy.path;\n        parseDecoration(objCopy);\n        if (objCopy.styles) {\n            for(var i in objCopy.styles){\n                for(var j in objCopy.styles[i]){\n                    parseDecoration(objCopy.styles[i][j]);\n                }\n            }\n        }\n        fabric.Object._fromObject(\"IText\", objCopy, function(textInstance) {\n            if (object.path) {\n                fabric.Object._fromObject(\"Path\", object.path, function(pathInstance) {\n                    textInstance.set(\"path\", pathInstance);\n                    callback(textInstance);\n                }, \"path\");\n            } else {\n                callback(textInstance);\n            }\n        }, \"text\");\n    };\n})();\n(function() {\n    var clone = fabric.util.object.clone;\n    fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {\n        /**\n     * Initializes all the interactive behavior of IText\n     */ initBehavior: function() {\n            this.initAddedHandler();\n            this.initRemovedHandler();\n            this.initCursorSelectionHandlers();\n            this.initDoubleClickSimulation();\n            this.mouseMoveHandler = this.mouseMoveHandler.bind(this);\n        },\n        onDeselect: function() {\n            this.isEditing && this.exitEditing();\n            this.selected = false;\n        },\n        /**\n     * Initializes \"added\" event handler\n     */ initAddedHandler: function() {\n            var _this = this;\n            this.on(\"added\", function() {\n                var canvas = _this.canvas;\n                if (canvas) {\n                    if (!canvas._hasITextHandlers) {\n                        canvas._hasITextHandlers = true;\n                        _this._initCanvasHandlers(canvas);\n                    }\n                    canvas._iTextInstances = canvas._iTextInstances || [];\n                    canvas._iTextInstances.push(_this);\n                }\n            });\n        },\n        initRemovedHandler: function() {\n            var _this = this;\n            this.on(\"removed\", function() {\n                var canvas = _this.canvas;\n                if (canvas) {\n                    canvas._iTextInstances = canvas._iTextInstances || [];\n                    fabric.util.removeFromArray(canvas._iTextInstances, _this);\n                    if (canvas._iTextInstances.length === 0) {\n                        canvas._hasITextHandlers = false;\n                        _this._removeCanvasHandlers(canvas);\n                    }\n                }\n            });\n        },\n        /**\n     * register canvas event to manage exiting on other instances\n     * @private\n     */ _initCanvasHandlers: function(canvas) {\n            canvas._mouseUpITextHandler = function() {\n                if (canvas._iTextInstances) {\n                    canvas._iTextInstances.forEach(function(obj) {\n                        obj.__isMousedown = false;\n                    });\n                }\n            };\n            canvas.on(\"mouse:up\", canvas._mouseUpITextHandler);\n        },\n        /**\n     * remove canvas event to manage exiting on other instances\n     * @private\n     */ _removeCanvasHandlers: function(canvas) {\n            canvas.off(\"mouse:up\", canvas._mouseUpITextHandler);\n        },\n        /**\n     * @private\n     */ _tick: function() {\n            this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, \"_onTickComplete\");\n        },\n        /**\n     * @private\n     */ _animateCursor: function(obj, targetOpacity, duration, completeMethod) {\n            var tickState;\n            tickState = {\n                isAborted: false,\n                abort: function() {\n                    this.isAborted = true;\n                }\n            };\n            obj.animate(\"_currentCursorOpacity\", targetOpacity, {\n                duration: duration,\n                onComplete: function() {\n                    if (!tickState.isAborted) {\n                        obj[completeMethod]();\n                    }\n                },\n                onChange: function() {\n                    // we do not want to animate a selection, only cursor\n                    if (obj.canvas && obj.selectionStart === obj.selectionEnd) {\n                        obj.renderCursorOrSelection();\n                    }\n                },\n                abort: function() {\n                    return tickState.isAborted;\n                }\n            });\n            return tickState;\n        },\n        /**\n     * @private\n     */ _onTickComplete: function() {\n            var _this = this;\n            if (this._cursorTimeout1) {\n                clearTimeout(this._cursorTimeout1);\n            }\n            this._cursorTimeout1 = setTimeout(function() {\n                _this._currentTickCompleteState = _this._animateCursor(_this, 0, this.cursorDuration / 2, \"_tick\");\n            }, 100);\n        },\n        /**\n     * Initializes delayed cursor\n     */ initDelayedCursor: function(restart) {\n            var _this = this, delay = restart ? 0 : this.cursorDelay;\n            this.abortCursorAnimation();\n            this._currentCursorOpacity = 1;\n            this._cursorTimeout2 = setTimeout(function() {\n                _this._tick();\n            }, delay);\n        },\n        /**\n     * Aborts cursor animation and clears all timeouts\n     */ abortCursorAnimation: function() {\n            var shouldClear = this._currentTickState || this._currentTickCompleteState, canvas = this.canvas;\n            this._currentTickState && this._currentTickState.abort();\n            this._currentTickCompleteState && this._currentTickCompleteState.abort();\n            clearTimeout(this._cursorTimeout1);\n            clearTimeout(this._cursorTimeout2);\n            this._currentCursorOpacity = 0;\n            // to clear just itext area we need to transform the context\n            // it may not be worth it\n            if (shouldClear && canvas) {\n                canvas.clearContext(canvas.contextTop || canvas.contextContainer);\n            }\n        },\n        /**\n     * Selects entire text\n     * @return {fabric.IText} thisArg\n     * @chainable\n     */ selectAll: function() {\n            this.selectionStart = 0;\n            this.selectionEnd = this._text.length;\n            this._fireSelectionChanged();\n            this._updateTextarea();\n            return this;\n        },\n        /**\n     * Returns selected text\n     * @return {String}\n     */ getSelectedText: function() {\n            return this._text.slice(this.selectionStart, this.selectionEnd).join(\"\");\n        },\n        /**\n     * Find new selection index representing start of current word according to current selection index\n     * @param {Number} startFrom Current selection index\n     * @return {Number} New selection index\n     */ findWordBoundaryLeft: function(startFrom) {\n            var offset = 0, index = startFrom - 1;\n            // remove space before cursor first\n            if (this._reSpace.test(this._text[index])) {\n                while(this._reSpace.test(this._text[index])){\n                    offset++;\n                    index--;\n                }\n            }\n            while(/\\S/.test(this._text[index]) && index > -1){\n                offset++;\n                index--;\n            }\n            return startFrom - offset;\n        },\n        /**\n     * Find new selection index representing end of current word according to current selection index\n     * @param {Number} startFrom Current selection index\n     * @return {Number} New selection index\n     */ findWordBoundaryRight: function(startFrom) {\n            var offset = 0, index = startFrom;\n            // remove space after cursor first\n            if (this._reSpace.test(this._text[index])) {\n                while(this._reSpace.test(this._text[index])){\n                    offset++;\n                    index++;\n                }\n            }\n            while(/\\S/.test(this._text[index]) && index < this._text.length){\n                offset++;\n                index++;\n            }\n            return startFrom + offset;\n        },\n        /**\n     * Find new selection index representing start of current line according to current selection index\n     * @param {Number} startFrom Current selection index\n     * @return {Number} New selection index\n     */ findLineBoundaryLeft: function(startFrom) {\n            var offset = 0, index = startFrom - 1;\n            while(!/\\n/.test(this._text[index]) && index > -1){\n                offset++;\n                index--;\n            }\n            return startFrom - offset;\n        },\n        /**\n     * Find new selection index representing end of current line according to current selection index\n     * @param {Number} startFrom Current selection index\n     * @return {Number} New selection index\n     */ findLineBoundaryRight: function(startFrom) {\n            var offset = 0, index = startFrom;\n            while(!/\\n/.test(this._text[index]) && index < this._text.length){\n                offset++;\n                index++;\n            }\n            return startFrom + offset;\n        },\n        /**\n     * Finds index corresponding to beginning or end of a word\n     * @param {Number} selectionStart Index of a character\n     * @param {Number} direction 1 or -1\n     * @return {Number} Index of the beginning or end of a word\n     */ searchWordBoundary: function(selectionStart, direction) {\n            var text = this._text, index = this._reSpace.test(text[selectionStart]) ? selectionStart - 1 : selectionStart, _char = text[index], // wrong\n            reNonWord = fabric.reNonWord;\n            while(!reNonWord.test(_char) && index > 0 && index < text.length){\n                index += direction;\n                _char = text[index];\n            }\n            if (reNonWord.test(_char)) {\n                index += direction === 1 ? 0 : 1;\n            }\n            return index;\n        },\n        /**\n     * Selects a word based on the index\n     * @param {Number} selectionStart Index of a character\n     */ selectWord: function(selectionStart) {\n            selectionStart = selectionStart || this.selectionStart;\n            var newSelectionStart = this.searchWordBoundary(selectionStart, -1), /* search backwards */ newSelectionEnd = this.searchWordBoundary(selectionStart, 1); /* search forward */ \n            this.selectionStart = newSelectionStart;\n            this.selectionEnd = newSelectionEnd;\n            this._fireSelectionChanged();\n            this._updateTextarea();\n            this.renderCursorOrSelection();\n        },\n        /**\n     * Selects a line based on the index\n     * @param {Number} selectionStart Index of a character\n     * @return {fabric.IText} thisArg\n     * @chainable\n     */ selectLine: function(selectionStart) {\n            selectionStart = selectionStart || this.selectionStart;\n            var newSelectionStart = this.findLineBoundaryLeft(selectionStart), newSelectionEnd = this.findLineBoundaryRight(selectionStart);\n            this.selectionStart = newSelectionStart;\n            this.selectionEnd = newSelectionEnd;\n            this._fireSelectionChanged();\n            this._updateTextarea();\n            return this;\n        },\n        /**\n     * Enters editing state\n     * @return {fabric.IText} thisArg\n     * @chainable\n     */ enterEditing: function(e) {\n            if (this.isEditing || !this.editable) {\n                return;\n            }\n            if (this.canvas) {\n                this.canvas.calcOffset();\n                this.exitEditingOnOthers(this.canvas);\n            }\n            this.isEditing = true;\n            this.initHiddenTextarea(e);\n            this.hiddenTextarea.focus();\n            this.hiddenTextarea.value = this.text;\n            this._updateTextarea();\n            this._saveEditingProps();\n            this._setEditingProps();\n            this._textBeforeEdit = this.text;\n            this._tick();\n            this.fire(\"editing:entered\");\n            this._fireSelectionChanged();\n            if (!this.canvas) {\n                return this;\n            }\n            this.canvas.fire(\"text:editing:entered\", {\n                target: this\n            });\n            this.initMouseMoveHandler();\n            this.canvas.requestRenderAll();\n            return this;\n        },\n        exitEditingOnOthers: function(canvas) {\n            if (canvas._iTextInstances) {\n                canvas._iTextInstances.forEach(function(obj) {\n                    obj.selected = false;\n                    if (obj.isEditing) {\n                        obj.exitEditing();\n                    }\n                });\n            }\n        },\n        /**\n     * Initializes \"mousemove\" event handler\n     */ initMouseMoveHandler: function() {\n            this.canvas.on(\"mouse:move\", this.mouseMoveHandler);\n        },\n        /**\n     * @private\n     */ mouseMoveHandler: function(options) {\n            if (!this.__isMousedown || !this.isEditing) {\n                return;\n            }\n            // regain focus\n            document.activeElement !== this.hiddenTextarea && this.hiddenTextarea.focus();\n            var newSelectionStart = this.getSelectionStartFromPointer(options.e), currentStart = this.selectionStart, currentEnd = this.selectionEnd;\n            if ((newSelectionStart !== this.__selectionStartOnMouseDown || currentStart === currentEnd) && (currentStart === newSelectionStart || currentEnd === newSelectionStart)) {\n                return;\n            }\n            if (newSelectionStart > this.__selectionStartOnMouseDown) {\n                this.selectionStart = this.__selectionStartOnMouseDown;\n                this.selectionEnd = newSelectionStart;\n            } else {\n                this.selectionStart = newSelectionStart;\n                this.selectionEnd = this.__selectionStartOnMouseDown;\n            }\n            if (this.selectionStart !== currentStart || this.selectionEnd !== currentEnd) {\n                this.restartCursorIfNeeded();\n                this._fireSelectionChanged();\n                this._updateTextarea();\n                this.renderCursorOrSelection();\n            }\n        },\n        /**\n     * @private\n     */ _setEditingProps: function() {\n            this.hoverCursor = \"text\";\n            if (this.canvas) {\n                this.canvas.defaultCursor = this.canvas.moveCursor = \"text\";\n            }\n            this.borderColor = this.editingBorderColor;\n            this.hasControls = this.selectable = false;\n            this.lockMovementX = this.lockMovementY = true;\n        },\n        /**\n     * convert from textarea to grapheme indexes\n     */ fromStringToGraphemeSelection: function(start, end, text) {\n            var smallerTextStart = text.slice(0, start), graphemeStart = fabric.util.string.graphemeSplit(smallerTextStart).length;\n            if (start === end) {\n                return {\n                    selectionStart: graphemeStart,\n                    selectionEnd: graphemeStart\n                };\n            }\n            var smallerTextEnd = text.slice(start, end), graphemeEnd = fabric.util.string.graphemeSplit(smallerTextEnd).length;\n            return {\n                selectionStart: graphemeStart,\n                selectionEnd: graphemeStart + graphemeEnd\n            };\n        },\n        /**\n     * convert from fabric to textarea values\n     */ fromGraphemeToStringSelection: function(start, end, _text) {\n            var smallerTextStart = _text.slice(0, start), graphemeStart = smallerTextStart.join(\"\").length;\n            if (start === end) {\n                return {\n                    selectionStart: graphemeStart,\n                    selectionEnd: graphemeStart\n                };\n            }\n            var smallerTextEnd = _text.slice(start, end), graphemeEnd = smallerTextEnd.join(\"\").length;\n            return {\n                selectionStart: graphemeStart,\n                selectionEnd: graphemeStart + graphemeEnd\n            };\n        },\n        /**\n     * @private\n     */ _updateTextarea: function() {\n            this.cursorOffsetCache = {};\n            if (!this.hiddenTextarea) {\n                return;\n            }\n            if (!this.inCompositionMode) {\n                var newSelection = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);\n                this.hiddenTextarea.selectionStart = newSelection.selectionStart;\n                this.hiddenTextarea.selectionEnd = newSelection.selectionEnd;\n            }\n            this.updateTextareaPosition();\n        },\n        /**\n     * @private\n     */ updateFromTextArea: function() {\n            if (!this.hiddenTextarea) {\n                return;\n            }\n            this.cursorOffsetCache = {};\n            this.text = this.hiddenTextarea.value;\n            if (this._shouldClearDimensionCache()) {\n                this.initDimensions();\n                this.setCoords();\n            }\n            var newSelection = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value);\n            this.selectionEnd = this.selectionStart = newSelection.selectionEnd;\n            if (!this.inCompositionMode) {\n                this.selectionStart = newSelection.selectionStart;\n            }\n            this.updateTextareaPosition();\n        },\n        /**\n     * @private\n     */ updateTextareaPosition: function() {\n            if (this.selectionStart === this.selectionEnd) {\n                var style = this._calcTextareaPosition();\n                this.hiddenTextarea.style.left = style.left;\n                this.hiddenTextarea.style.top = style.top;\n            }\n        },\n        /**\n     * @private\n     * @return {Object} style contains style for hiddenTextarea\n     */ _calcTextareaPosition: function() {\n            if (!this.canvas) {\n                return {\n                    x: 1,\n                    y: 1\n                };\n            }\n            var desiredPosition = this.inCompositionMode ? this.compositionStart : this.selectionStart, boundaries = this._getCursorBoundaries(desiredPosition), cursorLocation = this.get2DCursorLocation(desiredPosition), lineIndex = cursorLocation.lineIndex, charIndex = cursorLocation.charIndex, charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, \"fontSize\") * this.lineHeight, leftOffset = boundaries.leftOffset, m = this.calcTransformMatrix(), p = {\n                x: boundaries.left + leftOffset,\n                y: boundaries.top + boundaries.topOffset + charHeight\n            }, retinaScaling = this.canvas.getRetinaScaling(), upperCanvas = this.canvas.upperCanvasEl, upperCanvasWidth = upperCanvas.width / retinaScaling, upperCanvasHeight = upperCanvas.height / retinaScaling, maxWidth = upperCanvasWidth - charHeight, maxHeight = upperCanvasHeight - charHeight, scaleX = upperCanvas.clientWidth / upperCanvasWidth, scaleY = upperCanvas.clientHeight / upperCanvasHeight;\n            p = fabric.util.transformPoint(p, m);\n            p = fabric.util.transformPoint(p, this.canvas.viewportTransform);\n            p.x *= scaleX;\n            p.y *= scaleY;\n            if (p.x < 0) {\n                p.x = 0;\n            }\n            if (p.x > maxWidth) {\n                p.x = maxWidth;\n            }\n            if (p.y < 0) {\n                p.y = 0;\n            }\n            if (p.y > maxHeight) {\n                p.y = maxHeight;\n            }\n            // add canvas offset on document\n            p.x += this.canvas._offset.left;\n            p.y += this.canvas._offset.top;\n            return {\n                left: p.x + \"px\",\n                top: p.y + \"px\",\n                fontSize: charHeight + \"px\",\n                charHeight: charHeight\n            };\n        },\n        /**\n     * @private\n     */ _saveEditingProps: function() {\n            this._savedProps = {\n                hasControls: this.hasControls,\n                borderColor: this.borderColor,\n                lockMovementX: this.lockMovementX,\n                lockMovementY: this.lockMovementY,\n                hoverCursor: this.hoverCursor,\n                selectable: this.selectable,\n                defaultCursor: this.canvas && this.canvas.defaultCursor,\n                moveCursor: this.canvas && this.canvas.moveCursor\n            };\n        },\n        /**\n     * @private\n     */ _restoreEditingProps: function() {\n            if (!this._savedProps) {\n                return;\n            }\n            this.hoverCursor = this._savedProps.hoverCursor;\n            this.hasControls = this._savedProps.hasControls;\n            this.borderColor = this._savedProps.borderColor;\n            this.selectable = this._savedProps.selectable;\n            this.lockMovementX = this._savedProps.lockMovementX;\n            this.lockMovementY = this._savedProps.lockMovementY;\n            if (this.canvas) {\n                this.canvas.defaultCursor = this._savedProps.defaultCursor;\n                this.canvas.moveCursor = this._savedProps.moveCursor;\n            }\n        },\n        /**\n     * Exits from editing state\n     * @return {fabric.IText} thisArg\n     * @chainable\n     */ exitEditing: function() {\n            var isTextChanged = this._textBeforeEdit !== this.text;\n            var hiddenTextarea = this.hiddenTextarea;\n            this.selected = false;\n            this.isEditing = false;\n            this.selectionEnd = this.selectionStart;\n            if (hiddenTextarea) {\n                hiddenTextarea.blur && hiddenTextarea.blur();\n                hiddenTextarea.parentNode && hiddenTextarea.parentNode.removeChild(hiddenTextarea);\n            }\n            this.hiddenTextarea = null;\n            this.abortCursorAnimation();\n            this._restoreEditingProps();\n            this._currentCursorOpacity = 0;\n            if (this._shouldClearDimensionCache()) {\n                this.initDimensions();\n                this.setCoords();\n            }\n            this.fire(\"editing:exited\");\n            isTextChanged && this.fire(\"modified\");\n            if (this.canvas) {\n                this.canvas.off(\"mouse:move\", this.mouseMoveHandler);\n                this.canvas.fire(\"text:editing:exited\", {\n                    target: this\n                });\n                isTextChanged && this.canvas.fire(\"object:modified\", {\n                    target: this\n                });\n            }\n            return this;\n        },\n        /**\n     * @private\n     */ _removeExtraneousStyles: function() {\n            for(var prop in this.styles){\n                if (!this._textLines[prop]) {\n                    delete this.styles[prop];\n                }\n            }\n        },\n        /**\n     * remove and reflow a style block from start to end.\n     * @param {Number} start linear start position for removal (included in removal)\n     * @param {Number} end linear end position for removal ( excluded from removal )\n     */ removeStyleFromTo: function(start, end) {\n            var cursorStart = this.get2DCursorLocation(start, true), cursorEnd = this.get2DCursorLocation(end, true), lineStart = cursorStart.lineIndex, charStart = cursorStart.charIndex, lineEnd = cursorEnd.lineIndex, charEnd = cursorEnd.charIndex, i, styleObj;\n            if (lineStart !== lineEnd) {\n                // step1 remove the trailing of lineStart\n                if (this.styles[lineStart]) {\n                    for(i = charStart; i < this._unwrappedTextLines[lineStart].length; i++){\n                        delete this.styles[lineStart][i];\n                    }\n                }\n                // step2 move the trailing of lineEnd to lineStart if needed\n                if (this.styles[lineEnd]) {\n                    for(i = charEnd; i < this._unwrappedTextLines[lineEnd].length; i++){\n                        styleObj = this.styles[lineEnd][i];\n                        if (styleObj) {\n                            this.styles[lineStart] || (this.styles[lineStart] = {});\n                            this.styles[lineStart][charStart + i - charEnd] = styleObj;\n                        }\n                    }\n                }\n                // step3 detects lines will be completely removed.\n                for(i = lineStart + 1; i <= lineEnd; i++){\n                    delete this.styles[i];\n                }\n                // step4 shift remaining lines.\n                this.shiftLineStyles(lineEnd, lineStart - lineEnd);\n            } else {\n                // remove and shift left on the same line\n                if (this.styles[lineStart]) {\n                    styleObj = this.styles[lineStart];\n                    var diff = charEnd - charStart, numericChar, _char;\n                    for(i = charStart; i < charEnd; i++){\n                        delete styleObj[i];\n                    }\n                    for(_char in this.styles[lineStart]){\n                        numericChar = parseInt(_char, 10);\n                        if (numericChar >= charEnd) {\n                            styleObj[numericChar - diff] = styleObj[_char];\n                            delete styleObj[_char];\n                        }\n                    }\n                }\n            }\n        },\n        /**\n     * Shifts line styles up or down\n     * @param {Number} lineIndex Index of a line\n     * @param {Number} offset Can any number?\n     */ shiftLineStyles: function(lineIndex, offset) {\n            // shift all line styles by offset upward or downward\n            // do not clone deep. we need new array, not new style objects\n            var clonedStyles = clone(this.styles);\n            for(var line in this.styles){\n                var numericLine = parseInt(line, 10);\n                if (numericLine > lineIndex) {\n                    this.styles[numericLine + offset] = clonedStyles[numericLine];\n                    if (!clonedStyles[numericLine - offset]) {\n                        delete this.styles[numericLine];\n                    }\n                }\n            }\n        },\n        restartCursorIfNeeded: function() {\n            if (!this._currentTickState || this._currentTickState.isAborted || !this._currentTickCompleteState || this._currentTickCompleteState.isAborted) {\n                this.initDelayedCursor();\n            }\n        },\n        /**\n     * Handle insertion of more consecutive style lines for when one or more\n     * newlines gets added to the text. Since current style needs to be shifted\n     * first we shift the current style of the number lines needed, then we add\n     * new lines from the last to the first.\n     * @param {Number} lineIndex Index of a line\n     * @param {Number} charIndex Index of a char\n     * @param {Number} qty number of lines to add\n     * @param {Array} copiedStyle Array of objects styles\n     */ insertNewlineStyleObject: function(lineIndex, charIndex, qty, copiedStyle) {\n            var currentCharStyle, newLineStyles = {}, someStyleIsCarryingOver = false, originalLineLength = this._unwrappedTextLines[lineIndex].length, isEndOfLine = originalLineLength === charIndex;\n            qty || (qty = 1);\n            this.shiftLineStyles(lineIndex, qty);\n            if (this.styles[lineIndex]) {\n                currentCharStyle = this.styles[lineIndex][charIndex === 0 ? charIndex : charIndex - 1];\n            }\n            // we clone styles of all chars\n            // after cursor onto the current line\n            for(var index in this.styles[lineIndex]){\n                var numIndex = parseInt(index, 10);\n                if (numIndex >= charIndex) {\n                    someStyleIsCarryingOver = true;\n                    newLineStyles[numIndex - charIndex] = this.styles[lineIndex][index];\n                    // remove lines from the previous line since they're on a new line now\n                    if (!(isEndOfLine && charIndex === 0)) {\n                        delete this.styles[lineIndex][index];\n                    }\n                }\n            }\n            var styleCarriedOver = false;\n            if (someStyleIsCarryingOver && !isEndOfLine) {\n                // if is end of line, the extra style we copied\n                // is probably not something we want\n                this.styles[lineIndex + qty] = newLineStyles;\n                styleCarriedOver = true;\n            }\n            if (styleCarriedOver || originalLineLength > charIndex) {\n                // skip the last line of since we already prepared it\n                // or contains text without style that we don't want to style\n                // just because it changed lines\n                qty--;\n            }\n            // for the all the lines or all the other lines\n            // we clone current char style onto the next (otherwise empty) line\n            while(qty > 0){\n                if (copiedStyle && copiedStyle[qty - 1]) {\n                    this.styles[lineIndex + qty] = {\n                        0: clone(copiedStyle[qty - 1])\n                    };\n                } else if (currentCharStyle) {\n                    this.styles[lineIndex + qty] = {\n                        0: clone(currentCharStyle)\n                    };\n                } else {\n                    delete this.styles[lineIndex + qty];\n                }\n                qty--;\n            }\n            this._forceClearCache = true;\n        },\n        /**\n     * Inserts style object for a given line/char index\n     * @param {Number} lineIndex Index of a line\n     * @param {Number} charIndex Index of a char\n     * @param {Number} quantity number Style object to insert, if given\n     * @param {Array} copiedStyle array of style objects\n     */ insertCharStyleObject: function(lineIndex, charIndex, quantity, copiedStyle) {\n            if (!this.styles) {\n                this.styles = {};\n            }\n            var currentLineStyles = this.styles[lineIndex], currentLineStylesCloned = currentLineStyles ? clone(currentLineStyles) : {};\n            quantity || (quantity = 1);\n            // shift all char styles by quantity forward\n            // 0,1,2,3 -> (charIndex=2) -> 0,1,3,4 -> (insert 2) -> 0,1,2,3,4\n            for(var index in currentLineStylesCloned){\n                var numericIndex = parseInt(index, 10);\n                if (numericIndex >= charIndex) {\n                    currentLineStyles[numericIndex + quantity] = currentLineStylesCloned[numericIndex];\n                    // only delete the style if there was nothing moved there\n                    if (!currentLineStylesCloned[numericIndex - quantity]) {\n                        delete currentLineStyles[numericIndex];\n                    }\n                }\n            }\n            this._forceClearCache = true;\n            if (copiedStyle) {\n                while(quantity--){\n                    if (!Object.keys(copiedStyle[quantity]).length) {\n                        continue;\n                    }\n                    if (!this.styles[lineIndex]) {\n                        this.styles[lineIndex] = {};\n                    }\n                    this.styles[lineIndex][charIndex + quantity] = clone(copiedStyle[quantity]);\n                }\n                return;\n            }\n            if (!currentLineStyles) {\n                return;\n            }\n            var newStyle = currentLineStyles[charIndex ? charIndex - 1 : 1];\n            while(newStyle && quantity--){\n                this.styles[lineIndex][charIndex + quantity] = clone(newStyle);\n            }\n        },\n        /**\n     * Inserts style object(s)\n     * @param {Array} insertedText Characters at the location where style is inserted\n     * @param {Number} start cursor index for inserting style\n     * @param {Array} [copiedStyle] array of style objects to insert.\n     */ insertNewStyleBlock: function(insertedText, start, copiedStyle) {\n            var cursorLoc = this.get2DCursorLocation(start, true), addedLines = [\n                0\n            ], linesLength = 0;\n            // get an array of how many char per lines are being added.\n            for(var i = 0; i < insertedText.length; i++){\n                if (insertedText[i] === \"\\n\") {\n                    linesLength++;\n                    addedLines[linesLength] = 0;\n                } else {\n                    addedLines[linesLength]++;\n                }\n            }\n            // for the first line copy the style from the current char position.\n            if (addedLines[0] > 0) {\n                this.insertCharStyleObject(cursorLoc.lineIndex, cursorLoc.charIndex, addedLines[0], copiedStyle);\n                copiedStyle = copiedStyle && copiedStyle.slice(addedLines[0] + 1);\n            }\n            linesLength && this.insertNewlineStyleObject(cursorLoc.lineIndex, cursorLoc.charIndex + addedLines[0], linesLength);\n            for(var i = 1; i < linesLength; i++){\n                if (addedLines[i] > 0) {\n                    this.insertCharStyleObject(cursorLoc.lineIndex + i, 0, addedLines[i], copiedStyle);\n                } else if (copiedStyle) {\n                    // this test is required in order to close #6841\n                    // when a pasted buffer begins with a newline then\n                    // this.styles[cursorLoc.lineIndex + i] and copiedStyle[0]\n                    // may be undefined for some reason\n                    if (this.styles[cursorLoc.lineIndex + i] && copiedStyle[0]) {\n                        this.styles[cursorLoc.lineIndex + i][0] = copiedStyle[0];\n                    }\n                }\n                copiedStyle = copiedStyle && copiedStyle.slice(addedLines[i] + 1);\n            }\n            // we use i outside the loop to get it like linesLength\n            if (addedLines[i] > 0) {\n                this.insertCharStyleObject(cursorLoc.lineIndex + i, 0, addedLines[i], copiedStyle);\n            }\n        },\n        /**\n     * Set the selectionStart and selectionEnd according to the new position of cursor\n     * mimic the key - mouse navigation when shift is pressed.\n     */ setSelectionStartEndWithShift: function(start, end, newSelection) {\n            if (newSelection <= start) {\n                if (end === start) {\n                    this._selectionDirection = \"left\";\n                } else if (this._selectionDirection === \"right\") {\n                    this._selectionDirection = \"left\";\n                    this.selectionEnd = start;\n                }\n                this.selectionStart = newSelection;\n            } else if (newSelection > start && newSelection < end) {\n                if (this._selectionDirection === \"right\") {\n                    this.selectionEnd = newSelection;\n                } else {\n                    this.selectionStart = newSelection;\n                }\n            } else {\n                // newSelection is > selection start and end\n                if (end === start) {\n                    this._selectionDirection = \"right\";\n                } else if (this._selectionDirection === \"left\") {\n                    this._selectionDirection = \"right\";\n                    this.selectionStart = end;\n                }\n                this.selectionEnd = newSelection;\n            }\n        },\n        setSelectionInBoundaries: function() {\n            var length = this.text.length;\n            if (this.selectionStart > length) {\n                this.selectionStart = length;\n            } else if (this.selectionStart < 0) {\n                this.selectionStart = 0;\n            }\n            if (this.selectionEnd > length) {\n                this.selectionEnd = length;\n            } else if (this.selectionEnd < 0) {\n                this.selectionEnd = 0;\n            }\n        }\n    });\n})();\nfabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {\n    /**\n   * Initializes \"dbclick\" event handler\n   */ initDoubleClickSimulation: function() {\n        // for double click\n        this.__lastClickTime = +new Date();\n        // for triple click\n        this.__lastLastClickTime = +new Date();\n        this.__lastPointer = {};\n        this.on(\"mousedown\", this.onMouseDown);\n    },\n    /**\n   * Default event handler to simulate triple click\n   * @private\n   */ onMouseDown: function(options) {\n        if (!this.canvas) {\n            return;\n        }\n        this.__newClickTime = +new Date();\n        var newPointer = options.pointer;\n        if (this.isTripleClick(newPointer)) {\n            this.fire(\"tripleclick\", options);\n            this._stopEvent(options.e);\n        }\n        this.__lastLastClickTime = this.__lastClickTime;\n        this.__lastClickTime = this.__newClickTime;\n        this.__lastPointer = newPointer;\n        this.__lastIsEditing = this.isEditing;\n        this.__lastSelected = this.selected;\n    },\n    isTripleClick: function(newPointer) {\n        return this.__newClickTime - this.__lastClickTime < 500 && this.__lastClickTime - this.__lastLastClickTime < 500 && this.__lastPointer.x === newPointer.x && this.__lastPointer.y === newPointer.y;\n    },\n    /**\n   * @private\n   */ _stopEvent: function(e) {\n        e.preventDefault && e.preventDefault();\n        e.stopPropagation && e.stopPropagation();\n    },\n    /**\n   * Initializes event handlers related to cursor or selection\n   */ initCursorSelectionHandlers: function() {\n        this.initMousedownHandler();\n        this.initMouseupHandler();\n        this.initClicks();\n    },\n    /**\n   * Default handler for double click, select a word\n   */ doubleClickHandler: function(options) {\n        if (!this.isEditing) {\n            return;\n        }\n        this.selectWord(this.getSelectionStartFromPointer(options.e));\n    },\n    /**\n   * Default handler for triple click, select a line\n   */ tripleClickHandler: function(options) {\n        if (!this.isEditing) {\n            return;\n        }\n        this.selectLine(this.getSelectionStartFromPointer(options.e));\n    },\n    /**\n   * Initializes double and triple click event handlers\n   */ initClicks: function() {\n        this.on(\"mousedblclick\", this.doubleClickHandler);\n        this.on(\"tripleclick\", this.tripleClickHandler);\n    },\n    /**\n   * Default event handler for the basic functionalities needed on _mouseDown\n   * can be overridden to do something different.\n   * Scope of this implementation is: find the click position, set selectionStart\n   * find selectionEnd, initialize the drawing of either cursor or selection area\n   * initializing a mousedDown on a text area will cancel fabricjs knowledge of\n   * current compositionMode. It will be set to false.\n   */ _mouseDownHandler: function(options) {\n        if (!this.canvas || !this.editable || options.e.button && options.e.button !== 1) {\n            return;\n        }\n        this.__isMousedown = true;\n        if (this.selected) {\n            this.inCompositionMode = false;\n            this.setCursorByClick(options.e);\n        }\n        if (this.isEditing) {\n            this.__selectionStartOnMouseDown = this.selectionStart;\n            if (this.selectionStart === this.selectionEnd) {\n                this.abortCursorAnimation();\n            }\n            this.renderCursorOrSelection();\n        }\n    },\n    /**\n   * Default event handler for the basic functionalities needed on mousedown:before\n   * can be overridden to do something different.\n   * Scope of this implementation is: verify the object is already selected when mousing down\n   */ _mouseDownHandlerBefore: function(options) {\n        if (!this.canvas || !this.editable || options.e.button && options.e.button !== 1) {\n            return;\n        }\n        // we want to avoid that an object that was selected and then becomes unselectable,\n        // may trigger editing mode in some way.\n        this.selected = this === this.canvas._activeObject;\n    },\n    /**\n   * Initializes \"mousedown\" event handler\n   */ initMousedownHandler: function() {\n        this.on(\"mousedown\", this._mouseDownHandler);\n        this.on(\"mousedown:before\", this._mouseDownHandlerBefore);\n    },\n    /**\n   * Initializes \"mouseup\" event handler\n   */ initMouseupHandler: function() {\n        this.on(\"mouseup\", this.mouseUpHandler);\n    },\n    /**\n   * standard handler for mouse up, overridable\n   * @private\n   */ mouseUpHandler: function(options) {\n        this.__isMousedown = false;\n        if (!this.editable || this.group || options.transform && options.transform.actionPerformed || options.e.button && options.e.button !== 1) {\n            return;\n        }\n        if (this.canvas) {\n            var currentActive = this.canvas._activeObject;\n            if (currentActive && currentActive !== this) {\n                // avoid running this logic when there is an active object\n                // this because is possible with shift click and fast clicks,\n                // to rapidly deselect and reselect this object and trigger an enterEdit\n                return;\n            }\n        }\n        if (this.__lastSelected && !this.__corner) {\n            this.selected = false;\n            this.__lastSelected = false;\n            this.enterEditing(options.e);\n            if (this.selectionStart === this.selectionEnd) {\n                this.initDelayedCursor(true);\n            } else {\n                this.renderCursorOrSelection();\n            }\n        } else {\n            this.selected = true;\n        }\n    },\n    /**\n   * Changes cursor location in a text depending on passed pointer (x/y) object\n   * @param {Event} e Event object\n   */ setCursorByClick: function(e) {\n        var newSelection = this.getSelectionStartFromPointer(e), start = this.selectionStart, end = this.selectionEnd;\n        if (e.shiftKey) {\n            this.setSelectionStartEndWithShift(start, end, newSelection);\n        } else {\n            this.selectionStart = newSelection;\n            this.selectionEnd = newSelection;\n        }\n        if (this.isEditing) {\n            this._fireSelectionChanged();\n            this._updateTextarea();\n        }\n    },\n    /**\n   * Returns index of a character corresponding to where an object was clicked\n   * @param {Event} e Event object\n   * @return {Number} Index of a character\n   */ getSelectionStartFromPointer: function(e) {\n        var mouseOffset = this.getLocalPointer(e), prevWidth = 0, width = 0, height = 0, charIndex = 0, lineIndex = 0, lineLeftOffset, line;\n        for(var i = 0, len = this._textLines.length; i < len; i++){\n            if (height <= mouseOffset.y) {\n                height += this.getHeightOfLine(i) * this.scaleY;\n                lineIndex = i;\n                if (i > 0) {\n                    charIndex += this._textLines[i - 1].length + this.missingNewlineOffset(i - 1);\n                }\n            } else {\n                break;\n            }\n        }\n        lineLeftOffset = this._getLineLeftOffset(lineIndex);\n        width = lineLeftOffset * this.scaleX;\n        line = this._textLines[lineIndex];\n        // handling of RTL: in order to get things work correctly,\n        // we assume RTL writing is mirrored compared to LTR writing.\n        // so in position detection we mirror the X offset, and when is time\n        // of rendering it, we mirror it again.\n        if (this.direction === \"rtl\") {\n            mouseOffset.x = this.width * this.scaleX - mouseOffset.x + width;\n        }\n        for(var j = 0, jlen = line.length; j < jlen; j++){\n            prevWidth = width;\n            // i removed something about flipX here, check.\n            width += this.__charBounds[lineIndex][j].kernedWidth * this.scaleX;\n            if (width <= mouseOffset.x) {\n                charIndex++;\n            } else {\n                break;\n            }\n        }\n        return this._getNewSelectionStartFromOffset(mouseOffset, prevWidth, width, charIndex, jlen);\n    },\n    /**\n   * @private\n   */ _getNewSelectionStartFromOffset: function(mouseOffset, prevWidth, width, index, jlen) {\n        // we need Math.abs because when width is after the last char, the offset is given as 1, while is 0\n        var distanceBtwLastCharAndCursor = mouseOffset.x - prevWidth, distanceBtwNextCharAndCursor = width - mouseOffset.x, offset = distanceBtwNextCharAndCursor > distanceBtwLastCharAndCursor || distanceBtwNextCharAndCursor < 0 ? 0 : 1, newSelectionStart = index + offset;\n        // if object is horizontally flipped, mirror cursor location from the end\n        if (this.flipX) {\n            newSelectionStart = jlen - newSelectionStart;\n        }\n        if (newSelectionStart > this._text.length) {\n            newSelectionStart = this._text.length;\n        }\n        return newSelectionStart;\n    }\n});\nfabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {\n    /**\n   * Initializes hidden textarea (needed to bring up keyboard in iOS)\n   */ initHiddenTextarea: function() {\n        this.hiddenTextarea = fabric.document.createElement(\"textarea\");\n        this.hiddenTextarea.setAttribute(\"autocapitalize\", \"off\");\n        this.hiddenTextarea.setAttribute(\"autocorrect\", \"off\");\n        this.hiddenTextarea.setAttribute(\"autocomplete\", \"off\");\n        this.hiddenTextarea.setAttribute(\"spellcheck\", \"false\");\n        this.hiddenTextarea.setAttribute(\"data-fabric-hiddentextarea\", \"\");\n        this.hiddenTextarea.setAttribute(\"wrap\", \"off\");\n        var style = this._calcTextareaPosition();\n        // line-height: 1px; was removed from the style to fix this:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=870966\n        this.hiddenTextarea.style.cssText = \"position: absolute; top: \" + style.top + \"; left: \" + style.left + \"; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px;\" + \" padding-top: \" + style.fontSize + \";\";\n        if (this.hiddenTextareaContainer) {\n            this.hiddenTextareaContainer.appendChild(this.hiddenTextarea);\n        } else {\n            fabric.document.body.appendChild(this.hiddenTextarea);\n        }\n        fabric.util.addListener(this.hiddenTextarea, \"keydown\", this.onKeyDown.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"keyup\", this.onKeyUp.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"input\", this.onInput.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"copy\", this.copy.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"cut\", this.copy.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"paste\", this.paste.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"compositionstart\", this.onCompositionStart.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"compositionupdate\", this.onCompositionUpdate.bind(this));\n        fabric.util.addListener(this.hiddenTextarea, \"compositionend\", this.onCompositionEnd.bind(this));\n        if (!this._clickHandlerInitialized && this.canvas) {\n            fabric.util.addListener(this.canvas.upperCanvasEl, \"click\", this.onClick.bind(this));\n            this._clickHandlerInitialized = true;\n        }\n    },\n    /**\n   * For functionalities on keyDown\n   * Map a special key to a function of the instance/prototype\n   * If you need different behaviour for ESC or TAB or arrows, you have to change\n   * this map setting the name of a function that you build on the fabric.Itext or\n   * your prototype.\n   * the map change will affect all Instances unless you need for only some text Instances\n   * in that case you have to clone this object and assign your Instance.\n   * this.keysMap = fabric.util.object.clone(this.keysMap);\n   * The function must be in fabric.Itext.prototype.myFunction And will receive event as args[0]\n   */ keysMap: {\n        9: \"exitEditing\",\n        27: \"exitEditing\",\n        33: \"moveCursorUp\",\n        34: \"moveCursorDown\",\n        35: \"moveCursorRight\",\n        36: \"moveCursorLeft\",\n        37: \"moveCursorLeft\",\n        38: \"moveCursorUp\",\n        39: \"moveCursorRight\",\n        40: \"moveCursorDown\"\n    },\n    keysMapRtl: {\n        9: \"exitEditing\",\n        27: \"exitEditing\",\n        33: \"moveCursorUp\",\n        34: \"moveCursorDown\",\n        35: \"moveCursorLeft\",\n        36: \"moveCursorRight\",\n        37: \"moveCursorRight\",\n        38: \"moveCursorUp\",\n        39: \"moveCursorLeft\",\n        40: \"moveCursorDown\"\n    },\n    /**\n   * For functionalities on keyUp + ctrl || cmd\n   */ ctrlKeysMapUp: {\n        67: \"copy\",\n        88: \"cut\"\n    },\n    /**\n   * For functionalities on keyDown + ctrl || cmd\n   */ ctrlKeysMapDown: {\n        65: \"selectAll\"\n    },\n    onClick: function() {\n        // No need to trigger click event here, focus is enough to have the keyboard appear on Android\n        this.hiddenTextarea && this.hiddenTextarea.focus();\n    },\n    /**\n   * Handles keydown event\n   * only used for arrows and combination of modifier keys.\n   * @param {Event} e Event object\n   */ onKeyDown: function(e) {\n        if (!this.isEditing) {\n            return;\n        }\n        var keyMap = this.direction === \"rtl\" ? this.keysMapRtl : this.keysMap;\n        if (e.keyCode in keyMap) {\n            this[keyMap[e.keyCode]](e);\n        } else if (e.keyCode in this.ctrlKeysMapDown && (e.ctrlKey || e.metaKey)) {\n            this[this.ctrlKeysMapDown[e.keyCode]](e);\n        } else {\n            return;\n        }\n        e.stopImmediatePropagation();\n        e.preventDefault();\n        if (e.keyCode >= 33 && e.keyCode <= 40) {\n            // if i press an arrow key just update selection\n            this.inCompositionMode = false;\n            this.clearContextTop();\n            this.renderCursorOrSelection();\n        } else {\n            this.canvas && this.canvas.requestRenderAll();\n        }\n    },\n    /**\n   * Handles keyup event\n   * We handle KeyUp because ie11 and edge have difficulties copy/pasting\n   * if a copy/cut event fired, keyup is dismissed\n   * @param {Event} e Event object\n   */ onKeyUp: function(e) {\n        if (!this.isEditing || this._copyDone || this.inCompositionMode) {\n            this._copyDone = false;\n            return;\n        }\n        if (e.keyCode in this.ctrlKeysMapUp && (e.ctrlKey || e.metaKey)) {\n            this[this.ctrlKeysMapUp[e.keyCode]](e);\n        } else {\n            return;\n        }\n        e.stopImmediatePropagation();\n        e.preventDefault();\n        this.canvas && this.canvas.requestRenderAll();\n    },\n    /**\n   * Handles onInput event\n   * @param {Event} e Event object\n   */ onInput: function(e) {\n        var fromPaste = this.fromPaste;\n        this.fromPaste = false;\n        e && e.stopPropagation();\n        if (!this.isEditing) {\n            return;\n        }\n        // decisions about style changes.\n        var nextText = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText, charCount = this._text.length, nextCharCount = nextText.length, removedText, insertedText, charDiff = nextCharCount - charCount, selectionStart = this.selectionStart, selectionEnd = this.selectionEnd, selection = selectionStart !== selectionEnd, copiedStyle, removeFrom, removeTo;\n        if (this.hiddenTextarea.value === \"\") {\n            this.styles = {};\n            this.updateFromTextArea();\n            this.fire(\"changed\");\n            if (this.canvas) {\n                this.canvas.fire(\"text:changed\", {\n                    target: this\n                });\n                this.canvas.requestRenderAll();\n            }\n            return;\n        }\n        var textareaSelection = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value);\n        var backDelete = selectionStart > textareaSelection.selectionStart;\n        if (selection) {\n            removedText = this._text.slice(selectionStart, selectionEnd);\n            charDiff += selectionEnd - selectionStart;\n        } else if (nextCharCount < charCount) {\n            if (backDelete) {\n                removedText = this._text.slice(selectionEnd + charDiff, selectionEnd);\n            } else {\n                removedText = this._text.slice(selectionStart, selectionStart - charDiff);\n            }\n        }\n        insertedText = nextText.slice(textareaSelection.selectionEnd - charDiff, textareaSelection.selectionEnd);\n        if (removedText && removedText.length) {\n            if (insertedText.length) {\n                // let's copy some style before deleting.\n                // we want to copy the style before the cursor OR the style at the cursor if selection\n                // is bigger than 0.\n                copiedStyle = this.getSelectionStyles(selectionStart, selectionStart + 1, false);\n                // now duplicate the style one for each inserted text.\n                copiedStyle = insertedText.map(function() {\n                    // this return an array of references, but that is fine since we are\n                    // copying the style later.\n                    return copiedStyle[0];\n                });\n            }\n            if (selection) {\n                removeFrom = selectionStart;\n                removeTo = selectionEnd;\n            } else if (backDelete) {\n                // detect differences between forwardDelete and backDelete\n                removeFrom = selectionEnd - removedText.length;\n                removeTo = selectionEnd;\n            } else {\n                removeFrom = selectionEnd;\n                removeTo = selectionEnd + removedText.length;\n            }\n            this.removeStyleFromTo(removeFrom, removeTo);\n        }\n        if (insertedText.length) {\n            if (fromPaste && insertedText.join(\"\") === fabric.copiedText && !fabric.disableStyleCopyPaste) {\n                copiedStyle = fabric.copiedTextStyle;\n            }\n            this.insertNewStyleBlock(insertedText, selectionStart, copiedStyle);\n        }\n        this.updateFromTextArea();\n        this.fire(\"changed\");\n        if (this.canvas) {\n            this.canvas.fire(\"text:changed\", {\n                target: this\n            });\n            this.canvas.requestRenderAll();\n        }\n    },\n    /**\n   * Composition start\n   */ onCompositionStart: function() {\n        this.inCompositionMode = true;\n    },\n    /**\n   * Composition end\n   */ onCompositionEnd: function() {\n        this.inCompositionMode = false;\n    },\n    // /**\n    //  * Composition update\n    //  */\n    onCompositionUpdate: function(e) {\n        this.compositionStart = e.target.selectionStart;\n        this.compositionEnd = e.target.selectionEnd;\n        this.updateTextareaPosition();\n    },\n    /**\n   * Copies selected text\n   * @param {Event} e Event object\n   */ copy: function() {\n        if (this.selectionStart === this.selectionEnd) {\n            //do not cut-copy if no selection\n            return;\n        }\n        fabric.copiedText = this.getSelectedText();\n        if (!fabric.disableStyleCopyPaste) {\n            fabric.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, true);\n        } else {\n            fabric.copiedTextStyle = null;\n        }\n        this._copyDone = true;\n    },\n    /**\n   * Pastes text\n   * @param {Event} e Event object\n   */ paste: function() {\n        this.fromPaste = true;\n    },\n    /**\n   * @private\n   * @param {Event} e Event object\n   * @return {Object} Clipboard data object\n   */ _getClipboardData: function(e) {\n        return e && e.clipboardData || fabric.window.clipboardData;\n    },\n    /**\n   * Finds the width in pixels before the cursor on the same line\n   * @private\n   * @param {Number} lineIndex\n   * @param {Number} charIndex\n   * @return {Number} widthBeforeCursor width before cursor\n   */ _getWidthBeforeCursor: function(lineIndex, charIndex) {\n        var widthBeforeCursor = this._getLineLeftOffset(lineIndex), bound;\n        if (charIndex > 0) {\n            bound = this.__charBounds[lineIndex][charIndex - 1];\n            widthBeforeCursor += bound.left + bound.width;\n        }\n        return widthBeforeCursor;\n    },\n    /**\n   * Gets start offset of a selection\n   * @param {Event} e Event object\n   * @param {Boolean} isRight\n   * @return {Number}\n   */ getDownCursorOffset: function(e, isRight) {\n        var selectionProp = this._getSelectionForOffset(e, isRight), cursorLocation = this.get2DCursorLocation(selectionProp), lineIndex = cursorLocation.lineIndex;\n        // if on last line, down cursor goes to end of line\n        if (lineIndex === this._textLines.length - 1 || e.metaKey || e.keyCode === 34) {\n            // move to the end of a text\n            return this._text.length - selectionProp;\n        }\n        var charIndex = cursorLocation.charIndex, widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex), indexOnOtherLine = this._getIndexOnLine(lineIndex + 1, widthBeforeCursor), textAfterCursor = this._textLines[lineIndex].slice(charIndex);\n        return textAfterCursor.length + indexOnOtherLine + 1 + this.missingNewlineOffset(lineIndex);\n    },\n    /**\n   * private\n   * Helps finding if the offset should be counted from Start or End\n   * @param {Event} e Event object\n   * @param {Boolean} isRight\n   * @return {Number}\n   */ _getSelectionForOffset: function(e, isRight) {\n        if (e.shiftKey && this.selectionStart !== this.selectionEnd && isRight) {\n            return this.selectionEnd;\n        } else {\n            return this.selectionStart;\n        }\n    },\n    /**\n   * @param {Event} e Event object\n   * @param {Boolean} isRight\n   * @return {Number}\n   */ getUpCursorOffset: function(e, isRight) {\n        var selectionProp = this._getSelectionForOffset(e, isRight), cursorLocation = this.get2DCursorLocation(selectionProp), lineIndex = cursorLocation.lineIndex;\n        if (lineIndex === 0 || e.metaKey || e.keyCode === 33) {\n            // if on first line, up cursor goes to start of line\n            return -selectionProp;\n        }\n        var charIndex = cursorLocation.charIndex, widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex), indexOnOtherLine = this._getIndexOnLine(lineIndex - 1, widthBeforeCursor), textBeforeCursor = this._textLines[lineIndex].slice(0, charIndex), missingNewlineOffset = this.missingNewlineOffset(lineIndex - 1);\n        // return a negative offset\n        return -this._textLines[lineIndex - 1].length + indexOnOtherLine - textBeforeCursor.length + (1 - missingNewlineOffset);\n    },\n    /**\n   * for a given width it founds the matching character.\n   * @private\n   */ _getIndexOnLine: function(lineIndex, width) {\n        var line = this._textLines[lineIndex], lineLeftOffset = this._getLineLeftOffset(lineIndex), widthOfCharsOnLine = lineLeftOffset, indexOnLine = 0, charWidth, foundMatch;\n        for(var j = 0, jlen = line.length; j < jlen; j++){\n            charWidth = this.__charBounds[lineIndex][j].width;\n            widthOfCharsOnLine += charWidth;\n            if (widthOfCharsOnLine > width) {\n                foundMatch = true;\n                var leftEdge = widthOfCharsOnLine - charWidth, rightEdge = widthOfCharsOnLine, offsetFromLeftEdge = Math.abs(leftEdge - width), offsetFromRightEdge = Math.abs(rightEdge - width);\n                indexOnLine = offsetFromRightEdge < offsetFromLeftEdge ? j : j - 1;\n                break;\n            }\n        }\n        // reached end\n        if (!foundMatch) {\n            indexOnLine = line.length - 1;\n        }\n        return indexOnLine;\n    },\n    /**\n   * Moves cursor down\n   * @param {Event} e Event object\n   */ moveCursorDown: function(e) {\n        if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {\n            return;\n        }\n        this._moveCursorUpOrDown(\"Down\", e);\n    },\n    /**\n   * Moves cursor up\n   * @param {Event} e Event object\n   */ moveCursorUp: function(e) {\n        if (this.selectionStart === 0 && this.selectionEnd === 0) {\n            return;\n        }\n        this._moveCursorUpOrDown(\"Up\", e);\n    },\n    /**\n   * Moves cursor up or down, fires the events\n   * @param {String} direction 'Up' or 'Down'\n   * @param {Event} e Event object\n   */ _moveCursorUpOrDown: function(direction, e) {\n        // getUpCursorOffset\n        // getDownCursorOffset\n        var action = \"get\" + direction + \"CursorOffset\", offset = this[action](e, this._selectionDirection === \"right\");\n        if (e.shiftKey) {\n            this.moveCursorWithShift(offset);\n        } else {\n            this.moveCursorWithoutShift(offset);\n        }\n        if (offset !== 0) {\n            this.setSelectionInBoundaries();\n            this.abortCursorAnimation();\n            this._currentCursorOpacity = 1;\n            this.initDelayedCursor();\n            this._fireSelectionChanged();\n            this._updateTextarea();\n        }\n    },\n    /**\n   * Moves cursor with shift\n   * @param {Number} offset\n   */ moveCursorWithShift: function(offset) {\n        var newSelection = this._selectionDirection === \"left\" ? this.selectionStart + offset : this.selectionEnd + offset;\n        this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, newSelection);\n        return offset !== 0;\n    },\n    /**\n   * Moves cursor up without shift\n   * @param {Number} offset\n   */ moveCursorWithoutShift: function(offset) {\n        if (offset < 0) {\n            this.selectionStart += offset;\n            this.selectionEnd = this.selectionStart;\n        } else {\n            this.selectionEnd += offset;\n            this.selectionStart = this.selectionEnd;\n        }\n        return offset !== 0;\n    },\n    /**\n   * Moves cursor left\n   * @param {Event} e Event object\n   */ moveCursorLeft: function(e) {\n        if (this.selectionStart === 0 && this.selectionEnd === 0) {\n            return;\n        }\n        this._moveCursorLeftOrRight(\"Left\", e);\n    },\n    /**\n   * @private\n   * @return {Boolean} true if a change happened\n   */ _move: function(e, prop, direction) {\n        var newValue;\n        if (e.altKey) {\n            newValue = this[\"findWordBoundary\" + direction](this[prop]);\n        } else if (e.metaKey || e.keyCode === 35 || e.keyCode === 36) {\n            newValue = this[\"findLineBoundary\" + direction](this[prop]);\n        } else {\n            this[prop] += direction === \"Left\" ? -1 : 1;\n            return true;\n        }\n        if (typeof newValue !== \"undefined\" && this[prop] !== newValue) {\n            this[prop] = newValue;\n            return true;\n        }\n    },\n    /**\n   * @private\n   */ _moveLeft: function(e, prop) {\n        return this._move(e, prop, \"Left\");\n    },\n    /**\n   * @private\n   */ _moveRight: function(e, prop) {\n        return this._move(e, prop, \"Right\");\n    },\n    /**\n   * Moves cursor left without keeping selection\n   * @param {Event} e\n   */ moveCursorLeftWithoutShift: function(e) {\n        var change = true;\n        this._selectionDirection = \"left\";\n        // only move cursor when there is no selection,\n        // otherwise we discard it, and leave cursor on same place\n        if (this.selectionEnd === this.selectionStart && this.selectionStart !== 0) {\n            change = this._moveLeft(e, \"selectionStart\");\n        }\n        this.selectionEnd = this.selectionStart;\n        return change;\n    },\n    /**\n   * Moves cursor left while keeping selection\n   * @param {Event} e\n   */ moveCursorLeftWithShift: function(e) {\n        if (this._selectionDirection === \"right\" && this.selectionStart !== this.selectionEnd) {\n            return this._moveLeft(e, \"selectionEnd\");\n        } else if (this.selectionStart !== 0) {\n            this._selectionDirection = \"left\";\n            return this._moveLeft(e, \"selectionStart\");\n        }\n    },\n    /**\n   * Moves cursor right\n   * @param {Event} e Event object\n   */ moveCursorRight: function(e) {\n        if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {\n            return;\n        }\n        this._moveCursorLeftOrRight(\"Right\", e);\n    },\n    /**\n   * Moves cursor right or Left, fires event\n   * @param {String} direction 'Left', 'Right'\n   * @param {Event} e Event object\n   */ _moveCursorLeftOrRight: function(direction, e) {\n        var actionName = \"moveCursor\" + direction + \"With\";\n        this._currentCursorOpacity = 1;\n        if (e.shiftKey) {\n            actionName += \"Shift\";\n        } else {\n            actionName += \"outShift\";\n        }\n        if (this[actionName](e)) {\n            this.abortCursorAnimation();\n            this.initDelayedCursor();\n            this._fireSelectionChanged();\n            this._updateTextarea();\n        }\n    },\n    /**\n   * Moves cursor right while keeping selection\n   * @param {Event} e\n   */ moveCursorRightWithShift: function(e) {\n        if (this._selectionDirection === \"left\" && this.selectionStart !== this.selectionEnd) {\n            return this._moveRight(e, \"selectionStart\");\n        } else if (this.selectionEnd !== this._text.length) {\n            this._selectionDirection = \"right\";\n            return this._moveRight(e, \"selectionEnd\");\n        }\n    },\n    /**\n   * Moves cursor right without keeping selection\n   * @param {Event} e Event object\n   */ moveCursorRightWithoutShift: function(e) {\n        var changed = true;\n        this._selectionDirection = \"right\";\n        if (this.selectionStart === this.selectionEnd) {\n            changed = this._moveRight(e, \"selectionStart\");\n            this.selectionEnd = this.selectionStart;\n        } else {\n            this.selectionStart = this.selectionEnd;\n        }\n        return changed;\n    },\n    /**\n   * Removes characters from start/end\n   * start/end ar per grapheme position in _text array.\n   *\n   * @param {Number} start\n   * @param {Number} end default to start + 1\n   */ removeChars: function(start, end) {\n        if (typeof end === \"undefined\") {\n            end = start + 1;\n        }\n        this.removeStyleFromTo(start, end);\n        this._text.splice(start, end - start);\n        this.text = this._text.join(\"\");\n        this.set(\"dirty\", true);\n        if (this._shouldClearDimensionCache()) {\n            this.initDimensions();\n            this.setCoords();\n        }\n        this._removeExtraneousStyles();\n    },\n    /**\n   * insert characters at start position, before start position.\n   * start  equal 1 it means the text get inserted between actual grapheme 0 and 1\n   * if style array is provided, it must be as the same length of text in graphemes\n   * if end is provided and is bigger than start, old text is replaced.\n   * start/end ar per grapheme position in _text array.\n   *\n   * @param {String} text text to insert\n   * @param {Array} style array of style objects\n   * @param {Number} start\n   * @param {Number} end default to start + 1\n   */ insertChars: function(text, style, start, end) {\n        if (typeof end === \"undefined\") {\n            end = start;\n        }\n        if (end > start) {\n            this.removeStyleFromTo(start, end);\n        }\n        var graphemes = fabric.util.string.graphemeSplit(text);\n        this.insertNewStyleBlock(graphemes, start, style);\n        this._text = [].concat(this._text.slice(0, start), graphemes, this._text.slice(end));\n        this.text = this._text.join(\"\");\n        this.set(\"dirty\", true);\n        if (this._shouldClearDimensionCache()) {\n            this.initDimensions();\n            this.setCoords();\n        }\n        this._removeExtraneousStyles();\n    }\n});\n/* _TO_SVG_START_ */ (function() {\n    var toFixed = fabric.util.toFixed, radiansToDegrees = fabric.util.radiansToDegrees, calcRotateMatrix = fabric.util.calcRotateMatrix, transformPoint = fabric.util.transformPoint, multipleSpacesRegex = /  +/g;\n    fabric.util.object.extend(fabric.Text.prototype, /** @lends fabric.Text.prototype */ {\n        /**\n     * Returns SVG representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ _toSVG: function() {\n            var offsets = this._getSVGLeftTopOffsets(), textAndBg = this._getSVGTextAndBg(offsets.textTop, offsets.textLeft);\n            return this._wrapSVGTextAndBg(textAndBg);\n        },\n        /**\n     * Returns svg representation of an instance\n     * @param {Function} [reviver] Method for further parsing of svg representation.\n     * @return {String} svg representation of an instance\n     */ toSVG: function(reviver) {\n            var textSvg = this._createBaseSVGMarkup(this._toSVG(), {\n                reviver: reviver,\n                noStyle: true,\n                withShadow: true\n            }), path = this.path;\n            if (path) {\n                return textSvg + path._createBaseSVGMarkup(path._toSVG(), {\n                    reviver: reviver,\n                    withShadow: true\n                });\n            }\n            return textSvg;\n        },\n        /**\n     * @private\n     */ _getSVGLeftTopOffsets: function() {\n            return {\n                textLeft: -this.width / 2,\n                textTop: -this.height / 2,\n                lineTop: this.getHeightOfLine(0)\n            };\n        },\n        /**\n     * @private\n     */ _wrapSVGTextAndBg: function(textAndBg) {\n            var noShadow = true, textDecoration = this.getSvgTextDecoration(this);\n            return [\n                textAndBg.textBgRects.join(\"\"),\n                '\t\t<text xml:space=\"preserve\" ',\n                this.fontFamily ? 'font-family=\"' + this.fontFamily.replace(/\"/g, \"'\") + '\" ' : \"\",\n                this.fontSize ? 'font-size=\"' + this.fontSize + '\" ' : \"\",\n                this.fontStyle ? 'font-style=\"' + this.fontStyle + '\" ' : \"\",\n                this.fontWeight ? 'font-weight=\"' + this.fontWeight + '\" ' : \"\",\n                textDecoration ? 'text-decoration=\"' + textDecoration + '\" ' : \"\",\n                'style=\"',\n                this.getSvgStyles(noShadow),\n                '\"',\n                this.addPaintOrder(),\n                \" >\",\n                textAndBg.textSpans.join(\"\"),\n                \"</text>\\n\"\n            ];\n        },\n        /**\n     * @private\n     * @param {Number} textTopOffset Text top offset\n     * @param {Number} textLeftOffset Text left offset\n     * @return {Object}\n     */ _getSVGTextAndBg: function(textTopOffset, textLeftOffset) {\n            var textSpans = [], textBgRects = [], height = textTopOffset, lineOffset;\n            // bounding-box background\n            this._setSVGBg(textBgRects);\n            // text and text-background\n            for(var i = 0, len = this._textLines.length; i < len; i++){\n                lineOffset = this._getLineLeftOffset(i);\n                if (this.textBackgroundColor || this.styleHas(\"textBackgroundColor\", i)) {\n                    this._setSVGTextLineBg(textBgRects, i, textLeftOffset + lineOffset, height);\n                }\n                this._setSVGTextLineText(textSpans, i, textLeftOffset + lineOffset, height);\n                height += this.getHeightOfLine(i);\n            }\n            return {\n                textSpans: textSpans,\n                textBgRects: textBgRects\n            };\n        },\n        /**\n     * @private\n     */ _createTextCharSpan: function(_char, styleDecl, left, top, charBox) {\n            var shouldUseWhitespace = _char !== _char.trim() || _char.match(multipleSpacesRegex), styleProps = this.getSvgSpanStyles(styleDecl, shouldUseWhitespace), fillStyles = styleProps ? 'style=\"' + styleProps + '\"' : \"\", dy = styleDecl.deltaY, dySpan = \"\", NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS, angleAttr = \"\";\n            if (dy) {\n                dySpan = ' dy=\"' + toFixed(dy, NUM_FRACTION_DIGITS) + '\" ';\n            }\n            if (charBox.renderLeft !== undefined) {\n                var angle = charBox.angle;\n                angleAttr = ' rotate=\"' + toFixed(radiansToDegrees(angle), fabric.Object.NUM_FRACTION_DIGITS) + '\" ';\n                var wBy2 = charBox.width / 2, m = calcRotateMatrix({\n                    angle: radiansToDegrees(angle)\n                });\n                m[4] = charBox.renderLeft;\n                m[5] = charBox.renderTop;\n                var renderPoint = transformPoint({\n                    x: -wBy2,\n                    y: 0\n                }, m);\n                left = renderPoint.x;\n                top = renderPoint.y;\n            }\n            return [\n                '<tspan x=\"',\n                toFixed(left, NUM_FRACTION_DIGITS),\n                '\" y=\"',\n                toFixed(top, NUM_FRACTION_DIGITS),\n                '\" ',\n                dySpan,\n                fillStyles,\n                angleAttr,\n                \">\",\n                fabric.util.string.escapeXml(_char),\n                \"</tspan>\"\n            ].join(\"\");\n        },\n        _setSVGTextLineText: function(textSpans, lineIndex, textLeftOffset, textTopOffset) {\n            // set proper line offset\n            var lineHeight = this.getHeightOfLine(lineIndex), isJustify = this.textAlign.indexOf(\"justify\") !== -1, actualStyle, nextStyle, charsToRender = \"\", charBox, style, boxWidth = 0, line = this._textLines[lineIndex], timeToRender;\n            textTopOffset += lineHeight * (1 - this._fontSizeFraction) / this.lineHeight;\n            for(var i = 0, len = line.length - 1; i <= len; i++){\n                timeToRender = i === len || this.charSpacing || this.path;\n                charsToRender += line[i];\n                charBox = this.__charBounds[lineIndex][i];\n                if (boxWidth === 0) {\n                    textLeftOffset += charBox.kernedWidth - charBox.width;\n                    boxWidth += charBox.width;\n                } else {\n                    boxWidth += charBox.kernedWidth;\n                }\n                if (isJustify && !timeToRender) {\n                    if (this._reSpaceAndTab.test(line[i])) {\n                        timeToRender = true;\n                    }\n                }\n                if (!timeToRender) {\n                    // if we have charSpacing, we render char by char\n                    actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);\n                    nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);\n                    timeToRender = fabric.util.hasStyleChanged(actualStyle, nextStyle, true);\n                }\n                if (timeToRender) {\n                    style = this._getStyleDeclaration(lineIndex, i) || {};\n                    textSpans.push(this._createTextCharSpan(charsToRender, style, textLeftOffset, textTopOffset, charBox));\n                    charsToRender = \"\";\n                    actualStyle = nextStyle;\n                    textLeftOffset += boxWidth;\n                    boxWidth = 0;\n                }\n            }\n        },\n        _pushTextBgRect: function(textBgRects, color, left, top, width, height) {\n            var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;\n            textBgRects.push(\"\t\t<rect \", this._getFillAttributes(color), ' x=\"', toFixed(left, NUM_FRACTION_DIGITS), '\" y=\"', toFixed(top, NUM_FRACTION_DIGITS), '\" width=\"', toFixed(width, NUM_FRACTION_DIGITS), '\" height=\"', toFixed(height, NUM_FRACTION_DIGITS), '\"></rect>\\n');\n        },\n        _setSVGTextLineBg: function(textBgRects, i, leftOffset, textTopOffset) {\n            var line = this._textLines[i], heightOfLine = this.getHeightOfLine(i) / this.lineHeight, boxWidth = 0, boxStart = 0, charBox, currentColor, lastColor = this.getValueOfPropertyAt(i, 0, \"textBackgroundColor\");\n            for(var j = 0, jlen = line.length; j < jlen; j++){\n                charBox = this.__charBounds[i][j];\n                currentColor = this.getValueOfPropertyAt(i, j, \"textBackgroundColor\");\n                if (currentColor !== lastColor) {\n                    lastColor && this._pushTextBgRect(textBgRects, lastColor, leftOffset + boxStart, textTopOffset, boxWidth, heightOfLine);\n                    boxStart = charBox.left;\n                    boxWidth = charBox.width;\n                    lastColor = currentColor;\n                } else {\n                    boxWidth += charBox.kernedWidth;\n                }\n            }\n            currentColor && this._pushTextBgRect(textBgRects, currentColor, leftOffset + boxStart, textTopOffset, boxWidth, heightOfLine);\n        },\n        /**\n     * Adobe Illustrator (at least CS5) is unable to render rgba()-based fill values\n     * we work around it by \"moving\" alpha channel into opacity attribute and setting fill's alpha to 1\n     *\n     * @private\n     * @param {*} value\n     * @return {String}\n     */ _getFillAttributes: function(value) {\n            var fillColor = value && typeof value === \"string\" ? new fabric.Color(value) : \"\";\n            if (!fillColor || !fillColor.getSource() || fillColor.getAlpha() === 1) {\n                return 'fill=\"' + value + '\"';\n            }\n            return 'opacity=\"' + fillColor.getAlpha() + '\" fill=\"' + fillColor.setAlpha(1).toRgb() + '\"';\n        },\n        /**\n     * @private\n     */ _getSVGLineTopOffset: function(lineIndex) {\n            var lineTopOffset = 0, lastHeight = 0;\n            for(var j = 0; j < lineIndex; j++){\n                lineTopOffset += this.getHeightOfLine(j);\n            }\n            lastHeight = this.getHeightOfLine(j);\n            return {\n                lineTop: lineTopOffset,\n                offset: (this._fontSizeMult - this._fontSizeFraction) * lastHeight / (this.lineHeight * this._fontSizeMult)\n            };\n        },\n        /**\n     * Returns styles-string for svg-export\n     * @param {Boolean} skipShadow a boolean to skip shadow filter output\n     * @return {String}\n     */ getSvgStyles: function(skipShadow) {\n            var svgStyle = fabric.Object.prototype.getSvgStyles.call(this, skipShadow);\n            return svgStyle + \" white-space: pre;\";\n        }\n    });\n})();\n/* _TO_SVG_END_ */ (function(global) {\n    \"use strict\";\n    var fabric = global.fabric || (global.fabric = {});\n    /**\n   * Textbox class, based on IText, allows the user to resize the text rectangle\n   * and wraps lines automatically. Textboxes have their Y scaling locked, the\n   * user can only change width. Height is adjusted automatically based on the\n   * wrapping of lines.\n   * @class fabric.Textbox\n   * @extends fabric.IText\n   * @mixes fabric.Observable\n   * @return {fabric.Textbox} thisArg\n   * @see {@link fabric.Textbox#initialize} for constructor definition\n   */ fabric.Textbox = fabric.util.createClass(fabric.IText, fabric.Observable, {\n        /**\n     * Type of an object\n     * @type String\n     * @default\n     */ type: \"textbox\",\n        /**\n     * Minimum width of textbox, in pixels.\n     * @type Number\n     * @default\n     */ minWidth: 20,\n        /**\n     * Minimum calculated width of a textbox, in pixels.\n     * fixed to 2 so that an empty textbox cannot go to 0\n     * and is still selectable without text.\n     * @type Number\n     * @default\n     */ dynamicMinWidth: 2,\n        /**\n     * Cached array of text wrapping.\n     * @type Array\n     */ __cachedLines: null,\n        /**\n     * Override standard Object class values\n     */ lockScalingFlip: true,\n        /**\n     * Override standard Object class values\n     * Textbox needs this on false\n     */ noScaleCache: false,\n        /**\n     * Properties which when set cause object to change dimensions\n     * @type Object\n     * @private\n     */ _dimensionAffectingProps: fabric.Text.prototype._dimensionAffectingProps.concat(\"width\"),\n        /**\n     * Use this regular expression to split strings in breakable lines\n     * @private\n     */ _wordJoiners: /[ \\t\\r]/,\n        /**\n     * Use this boolean property in order to split strings that have no white space concept.\n     * this is a cheap way to help with chinese/japanese\n     * @type Boolean\n     * @since 2.6.0\n     */ splitByGrapheme: false,\n        /**\n     * Unlike superclass's version of this function, Textbox does not update\n     * its width.\n     * @private\n     * @override\n     */ initDimensions: function() {\n            if (this.__skipDimension) {\n                return;\n            }\n            this.isEditing && this.initDelayedCursor();\n            this.clearContextTop();\n            this._clearCache();\n            // clear dynamicMinWidth as it will be different after we re-wrap line\n            this.dynamicMinWidth = 0;\n            // wrap lines\n            this._styleMap = this._generateStyleMap(this._splitText());\n            // if after wrapping, the width is smaller than dynamicMinWidth, change the width and re-wrap\n            if (this.dynamicMinWidth > this.width) {\n                this._set(\"width\", this.dynamicMinWidth);\n            }\n            if (this.textAlign.indexOf(\"justify\") !== -1) {\n                // once text is measured we need to make space fatter to make justified text.\n                this.enlargeSpaces();\n            }\n            // clear cache and re-calculate height\n            this.height = this.calcTextHeight();\n            this.saveState({\n                propertySet: \"_dimensionAffectingProps\"\n            });\n        },\n        /**\n     * Generate an object that translates the style object so that it is\n     * broken up by visual lines (new lines and automatic wrapping).\n     * The original text styles object is broken up by actual lines (new lines only),\n     * which is only sufficient for Text / IText\n     * @private\n     */ _generateStyleMap: function(textInfo) {\n            var realLineCount = 0, realLineCharCount = 0, charCount = 0, map = {};\n            for(var i = 0; i < textInfo.graphemeLines.length; i++){\n                if (textInfo.graphemeText[charCount] === \"\\n\" && i > 0) {\n                    realLineCharCount = 0;\n                    charCount++;\n                    realLineCount++;\n                } else if (!this.splitByGrapheme && this._reSpaceAndTab.test(textInfo.graphemeText[charCount]) && i > 0) {\n                    // this case deals with space's that are removed from end of lines when wrapping\n                    realLineCharCount++;\n                    charCount++;\n                }\n                map[i] = {\n                    line: realLineCount,\n                    offset: realLineCharCount\n                };\n                charCount += textInfo.graphemeLines[i].length;\n                realLineCharCount += textInfo.graphemeLines[i].length;\n            }\n            return map;\n        },\n        /**\n     * Returns true if object has a style property or has it on a specified line\n     * @param {Number} lineIndex\n     * @return {Boolean}\n     */ styleHas: function(property, lineIndex) {\n            if (this._styleMap && !this.isWrapping) {\n                var map = this._styleMap[lineIndex];\n                if (map) {\n                    lineIndex = map.line;\n                }\n            }\n            return fabric.Text.prototype.styleHas.call(this, property, lineIndex);\n        },\n        /**\n     * Returns true if object has no styling or no styling in a line\n     * @param {Number} lineIndex , lineIndex is on wrapped lines.\n     * @return {Boolean}\n     */ isEmptyStyles: function(lineIndex) {\n            if (!this.styles) {\n                return true;\n            }\n            var offset = 0, nextLineIndex = lineIndex + 1, nextOffset, obj, shouldLimit = false, map = this._styleMap[lineIndex], mapNextLine = this._styleMap[lineIndex + 1];\n            if (map) {\n                lineIndex = map.line;\n                offset = map.offset;\n            }\n            if (mapNextLine) {\n                nextLineIndex = mapNextLine.line;\n                shouldLimit = nextLineIndex === lineIndex;\n                nextOffset = mapNextLine.offset;\n            }\n            obj = typeof lineIndex === \"undefined\" ? this.styles : {\n                line: this.styles[lineIndex]\n            };\n            for(var p1 in obj){\n                for(var p2 in obj[p1]){\n                    if (p2 >= offset && (!shouldLimit || p2 < nextOffset)) {\n                        // eslint-disable-next-line no-unused-vars\n                        for(var p3 in obj[p1][p2]){\n                            return false;\n                        }\n                    }\n                }\n            }\n            return true;\n        },\n        /**\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @private\n     */ _getStyleDeclaration: function(lineIndex, charIndex) {\n            if (this._styleMap && !this.isWrapping) {\n                var map = this._styleMap[lineIndex];\n                if (!map) {\n                    return null;\n                }\n                lineIndex = map.line;\n                charIndex = map.offset + charIndex;\n            }\n            return this.callSuper(\"_getStyleDeclaration\", lineIndex, charIndex);\n        },\n        /**\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @param {Object} style\n     * @private\n     */ _setStyleDeclaration: function(lineIndex, charIndex, style) {\n            var map = this._styleMap[lineIndex];\n            lineIndex = map.line;\n            charIndex = map.offset + charIndex;\n            this.styles[lineIndex][charIndex] = style;\n        },\n        /**\n     * @param {Number} lineIndex\n     * @param {Number} charIndex\n     * @private\n     */ _deleteStyleDeclaration: function(lineIndex, charIndex) {\n            var map = this._styleMap[lineIndex];\n            lineIndex = map.line;\n            charIndex = map.offset + charIndex;\n            delete this.styles[lineIndex][charIndex];\n        },\n        /**\n     * probably broken need a fix\n     * Returns the real style line that correspond to the wrapped lineIndex line\n     * Used just to verify if the line does exist or not.\n     * @param {Number} lineIndex\n     * @returns {Boolean} if the line exists or not\n     * @private\n     */ _getLineStyle: function(lineIndex) {\n            var map = this._styleMap[lineIndex];\n            return !!this.styles[map.line];\n        },\n        /**\n     * Set the line style to an empty object so that is initialized\n     * @param {Number} lineIndex\n     * @param {Object} style\n     * @private\n     */ _setLineStyle: function(lineIndex) {\n            var map = this._styleMap[lineIndex];\n            this.styles[map.line] = {};\n        },\n        /**\n     * Wraps text using the 'width' property of Textbox. First this function\n     * splits text on newlines, so we preserve newlines entered by the user.\n     * Then it wraps each line using the width of the Textbox by calling\n     * _wrapLine().\n     * @param {Array} lines The string array of text that is split into lines\n     * @param {Number} desiredWidth width you want to wrap to\n     * @returns {Array} Array of lines\n     */ _wrapText: function(lines, desiredWidth) {\n            var wrapped = [], i;\n            this.isWrapping = true;\n            for(i = 0; i < lines.length; i++){\n                wrapped = wrapped.concat(this._wrapLine(lines[i], i, desiredWidth));\n            }\n            this.isWrapping = false;\n            return wrapped;\n        },\n        /**\n     * Helper function to measure a string of text, given its lineIndex and charIndex offset\n     * it gets called when charBounds are not available yet.\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {String} text\n     * @param {number} lineIndex\n     * @param {number} charOffset\n     * @returns {number}\n     * @private\n     */ _measureWord: function(word, lineIndex, charOffset) {\n            var width = 0, prevGrapheme, skipLeft = true;\n            charOffset = charOffset || 0;\n            for(var i = 0, len = word.length; i < len; i++){\n                var box = this._getGraphemeBox(word[i], lineIndex, i + charOffset, prevGrapheme, skipLeft);\n                width += box.kernedWidth;\n                prevGrapheme = word[i];\n            }\n            return width;\n        },\n        /**\n     * Wraps a line of text using the width of the Textbox and a context.\n     * @param {Array} line The grapheme array that represent the line\n     * @param {Number} lineIndex\n     * @param {Number} desiredWidth width you want to wrap the line to\n     * @param {Number} reservedSpace space to remove from wrapping for custom functionalities\n     * @returns {Array} Array of line(s) into which the given text is wrapped\n     * to.\n     */ _wrapLine: function(_line, lineIndex, desiredWidth, reservedSpace) {\n            var lineWidth = 0, splitByGrapheme = this.splitByGrapheme, graphemeLines = [], line = [], // spaces in different languages?\n            words = splitByGrapheme ? fabric.util.string.graphemeSplit(_line) : _line.split(this._wordJoiners), word = \"\", offset = 0, infix = splitByGrapheme ? \"\" : \" \", wordWidth = 0, infixWidth = 0, largestWordWidth = 0, lineJustStarted = true, additionalSpace = this._getWidthOfCharSpacing(), reservedSpace = reservedSpace || 0;\n            // fix a difference between split and graphemeSplit\n            if (words.length === 0) {\n                words.push([]);\n            }\n            desiredWidth -= reservedSpace;\n            for(var i = 0; i < words.length; i++){\n                // if using splitByGrapheme words are already in graphemes.\n                word = splitByGrapheme ? words[i] : fabric.util.string.graphemeSplit(words[i]);\n                wordWidth = this._measureWord(word, lineIndex, offset);\n                offset += word.length;\n                lineWidth += infixWidth + wordWidth - additionalSpace;\n                if (lineWidth > desiredWidth && !lineJustStarted) {\n                    graphemeLines.push(line);\n                    line = [];\n                    lineWidth = wordWidth;\n                    lineJustStarted = true;\n                } else {\n                    lineWidth += additionalSpace;\n                }\n                if (!lineJustStarted && !splitByGrapheme) {\n                    line.push(infix);\n                }\n                line = line.concat(word);\n                infixWidth = splitByGrapheme ? 0 : this._measureWord([\n                    infix\n                ], lineIndex, offset);\n                offset++;\n                lineJustStarted = false;\n                // keep track of largest word\n                if (wordWidth > largestWordWidth) {\n                    largestWordWidth = wordWidth;\n                }\n            }\n            i && graphemeLines.push(line);\n            if (largestWordWidth + reservedSpace > this.dynamicMinWidth) {\n                this.dynamicMinWidth = largestWordWidth - additionalSpace + reservedSpace;\n            }\n            return graphemeLines;\n        },\n        /**\n     * Detect if the text line is ended with an hard break\n     * text and itext do not have wrapping, return false\n     * @param {Number} lineIndex text to split\n     * @return {Boolean}\n     */ isEndOfWrapping: function(lineIndex) {\n            if (!this._styleMap[lineIndex + 1]) {\n                // is last line, return true;\n                return true;\n            }\n            if (this._styleMap[lineIndex + 1].line !== this._styleMap[lineIndex].line) {\n                // this is last line before a line break, return true;\n                return true;\n            }\n            return false;\n        },\n        /**\n     * Detect if a line has a linebreak and so we need to account for it when moving\n     * and counting style.\n     * This is important only for splitByGrapheme at the end of wrapping.\n     * If we are not wrapping the offset is always 1\n     * @return Number\n     */ missingNewlineOffset: function(lineIndex, skipWrapping) {\n            if (this.splitByGrapheme && !skipWrapping) {\n                return this.isEndOfWrapping(lineIndex) ? 1 : 0;\n            }\n            return 1;\n        },\n        /**\n    * Gets lines of text to render in the Textbox. This function calculates\n    * text wrapping on the fly every time it is called.\n    * @param {String} text text to split\n    * @returns {Array} Array of lines in the Textbox.\n    * @override\n    */ _splitTextIntoLines: function(text) {\n            var newText = fabric.Text.prototype._splitTextIntoLines.call(this, text), graphemeLines = this._wrapText(newText.lines, this.width), lines = new Array(graphemeLines.length);\n            for(var i = 0; i < graphemeLines.length; i++){\n                lines[i] = graphemeLines[i].join(\"\");\n            }\n            newText.lines = lines;\n            newText.graphemeLines = graphemeLines;\n            return newText;\n        },\n        getMinWidth: function() {\n            return Math.max(this.minWidth, this.dynamicMinWidth);\n        },\n        _removeExtraneousStyles: function() {\n            var linesToKeep = {};\n            for(var prop in this._styleMap){\n                if (this._textLines[prop]) {\n                    linesToKeep[this._styleMap[prop].line] = 1;\n                }\n            }\n            for(var prop in this.styles){\n                if (!linesToKeep[prop]) {\n                    delete this.styles[prop];\n                }\n            }\n        },\n        /**\n     * Returns object representation of an instance\n     * @method toObject\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n     * @return {Object} object representation of an instance\n     */ toObject: function(propertiesToInclude) {\n            return this.callSuper(\"toObject\", [\n                \"minWidth\",\n                \"splitByGrapheme\"\n            ].concat(propertiesToInclude));\n        }\n    });\n    /**\n   * Returns fabric.Textbox instance from an object representation\n   * @static\n   * @memberOf fabric.Textbox\n   * @param {Object} object Object to create an instance from\n   * @param {Function} [callback] Callback to invoke when an fabric.Textbox instance is created\n   */ fabric.Textbox.fromObject = function(object, callback) {\n        var styles = fabric.util.stylesFromArray(object.styles, object.text);\n        //copy object to prevent mutation\n        var objCopy = Object.assign({}, object, {\n            styles: styles\n        });\n        delete objCopy.path;\n        return fabric.Object._fromObject(\"Textbox\", objCopy, function(textInstance) {\n            if (object.path) {\n                fabric.Object._fromObject(\"Path\", object.path, function(pathInstance) {\n                    textInstance.set(\"path\", pathInstance);\n                    callback(textInstance);\n                }, \"path\");\n            } else {\n                callback(textInstance);\n            }\n        }, \"text\");\n    };\n})( true ? exports : 0);\n(function() {\n    var controlsUtils = fabric.controlsUtils, scaleSkewStyleHandler = controlsUtils.scaleSkewCursorStyleHandler, scaleStyleHandler = controlsUtils.scaleCursorStyleHandler, scalingEqually = controlsUtils.scalingEqually, scalingYOrSkewingX = controlsUtils.scalingYOrSkewingX, scalingXOrSkewingY = controlsUtils.scalingXOrSkewingY, scaleOrSkewActionName = controlsUtils.scaleOrSkewActionName, objectControls = fabric.Object.prototype.controls;\n    objectControls.ml = new fabric.Control({\n        x: -0.5,\n        y: 0,\n        cursorStyleHandler: scaleSkewStyleHandler,\n        actionHandler: scalingXOrSkewingY,\n        getActionName: scaleOrSkewActionName\n    });\n    objectControls.mr = new fabric.Control({\n        x: 0.5,\n        y: 0,\n        cursorStyleHandler: scaleSkewStyleHandler,\n        actionHandler: scalingXOrSkewingY,\n        getActionName: scaleOrSkewActionName\n    });\n    objectControls.mb = new fabric.Control({\n        x: 0,\n        y: 0.5,\n        cursorStyleHandler: scaleSkewStyleHandler,\n        actionHandler: scalingYOrSkewingX,\n        getActionName: scaleOrSkewActionName\n    });\n    objectControls.mt = new fabric.Control({\n        x: 0,\n        y: -0.5,\n        cursorStyleHandler: scaleSkewStyleHandler,\n        actionHandler: scalingYOrSkewingX,\n        getActionName: scaleOrSkewActionName\n    });\n    objectControls.tl = new fabric.Control({\n        x: -0.5,\n        y: -0.5,\n        cursorStyleHandler: scaleStyleHandler,\n        actionHandler: scalingEqually\n    });\n    objectControls.tr = new fabric.Control({\n        x: 0.5,\n        y: -0.5,\n        cursorStyleHandler: scaleStyleHandler,\n        actionHandler: scalingEqually\n    });\n    objectControls.bl = new fabric.Control({\n        x: -0.5,\n        y: 0.5,\n        cursorStyleHandler: scaleStyleHandler,\n        actionHandler: scalingEqually\n    });\n    objectControls.br = new fabric.Control({\n        x: 0.5,\n        y: 0.5,\n        cursorStyleHandler: scaleStyleHandler,\n        actionHandler: scalingEqually\n    });\n    objectControls.mtr = new fabric.Control({\n        x: 0,\n        y: -0.5,\n        actionHandler: controlsUtils.rotationWithSnapping,\n        cursorStyleHandler: controlsUtils.rotationStyleHandler,\n        offsetY: -40,\n        withConnection: true,\n        actionName: \"rotate\"\n    });\n    if (fabric.Textbox) {\n        // this is breaking the prototype inheritance, no time / ideas to fix it.\n        // is important to document that if you want to have all objects to have a\n        // specific custom control, you have to add it to Object prototype and to Textbox\n        // prototype. The controls are shared as references. So changes to control `tr`\n        // can still apply to all objects if needed.\n        var textBoxControls = fabric.Textbox.prototype.controls = {};\n        textBoxControls.mtr = objectControls.mtr;\n        textBoxControls.tr = objectControls.tr;\n        textBoxControls.br = objectControls.br;\n        textBoxControls.tl = objectControls.tl;\n        textBoxControls.bl = objectControls.bl;\n        textBoxControls.mt = objectControls.mt;\n        textBoxControls.mb = objectControls.mb;\n        textBoxControls.mr = new fabric.Control({\n            x: 0.5,\n            y: 0,\n            actionHandler: controlsUtils.changeWidth,\n            cursorStyleHandler: scaleSkewStyleHandler,\n            actionName: \"resizing\"\n        });\n        textBoxControls.ml = new fabric.Control({\n            x: -0.5,\n            y: 0,\n            actionHandler: controlsUtils.changeWidth,\n            cursorStyleHandler: scaleSkewStyleHandler,\n            actionName: \"resizing\"\n        });\n    }\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZhYnJpY0A1LjUuMi9ub2RlX21vZHVsZXMvZmFicmljL2Rpc3QvZmFicmljLmpzIiwibWFwcGluZ3MiOiJBQUFBLHFHQUFxRyxHQUNyRywyRUFBMkU7QUFFM0UsSUFBSUEsU0FBU0EsVUFBVTtJQUFFQyxTQUFTO0FBQVE7QUFDMUMsSUFBSSxJQUFtQixFQUFhO0lBQ2xDQyxjQUFjLEdBQUdGO0FBQ25CLE9BRUssRUFFSjtBQUNELGFBQWEsR0FDYixJQUFJLE9BQU9LLGFBQWEsZUFBZSxnQkFBa0IsYUFBYSxFQVFyRSxNQUNJO0lBQ0gsMEVBQTBFO0lBQzFFLElBQUlNLFFBQVFDLG1CQUFPQSxDQUFDO0lBQ3BCLElBQUlDLGdCQUFnQixJQUFJRixNQUFNRyxLQUFLLENBQ2pDQyxtQkFBbUIsK0ZBQ25CO1FBQ0VDLFVBQVU7WUFDUkMsd0JBQXdCO2dCQUFDO2FBQU07UUFDakM7UUFDQUMsV0FBVztJQUNiLEdBQUdSLE1BQU07SUFDWFYsT0FBT0ssUUFBUSxHQUFHUSxjQUFjUixRQUFRO0lBQ3hDTCxPQUFPbUIsbUJBQW1CLEdBQUdQLG1NQUFnRTtJQUM3RlosT0FBT3FCLFVBQVUsR0FBR1QseUpBQXVDO0lBQzNEWixPQUFPVSxNQUFNLEdBQUdHO0lBQ2hCVSxZQUFZdkIsT0FBT1UsTUFBTSxDQUFDYSxTQUFTO0FBQ3JDO0FBRUE7OztDQUdDLEdBQ0R2QixPQUFPd0IsZ0JBQWdCLEdBQUcsa0JBQWtCeEIsT0FBT1UsTUFBTSxJQUFJLGtCQUFrQlYsT0FBT0ssUUFBUSxJQUMzRkwsT0FBT1UsTUFBTSxJQUFJVixPQUFPVSxNQUFNLENBQUNlLFNBQVMsSUFBSXpCLE9BQU9VLE1BQU0sQ0FBQ2UsU0FBUyxDQUFDQyxjQUFjLEdBQUc7QUFFeEY7OztDQUdDLEdBQ0QxQixPQUFPMkIsWUFBWSxHQUFHLE9BQU9DLFdBQVcsZUFDbEIsZ0JBQWtCO0FBRXhDLG9CQUFvQixHQUNwQjs7O0NBR0MsR0FDRDVCLE9BQU82QixpQkFB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LFVBQXNCO1FBQ3RCQyxTQUFzQjtRQUN0QkMsTUFBc0I7UUFDdEJDLFVBQXNCO1FBQ3RCQyxVQUFzQjtRQUN0QkMsZUFBc0I7UUFDdEJDLFVBQXNCO1FBQ3RCQyxVQUFzQjtRQUN0QkMsV0FBc0I7UUFDdEJDLFdBQXNCO1FBQ3RCQyxhQUFzQjtRQUN0QkMsZ0JBQXNCO1FBQ3RCQyxZQUFzQjtRQUN0QkMsWUFBc0I7UUFDdEJDLFNBQXNCO1FBQ3RCQyxZQUFzQjtRQUN0QkMsY0FBc0I7UUFDdEJDLGVBQXNCO1FBQ3RCQyxlQUFzQjtRQUN0QkMsZUFBc0I7UUFDdEJDLGVBQXNCO1FBQ3RCQyxZQUFzQjtRQUN0QkMsVUFBc0I7UUFDdEJDLGFBQXNCO1FBQ3RCQyxTQUFzQjtRQUN0QkMsU0FBc0I7UUFDdEJDLFlBQXNCO1FBQ3RCQyxXQUFzQjtRQUN0QkMsYUFBc0I7UUFDdEJDLGFBQXNCO1FBQ3RCQyxTQUFzQjtRQUN0QkMsV0FBc0I7UUFDdEJDLFlBQXNCO1FBQ3RCQyxNQUFzQjtRQUN0QkMsV0FBc0I7UUFDdEJDLE1BQXNCO1FBQ3RCQyxNQUFzQjtRQUN0QkMsT0FBc0I7UUFDdEJDLGFBQXNCO1FBQ3RCQyxVQUFzQjtRQUN0QkMsU0FBc0I7UUFDdEJDLFdBQXNCO1FBQ3RCQyxRQUFzQjtRQUN0QkMsT0FBc0I7UUFDdEJDLE9BQXNCO1FBQ3RCQyxVQUFzQjtRQUN0QkMsZUFBc0I7UUFDdEJDLFdBQXNCO1FBQ3RCQyxjQUFzQjtRQUN0QkMsV0FBc0I7UUFDdEJDLFlBQXNCO1FBQ3RCQyxXQUFzQjtRQUN0QkMsc0JBQXNCO1FBQ3RCQyxXQUFzQjtRQUN0QkMsV0FBc0I7UUFDdEJDLFlBQXNCO1FBQ3RCQyxXQUFzQjtRQUN0QkMsYUFBc0I7UUFDdEJDLGVBQXNCO1FBQ3RCQyxjQUFzQjtRQUN0QkMsZ0JBQXNCO1FBQ3RCQyxnQkFBc0I7UUFDdEJDLGdCQUFzQjtRQUN0QkMsYUFBc0I7UUFDdEJDLE1BQXNCO1FBQ3RCQyxXQUFzQjtRQUN0QkMsT0FBc0I7UUFDdEJDLFNBQXNCO1FBQ3RCQyxRQUFzQjtRQUN0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aUY7UUFDakYsK0VBQStFO1FBQy9FLDRDQUE0QztRQUM1QyxJQUFJeUMsa0JBQWtCNzFHLE9BQU9vekcsT0FBTyxDQUFDbDVGLFNBQVMsQ0FBQzAxQixRQUFRLEdBQUcsQ0FBRTtRQUU1RGltRSxnQkFBZ0JELEdBQUcsR0FBR0osZUFBZUksR0FBRztRQUN4Q0MsZ0JBQWdCNzZELEVBQUUsR0FBR3c2RCxlQUFleDZELEVBQUU7UUFDdEM2NkQsZ0JBQWdCMzZELEVBQUUsR0FBR3M2RCxlQUFldDZELEVBQUU7UUFDdEMyNkQsZ0JBQWdCOTZELEVBQUUsR0FBR3k2RCxlQUFlejZELEVBQUU7UUFDdEM4NkQsZ0JBQWdCNTZELEVBQUUsR0FBR3U2RCxlQUFldjZELEVBQUU7UUFDdEM0NkQsZ0JBQWdCajNGLEVBQUUsR0FBRzQyRixlQUFlNTJGLEVBQUU7UUFDdENpM0YsZ0JBQWdCRixFQUFFLEdBQUdILGVBQWVHLEVBQUU7UUFFdENFLGdCQUFnQkgsRUFBRSxHQUFHLElBQUkxMUcsT0FBTzg0QyxPQUFPLENBQUM7WUFDdEN0dUMsR0FBRztZQUNIQyxHQUFHO1lBQ0hrb0MsZUFBZTJFLGNBQWNYLFdBQVc7WUFDeEM2QyxvQkFBb0I4N0Q7WUFDcEJ2OEQsWUFBWTtRQUNkO1FBRUE4OEQsZ0JBQWdCSixFQUFFLEdBQUcsSUFBSXoxRyxPQUFPODRDLE9BQU8sQ0FBQztZQUN0Q3R1QyxHQUFHLENBQUM7WUFDSkMsR0FBRztZQUNIa29DLGVBQWUyRSxjQUFjWCxXQUFXO1lBQ3hDNkMsb0JBQW9CODdEO1lBQ3BCdjhELFlBQVk7UUFDZDtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ad2hpdGVib2FyZC93ZWIvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2ZhYnJpY0A1LjUuMi9ub2RlX21vZHVsZXMvZmFicmljL2Rpc3QvZmFicmljLmpzPzRlMmQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogYnVpbGQ6IGBub2RlIGJ1aWxkLmpzIG1vZHVsZXM9QUxMIGV4Y2x1ZGU9Z2VzdHVyZXMsYWNjZXNzb3JzLGVyYXNpbmcgcmVxdWlyZWpzIG1pbmlmaWVyPXVnbGlmeWpzYCAqL1xuLyohIEZhYnJpYy5qcyBDb3B5cmlnaHQgMjAwOC0yMDE1LCBQcmludGlvIChKdXJpeSBaYXl0c2V2LCBNYXhpbSBDaGVybnlhaykgKi9cblxudmFyIGZhYnJpYyA9IGZhYnJpYyB8fCB7IHZlcnNpb246ICc1LjUuMicgfTtcbmlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZXhwb3J0cy5mYWJyaWMgPSBmYWJyaWM7XG59XG4vKiBfQU1EX1NUQVJUXyAqL1xuZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7IHJldHVybiBmYWJyaWM7IH0pO1xufVxuLyogX0FNRF9FTkRfICovXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBpZiAoZG9jdW1lbnQgaW5zdGFuY2VvZiAodHlwZW9mIEhUTUxEb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBIVE1MRG9jdW1lbnQgOiBEb2N1bWVudCkpIHtcbiAgICBmYWJyaWMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgfVxuICBlbHNlIHtcbiAgICBmYWJyaWMuZG9jdW1lbnQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoJycpO1xuICB9XG4gIGZhYnJpYy53aW5kb3cgPSB3aW5kb3c7XG59XG5lbHNlIHtcbiAgLy8gYXNzdW1lIHdlJ3JlIHJ1bm5pbmcgdW5kZXIgbm9kZS5qcyB3aGVuIGRvY3VtZW50L3dpbmRvdyBhcmUgbm90IHByZXNlbnRcbiAgdmFyIGpzZG9tID0gcmVxdWlyZSgnanNkb20nKTtcbiAgdmFyIHZpcnR1YWxXaW5kb3cgPSBuZXcganNkb20uSlNET00oXG4gICAgZGVjb2RlVVJJQ29tcG9uZW50KCclM0MhRE9DVFlQRSUyMGh0bWwlM0UlM0NodG1sJTNFJTNDaGVhZCUzRSUzQyUyRmhlYWQlM0UlM0Nib2R5JTNFJTNDJTJGYm9keSUzRSUzQyUyRmh0bWwlM0UnKSxcbiAgICB7XG4gICAgICBmZWF0dXJlczoge1xuICAgICAgICBGZXRjaEV4dGVybmFsUmVzb3VyY2VzOiBbJ2ltZyddXG4gICAgICB9LFxuICAgICAgcmVzb3VyY2VzOiAndXNhYmxlJ1xuICAgIH0pLndpbmRvdztcbiAgZmFicmljLmRvY3VtZW50ID0gdmlydHVhbFdpbmRvdy5kb2N1bWVudDtcbiAgZmFicmljLmpzZG9tSW1wbEZvcldyYXBwZXIgPSByZXF1aXJlKCdqc2RvbS9saWIvanNkb20vbGl2aW5nL2dlbmVyYXRlZC91dGlscycpLmltcGxGb3JXcmFwcGVyO1xuICBmYWJyaWMubm9kZUNhbnZhcyA9IHJlcXVpcmUoJ2pzZG9tL2xpYi9qc2RvbS91dGlscycpLkNhbnZhcztcbiAgZmFicmljLndpbmRvdyA9IHZpcnR1YWxXaW5kb3c7XG4gIERPTVBhcnNlciA9IGZhYnJpYy53aW5kb3cuRE9NUGFyc2VyO1xufVxuXG4vKipcbiAqIFRydWUgd2hlbiBpbiBlbnZpcm9ubWVudCB0aGF0IHN1cHBvcnRzIHRvdWNoIGV2ZW50c1xuICogQHR5cGUgYm9vbGVhblxuICovXG5mYWJyaWMuaXNUb3VjaFN1cHBvcnRlZCA9ICdvbnRvdWNoc3RhcnQnIGluIGZhYnJpYy53aW5kb3cgfHwgJ29udG91Y2hzdGFydCcgaW4gZmFicmljLmRvY3VtZW50IHx8XG4gIChmYWJyaWMud2luZG93ICYmIGZhYnJpYy53aW5kb3cubmF2aWdhdG9yICYmIGZhYnJpYy53aW5kb3cubmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMCk7XG5cbi8qKlxuICogVHJ1ZSB3aGVuIGluIGVudmlyb25tZW50IHRoYXQncyBwcm9iYWJseSBOb2RlLmpzXG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbmZhYnJpYy5pc0xpa2VseU5vZGUgPSB0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnO1xuXG4vKiBfRlJPTV9TVkdfU1RBUlRfICovXG4vKipcbiAqIEF0dHJpYnV0ZXMgcGFyc2VkIGZyb20gYWxsIFNWRyBlbGVtZW50c1xuICogQHR5cGUgYXJyYXlcbiAqL1xuZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTID0gW1xuICAnZGlzcGxheScsXG4gICd0cmFuc2Zvcm0nLFxuICAnZmlsbCcsICdmaWxsLW9wYWNpdHknLCAnZmlsbC1ydWxlJyxcbiAgJ29wYWNpdHknLFxuICAnc3Ryb2tlJywgJ3N0cm9rZS1kYXNoYXJyYXknLCAnc3Ryb2tlLWxpbmVjYXAnLCAnc3Ryb2tlLWRhc2hvZmZzZXQnLFxuICAnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cm9rZS1taXRlcmxpbWl0JyxcbiAgJ3N0cm9rZS1vcGFjaXR5JywgJ3N0cm9rZS13aWR0aCcsXG4gICdpZCcsICdwYWludC1vcmRlcicsICd2ZWN0b3ItZWZmZWN0JyxcbiAgJ2luc3RhbnRpYXRlZF9ieV91c2UnLCAnY2xpcC1wYXRoJyxcbl07XG4vKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4vKipcbiAqIFBpeGVsIHBlciBJbmNoIGFzIGEgZGVmYXVsdCB2YWx1ZSBzZXQgdG8gOTYuIENhbiBiZSBjaGFuZ2VkIGZvciBtb3JlIHJlYWxpc3RpYyBjb252ZXJzaW9uLlxuICovXG5mYWJyaWMuRFBJID0gOTY7XG5mYWJyaWMucmVOdW0gPSAnKD86Wy0rXT8oPzpcXFxcZCt8XFxcXGQqXFxcXC5cXFxcZCspKD86W2VFXVstK10/XFxcXGQrKT8pJztcbmZhYnJpYy5jb21tYVdzcCA9ICcoPzpcXFxccyssP1xcXFxzKnwsXFxcXHMqKSc7XG5mYWJyaWMucmVQYXRoQ29tbWFuZCA9IC8oWy0rXT8oKFxcZCtcXC5cXGQrKXwoKFxcZCspfChcXC5cXGQrKSkpKD86W2VFXVstK10/XFxkKyk/KS9pZztcbmZhYnJpYy5yZU5vbldvcmQgPSAvWyBcXG5cXC4sOyFcXD9cXC1dLztcbmZhYnJpYy5mb250UGF0aHMgPSB7IH07XG5mYWJyaWMuaU1hdHJpeCA9IFsxLCAwLCAwLCAxLCAwLCAwXTtcbmZhYnJpYy5zdmdOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG5cbi8qKlxuICogUGl4ZWwgbGltaXQgZm9yIGNhY2hlIGNhbnZhc2VzLiAxTXB4ICwgNE1weCBzaG91bGQgYmUgZmluZS5cbiAqIEBzaW5jZSAxLjcuMTRcbiAqIEB0eXBlIE51bWJlclxuICogQGRlZmF1bHRcbiAqL1xuZmFicmljLnBlcmZMaW1pdFNpemVUb3RhbCA9IDIwOTcxNTI7XG5cbi8qKlxuICogUGl4ZWwgbGltaXQgZm9yIGNhY2hlIGNhbnZhc2VzIHdpZHRoIG9yIGhlaWdodC4gSUUgZml4ZXMgdGhlIG1heGltdW0gYXQgNTAwMFxuICogQHNpbmNlIDEuNy4xNFxuICogQHR5cGUgTnVtYmVyXG4gKiBAZGVmYXVsdFxuICovXG5mYWJyaWMubWF4Q2FjaGVTaWRlTGltaXQgPSA0MDk2O1xuXG4vKipcbiAqIExvd2VzdCBwaXhlbCBsaW1pdCBmb3IgY2FjaGUgY2FudmFzZXMsIHNldCBhdCAyNTZQWFxuICogQHNpbmNlIDEuNy4xNFxuICogQHR5cGUgTnVtYmVyXG4gKiBAZGVmYXVsdFxuICovXG5mYWJyaWMubWluQ2FjaGVTaWRlTGltaXQgPSAyNTY7XG5cbi8qKlxuICogQ2FjaGUgT2JqZWN0IGZvciB3aWR0aHMgb2YgY2hhcnMgaW4gdGV4dCByZW5kZXJpbmcuXG4gKi9cbmZhYnJpYy5jaGFyV2lkdGhzQ2FjaGUgPSB7IH07XG5cbi8qKlxuICogaWYgd2ViZ2wgaXMgZW5hYmxlZCBhbmQgYXZhaWxhYmxlLCB0ZXh0dXJlU2l6ZSB3aWxsIGRldGVybWluZSB0aGUgc2l6ZVxuICogb2YgdGhlIGNhbnZhcyBiYWNrZW5kXG4gKiBAc2luY2UgMi4wLjBcbiAqIEB0eXBlIE51bWJlclxuICogQGRlZmF1bHRcbiAqL1xuZmFicmljLnRleHR1cmVTaXplID0gMjA0ODtcblxuLyoqXG4gKiBXaGVuICd0cnVlJywgc3R5bGUgaW5mb3JtYXRpb24gaXMgbm90IHJldGFpbmVkIHdoZW4gY29weS9wYXN0aW5nIHRleHQsIG1ha2luZ1xuICogcGFzdGVkIHRleHQgdXNlIGRlc3RpbmF0aW9uIHN0eWxlLlxuICogRGVmYXVsdHMgdG8gJ2ZhbHNlJy5cbiAqIEB0eXBlIEJvb2xlYW5cbiAqIEBkZWZhdWx0XG4gKi9cbmZhYnJpYy5kaXNhYmxlU3R5bGVDb3B5UGFzdGUgPSBmYWxzZTtcblxuLyoqXG4gKiBFbmFibGUgd2ViZ2wgZm9yIGZpbHRlcmluZyBwaWN0dXJlIGlzIGF2YWlsYWJsZVxuICogQSBmaWx0ZXJpbmcgYmFja2VuZCB3aWxsIGJlIGluaXRpYWxpemVkLCB0aGlzIHdpbGwgYm90aCB0YWtlIG1lbW9yeSBhbmRcbiAqIHRpbWUgc2luY2UgYSBkZWZhdWx0IDIwNDh4MjA0OCBjYW52YXMgd2lsbCBiZSBjcmVhdGVkIGZvciB0aGUgZ2wgY29udGV4dFxuICogQHNpbmNlIDIuMC4wXG4gKiBAdHlwZSBCb29sZWFuXG4gKiBAZGVmYXVsdFxuICovXG5mYWJyaWMuZW5hYmxlR0xGaWx0ZXJpbmcgPSB0cnVlO1xuXG4vKipcbiAqIERldmljZSBQaXhlbCBSYXRpb1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vbGlicmFyeS9zYWZhcmkvZG9jdW1lbnRhdGlvbi9BdWRpb1ZpZGVvL0NvbmNlcHR1YWwvSFRNTC1jYW52YXMtZ3VpZGUvU2V0dGluZ1VwdGhlQ2FudmFzL1NldHRpbmdVcHRoZUNhbnZhcy5odG1sXG4gKi9cbmZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvID0gZmFicmljLndpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZhYnJpYy53aW5kb3cud2Via2l0RGV2aWNlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWJyaWMud2luZG93Lm1vekRldmljZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMTtcbi8qKlxuICogQnJvd3Nlci1zcGVjaWZpYyBjb25zdGFudCB0byBhZGp1c3QgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnNoYWRvd0JsdXIgdmFsdWUsXG4gKiB3aGljaCBpcyB1bml0bGVzcyBhbmQgbm90IHJlbmRlcmVkIGVxdWFsbHkgYWNyb3NzIGJyb3dzZXJzLlxuICpcbiAqIFZhbHVlcyB0aGF0IHdvcmsgcXVpdGUgd2VsbCAoYXMgb2YgT2N0b2JlciAyMDE3KSBhcmU6XG4gKiAtIENocm9tZTogMS41XG4gKiAtIEVkZ2U6IDEuNzVcbiAqIC0gRmlyZWZveDogMC45XG4gKiAtIFNhZmFyaTogMC45NVxuICpcbiAqIEBzaW5jZSAyLjAuMFxuICogQHR5cGUgTnVtYmVyXG4gKiBAZGVmYXVsdCAxXG4gKi9cbmZhYnJpYy5icm93c2VyU2hhZG93Qmx1ckNvbnN0YW50ID0gMTtcblxuLyoqXG4gKiBUaGlzIG9iamVjdCBjb250YWlucyB0aGUgcmVzdWx0IG9mIGFyYyB0byBiZXppZXIgY29udmVyc2lvbiBmb3IgZmFzdGVyIHJldHJpZXZpbmcgaWYgdGhlIHNhbWUgYXJjIG5lZWRzIHRvIGJlIGNvbnZlcnRlZCBhZ2Fpbi5cbiAqIEl0IHdhcyBhbiBpbnRlcm5hbCB2YXJpYWJsZSwgaXMgYWNjZXNzaWJsZSBzaW5jZSB2ZXJzaW9uIDIuMy40XG4gKi9cbmZhYnJpYy5hcmNUb1NlZ21lbnRzQ2FjaGUgPSB7IH07XG5cbi8qKlxuICogVGhpcyBvYmplY3Qga2VlcHMgdGhlIHJlc3VsdHMgb2YgdGhlIGJvdW5kc09mQ3VydmUgY2FsY3VsYXRpb24gbWFwcGVkIGJ5IHRoZSBqb2luZWQgYXJndW1lbnRzIG5lY2Vzc2FyeSB0byBjYWxjdWxhdGUgaXQuXG4gKiBJdCBkb2VzIHNwZWVkIHVwIGNhbGN1bGF0aW9uLCBpZiB5b3UgcGFyc2UgYW5kIGFkZCBhbHdheXMgdGhlIHNhbWUgcGF0aHMsIGJ1dCBpbiBjYXNlIG9mIGhlYXZ5IHVzYWdlIG9mIGZyZWVkcmF3aW5nXG4gKiB5b3UgZG8gbm90IGdldCBhbnkgc3BlZWQgYmVuZWZpdCBhbmQgeW91IGdldCBhIGJpZyBvYmplY3QgaW4gbWVtb3J5LlxuICogVGhlIG9iamVjdCB3YXMgYSBwcml2YXRlIHZhcmlhYmxlIGJlZm9yZSwgd2hpbGUgbm93IGlzIGFwcGVuZGVkIHRvIHRoZSBsaWIgc28gdGhhdCB5b3UgaGF2ZSBhY2Nlc3MgdG8gaXQgYW5kIHlvdVxuICogY2FuIGV2ZW50dWFsbHkgY2xlYXIgaXQuXG4gKiBJdCB3YXMgYW4gaW50ZXJuYWwgdmFyaWFibGUsIGlzIGFjY2Vzc2libGUgc2luY2UgdmVyc2lvbiAyLjMuNFxuICovXG5mYWJyaWMuYm91bmRzT2ZDdXJ2ZUNhY2hlID0geyB9O1xuXG4vKipcbiAqIElmIGRpc2FibGVkIGJvdW5kc09mQ3VydmVDYWNoZSBpcyBub3QgdXNlZC4gRm9yIGFwcHMgdGhhdCBtYWtlIGhlYXZ5IHVzYWdlIG9mIHBlbmNpbCBkcmF3aW5nIHByb2JhYmx5IGRpc2FibGluZyBpdCBpcyBiZXR0ZXJcbiAqIEBkZWZhdWx0IHRydWVcbiAqL1xuZmFicmljLmNhY2hlc0JvdW5kc09mQ3VydmUgPSB0cnVlO1xuXG4vKipcbiAqIFNraXAgcGVyZm9ybWFuY2UgdGVzdGluZyBvZiBzZXR1cEdMQ29udGV4dCBhbmQgZm9yY2UgdGhlIHVzZSBvZiBwdXRJbWFnZURhdGEgdGhhdCBzZWVtcyB0byBiZSB0aGUgb25lIHRoYXQgd29ya3MgYmVzdCBvblxuICogQ2hyb21lICsgb2xkIGhhcmR3YXJlLiBpZiB5b3VyIHVzZXJzIGFyZSBleHBlcmllbmNpbmcgZW1wdHkgaW1hZ2VzIGFmdGVyIGZpbHRlcmluZyB5b3UgbWF5IHRyeSB0byBmb3JjZSB0aGlzIHRvIHRydWVcbiAqIHRoaXMgaGFzIHRvIGJlIHNldCBiZWZvcmUgaW5zdGFudGlhdGluZyB0aGUgZmlsdGVyaW5nIGJhY2tlbmQgKCBiZWZvcmUgZmlsdGVyaW5nIHRoZSBmaXJzdCBpbWFnZSApXG4gKiBAdHlwZSBCb29sZWFuXG4gKiBAZGVmYXVsdCBmYWxzZVxuICovXG5mYWJyaWMuZm9yY2VHTFB1dEltYWdlRGF0YSA9IGZhbHNlO1xuXG5mYWJyaWMuaW5pdEZpbHRlckJhY2tlbmQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKGZhYnJpYy5lbmFibGVHTEZpbHRlcmluZyAmJiBmYWJyaWMuaXNXZWJnbFN1cHBvcnRlZCAmJiBmYWJyaWMuaXNXZWJnbFN1cHBvcnRlZChmYWJyaWMudGV4dHVyZVNpemUpKSB7XG4gICAgY29uc29sZS5sb2coJ21heCB0ZXh0dXJlIHNpemU6ICcgKyBmYWJyaWMubWF4VGV4dHVyZVNpemUpO1xuICAgIHJldHVybiAobmV3IGZhYnJpYy5XZWJnbEZpbHRlckJhY2tlbmQoeyB0aWxlU2l6ZTogZmFicmljLnRleHR1cmVTaXplIH0pKTtcbiAgfVxuICBlbHNlIGlmIChmYWJyaWMuQ2FudmFzMmRGaWx0ZXJCYWNrZW5kKSB7XG4gICAgcmV0dXJuIChuZXcgZmFicmljLkNhbnZhczJkRmlsdGVyQmFja2VuZCgpKTtcbiAgfVxufTtcblxuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAvLyBlbnN1cmUgZ2xvYmFsaXR5IGV2ZW4gaWYgZW50aXJlIGxpYnJhcnkgd2VyZSBmdW5jdGlvbiB3cmFwcGVkIChhcyBpbiBNZXRlb3IuanMgcGFja2FnaW5nIHN5c3RlbSlcbiAgd2luZG93LmZhYnJpYyA9IGZhYnJpYztcbn1cblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZnVuY3Rpb24gX3JlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgaWYgKCF0aGlzLl9fZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZXZlbnRMaXN0ZW5lciA9IHRoaXMuX19ldmVudExpc3RlbmVyc1tldmVudE5hbWVdO1xuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICBldmVudExpc3RlbmVyW2V2ZW50TGlzdGVuZXIuaW5kZXhPZihoYW5kbGVyKV0gPSBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmYWJyaWMudXRpbC5hcnJheS5maWxsKGV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT2JzZXJ2ZXMgc3BlY2lmaWVkIGV2ZW50XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JzZXJ2YWJsZVxuICAgKiBAYWxpYXMgb25cbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBldmVudE5hbWUgRXZlbnQgbmFtZSAoZWcuICdhZnRlcjpyZW5kZXInKSBvciBvYmplY3Qgd2l0aCBrZXkvdmFsdWUgcGFpcnMgKGVnLiB7J2FmdGVyOnJlbmRlcic6IGhhbmRsZXIsICdzZWxlY3Rpb246Y2xlYXJlZCc6IGhhbmRsZXJ9KVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIEZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYSBub3RpZmljYXRpb24gd2hlbiBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgb2NjdXJzXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZnVuY3Rpb24gb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgaWYgKCF0aGlzLl9fZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX19ldmVudExpc3RlbmVycyA9IHsgfTtcbiAgICB9XG4gICAgLy8gb25lIG9iamVjdCB3aXRoIGtleS92YWx1ZSBwYWlycyB3YXMgcGFzc2VkXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gZXZlbnROYW1lKSB7XG4gICAgICAgIHRoaXMub24ocHJvcCwgZXZlbnROYW1lW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuX19ldmVudExpc3RlbmVyc1tldmVudE5hbWVdKSB7XG4gICAgICAgIHRoaXMuX19ldmVudExpc3RlbmVyc1tldmVudE5hbWVdID0gW107XG4gICAgICB9XG4gICAgICB0aGlzLl9fZXZlbnRMaXN0ZW5lcnNbZXZlbnROYW1lXS5wdXNoKGhhbmRsZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZ1bmN0aW9uIF9vbmNlKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIHZhciBfaGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMub2ZmKGV2ZW50TmFtZSwgX2hhbmRsZXIpO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uKGV2ZW50TmFtZSwgX2hhbmRsZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25jZShldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAvLyBvbmUgb2JqZWN0IHdpdGgga2V5L3ZhbHVlIHBhaXJzIHdhcyBwYXNzZWRcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBldmVudE5hbWUpIHtcbiAgICAgICAgX29uY2UuY2FsbCh0aGlzLCBwcm9wLCBldmVudE5hbWVbcHJvcF0pO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIF9vbmNlLmNhbGwodGhpcywgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgZXZlbnQgb2JzZXJ2aW5nIGZvciBhIHBhcnRpY3VsYXIgZXZlbnQgaGFuZGxlci4gQ2FsbGluZyB0aGlzIG1ldGhvZFxuICAgKiB3aXRob3V0IGFyZ3VtZW50cyByZW1vdmVzIGFsbCBoYW5kbGVycyBmb3IgYWxsIGV2ZW50c1xuICAgKiBAbWVtYmVyT2YgZmFicmljLk9ic2VydmFibGVcbiAgICogQGFsaWFzIG9mZlxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGV2ZW50TmFtZSBFdmVudCBuYW1lIChlZy4gJ2FmdGVyOnJlbmRlcicpIG9yIG9iamVjdCB3aXRoIGtleS92YWx1ZSBwYWlycyAoZWcuIHsnYWZ0ZXI6cmVuZGVyJzogaGFuZGxlciwgJ3NlbGVjdGlvbjpjbGVhcmVkJzogaGFuZGxlcn0pXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgRnVuY3Rpb24gdG8gYmUgZGVsZXRlZCBmcm9tIEV2ZW50TGlzdGVuZXJzXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZnVuY3Rpb24gb2ZmKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIGlmICghdGhpcy5fX2V2ZW50TGlzdGVuZXJzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYWxsIGtleS92YWx1ZSBwYWlycyAoZXZlbnQgbmFtZSAtPiBldmVudCBoYW5kbGVyKVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBmb3IgKGV2ZW50TmFtZSBpbiB0aGlzLl9fZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgX3JlbW92ZUV2ZW50TGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBvbmUgb2JqZWN0IHdpdGgga2V5L3ZhbHVlIHBhaXJzIHdhcyBwYXNzZWRcbiAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIGV2ZW50TmFtZSkge1xuICAgICAgICBfcmVtb3ZlRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIHByb3AsIGV2ZW50TmFtZVtwcm9wXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgX3JlbW92ZUV2ZW50TGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyBldmVudCB3aXRoIGFuIG9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JzZXJ2YWJsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWUgdG8gZmlyZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZnVuY3Rpb24gZmlyZShldmVudE5hbWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuX19ldmVudExpc3RlbmVycykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGxpc3RlbmVyc0ZvckV2ZW50ID0gdGhpcy5fX2V2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV07XG4gICAgaWYgKCFsaXN0ZW5lcnNGb3JFdmVudCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVyc0ZvckV2ZW50Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBsaXN0ZW5lcnNGb3JFdmVudFtpXSAmJiBsaXN0ZW5lcnNGb3JFdmVudFtpXS5jYWxsKHRoaXMsIG9wdGlvbnMgfHwgeyB9KTtcbiAgICB9XG4gICAgdGhpcy5fX2V2ZW50TGlzdGVuZXJzW2V2ZW50TmFtZV0gPSBsaXN0ZW5lcnNGb3JFdmVudC5maWx0ZXIoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAhPT0gZmFsc2U7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWVzcGFjZSBmYWJyaWMuT2JzZXJ2YWJsZVxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMiNldmVudHN9XG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZXZlbnRzfEV2ZW50cyBkZW1vfVxuICAgKi9cbiAgZmFicmljLk9ic2VydmFibGUgPSB7XG4gICAgZmlyZTogZmlyZSxcbiAgICBvbjogb24sXG4gICAgb25jZTogb25jZSxcbiAgICBvZmY6IG9mZixcbiAgfTtcbn0pKCk7XG5cblxuLyoqXG4gKiBAbmFtZXNwYWNlIGZhYnJpYy5Db2xsZWN0aW9uXG4gKi9cbmZhYnJpYy5Db2xsZWN0aW9uID0ge1xuXG4gIF9vYmplY3RzOiBbXSxcblxuICAvKipcbiAgICogQWRkcyBvYmplY3RzIHRvIGNvbGxlY3Rpb24sIENhbnZhcyBvciBHcm91cCwgdGhlbiByZW5kZXJzIGNhbnZhc1xuICAgKiAoaWYgYHJlbmRlck9uQWRkUmVtb3ZlYCBpcyBub3QgYGZhbHNlYCkuXG4gICAqIGluIGNhc2Ugb2YgR3JvdXAgbm8gY2hhbmdlcyB0byBib3VuZGluZyBib3ggYXJlIG1hZGUuXG4gICAqIE9iamVjdHMgc2hvdWxkIGJlIGluc3RhbmNlcyBvZiAob3IgaW5oZXJpdCBmcm9tKSBmYWJyaWMuT2JqZWN0XG4gICAqIFVzZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIGhpZ2hseSBkaXNjb3VyYWdlZCBmb3IgZ3JvdXBzLlxuICAgKiB5b3UgY2FuIGFkZCBhIGJ1bmNoIG9mIG9iamVjdHMgd2l0aCB0aGUgYWRkIG1ldGhvZCBidXQgdGhlbiB5b3UgTkVFRFxuICAgKiB0byBydW4gYSBhZGRXaXRoVXBkYXRlIGNhbGwgZm9yIHRoZSBHcm91cCBjbGFzcyBvciBwb3NpdGlvbi9iYm94IHdpbGwgYmUgd3JvbmcuXG4gICAqIEBwYXJhbSB7Li4uZmFicmljLk9iamVjdH0gb2JqZWN0IFplcm8gb3IgbW9yZSBmYWJyaWMgaW5zdGFuY2VzXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgYWRkOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fb2JqZWN0cy5wdXNoLmFwcGx5KHRoaXMuX29iamVjdHMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHRoaXMuX29uT2JqZWN0QWRkZWQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fb25PYmplY3RBZGRlZChhcmd1bWVudHNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIGFuIG9iamVjdCBpbnRvIGNvbGxlY3Rpb24gYXQgc3BlY2lmaWVkIGluZGV4LCB0aGVuIHJlbmRlcnMgY2FudmFzIChpZiBgcmVuZGVyT25BZGRSZW1vdmVgIGlzIG5vdCBgZmFsc2VgKVxuICAgKiBBbiBvYmplY3Qgc2hvdWxkIGJlIGFuIGluc3RhbmNlIG9mIChvciBpbmhlcml0IGZyb20pIGZhYnJpYy5PYmplY3RcbiAgICogVXNlIG9mIHRoaXMgZnVuY3Rpb24gaXMgaGlnaGx5IGRpc2NvdXJhZ2VkIGZvciBncm91cHMuXG4gICAqIHlvdSBjYW4gYWRkIGEgYnVuY2ggb2Ygb2JqZWN0cyB3aXRoIHRoZSBpbnNlcnRBdCBtZXRob2QgYnV0IHRoZW4geW91IE5FRURcbiAgICogdG8gcnVuIGEgYWRkV2l0aFVwZGF0ZSBjYWxsIGZvciB0aGUgR3JvdXAgY2xhc3Mgb3IgcG9zaXRpb24vYmJveCB3aWxsIGJlIHdyb25nLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBpbnNlcnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IEluZGV4IHRvIGluc2VydCBvYmplY3QgYXRcbiAgICogQHBhcmFtIHtCb29sZWFufSBub25TcGxpY2luZyBXaGVuIGB0cnVlYCwgbm8gc3BsaWNpbmcgKHNoaWZ0aW5nKSBvZiBvYmplY3RzIG9jY3Vyc1xuICAgKiBAcmV0dXJuIHtTZWxmfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIGluc2VydEF0OiBmdW5jdGlvbiAob2JqZWN0LCBpbmRleCwgbm9uU3BsaWNpbmcpIHtcbiAgICB2YXIgb2JqZWN0cyA9IHRoaXMuX29iamVjdHM7XG4gICAgaWYgKG5vblNwbGljaW5nKSB7XG4gICAgICBvYmplY3RzW2luZGV4XSA9IG9iamVjdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBvYmplY3RzLnNwbGljZShpbmRleCwgMCwgb2JqZWN0KTtcbiAgICB9XG4gICAgdGhpcy5fb25PYmplY3RBZGRlZCAmJiB0aGlzLl9vbk9iamVjdEFkZGVkKG9iamVjdCk7XG4gICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyBvYmplY3RzIGZyb20gYSBjb2xsZWN0aW9uLCB0aGVuIHJlbmRlcnMgY2FudmFzIChpZiBgcmVuZGVyT25BZGRSZW1vdmVgIGlzIG5vdCBgZmFsc2VgKVxuICAgKiBAcGFyYW0gey4uLmZhYnJpYy5PYmplY3R9IG9iamVjdCBaZXJvIG9yIG1vcmUgZmFicmljIGluc3RhbmNlc1xuICAgKiBAcmV0dXJuIHtTZWxmfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLFxuICAgICAgICBpbmRleCwgc29tZXRoaW5nUmVtb3ZlZCA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaW5kZXggPSBvYmplY3RzLmluZGV4T2YoYXJndW1lbnRzW2ldKTtcblxuICAgICAgLy8gb25seSBjYWxsIG9uT2JqZWN0UmVtb3ZlZCBpZiBhbiBvYmplY3Qgd2FzIGFjdHVhbGx5IHJlbW92ZWRcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgc29tZXRoaW5nUmVtb3ZlZCA9IHRydWU7XG4gICAgICAgIG9iamVjdHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5fb25PYmplY3RSZW1vdmVkICYmIHRoaXMuX29uT2JqZWN0UmVtb3ZlZChhcmd1bWVudHNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgc29tZXRoaW5nUmVtb3ZlZCAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogRXhlY3V0ZXMgZ2l2ZW4gZnVuY3Rpb24gZm9yIGVhY2ggb2JqZWN0IGluIHRoaXMgZ3JvdXBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogICAgICAgICAgICAgICAgICAgQ2FsbGJhY2sgaW52b2tlZCB3aXRoIGN1cnJlbnQgb2JqZWN0IGFzIGZpcnN0IGFyZ3VtZW50LFxuICAgKiAgICAgICAgICAgICAgICAgICBpbmRleCAtIGFzIHNlY29uZCBhbmQgYW4gYXJyYXkgb2YgYWxsIG9iamVjdHMgLSBhcyB0aGlyZC5cbiAgICogICAgICAgICAgICAgICAgICAgQ2FsbGJhY2sgaXMgaW52b2tlZCBpbiBhIGNvbnRleHQgb2YgR2xvYmFsIE9iamVjdCAoZS5nLiBgd2luZG93YClcbiAgICogICAgICAgICAgICAgICAgICAgd2hlbiBubyBgY29udGV4dGAgYXJndW1lbnQgaXMgZ2l2ZW5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgQ29udGV4dCAoYWthIHRoaXNPYmplY3QpXG4gICAqIEByZXR1cm4ge1NlbGZ9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgZm9yRWFjaE9iamVjdDogZnVuY3Rpb24oY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB2YXIgb2JqZWN0cyA9IHRoaXMuZ2V0T2JqZWN0cygpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIG9iamVjdHNbaV0sIGksIG9iamVjdHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBjaGlsZHJlbiBvYmplY3RzIG9mIHRoaXMgaW5zdGFuY2VcbiAgICogVHlwZSBwYXJhbWV0ZXIgaW50cm9kdWNlZCBpbiAxLjMuMTBcbiAgICogc2luY2UgMi4zLjUgdGhpcyBtZXRob2QgcmV0dXJuIGFsd2F5cyBhIENPUFkgb2YgdGhlIGFycmF5O1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW3R5cGVdIFdoZW4gc3BlY2lmaWVkLCBvbmx5IG9iamVjdHMgb2YgdGhpcyB0eXBlIGFyZSByZXR1cm5lZFxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGdldE9iamVjdHM6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2JqZWN0cy5jb25jYXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX29iamVjdHMuZmlsdGVyKGZ1bmN0aW9uKG8pIHtcbiAgICAgIHJldHVybiBvLnR5cGUgPT09IHR5cGU7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgb2JqZWN0IGF0IHNwZWNpZmllZCBpbmRleFxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHJldHVybiB7U2VsZn0gdGhpc0FyZ1xuICAgKi9cbiAgaXRlbTogZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX29iamVjdHNbaW5kZXhdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgY29sbGVjdGlvbiBjb250YWlucyBubyBvYmplY3RzXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgY29sbGVjdGlvbiBpcyBlbXB0eVxuICAgKi9cbiAgaXNFbXB0eTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9vYmplY3RzLmxlbmd0aCA9PT0gMDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHNpemUgb2YgYSBjb2xsZWN0aW9uIChpLmU6IGxlbmd0aCBvZiBhbiBhcnJheSBjb250YWluaW5nIGl0cyBvYmplY3RzKVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IENvbGxlY3Rpb24gc2l6ZVxuICAgKi9cbiAgc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX29iamVjdHMubGVuZ3RoO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgY29sbGVjdGlvbiBjb250YWlucyBhbiBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2hlY2sgYWdhaW5zdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkZWVwPWZhbHNlXSBgdHJ1ZWAgdG8gY2hlY2sgYWxsIGRlc2NlbmRhbnRzLCBgZmFsc2VgIHRvIGNoZWNrIG9ubHkgYF9vYmplY3RzYFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgY29sbGVjdGlvbiBjb250YWlucyBhbiBvYmplY3RcbiAgICovXG4gIGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqZWN0LCBkZWVwKSB7XG4gICAgaWYgKHRoaXMuX29iamVjdHMuaW5kZXhPZihvYmplY3QpID4gLTEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChkZWVwKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2JqZWN0cy5zb21lKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmouY29udGFpbnMgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnRhaW5zKG9iamVjdCwgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG51bWJlciByZXByZXNlbnRhdGlvbiBvZiBhIGNvbGxlY3Rpb24gY29tcGxleGl0eVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBsZXhpdHlcbiAgICovXG4gIGNvbXBsZXhpdHk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fb2JqZWN0cy5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGN1cnJlbnQpIHtcbiAgICAgIG1lbW8gKz0gY3VycmVudC5jb21wbGV4aXR5ID8gY3VycmVudC5jb21wbGV4aXR5KCkgOiAwO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSwgMCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAbmFtZXNwYWNlIGZhYnJpYy5Db21tb25NZXRob2RzXG4gKi9cbmZhYnJpYy5Db21tb25NZXRob2RzID0ge1xuXG4gIC8qKlxuICAgKiBTZXRzIG9iamVjdCdzIHByb3BlcnRpZXMgZnJvbSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIF9zZXRPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzLnNldChwcm9wLCBvcHRpb25zW3Byb3BdKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZmlsbGVyXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5XSBwcm9wZXJ0eSB0byBzZXQgdGhlIEdyYWRpZW50IHRvXG4gICAqL1xuICBfaW5pdEdyYWRpZW50OiBmdW5jdGlvbihmaWxsZXIsIHByb3BlcnR5KSB7XG4gICAgaWYgKGZpbGxlciAmJiBmaWxsZXIuY29sb3JTdG9wcyAmJiAhKGZpbGxlciBpbnN0YW5jZW9mIGZhYnJpYy5HcmFkaWVudCkpIHtcbiAgICAgIHRoaXMuc2V0KHByb3BlcnR5LCBuZXcgZmFicmljLkdyYWRpZW50KGZpbGxlcikpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtmaWxsZXJdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldIHByb3BlcnR5IHRvIHNldCB0aGUgUGF0dGVybiB0b1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIGNhbGxiYWNrIHRvIGludm9rZSBhZnRlciBwYXR0ZXJuIGxvYWRcbiAgICovXG4gIF9pbml0UGF0dGVybjogZnVuY3Rpb24oZmlsbGVyLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICBpZiAoZmlsbGVyICYmIGZpbGxlci5zb3VyY2UgJiYgIShmaWxsZXIgaW5zdGFuY2VvZiBmYWJyaWMuUGF0dGVybikpIHtcbiAgICAgIHRoaXMuc2V0KHByb3BlcnR5LCBuZXcgZmFicmljLlBhdHRlcm4oZmlsbGVyLCBjYWxsYmFjaykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldE9iamVjdDogZnVuY3Rpb24ob2JqKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICAgIHRoaXMuX3NldChwcm9wLCBvYmpbcHJvcF0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBwcm9wZXJ0eSB0byBhIGdpdmVuIHZhbHVlLiBXaGVuIGNoYW5naW5nIHBvc2l0aW9uL2RpbWVuc2lvbiAtcmVsYXRlZCBwcm9wZXJ0aWVzIChsZWZ0LCB0b3AsIHNjYWxlLCBhbmdsZSwgZXRjLikgYHNldGAgZG9lcyBub3QgdXBkYXRlIHBvc2l0aW9uIG9mIG9iamVjdCdzIGJvcmRlcnMvY29udHJvbHMuIElmIHlvdSBuZWVkIHRvIHVwZGF0ZSB0aG9zZSwgY2FsbCBgc2V0Q29vcmRzKClgLlxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGtleSBQcm9wZXJ0eSBuYW1lIG9yIG9iamVjdCAoaWYgb2JqZWN0LCBpdGVyYXRlIG92ZXIgdGhlIG9iamVjdCBwcm9wZXJ0aWVzKVxuICAgKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gdmFsdWUgUHJvcGVydHkgdmFsdWUgKGlmIGZ1bmN0aW9uLCB0aGUgdmFsdWUgaXMgcGFzc2VkIGludG8gaXQgYW5kIGl0cyByZXR1cm4gdmFsdWUgaXMgdXNlZCBhcyBhIG5ldyBvbmUpXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICB0aGlzLl9zZXRPYmplY3Qoa2V5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl9zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogVG9nZ2xlcyBzcGVjaWZpZWQgcHJvcGVydHkgZnJvbSBgdHJ1ZWAgdG8gYGZhbHNlYCBvciBmcm9tIGBmYWxzZWAgdG8gYHRydWVgXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0byB0b2dnbGVcbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICB0b2dnbGU6IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQocHJvcGVydHkpO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgdGhpcy5zZXQocHJvcGVydHksICF2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBCYXNpYyBnZXR0ZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICogQHJldHVybiB7Kn0gdmFsdWUgb2YgYSBwcm9wZXJ0eVxuICAgKi9cbiAgZ2V0OiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgIHJldHVybiB0aGlzW3Byb3BlcnR5XTtcbiAgfVxufTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgdmFyIHNxcnQgPSBNYXRoLnNxcnQsXG4gICAgICBhdGFuMiA9IE1hdGguYXRhbjIsXG4gICAgICBwb3cgPSBNYXRoLnBvdyxcbiAgICAgIFBpQnkxODAgPSBNYXRoLlBJIC8gMTgwLFxuICAgICAgUGlCeTIgPSBNYXRoLlBJIC8gMjtcblxuICAvKipcbiAgICogQG5hbWVzcGFjZSBmYWJyaWMudXRpbFxuICAgKi9cbiAgZmFicmljLnV0aWwgPSB7XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGNvcyBvZiBhbiBhbmdsZSwgYXZvaWRpbmcgcmV0dXJuaW5nIGZsb2F0cyBmb3Iga25vd24gcmVzdWx0c1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgdGhlIGFuZ2xlIGluIHJhZGlhbnMgb3IgaW4gZGVncmVlXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGNvczogZnVuY3Rpb24oYW5nbGUpIHtcbiAgICAgIGlmIChhbmdsZSA9PT0gMCkgeyByZXR1cm4gMTsgfVxuICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICAvLyBjb3MoYSkgPSBjb3MoLWEpXG4gICAgICAgIGFuZ2xlID0gLWFuZ2xlO1xuICAgICAgfVxuICAgICAgdmFyIGFuZ2xlU2xpY2UgPSBhbmdsZSAvIFBpQnkyO1xuICAgICAgc3dpdGNoIChhbmdsZVNsaWNlKSB7XG4gICAgICAgIGNhc2UgMTogY2FzZSAzOiByZXR1cm4gMDtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC5jb3MoYW5nbGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHNpbiBvZiBhbiBhbmdsZSwgYXZvaWRpbmcgcmV0dXJuaW5nIGZsb2F0cyBmb3Iga25vd24gcmVzdWx0c1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgdGhlIGFuZ2xlIGluIHJhZGlhbnMgb3IgaW4gZGVncmVlXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIHNpbjogZnVuY3Rpb24oYW5nbGUpIHtcbiAgICAgIGlmIChhbmdsZSA9PT0gMCkgeyByZXR1cm4gMDsgfVxuICAgICAgdmFyIGFuZ2xlU2xpY2UgPSBhbmdsZSAvIFBpQnkyLCBzaWduID0gMTtcbiAgICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgLy8gc2luKC1hKSA9IC1zaW4oYSlcbiAgICAgICAgc2lnbiA9IC0xO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChhbmdsZVNsaWNlKSB7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIHNpZ247XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIDA7XG4gICAgICAgIGNhc2UgMzogcmV0dXJuIC1zaWduO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGguc2luKGFuZ2xlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB2YWx1ZSBmcm9tIGFuIGFycmF5LlxuICAgICAqIFByZXNlbmNlIG9mIHZhbHVlIChhbmQgaXRzIHBvc2l0aW9uIGluIGFuIGFycmF5KSBpcyBkZXRlcm1pbmVkIHZpYSBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBvcmlnaW5hbCBhcnJheVxuICAgICAqL1xuICAgIHJlbW92ZUZyb21BcnJheTogZnVuY3Rpb24oYXJyYXksIHZhbHVlKSB7XG4gICAgICB2YXIgaWR4ID0gYXJyYXkuaW5kZXhPZih2YWx1ZSk7XG4gICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICBhcnJheS5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyByYW5kb20gbnVtYmVyIGJldHdlZW4gMiBzcGVjaWZpZWQgb25lcy5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1pbiBsb3dlciBsaW1pdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXggdXBwZXIgbGltaXRcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHJhbmRvbSB2YWx1ZSAoYmV0d2VlbiBtaW4gYW5kIG1heClcbiAgICAgKi9cbiAgICBnZXRSYW5kb21JbnQ6IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBkZWdyZWVzIHRvIHJhZGlhbnMuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWdyZWVzIHZhbHVlIGluIGRlZ3JlZXNcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHZhbHVlIGluIHJhZGlhbnNcbiAgICAgKi9cbiAgICBkZWdyZWVzVG9SYWRpYW5zOiBmdW5jdGlvbihkZWdyZWVzKSB7XG4gICAgICByZXR1cm4gZGVncmVlcyAqIFBpQnkxODA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgcmFkaWFucyB0byBkZWdyZWVzLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaWFucyB2YWx1ZSBpbiByYWRpYW5zXG4gICAgICogQHJldHVybiB7TnVtYmVyfSB2YWx1ZSBpbiBkZWdyZWVzXG4gICAgICovXG4gICAgcmFkaWFuc1RvRGVncmVlczogZnVuY3Rpb24ocmFkaWFucykge1xuICAgICAgcmV0dXJuIHJhZGlhbnMgLyBQaUJ5MTgwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSb3RhdGVzIGBwb2ludGAgYXJvdW5kIGBvcmlnaW5gIHdpdGggYHJhZGlhbnNgXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCBUaGUgcG9pbnQgdG8gcm90YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IG9yaWdpbiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpYW5zIFRoZSByYWRpYW5zIG9mIHRoZSBhbmdsZSBmb3IgdGhlIHJvdGF0aW9uXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSBUaGUgbmV3IHJvdGF0ZWQgcG9pbnRcbiAgICAgKi9cbiAgICByb3RhdGVQb2ludDogZnVuY3Rpb24ocG9pbnQsIG9yaWdpbiwgcmFkaWFucykge1xuICAgICAgdmFyIG5ld1BvaW50ID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludC54IC0gb3JpZ2luLngsIHBvaW50LnkgLSBvcmlnaW4ueSksXG4gICAgICAgICAgdiA9IGZhYnJpYy51dGlsLnJvdGF0ZVZlY3RvcihuZXdQb2ludCwgcmFkaWFucyk7XG4gICAgICByZXR1cm4gbmV3IGZhYnJpYy5Qb2ludCh2LngsIHYueSkuYWRkRXF1YWxzKG9yaWdpbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJvdGF0ZXMgYHZlY3RvcmAgd2l0aCBgcmFkaWFuc2BcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZlY3RvciBUaGUgdmVjdG9yIHRvIHJvdGF0ZSAoeCBhbmQgeSlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaWFucyBUaGUgcmFkaWFucyBvZiB0aGUgYW5nbGUgZm9yIHRoZSByb3RhdGlvblxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyByb3RhdGVkIHBvaW50XG4gICAgICovXG4gICAgcm90YXRlVmVjdG9yOiBmdW5jdGlvbih2ZWN0b3IsIHJhZGlhbnMpIHtcbiAgICAgIHZhciBzaW4gPSBmYWJyaWMudXRpbC5zaW4ocmFkaWFucyksXG4gICAgICAgICAgY29zID0gZmFicmljLnV0aWwuY29zKHJhZGlhbnMpLFxuICAgICAgICAgIHJ4ID0gdmVjdG9yLnggKiBjb3MgLSB2ZWN0b3IueSAqIHNpbixcbiAgICAgICAgICByeSA9IHZlY3Rvci54ICogc2luICsgdmVjdG9yLnkgKiBjb3M7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiByeCxcbiAgICAgICAgeTogcnlcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB2ZXRvciBmcm9tIHBvaW50cyByZXByZXNlbnRlZCBhcyBhIHBvaW50XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUG9pbnRcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0geFxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBmcm9tXG4gICAgICogQHBhcmFtIHtQb2ludH0gdG9cbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9IHZlY3RvclxuICAgICAqL1xuICAgIGNyZWF0ZVZlY3RvcjogZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgICByZXR1cm4gbmV3IGZhYnJpYy5Qb2ludCh0by54IC0gZnJvbS54LCB0by55IC0gZnJvbS55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBhbmdsZSBiZXR3ZWVuIDIgdmVjdG9ycyB1c2luZyBkb3QgcHJvZHVjdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBhXG4gICAgICogQHBhcmFtIHtQb2ludH0gYlxuICAgICAqIEByZXR1cm5zIHRoZSBhbmdsZSBpbiByYWRpYW4gYmV0d2VlbiB0aGUgdmVjdG9yc1xuICAgICAqL1xuICAgIGNhbGNBbmdsZUJldHdlZW5WZWN0b3JzOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIE1hdGguYWNvcygoYS54ICogYi54ICsgYS55ICogYi55KSAvIChNYXRoLmh5cG90KGEueCwgYS55KSAqIE1hdGguaHlwb3QoYi54LCBiLnkpKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge1BvaW50fSB2XG4gICAgICogQHJldHVybnMge1BvaW50fSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSB1bml0IHZlY3RvciBvZiBwb2ludGluZyB0byB0aGUgZGlyZWN0aW9uIG9mIGB2YFxuICAgICAqL1xuICAgIGdldEhhdFZlY3RvcjogZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiBuZXcgZmFicmljLlBvaW50KHYueCwgdi55KS5tdWx0aXBseSgxIC8gTWF0aC5oeXBvdCh2LngsIHYueSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtQb2ludH0gQVxuICAgICAqIEBwYXJhbSB7UG9pbnR9IEJcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBDXG4gICAgICogQHJldHVybnMge3sgdmVjdG9yOiBQb2ludCwgYW5nbGU6IG51bWJlciB9fSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBiaXNlY3RvciBvZiBBIGFuZCBBJ3MgYW5nbGVcbiAgICAgKi9cbiAgICBnZXRCaXNlY3RvcjogZnVuY3Rpb24gKEEsIEIsIEMpIHtcbiAgICAgIHZhciBBQiA9IGZhYnJpYy51dGlsLmNyZWF0ZVZlY3RvcihBLCBCKSwgQUMgPSBmYWJyaWMudXRpbC5jcmVhdGVWZWN0b3IoQSwgQyk7XG4gICAgICB2YXIgYWxwaGEgPSBmYWJyaWMudXRpbC5jYWxjQW5nbGVCZXR3ZWVuVmVjdG9ycyhBQiwgQUMpO1xuICAgICAgLy8gIGNoZWNrIGlmIGFscGhhIGlzIHJlbGF0aXZlIHRvIEFCLT5CQ1xuICAgICAgdmFyIHJvID0gZmFicmljLnV0aWwuY2FsY0FuZ2xlQmV0d2VlblZlY3RvcnMoZmFicmljLnV0aWwucm90YXRlVmVjdG9yKEFCLCBhbHBoYSksIEFDKTtcbiAgICAgIHZhciBwaGkgPSBhbHBoYSAqIChybyA9PT0gMCA/IDEgOiAtMSkgLyAyO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmVjdG9yOiBmYWJyaWMudXRpbC5nZXRIYXRWZWN0b3IoZmFicmljLnV0aWwucm90YXRlVmVjdG9yKEFCLCBwaGkpKSxcbiAgICAgICAgYW5nbGU6IGFscGhhXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0IHN0cm9rZSB3aWR0aCBvbiBwb2ludHMgcmV0dXJuaW5nIDIgcHJvamVjdGlvbnMgZm9yIGVhY2ggcG9pbnQgYXMgZm9sbG93czpcbiAgICAgKiAtIGBtaXRlcmA6IDIgcG9pbnRzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG91dGVyIGJvdW5kYXJ5IGFuZCB0aGUgaW5uZXIgYm91bmRhcnkgb2Ygc3Ryb2tlLlxuICAgICAqIC0gYGJldmVsYDogMiBwb2ludHMgY29ycmVzcG9uZGluZyB0byB0aGUgYmV2ZWwgYm91bmRhcmllcywgdGFuZ2VudCB0byB0aGUgYmlzZWN0b3IuXG4gICAgICogLSBgcm91bmRgOiBzYW1lIGFzIGBiZXZlbGBcbiAgICAgKiBVc2VkIHRvIGNhbGN1bGF0ZSBvYmplY3QncyBib3VuZGluZyBib3hcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtQb2ludFtdfSBwb2ludHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnN0cm9rZVdpZHRoXG4gICAgICogQHBhcmFtIHsnbWl0ZXInfCdiZXZlbCd8J3JvdW5kJ30gb3B0aW9ucy5zdHJva2VMaW5lSm9pblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnN0cm9rZU1pdGVyTGltaXQgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtbWl0ZXJsaW1pdFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zdHJva2VVbmlmb3JtXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuc2NhbGVYXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuc2NhbGVZXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3BlblBhdGhdIHdoZXRoZXIgdGhlIHNoYXBlIGlzIG9wZW4gb3Igbm90LCBhZmZlY3RzIHRoZSBjYWxjdWxhdGlvbnMgb2YgdGhlIGZpcnN0IGFuZCBsYXN0IHBvaW50c1xuICAgICAqIEByZXR1cm5zIHtmYWJyaWMuUG9pbnRbXX0gYXJyYXkgb2Ygc2l6ZSAybi80biBvZiBhbGwgc3VzcGVjdGVkIHBvaW50c1xuICAgICAqL1xuICAgIHByb2plY3RTdHJva2VPblBvaW50czogZnVuY3Rpb24gKHBvaW50cywgb3B0aW9ucywgb3BlblBhdGgpIHtcbiAgICAgIHZhciBjb29yZHMgPSBbXSwgcyA9IG9wdGlvbnMuc3Ryb2tlV2lkdGggLyAyLFxuICAgICAgICAgIHN0cm9rZVVuaWZvcm1TY2FsYXIgPSBvcHRpb25zLnN0cm9rZVVuaWZvcm0gP1xuICAgICAgICAgICAgbmV3IGZhYnJpYy5Qb2ludCgxIC8gb3B0aW9ucy5zY2FsZVgsIDEgLyBvcHRpb25zLnNjYWxlWSkgOiBuZXcgZmFicmljLlBvaW50KDEsIDEpLFxuICAgICAgICAgIGdldFN0cm9rZUhhdFZlY3RvciA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB2YXIgc2NhbGFyID0gcyAvIChNYXRoLmh5cG90KHYueCwgdi55KSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGZhYnJpYy5Qb2ludCh2LnggKiBzY2FsYXIgKiBzdHJva2VVbmlmb3JtU2NhbGFyLngsIHYueSAqIHNjYWxhciAqIHN0cm9rZVVuaWZvcm1TY2FsYXIueSk7XG4gICAgICAgICAgfTtcbiAgICAgIGlmIChwb2ludHMubGVuZ3RoIDw9IDEpIHtyZXR1cm4gY29vcmRzO31cbiAgICAgIHBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwLCBpbmRleCkge1xuICAgICAgICB2YXIgQSA9IG5ldyBmYWJyaWMuUG9pbnQocC54LCBwLnkpLCBCLCBDO1xuICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICBDID0gcG9pbnRzW2luZGV4ICsgMV07XG4gICAgICAgICAgQiA9IG9wZW5QYXRoID8gZ2V0U3Ryb2tlSGF0VmVjdG9yKGZhYnJpYy51dGlsLmNyZWF0ZVZlY3RvcihDLCBBKSkuYWRkRXF1YWxzKEEpIDogcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PT0gcG9pbnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBCID0gcG9pbnRzW2luZGV4IC0gMV07XG4gICAgICAgICAgQyA9IG9wZW5QYXRoID8gZ2V0U3Ryb2tlSGF0VmVjdG9yKGZhYnJpYy51dGlsLmNyZWF0ZVZlY3RvcihCLCBBKSkuYWRkRXF1YWxzKEEpIDogcG9pbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIEIgPSBwb2ludHNbaW5kZXggLSAxXTtcbiAgICAgICAgICBDID0gcG9pbnRzW2luZGV4ICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJpc2VjdG9yID0gZmFicmljLnV0aWwuZ2V0QmlzZWN0b3IoQSwgQiwgQyksXG4gICAgICAgICAgICBiaXNlY3RvclZlY3RvciA9IGJpc2VjdG9yLnZlY3RvcixcbiAgICAgICAgICAgIGFscGhhID0gYmlzZWN0b3IuYW5nbGUsXG4gICAgICAgICAgICBzY2FsYXIsXG4gICAgICAgICAgICBtaXRlclZlY3RvcjtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3Ryb2tlTGluZUpvaW4gPT09ICdtaXRlcicpIHtcbiAgICAgICAgICBzY2FsYXIgPSAtcyAvIE1hdGguc2luKGFscGhhIC8gMik7XG4gICAgICAgICAgbWl0ZXJWZWN0b3IgPSBuZXcgZmFicmljLlBvaW50KFxuICAgICAgICAgICAgYmlzZWN0b3JWZWN0b3IueCAqIHNjYWxhciAqIHN0cm9rZVVuaWZvcm1TY2FsYXIueCxcbiAgICAgICAgICAgIGJpc2VjdG9yVmVjdG9yLnkgKiBzY2FsYXIgKiBzdHJva2VVbmlmb3JtU2NhbGFyLnlcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChNYXRoLmh5cG90KG1pdGVyVmVjdG9yLngsIG1pdGVyVmVjdG9yLnkpIC8gcyA8PSBvcHRpb25zLnN0cm9rZU1pdGVyTGltaXQpIHtcbiAgICAgICAgICAgIGNvb3Jkcy5wdXNoKEEuYWRkKG1pdGVyVmVjdG9yKSk7XG4gICAgICAgICAgICBjb29yZHMucHVzaChBLnN1YnRyYWN0KG1pdGVyVmVjdG9yKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNjYWxhciA9IC1zICogTWF0aC5TUVJUMjtcbiAgICAgICAgbWl0ZXJWZWN0b3IgPSBuZXcgZmFicmljLlBvaW50KFxuICAgICAgICAgIGJpc2VjdG9yVmVjdG9yLnggKiBzY2FsYXIgKiBzdHJva2VVbmlmb3JtU2NhbGFyLngsXG4gICAgICAgICAgYmlzZWN0b3JWZWN0b3IueSAqIHNjYWxhciAqIHN0cm9rZVVuaWZvcm1TY2FsYXIueVxuICAgICAgICApO1xuICAgICAgICBjb29yZHMucHVzaChBLmFkZChtaXRlclZlY3RvcikpO1xuICAgICAgICBjb29yZHMucHVzaChBLnN1YnRyYWN0KG1pdGVyVmVjdG9yKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb29yZHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRyYW5zZm9ybSB0IHRvIHBvaW50IHBcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtICB7ZmFicmljLlBvaW50fSBwIFRoZSBwb2ludCB0byB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gdCBUaGUgdHJhbnNmb3JtXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gW2lnbm9yZU9mZnNldF0gSW5kaWNhdGVzIHRoYXQgdGhlIG9mZnNldCBzaG91bGQgbm90IGJlIGFwcGxpZWRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IFRoZSB0cmFuc2Zvcm1lZCBwb2ludFxuICAgICAqL1xuICAgIHRyYW5zZm9ybVBvaW50OiBmdW5jdGlvbihwLCB0LCBpZ25vcmVPZmZzZXQpIHtcbiAgICAgIGlmIChpZ25vcmVPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuUG9pbnQoXG4gICAgICAgICAgdFswXSAqIHAueCArIHRbMl0gKiBwLnksXG4gICAgICAgICAgdFsxXSAqIHAueCArIHRbM10gKiBwLnlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgZmFicmljLlBvaW50KFxuICAgICAgICB0WzBdICogcC54ICsgdFsyXSAqIHAueSArIHRbNF0sXG4gICAgICAgIHRbMV0gKiBwLnggKyB0WzNdICogcC55ICsgdFs1XVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb29yZGluYXRlcyBvZiBwb2ludHMncyBib3VuZGluZyByZWN0YW5nbGUgKGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodClcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgNCBwb2ludHMgYXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdHJhbnNmb3JtXSBhbiBhcnJheSBvZiA2IG51bWJlcnMgcmVwcmVzZW50aW5nIGEgMngzIHRyYW5zZm9ybSBtYXRyaXhcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCB3aXRoIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgbWFrZUJvdW5kaW5nQm94RnJvbVBvaW50czogZnVuY3Rpb24ocG9pbnRzLCB0cmFuc2Zvcm0pIHtcbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBwb2ludHNbaV0gPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludChwb2ludHNbaV0sIHRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB4UG9pbnRzID0gW3BvaW50c1swXS54LCBwb2ludHNbMV0ueCwgcG9pbnRzWzJdLngsIHBvaW50c1szXS54XSxcbiAgICAgICAgICBtaW5YID0gZmFicmljLnV0aWwuYXJyYXkubWluKHhQb2ludHMpLFxuICAgICAgICAgIG1heFggPSBmYWJyaWMudXRpbC5hcnJheS5tYXgoeFBvaW50cyksXG4gICAgICAgICAgd2lkdGggPSBtYXhYIC0gbWluWCxcbiAgICAgICAgICB5UG9pbnRzID0gW3BvaW50c1swXS55LCBwb2ludHNbMV0ueSwgcG9pbnRzWzJdLnksIHBvaW50c1szXS55XSxcbiAgICAgICAgICBtaW5ZID0gZmFicmljLnV0aWwuYXJyYXkubWluKHlQb2ludHMpLFxuICAgICAgICAgIG1heFkgPSBmYWJyaWMudXRpbC5hcnJheS5tYXgoeVBvaW50cyksXG4gICAgICAgICAgaGVpZ2h0ID0gbWF4WSAtIG1pblk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IG1pblgsXG4gICAgICAgIHRvcDogbWluWSxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW52ZXJ0IHRyYW5zZm9ybWF0aW9uIHRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gdCBUaGUgdHJhbnNmb3JtXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBpbnZlcnRlZCB0cmFuc2Zvcm1cbiAgICAgKi9cbiAgICBpbnZlcnRUcmFuc2Zvcm06IGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBhID0gMSAvICh0WzBdICogdFszXSAtIHRbMV0gKiB0WzJdKSxcbiAgICAgICAgICByID0gW2EgKiB0WzNdLCAtYSAqIHRbMV0sIC1hICogdFsyXSwgYSAqIHRbMF1dLFxuICAgICAgICAgIG8gPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludCh7IHg6IHRbNF0sIHk6IHRbNV0gfSwgciwgdHJ1ZSk7XG4gICAgICByWzRdID0gLW8ueDtcbiAgICAgIHJbNV0gPSAtby55O1xuICAgICAgcmV0dXJuIHI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgd3JhcHBlciBhcm91bmQgTnVtYmVyI3RvRml4ZWQsIHdoaWNoIGNvbnRyYXJ5IHRvIG5hdGl2ZSBtZXRob2QgcmV0dXJucyBudW1iZXIsIG5vdCBzdHJpbmcuXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gbnVtYmVyIG51bWJlciB0byBvcGVyYXRlIG9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYWN0aW9uRGlnaXRzIG51bWJlciBvZiBmcmFjdGlvbiBkaWdpdHMgdG8gXCJsZWF2ZVwiXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRvRml4ZWQ6IGZ1bmN0aW9uKG51bWJlciwgZnJhY3Rpb25EaWdpdHMpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KE51bWJlcihudW1iZXIpLnRvRml4ZWQoZnJhY3Rpb25EaWdpdHMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgZnJvbSBhdHRyaWJ1dGUgdmFsdWUgdG8gcGl4ZWwgdmFsdWUgaWYgYXBwbGljYWJsZS5cbiAgICAgKiBSZXR1cm5zIGNvbnZlcnRlZCBwaXhlbHMgb3Igb3JpZ2luYWwgdmFsdWUgbm90IGNvbnZlcnRlZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHZhbHVlIG51bWJlciB0byBvcGVyYXRlIG9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZvbnRTaXplXG4gICAgICogQHJldHVybiB7TnVtYmVyfFN0cmluZ31cbiAgICAgKi9cbiAgICBwYXJzZVVuaXQ6IGZ1bmN0aW9uKHZhbHVlLCBmb250U2l6ZSkge1xuICAgICAgdmFyIHVuaXQgPSAvXFxEezAsMn0kLy5leGVjKHZhbHVlKSxcbiAgICAgICAgICBudW1iZXIgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgIGlmICghZm9udFNpemUpIHtcbiAgICAgICAgZm9udFNpemUgPSBmYWJyaWMuVGV4dC5ERUZBVUxUX1NWR19GT05UX1NJWkU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHVuaXRbMF0pIHtcbiAgICAgICAgY2FzZSAnbW0nOlxuICAgICAgICAgIHJldHVybiBudW1iZXIgKiBmYWJyaWMuRFBJIC8gMjUuNDtcblxuICAgICAgICBjYXNlICdjbSc6XG4gICAgICAgICAgcmV0dXJuIG51bWJlciAqIGZhYnJpYy5EUEkgLyAyLjU0O1xuXG4gICAgICAgIGNhc2UgJ2luJzpcbiAgICAgICAgICByZXR1cm4gbnVtYmVyICogZmFicmljLkRQSTtcblxuICAgICAgICBjYXNlICdwdCc6XG4gICAgICAgICAgcmV0dXJuIG51bWJlciAqIGZhYnJpYy5EUEkgLyA3MjsgLy8gb3IgKiA0IC8gM1xuXG4gICAgICAgIGNhc2UgJ3BjJzpcbiAgICAgICAgICByZXR1cm4gbnVtYmVyICogZmFicmljLkRQSSAvIDcyICogMTI7IC8vIG9yICogMTZcblxuICAgICAgICBjYXNlICdlbSc6XG4gICAgICAgICAgcmV0dXJuIG51bWJlciAqIGZvbnRTaXplO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gd2hpY2ggYWx3YXlzIHJldHVybnMgYGZhbHNlYC5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBmYWxzZUZ1bmN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBrbGFzcyBcIkNsYXNzXCIgb2JqZWN0IG9mIGdpdmVuIG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFR5cGUgb2Ygb2JqZWN0IChlZy4gJ2NpcmNsZScpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBOYW1lc3BhY2UgdG8gZ2V0IGtsYXNzIFwiQ2xhc3NcIiBvYmplY3QgZnJvbVxuICAgICAqIEByZXR1cm4ge09iamVjdH0ga2xhc3MgXCJDbGFzc1wiXG4gICAgICovXG4gICAgZ2V0S2xhc3M6IGZ1bmN0aW9uKHR5cGUsIG5hbWVzcGFjZSkge1xuICAgICAgLy8gY2FwaXRhbGl6ZSBmaXJzdCBsZXR0ZXIgb25seVxuICAgICAgdHlwZSA9IGZhYnJpYy51dGlsLnN0cmluZy5jYW1lbGl6ZSh0eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdHlwZS5zbGljZSgxKSk7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwucmVzb2x2ZU5hbWVzcGFjZShuYW1lc3BhY2UpW3R5cGVdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFycmF5IG9mIGF0dHJpYnV0ZXMgZm9yIGdpdmVuIHN2ZyB0aGF0IGZhYnJpYyBwYXJzZXNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUeXBlIG9mIHN2ZyBlbGVtZW50IChlZy4gJ2NpcmNsZScpXG4gICAgICogQHJldHVybiB7QXJyYXl9IHN0cmluZyBuYW1lcyBvZiBzdXBwb3J0ZWQgYXR0cmlidXRlc1xuICAgICAqL1xuICAgIGdldFN2Z0F0dHJpYnV0ZXM6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gW1xuICAgICAgICAnaW5zdGFudGlhdGVkX2J5X3VzZScsXG4gICAgICAgICdzdHlsZScsXG4gICAgICAgICdpZCcsXG4gICAgICAgICdjbGFzcydcbiAgICAgIF07XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnbGluZWFyR3JhZGllbnQnOlxuICAgICAgICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLmNvbmNhdChbJ3gxJywgJ3kxJywgJ3gyJywgJ3kyJywgJ2dyYWRpZW50VW5pdHMnLCAnZ3JhZGllbnRUcmFuc2Zvcm0nXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JhZGlhbEdyYWRpZW50JzpcbiAgICAgICAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcy5jb25jYXQoWydncmFkaWVudFVuaXRzJywgJ2dyYWRpZW50VHJhbnNmb3JtJywgJ2N4JywgJ2N5JywgJ3InLCAnZngnLCAnZnknLCAnZnInXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N0b3AnOlxuICAgICAgICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLmNvbmNhdChbJ29mZnNldCcsICdzdG9wLWNvbG9yJywgJ3N0b3Atb3BhY2l0eSddKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCBvZiBnaXZlbiBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIE5hbWVzcGFjZSBzdHJpbmcgZS5nLiAnZmFicmljLkltYWdlLmZpbHRlcicgb3IgJ2ZhYnJpYydcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCBmb3IgZ2l2ZW4gbmFtZXNwYWNlIChkZWZhdWx0IGZhYnJpYylcbiAgICAgKi9cbiAgICByZXNvbHZlTmFtZXNwYWNlOiBmdW5jdGlvbihuYW1lc3BhY2UpIHtcbiAgICAgIGlmICghbmFtZXNwYWNlKSB7XG4gICAgICAgIHJldHVybiBmYWJyaWM7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJ0cyA9IG5hbWVzcGFjZS5zcGxpdCgnLicpLFxuICAgICAgICAgIGxlbiA9IHBhcnRzLmxlbmd0aCwgaSxcbiAgICAgICAgICBvYmogPSBnbG9iYWwgfHwgZmFicmljLndpbmRvdztcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIG9iaiA9IG9ialtwYXJ0c1tpXV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExvYWRzIGltYWdlIGVsZW1lbnQgZnJvbSBnaXZlbiB1cmwgYW5kIHBhc3NlcyBpdCB0byBhIGNhbGxiYWNrXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBVUkwgcmVwcmVzZW50aW5nIGFuIGltYWdlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2s7IGludm9rZWQgd2l0aCBsb2FkZWQgaW1hZ2VcbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XSBDb250ZXh0IHRvIGludm9rZSBjYWxsYmFjayBpblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY3Jvc3NPcmlnaW5dIGNyb3NzT3JpZ2luIHZhbHVlIHRvIHNldCBpbWFnZSBlbGVtZW50IHRvXG4gICAgICovXG4gICAgbG9hZEltYWdlOiBmdW5jdGlvbih1cmwsIGNhbGxiYWNrLCBjb250ZXh0LCBjcm9zc09yaWdpbikge1xuICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbChjb250ZXh0LCB1cmwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpbWcgPSBmYWJyaWMudXRpbC5jcmVhdGVJbWFnZSgpO1xuXG4gICAgICAvKiogQGlnbm9yZSAqL1xuICAgICAgdmFyIG9uTG9hZENhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGNvbnRleHQsIGltZywgZmFsc2UpO1xuICAgICAgICBpbWcgPSBpbWcub25sb2FkID0gaW1nLm9uZXJyb3IgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgaW1nLm9ubG9hZCA9IG9uTG9hZENhbGxiYWNrO1xuICAgICAgLyoqIEBpZ25vcmUgKi9cbiAgICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZhYnJpYy5sb2coJ0Vycm9yIGxvYWRpbmcgJyArIGltZy5zcmMpO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGNvbnRleHQsIG51bGwsIHRydWUpO1xuICAgICAgICBpbWcgPSBpbWcub25sb2FkID0gaW1nLm9uZXJyb3IgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgLy8gZGF0YS11cmxzIGFwcGVhciB0byBiZSBidWdneSB3aXRoIGNyb3NzT3JpZ2luXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20va2FuZ2F4L2ZhYnJpYy5qcy9jb21taXQvZDBhYmI5MGYxY2Q1YzVlZjlkMmE5NGQzZmIyMWEyMjMzMGRhM2UwYSNjb21taXRjb21tZW50LTQ1MTM3NjdcbiAgICAgIC8vIHNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzE1MTUyXG4gICAgICAvLyAgICAgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTM1MDY5XG4gICAgICAvLyBjcm9zc09yaWdpbiBudWxsIGlzIHRoZSBzYW1lIGFzIG5vdCBzZXQuXG4gICAgICBpZiAodXJsLmluZGV4T2YoJ2RhdGEnKSAhPT0gMCAmJlxuICAgICAgICBjcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIGNyb3NzT3JpZ2luICE9PSBudWxsKSB7XG4gICAgICAgIGltZy5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuICAgICAgfVxuXG4gICAgICAvLyBJRTEwIC8gSUUxMS1GaXg6IFNWRyBjb250ZW50cyBmcm9tIGRhdGE6IFVSSVxuICAgICAgLy8gd2lsbCBvbmx5IGJlIGF2YWlsYWJsZSBpZiB0aGUgSU1HIGlzIHByZXNlbnRcbiAgICAgIC8vIGluIHRoZSBET00gKGFuZCB2aXNpYmxlKVxuICAgICAgaWYgKHVybC5zdWJzdHJpbmcoMCwxNCkgPT09ICdkYXRhOmltYWdlL3N2ZycpIHtcbiAgICAgICAgaW1nLm9ubG9hZCA9IG51bGw7XG4gICAgICAgIGZhYnJpYy51dGlsLmxvYWRJbWFnZUluRG9tKGltZywgb25Mb2FkQ2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgICBpbWcuc3JjID0gdXJsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyBTVkcgaW1hZ2Ugd2l0aCBkYXRhOiBVUkwgdG8gdGhlIGRvbVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWcgSW1hZ2Ugb2JqZWN0IHdpdGggZGF0YTppbWFnZS9zdmcgc3JjXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2s7IGludm9rZWQgd2l0aCBsb2FkZWQgaW1hZ2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IERPTSBlbGVtZW50IChkaXYgY29udGFpbmluZyB0aGUgU1ZHIGltYWdlKVxuICAgICAqL1xuICAgIGxvYWRJbWFnZUluRG9tOiBmdW5jdGlvbihpbWcsIG9uTG9hZENhbGxiYWNrKSB7XG4gICAgICB2YXIgZGl2ID0gZmFicmljLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZGl2LnN0eWxlLndpZHRoID0gZGl2LnN0eWxlLmhlaWdodCA9ICcxcHgnO1xuICAgICAgZGl2LnN0eWxlLmxlZnQgPSBkaXYuc3R5bGUudG9wID0gJy0xMDAlJztcbiAgICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBkaXYuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICAgIGZhYnJpYy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5JykuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgIC8qKlxuICAgICAgICogV3JhcCBpbiBmdW5jdGlvbiB0bzpcbiAgICAgICAqICAgMS4gQ2FsbCBleGlzdGluZyBjYWxsYmFja1xuICAgICAgICogICAyLiBDbGVhbnVwIERPTVxuICAgICAgICovXG4gICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvbkxvYWRDYWxsYmFjaygpO1xuICAgICAgICBkaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkaXYpO1xuICAgICAgICBkaXYgPSBudWxsO1xuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBjb3JyZXNwb25kaW5nIGZhYnJpYyBpbnN0YW5jZXMgZnJvbSB0aGVpciBvYmplY3QgcmVwcmVzZW50YXRpb25zXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9iamVjdHMgT2JqZWN0cyB0byBlbmxpdmVuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYWxsIG9iamVjdHMgYXJlIGNyZWF0ZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIE5hbWVzcGFjZSB0byBnZXQga2xhc3MgXCJDbGFzc1wiIG9iamVjdCBmcm9tXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmV2aXZlciBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBvYmplY3QgZWxlbWVudHMsXG4gICAgICogY2FsbGVkIGFmdGVyIGVhY2ggZmFicmljIG9iamVjdCBjcmVhdGVkLlxuICAgICAqL1xuICAgIGVubGl2ZW5PYmplY3RzOiBmdW5jdGlvbihvYmplY3RzLCBjYWxsYmFjaywgbmFtZXNwYWNlLCByZXZpdmVyKSB7XG4gICAgICBvYmplY3RzID0gb2JqZWN0cyB8fCBbXTtcblxuICAgICAgdmFyIGVubGl2ZW5lZE9iamVjdHMgPSBbXSxcbiAgICAgICAgICBudW1Mb2FkZWRPYmplY3RzID0gMCxcbiAgICAgICAgICBudW1Ub3RhbE9iamVjdHMgPSBvYmplY3RzLmxlbmd0aDtcblxuICAgICAgZnVuY3Rpb24gb25Mb2FkZWQoKSB7XG4gICAgICAgIGlmICgrK251bUxvYWRlZE9iamVjdHMgPT09IG51bVRvdGFsT2JqZWN0cykge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVubGl2ZW5lZE9iamVjdHMuZmlsdGVyKGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgLy8gZmlsdGVyIG91dCB1bmRlZmluZWQgb2JqZWN0cyAob2JqZWN0cyB0aGF0IGdhdmUgZXJyb3IpXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIW51bVRvdGFsT2JqZWN0cykge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbmxpdmVuZWRPYmplY3RzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBvYmplY3RzLmZvckVhY2goZnVuY3Rpb24gKG8sIGluZGV4KSB7XG4gICAgICAgIC8vIGlmIHNwYXJzZSBhcnJheVxuICAgICAgICBpZiAoIW8gfHwgIW8udHlwZSkge1xuICAgICAgICAgIG9uTG9hZGVkKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrbGFzcyA9IGZhYnJpYy51dGlsLmdldEtsYXNzKG8udHlwZSwgbmFtZXNwYWNlKTtcbiAgICAgICAga2xhc3MuZnJvbU9iamVjdChvLCBmdW5jdGlvbiAob2JqLCBlcnJvcikge1xuICAgICAgICAgIGVycm9yIHx8IChlbmxpdmVuZWRPYmplY3RzW2luZGV4XSA9IG9iaik7XG4gICAgICAgICAgcmV2aXZlciAmJiByZXZpdmVyKG8sIG9iaiwgZXJyb3IpO1xuICAgICAgICAgIG9uTG9hZGVkKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgY29ycmVzcG9uZGluZyBmYWJyaWMgaW5zdGFuY2VzIHJlc2lkaW5nIGluIGFuIG9iamVjdCwgZS5nLiBgY2xpcFBhdGhgXG4gICAgICogQHNlZSB7QGxpbmsgZmFicmljLk9iamVjdC5FTkxJVkVOX1BST1BTfVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdIGFzc2lnbiBlbmxpdmVkIHByb3BzIHRvIHRoaXMgb2JqZWN0IChwYXNzIG51bGwgdG8gc2tpcCB0aGlzKVxuICAgICAqIEBwYXJhbSB7KG9iamVjdHM6ZmFicmljLk9iamVjdFtdKSA9PiB2b2lkfSBjYWxsYmFja1xuICAgICAqL1xuICAgIGVubGl2ZW5PYmplY3RFbmxpdmFibGVzOiBmdW5jdGlvbiAob2JqZWN0LCBjb250ZXh0LCBjYWxsYmFjaykge1xuICAgICAgdmFyIGVubGl2ZW5Qcm9wcyA9IGZhYnJpYy5PYmplY3QuRU5MSVZFTl9QUk9QUy5maWx0ZXIoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gISFvYmplY3Rba2V5XTsgfSk7XG4gICAgICBmYWJyaWMudXRpbC5lbmxpdmVuT2JqZWN0cyhlbmxpdmVuUHJvcHMubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIG9iamVjdFtrZXldOyB9KSwgZnVuY3Rpb24gKGVubGl2ZWRQcm9wcykge1xuICAgICAgICB2YXIgb2JqZWN0cyA9IHt9O1xuICAgICAgICBlbmxpdmVuUHJvcHMuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBpbmRleCkge1xuICAgICAgICAgIG9iamVjdHNba2V5XSA9IGVubGl2ZWRQcm9wc1tpbmRleF07XG4gICAgICAgICAgY29udGV4dCAmJiAoY29udGV4dFtrZXldID0gZW5saXZlZFByb3BzW2luZGV4XSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhvYmplY3RzKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW5kIHdhaXQgZm9yIGxvYWRpbmcgb2YgcGF0dGVybnNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0dGVybnMgT2JqZWN0cyB0byBlbmxpdmVuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYWxsIG9iamVjdHMgYXJlIGNyZWF0ZWRcbiAgICAgKiBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAgICovXG4gICAgZW5saXZlblBhdHRlcm5zOiBmdW5jdGlvbihwYXR0ZXJucywgY2FsbGJhY2spIHtcbiAgICAgIHBhdHRlcm5zID0gcGF0dGVybnMgfHwgW107XG5cbiAgICAgIGZ1bmN0aW9uIG9uTG9hZGVkKCkge1xuICAgICAgICBpZiAoKytudW1Mb2FkZWRQYXR0ZXJucyA9PT0gbnVtUGF0dGVybnMpIHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbmxpdmVuZWRQYXR0ZXJucyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGVubGl2ZW5lZFBhdHRlcm5zID0gW10sXG4gICAgICAgICAgbnVtTG9hZGVkUGF0dGVybnMgPSAwLFxuICAgICAgICAgIG51bVBhdHRlcm5zID0gcGF0dGVybnMubGVuZ3RoO1xuXG4gICAgICBpZiAoIW51bVBhdHRlcm5zKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVubGl2ZW5lZFBhdHRlcm5zKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwYXR0ZXJucy5mb3JFYWNoKGZ1bmN0aW9uIChwLCBpbmRleCkge1xuICAgICAgICBpZiAocCAmJiBwLnNvdXJjZSkge1xuICAgICAgICAgIG5ldyBmYWJyaWMuUGF0dGVybihwLCBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gICAgICAgICAgICBlbmxpdmVuZWRQYXR0ZXJuc1tpbmRleF0gPSBwYXR0ZXJuO1xuICAgICAgICAgICAgb25Mb2FkZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBlbmxpdmVuZWRQYXR0ZXJuc1tpbmRleF0gPSBwO1xuICAgICAgICAgIG9uTG9hZGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHcm91cHMgU1ZHIGVsZW1lbnRzICh1c3VhbGx5IHRob3NlIHJldHJpZXZlZCBmcm9tIFNWRyBkb2N1bWVudClcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gZWxlbWVudHMgU1ZHIGVsZW1lbnRzIHRvIGdyb3VwXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFZhbHVlIHRvIHNldCBzb3VyY2VQYXRoIHRvXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdHxmYWJyaWMuR3JvdXB9XG4gICAgICovXG4gICAgZ3JvdXBTVkdFbGVtZW50czogZnVuY3Rpb24oZWxlbWVudHMsIG9wdGlvbnMsIHBhdGgpIHtcbiAgICAgIHZhciBvYmplY3Q7XG4gICAgICBpZiAoZWxlbWVudHMgJiYgZWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBlbGVtZW50c1swXS5zb3VyY2VQYXRoID0gcGF0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudHNbMF07XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy53aWR0aCAmJiBvcHRpb25zLmhlaWdodCkge1xuICAgICAgICAgIG9wdGlvbnMuY2VudGVyUG9pbnQgPSB7XG4gICAgICAgICAgICB4OiBvcHRpb25zLndpZHRoIC8gMixcbiAgICAgICAgICAgIHk6IG9wdGlvbnMuaGVpZ2h0IC8gMlxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIG9wdGlvbnMud2lkdGg7XG4gICAgICAgICAgZGVsZXRlIG9wdGlvbnMuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBuZXcgZmFicmljLkdyb3VwKGVsZW1lbnRzLCBvcHRpb25zKTtcbiAgICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb2JqZWN0LnNvdXJjZVBhdGggPSBwYXRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUG9wdWxhdGVzIGFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgb2YgYW5vdGhlciBvYmplY3RcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBTb3VyY2Ugb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRlc3RpbmF0aW9uIERlc3RpbmF0aW9uIG9iamVjdFxuICAgICAqIEByZXR1cm4ge0FycmF5fSBwcm9wZXJ0aWVzIFByb3BlcnRpZXMgbmFtZXMgdG8gaW5jbHVkZVxuICAgICAqL1xuICAgIHBvcHVsYXRlV2l0aFByb3BlcnRpZXM6IGZ1bmN0aW9uKHNvdXJjZSwgZGVzdGluYXRpb24sIHByb3BlcnRpZXMpIHtcbiAgICAgIGlmIChwcm9wZXJ0aWVzICYmIEFycmF5LmlzQXJyYXkocHJvcGVydGllcykpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAocHJvcGVydGllc1tpXSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW3Byb3BlcnRpZXNbaV1dID0gc291cmNlW3Byb3BlcnRpZXNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEByZXR1cm4ge0NhbnZhc0VsZW1lbnR9IGluaXRpYWxpemVkIGNhbnZhcyBlbGVtZW50XG4gICAgICovXG4gICAgY3JlYXRlQ2FudmFzRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFicmljLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2FudmFzIGVsZW1lbnQgdGhhdCBpcyBhIGNvcHkgb2YgYW5vdGhlciBhbmQgaXMgYWxzbyBwYWludGVkXG4gICAgICogQHBhcmFtIHtDYW52YXNFbGVtZW50fSBjYW52YXMgdG8gY29weSBzaXplIGFuZCBjb250ZW50IG9mXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEByZXR1cm4ge0NhbnZhc0VsZW1lbnR9IGluaXRpYWxpemVkIGNhbnZhcyBlbGVtZW50XG4gICAgICovXG4gICAgY29weUNhbnZhc0VsZW1lbnQ6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgdmFyIG5ld0NhbnZhcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIG5ld0NhbnZhcy53aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICAgIG5ld0NhbnZhcy5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICAgICAgbmV3Q2FudmFzLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKGNhbnZhcywgMCwgMCk7XG4gICAgICByZXR1cm4gbmV3Q2FudmFzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBzaW5jZSAyLjYuMCBtb3ZlZCBmcm9tIGNhbnZhcyBpbnN0YW5jZSB0byB1dGlsaXR5LlxuICAgICAqIEBwYXJhbSB7Q2FudmFzRWxlbWVudH0gY2FudmFzRWwgdG8gY29weSBzaXplIGFuZCBjb250ZW50IG9mXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdCAnanBlZycgb3IgJ3BuZycsIGluIHNvbWUgYnJvd3NlcnMgJ3dlYnAnIGlzIG9rIHRvb1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBxdWFsaXR5IDw9IDEgYW5kID4gMFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGRhdGEgdXJsXG4gICAgICovXG4gICAgdG9EYXRhVVJMOiBmdW5jdGlvbihjYW52YXNFbCwgZm9ybWF0LCBxdWFsaXR5KSB7XG4gICAgICByZXR1cm4gY2FudmFzRWwudG9EYXRhVVJMKCdpbWFnZS8nICsgZm9ybWF0LCBxdWFsaXR5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBpbWFnZSBlbGVtZW50ICh3b3JrcyBvbiBjbGllbnQgYW5kIG5vZGUpXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IEhUTUwgaW1hZ2UgZWxlbWVudFxuICAgICAqL1xuICAgIGNyZWF0ZUltYWdlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE11bHRpcGx5IG1hdHJpeCBBIGJ5IG1hdHJpeCBCIHRvIG5lc3QgdHJhbnNmb3JtYXRpb25zXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhIEZpcnN0IHRyYW5zZm9ybU1hdHJpeFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBiIFNlY29uZCB0cmFuc2Zvcm1NYXRyaXhcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBpczJ4MiBmbGFnIHRvIG11bHRpcGx5IG1hdHJpY2VzIGFzIDJ4MiBtYXRyaWNlc1xuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgcHJvZHVjdCBvZiB0aGUgdHdvIHRyYW5zZm9ybSBtYXRyaWNlc1xuICAgICAqL1xuICAgIG11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXM6IGZ1bmN0aW9uKGEsIGIsIGlzMngyKSB7XG4gICAgICAvLyBNYXRyaXggbXVsdGlwbHkgYSAqIGJcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGFbMF0gKiBiWzBdICsgYVsyXSAqIGJbMV0sXG4gICAgICAgIGFbMV0gKiBiWzBdICsgYVszXSAqIGJbMV0sXG4gICAgICAgIGFbMF0gKiBiWzJdICsgYVsyXSAqIGJbM10sXG4gICAgICAgIGFbMV0gKiBiWzJdICsgYVszXSAqIGJbM10sXG4gICAgICAgIGlzMngyID8gMCA6IGFbMF0gKiBiWzRdICsgYVsyXSAqIGJbNV0gKyBhWzRdLFxuICAgICAgICBpczJ4MiA/IDAgOiBhWzFdICogYls0XSArIGFbM10gKiBiWzVdICsgYVs1XVxuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVjb21wb3NlcyBzdGFuZGFyZCAyeDMgbWF0cml4IGludG8gdHJhbnNmb3JtIGNvbXBvbmVudHNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGEgdHJhbnNmb3JtTWF0cml4XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDb21wb25lbnRzIG9mIHRyYW5zZm9ybVxuICAgICAqL1xuICAgIHFyRGVjb21wb3NlOiBmdW5jdGlvbihhKSB7XG4gICAgICB2YXIgYW5nbGUgPSBhdGFuMihhWzFdLCBhWzBdKSxcbiAgICAgICAgICBkZW5vbSA9IHBvdyhhWzBdLCAyKSArIHBvdyhhWzFdLCAyKSxcbiAgICAgICAgICBzY2FsZVggPSBzcXJ0KGRlbm9tKSxcbiAgICAgICAgICBzY2FsZVkgPSAoYVswXSAqIGFbM10gLSBhWzJdICogYVsxXSkgLyBzY2FsZVgsXG4gICAgICAgICAgc2tld1ggPSBhdGFuMihhWzBdICogYVsyXSArIGFbMV0gKiBhIFszXSwgZGVub20pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYW5nbGU6IGFuZ2xlIC8gUGlCeTE4MCxcbiAgICAgICAgc2NhbGVYOiBzY2FsZVgsXG4gICAgICAgIHNjYWxlWTogc2NhbGVZLFxuICAgICAgICBza2V3WDogc2tld1ggLyBQaUJ5MTgwLFxuICAgICAgICBza2V3WTogMCxcbiAgICAgICAgdHJhbnNsYXRlWDogYVs0XSxcbiAgICAgICAgdHJhbnNsYXRlWTogYVs1XVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHRyYW5zZm9ybSBtYXRyaXggc3RhcnRpbmcgZnJvbSBhbiBvYmplY3Qgb2YgdGhlIHNhbWUga2luZCBvZlxuICAgICAqIHRoZSBvbmUgcmV0dXJuZWQgZnJvbSBxckRlY29tcG9zZSwgdXNlZnVsIGFsc28gaWYgeW91IHdhbnQgdG8gY2FsY3VsYXRlIHNvbWVcbiAgICAgKiB0cmFuc2Zvcm1hdGlvbnMgZnJvbSBhbiBvYmplY3QgdGhhdCBpcyBub3QgZW5saXZlZCB5ZXRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5hbmdsZV0gYW5nbGUgaW4gZGVncmVlc1xuICAgICAqIEByZXR1cm4ge051bWJlcltdfSB0cmFuc2Zvcm0gbWF0cml4XG4gICAgICovXG4gICAgY2FsY1JvdGF0ZU1hdHJpeDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zLmFuZ2xlKSB7XG4gICAgICAgIHJldHVybiBmYWJyaWMuaU1hdHJpeC5jb25jYXQoKTtcbiAgICAgIH1cbiAgICAgIHZhciB0aGV0YSA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMob3B0aW9ucy5hbmdsZSksXG4gICAgICAgICAgY29zID0gZmFicmljLnV0aWwuY29zKHRoZXRhKSxcbiAgICAgICAgICBzaW4gPSBmYWJyaWMudXRpbC5zaW4odGhldGEpO1xuICAgICAgcmV0dXJuIFtjb3MsIHNpbiwgLXNpbiwgY29zLCAwLCAwXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHRyYW5zZm9ybSBtYXRyaXggc3RhcnRpbmcgZnJvbSBhbiBvYmplY3Qgb2YgdGhlIHNhbWUga2luZCBvZlxuICAgICAqIHRoZSBvbmUgcmV0dXJuZWQgZnJvbSBxckRlY29tcG9zZSwgdXNlZnVsIGFsc28gaWYgeW91IHdhbnQgdG8gY2FsY3VsYXRlIHNvbWVcbiAgICAgKiB0cmFuc2Zvcm1hdGlvbnMgZnJvbSBhbiBvYmplY3QgdGhhdCBpcyBub3QgZW5saXZlZCB5ZXQuXG4gICAgICogaXMgY2FsbGVkIERpbWVuc2lvbnNUcmFuc2Zvcm1NYXRyaXggYmVjYXVzZSB0aG9zZSBwcm9wZXJ0aWVzIGFyZSB0aGUgb25lIHRoYXQgaW5mbHVlbmNlXG4gICAgICogdGhlIHNpemUgb2YgdGhlIHJlc3VsdGluZyBib3ggb2YgdGhlIG9iamVjdC5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5zY2FsZVhdXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5zY2FsZVldXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMuZmxpcFhdXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMuZmxpcFldXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5za2V3WF1cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnNrZXdZXVxuICAgICAqIEByZXR1cm4ge051bWJlcltdfSB0cmFuc2Zvcm0gbWF0cml4XG4gICAgICovXG4gICAgY2FsY0RpbWVuc2lvbnNNYXRyaXg6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBzY2FsZVggPSB0eXBlb2Ygb3B0aW9ucy5zY2FsZVggPT09ICd1bmRlZmluZWQnID8gMSA6IG9wdGlvbnMuc2NhbGVYLFxuICAgICAgICAgIHNjYWxlWSA9IHR5cGVvZiBvcHRpb25zLnNjYWxlWSA9PT0gJ3VuZGVmaW5lZCcgPyAxIDogb3B0aW9ucy5zY2FsZVksXG4gICAgICAgICAgc2NhbGVNYXRyaXggPSBbXG4gICAgICAgICAgICBvcHRpb25zLmZsaXBYID8gLXNjYWxlWCA6IHNjYWxlWCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgb3B0aW9ucy5mbGlwWSA/IC1zY2FsZVkgOiBzY2FsZVksXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMF0sXG4gICAgICAgICAgbXVsdGlwbHkgPSBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzLFxuICAgICAgICAgIGRlZ3JlZXNUb1JhZGlhbnMgPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zO1xuICAgICAgaWYgKG9wdGlvbnMuc2tld1gpIHtcbiAgICAgICAgc2NhbGVNYXRyaXggPSBtdWx0aXBseShcbiAgICAgICAgICBzY2FsZU1hdHJpeCxcbiAgICAgICAgICBbMSwgMCwgTWF0aC50YW4oZGVncmVlc1RvUmFkaWFucyhvcHRpb25zLnNrZXdYKSksIDFdLFxuICAgICAgICAgIHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuc2tld1kpIHtcbiAgICAgICAgc2NhbGVNYXRyaXggPSBtdWx0aXBseShcbiAgICAgICAgICBzY2FsZU1hdHJpeCxcbiAgICAgICAgICBbMSwgTWF0aC50YW4oZGVncmVlc1RvUmFkaWFucyhvcHRpb25zLnNrZXdZKSksIDAsIDFdLFxuICAgICAgICAgIHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjYWxlTWF0cml4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgdHJhbnNmb3JtIG1hdHJpeCBzdGFydGluZyBmcm9tIGFuIG9iamVjdCBvZiB0aGUgc2FtZSBraW5kIG9mXG4gICAgICogdGhlIG9uZSByZXR1cm5lZCBmcm9tIHFyRGVjb21wb3NlLCB1c2VmdWwgYWxzbyBpZiB5b3Ugd2FudCB0byBjYWxjdWxhdGUgc29tZVxuICAgICAqIHRyYW5zZm9ybWF0aW9ucyBmcm9tIGFuIG9iamVjdCB0aGF0IGlzIG5vdCBlbmxpdmVkIHlldFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLmFuZ2xlXVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMuc2NhbGVYXVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMuc2NhbGVZXVxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLmZsaXBYXVxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLmZsaXBZXVxuICAgICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMuc2tld1hdXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5za2V3WF1cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnRyYW5zbGF0ZVhdXG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy50cmFuc2xhdGVZXVxuICAgICAqIEByZXR1cm4ge051bWJlcltdfSB0cmFuc2Zvcm0gbWF0cml4XG4gICAgICovXG4gICAgY29tcG9zZU1hdHJpeDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIG1hdHJpeCA9IFsxLCAwLCAwLCAxLCBvcHRpb25zLnRyYW5zbGF0ZVggfHwgMCwgb3B0aW9ucy50cmFuc2xhdGVZIHx8IDBdLFxuICAgICAgICAgIG11bHRpcGx5ID0gZmFicmljLnV0aWwubXVsdGlwbHlUcmFuc2Zvcm1NYXRyaWNlcztcbiAgICAgIGlmIChvcHRpb25zLmFuZ2xlKSB7XG4gICAgICAgIG1hdHJpeCA9IG11bHRpcGx5KG1hdHJpeCwgZmFicmljLnV0aWwuY2FsY1JvdGF0ZU1hdHJpeChvcHRpb25zKSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5zY2FsZVggIT09IDEgfHwgb3B0aW9ucy5zY2FsZVkgIT09IDEgfHxcbiAgICAgICAgICBvcHRpb25zLnNrZXdYIHx8IG9wdGlvbnMuc2tld1kgfHwgb3B0aW9ucy5mbGlwWCB8fCBvcHRpb25zLmZsaXBZKSB7XG4gICAgICAgIG1hdHJpeCA9IG11bHRpcGx5KG1hdHJpeCwgZmFicmljLnV0aWwuY2FsY0RpbWVuc2lvbnNNYXRyaXgob3B0aW9ucykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVzZXQgYW4gb2JqZWN0IHRyYW5zZm9ybSBzdGF0ZSB0byBuZXV0cmFsLiBUb3AgYW5kIGxlZnQgYXJlIG5vdCBhY2NvdW50ZWQgZm9yXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSAge2ZhYnJpYy5PYmplY3R9IHRhcmdldCBvYmplY3QgdG8gdHJhbnNmb3JtXG4gICAgICovXG4gICAgcmVzZXRPYmplY3RUcmFuc2Zvcm06IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIHRhcmdldC5zY2FsZVggPSAxO1xuICAgICAgdGFyZ2V0LnNjYWxlWSA9IDE7XG4gICAgICB0YXJnZXQuc2tld1ggPSAwO1xuICAgICAgdGFyZ2V0LnNrZXdZID0gMDtcbiAgICAgIHRhcmdldC5mbGlwWCA9IGZhbHNlO1xuICAgICAgdGFyZ2V0LmZsaXBZID0gZmFsc2U7XG4gICAgICB0YXJnZXQucm90YXRlKDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IE9iamVjdCB0cmFuc2Zvcm0gdmFsdWVzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSAge2ZhYnJpYy5PYmplY3R9IHRhcmdldCBvYmplY3QgdG8gcmVhZCBmcm9tXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDb21wb25lbnRzIG9mIHRyYW5zZm9ybVxuICAgICAqL1xuICAgIHNhdmVPYmplY3RUcmFuc2Zvcm06IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjYWxlWDogdGFyZ2V0LnNjYWxlWCxcbiAgICAgICAgc2NhbGVZOiB0YXJnZXQuc2NhbGVZLFxuICAgICAgICBza2V3WDogdGFyZ2V0LnNrZXdYLFxuICAgICAgICBza2V3WTogdGFyZ2V0LnNrZXdZLFxuICAgICAgICBhbmdsZTogdGFyZ2V0LmFuZ2xlLFxuICAgICAgICBsZWZ0OiB0YXJnZXQubGVmdCxcbiAgICAgICAgZmxpcFg6IHRhcmdldC5mbGlwWCxcbiAgICAgICAgZmxpcFk6IHRhcmdldC5mbGlwWSxcbiAgICAgICAgdG9wOiB0YXJnZXQudG9wXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgY29udGV4dCBoYXMgdHJhbnNwYXJlbnQgcGl4ZWxcbiAgICAgKiBhdCBzcGVjaWZpZWQgbG9jYXRpb24gKHRha2luZyB0b2xlcmFuY2UgaW50byBhY2NvdW50KVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggY29udGV4dFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b2xlcmFuY2UgVG9sZXJhbmNlXG4gICAgICovXG4gICAgaXNUcmFuc3BhcmVudDogZnVuY3Rpb24oY3R4LCB4LCB5LCB0b2xlcmFuY2UpIHtcblxuICAgICAgLy8gSWYgdG9sZXJhbmNlIGlzID4gMCBhZGp1c3Qgc3RhcnQgY29vcmRzIHRvIHRha2UgaW50byBhY2NvdW50LlxuICAgICAgLy8gSWYgbW92ZXMgb2ZmIENhbnZhcyBmaXggdG8gMFxuICAgICAgaWYgKHRvbGVyYW5jZSA+IDApIHtcbiAgICAgICAgaWYgKHggPiB0b2xlcmFuY2UpIHtcbiAgICAgICAgICB4IC09IHRvbGVyYW5jZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSA+IHRvbGVyYW5jZSkge1xuICAgICAgICAgIHkgLT0gdG9sZXJhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHkgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXNUcmFuc3BhcmVudCA9IHRydWUsIGksIHRlbXAsXG4gICAgICAgICAgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSh4LCB5LCAodG9sZXJhbmNlICogMikgfHwgMSwgKHRvbGVyYW5jZSAqIDIpIHx8IDEpLFxuICAgICAgICAgIGwgPSBpbWFnZURhdGEuZGF0YS5sZW5ndGg7XG5cbiAgICAgIC8vIFNwbGl0IGltYWdlIGRhdGEgLSBmb3IgdG9sZXJhbmNlID4gMSwgcGl4ZWxEYXRhU2l6ZSA9IDQ7XG4gICAgICBmb3IgKGkgPSAzOyBpIDwgbDsgaSArPSA0KSB7XG4gICAgICAgIHRlbXAgPSBpbWFnZURhdGEuZGF0YVtpXTtcbiAgICAgICAgX2lzVHJhbnNwYXJlbnQgPSB0ZW1wIDw9IDA7XG4gICAgICAgIGlmIChfaXNUcmFuc3BhcmVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhazsgLy8gU3RvcCBpZiBjb2xvdXIgZm91bmRcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbWFnZURhdGEgPSBudWxsO1xuXG4gICAgICByZXR1cm4gX2lzVHJhbnNwYXJlbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHByZXNlcnZlQXNwZWN0UmF0aW8gYXR0cmlidXRlIGZyb20gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgdG8gYmUgcGFyc2VkXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBhbiBvYmplY3QgY29udGFpbmluZyBhbGlnbiBhbmQgbWVldE9yU2xpY2UgYXR0cmlidXRlXG4gICAgICovXG4gICAgcGFyc2VQcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0cmlidXRlOiBmdW5jdGlvbihhdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBtZWV0T3JTbGljZSA9ICdtZWV0JywgYWxpZ25YID0gJ01pZCcsIGFsaWduWSA9ICdNaWQnLFxuICAgICAgICAgIGFzcGVjdFJhdGlvQXR0cnMgPSBhdHRyaWJ1dGUuc3BsaXQoJyAnKSwgYWxpZ247XG5cbiAgICAgIGlmIChhc3BlY3RSYXRpb0F0dHJzICYmIGFzcGVjdFJhdGlvQXR0cnMubGVuZ3RoKSB7XG4gICAgICAgIG1lZXRPclNsaWNlID0gYXNwZWN0UmF0aW9BdHRycy5wb3AoKTtcbiAgICAgICAgaWYgKG1lZXRPclNsaWNlICE9PSAnbWVldCcgJiYgbWVldE9yU2xpY2UgIT09ICdzbGljZScpIHtcbiAgICAgICAgICBhbGlnbiA9IG1lZXRPclNsaWNlO1xuICAgICAgICAgIG1lZXRPclNsaWNlID0gJ21lZXQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFzcGVjdFJhdGlvQXR0cnMubGVuZ3RoKSB7XG4gICAgICAgICAgYWxpZ24gPSBhc3BlY3RSYXRpb0F0dHJzLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL2RpdmlkZSBhbGlnbiBpbiBhbGlnblggYW5kIGFsaWduWVxuICAgICAgYWxpZ25YID0gYWxpZ24gIT09ICdub25lJyA/IGFsaWduLnNsaWNlKDEsIDQpIDogJ25vbmUnO1xuICAgICAgYWxpZ25ZID0gYWxpZ24gIT09ICdub25lJyA/IGFsaWduLnNsaWNlKDUsIDgpIDogJ25vbmUnO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWVldE9yU2xpY2U6IG1lZXRPclNsaWNlLFxuICAgICAgICBhbGlnblg6IGFsaWduWCxcbiAgICAgICAgYWxpZ25ZOiBhbGlnbllcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFyIGNoYXIgd2lkdGhzIGNhY2hlIGZvciB0aGUgZ2l2ZW4gZm9udCBmYW1pbHkgb3IgYWxsIHRoZSBjYWNoZSBpZiBub1xuICAgICAqIGZvbnRGYW1pbHkgaXMgc3BlY2lmaWVkLlxuICAgICAqIFVzZSBpdCBpZiB5b3Uga25vdyB5b3UgYXJlIGxvYWRpbmcgZm9udHMgaW4gYSBsYXp5IHdheSBhbmQgeW91IGFyZSBub3Qgd2FpdGluZ1xuICAgICAqIGZvciBjdXN0b20gZm9udHMgdG8gbG9hZCBwcm9wZXJseSB3aGVuIGFkZGluZyB0ZXh0IG9iamVjdHMgdG8gdGhlIGNhbnZhcy5cbiAgICAgKiBJZiBhIHRleHQgb2JqZWN0IGlzIGFkZGVkIHdoZW4gaXRzIG93biBmb250IGlzIG5vdCBsb2FkZWQgeWV0LCB5b3Ugd2lsbCBnZXQgd3JvbmdcbiAgICAgKiBtZWFzdXJlbWVudCBhbmQgc28gd3JvbmcgYm91bmRpbmcgYm94ZXMuXG4gICAgICogQWZ0ZXIgdGhlIGZvbnQgY2FjaGUgaXMgY2xlYXJlZCwgZWl0aGVyIGNoYW5nZSB0aGUgdGV4dE9iamVjdCB0ZXh0IGNvbnRlbnQgb3IgY2FsbFxuICAgICAqIGluaXREaW1lbnNpb25zKCkgdG8gdHJpZ2dlciBhIHJlY2FsY3VsYXRpb25cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2ZvbnRGYW1pbHldIGZvbnQgZmFtaWx5IHRvIGNsZWFyXG4gICAgICovXG4gICAgY2xlYXJGYWJyaWNGb250Q2FjaGU6IGZ1bmN0aW9uKGZvbnRGYW1pbHkpIHtcbiAgICAgIGZvbnRGYW1pbHkgPSAoZm9udEZhbWlseSB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICghZm9udEZhbWlseSkge1xuICAgICAgICBmYWJyaWMuY2hhcldpZHRoc0NhY2hlID0geyB9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmFicmljLmNoYXJXaWR0aHNDYWNoZVtmb250RmFtaWx5XSkge1xuICAgICAgICBkZWxldGUgZmFicmljLmNoYXJXaWR0aHNDYWNoZVtmb250RmFtaWx5XTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gY3VycmVudCBhc3BlY3QgcmF0aW8sIGRldGVybWluZXMgdGhlIG1heCB3aWR0aCBhbmQgaGVpZ2h0IHRoYXQgY2FuXG4gICAgICogcmVzcGVjdCB0aGUgdG90YWwgYWxsb3dlZCBhcmVhIGZvciB0aGUgY2FjaGUuXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFyIGFzcGVjdCByYXRpb1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhpbXVtQXJlYSBNYXhpbXVtIGFyZWEgeW91IHdhbnQgdG8gYWNoaWV2ZVxuICAgICAqIEByZXR1cm4ge09iamVjdC54fSBMaW1pdGVkIGRpbWVuc2lvbnMgYnkgWFxuICAgICAqIEByZXR1cm4ge09iamVjdC55fSBMaW1pdGVkIGRpbWVuc2lvbnMgYnkgWVxuICAgICAqL1xuICAgIGxpbWl0RGltc0J5QXJlYTogZnVuY3Rpb24oYXIsIG1heGltdW1BcmVhKSB7XG4gICAgICB2YXIgcm91Z2hXaWR0aCA9IE1hdGguc3FydChtYXhpbXVtQXJlYSAqIGFyKSxcbiAgICAgICAgICBwZXJmTGltaXRTaXplWSA9IE1hdGguZmxvb3IobWF4aW11bUFyZWEgLyByb3VnaFdpZHRoKTtcbiAgICAgIHJldHVybiB7IHg6IE1hdGguZmxvb3Iocm91Z2hXaWR0aCksIHk6IHBlcmZMaW1pdFNpemVZIH07XG4gICAgfSxcblxuICAgIGNhcFZhbHVlOiBmdW5jdGlvbihtaW4sIHZhbHVlLCBtYXgpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKHZhbHVlLCBtYXgpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIHNjYWxlIGZvciB0aGUgb2JqZWN0IHNvdXJjZSB0byBmaXQgaW5zaWRlIHRoZSBvYmplY3QgZGVzdGluYXRpb24sXG4gICAgICoga2VlcGluZyBhc3BlY3QgcmF0aW8gaW50YWN0LlxuICAgICAqIHJlc3BlY3QgdGhlIHRvdGFsIGFsbG93ZWQgYXJlYSBmb3IgdGhlIGNhY2hlLlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0IHwgZmFicmljLk9iamVjdH0gc291cmNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNvdXJjZS5oZWlnaHQgbmF0dXJhbCB1bnNjYWxlZCBoZWlnaHQgb2YgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzb3VyY2Uud2lkdGggbmF0dXJhbCB1bnNjYWxlZCB3aWR0aCBvZiB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3QgfCBmYWJyaWMuT2JqZWN0fSBkZXN0aW5hdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZXN0aW5hdGlvbi5oZWlnaHQgbmF0dXJhbCB1bnNjYWxlZCBoZWlnaHQgb2YgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZXN0aW5hdGlvbi53aWR0aCBuYXR1cmFsIHVuc2NhbGVkIHdpZHRoIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHNjYWxlIGZhY3RvciB0byBhcHBseSB0byBzb3VyY2UgdG8gZml0IGludG8gZGVzdGluYXRpb25cbiAgICAgKi9cbiAgICBmaW5kU2NhbGVUb0ZpdDogZnVuY3Rpb24oc291cmNlLCBkZXN0aW5hdGlvbikge1xuICAgICAgcmV0dXJuIE1hdGgubWluKGRlc3RpbmF0aW9uLndpZHRoIC8gc291cmNlLndpZHRoLCBkZXN0aW5hdGlvbi5oZWlnaHQgLyBzb3VyY2UuaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIHNjYWxlIGZvciB0aGUgb2JqZWN0IHNvdXJjZSB0byBjb3ZlciBlbnRpcmVseSB0aGUgb2JqZWN0IGRlc3RpbmF0aW9uLFxuICAgICAqIGtlZXBpbmcgYXNwZWN0IHJhdGlvIGludGFjdC5cbiAgICAgKiByZXNwZWN0IHRoZSB0b3RhbCBhbGxvd2VkIGFyZWEgZm9yIHRoZSBjYWNoZS5cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdCB8IGZhYnJpYy5PYmplY3R9IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzb3VyY2UuaGVpZ2h0IG5hdHVyYWwgdW5zY2FsZWQgaGVpZ2h0IG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc291cmNlLndpZHRoIG5hdHVyYWwgdW5zY2FsZWQgd2lkdGggb2YgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0IHwgZmFicmljLk9iamVjdH0gZGVzdGluYXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVzdGluYXRpb24uaGVpZ2h0IG5hdHVyYWwgdW5zY2FsZWQgaGVpZ2h0IG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVzdGluYXRpb24ud2lkdGggbmF0dXJhbCB1bnNjYWxlZCB3aWR0aCBvZiB0aGUgb2JqZWN0XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBzY2FsZSBmYWN0b3IgdG8gYXBwbHkgdG8gc291cmNlIHRvIGNvdmVyIGRlc3RpbmF0aW9uXG4gICAgICovXG4gICAgZmluZFNjYWxlVG9Db3ZlcjogZnVuY3Rpb24oc291cmNlLCBkZXN0aW5hdGlvbikge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KGRlc3RpbmF0aW9uLndpZHRoIC8gc291cmNlLndpZHRoLCBkZXN0aW5hdGlvbi5oZWlnaHQgLyBzb3VyY2UuaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZ2l2ZW4gYW4gYXJyYXkgb2YgNiBudW1iZXIgcmV0dXJucyBzb21ldGhpbmcgbGlrZSBgXCJtYXRyaXgoLi4ubnVtYmVycylcImBcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0cmFuc2Zvcm0gYW4gYXJyYXkgd2l0aCA2IG51bWJlcnNcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRyYW5zZm9ybSBtYXRyaXggZm9yIHN2Z1xuICAgICAqIEByZXR1cm4ge09iamVjdC55fSBMaW1pdGVkIGRpbWVuc2lvbnMgYnkgWVxuICAgICAqL1xuICAgIG1hdHJpeFRvU1ZHOiBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgICAgIHJldHVybiAnbWF0cml4KCcgKyB0cmFuc2Zvcm0ubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmYWJyaWMudXRpbC50b0ZpeGVkKHZhbHVlLCBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFMpO1xuICAgICAgfSkuam9pbignICcpICsgJyknO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBnaXZlbiBhbiBvYmplY3QgYW5kIGEgdHJhbnNmb3JtLCBhcHBseSB0aGUgaW52ZXJzZSB0cmFuc2Zvcm0gdG8gdGhlIG9iamVjdCxcbiAgICAgKiB0aGlzIGlzIGVxdWl2YWxlbnQgdG8gcmVtb3ZlIGZyb20gdGhhdCBvYmplY3QgdGhhdCB0cmFuc2Zvcm1hdGlvbiwgc28gdGhhdFxuICAgICAqIGFkZGVkIGluIGEgc3BhY2Ugd2l0aCB0aGUgcmVtb3ZlZCB0cmFuc2Zvcm0sIHRoZSBvYmplY3Qgd2lsbCBiZSB0aGUgc2FtZSBhcyBiZWZvcmUuXG4gICAgICogUmVtb3ZpbmcgZnJvbSBhbiBvYmplY3QgYSB0cmFuc2Zvcm0gdGhhdCBzY2FsZSBieSAyIGlzIGxpa2Ugc2NhbGluZyBpdCBieSAxLzIuXG4gICAgICogUmVtb3ZpbmcgZnJvbSBhbiBvYmplY3QgYSB0cmFuc2Zyb20gdGhhdCByb3RhdGUgYnkgMzBkZWcgaXMgbGlrZSByb3RhdGluZyBieSAzMGRlZ1xuICAgICAqIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24uXG4gICAgICogVGhpcyB1dGlsIGlzIHVzZWQgdG8gYWRkIG9iamVjdHMgaW5zaWRlIHRyYW5zZm9ybWVkIGdyb3VwcyBvciBuZXN0ZWQgZ3JvdXBzLlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IHRoZSBvYmplY3QgeW91IHdhbnQgdG8gdHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtIHRoZSBkZXN0aW5hdGlvbiB0cmFuc2Zvcm1cbiAgICAgKi9cbiAgICByZW1vdmVUcmFuc2Zvcm1Gcm9tT2JqZWN0OiBmdW5jdGlvbihvYmplY3QsIHRyYW5zZm9ybSkge1xuICAgICAgdmFyIGludmVydGVkID0gZmFicmljLnV0aWwuaW52ZXJ0VHJhbnNmb3JtKHRyYW5zZm9ybSksXG4gICAgICAgICAgZmluYWxUcmFuc2Zvcm0gPSBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzKGludmVydGVkLCBvYmplY3QuY2FsY093bk1hdHJpeCgpKTtcbiAgICAgIGZhYnJpYy51dGlsLmFwcGx5VHJhbnNmb3JtVG9PYmplY3Qob2JqZWN0LCBmaW5hbFRyYW5zZm9ybSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdpdmVuIGFuIG9iamVjdCBhbmQgYSB0cmFuc2Zvcm0sIGFwcGx5IHRoZSB0cmFuc2Zvcm0gdG8gdGhlIG9iamVjdC5cbiAgICAgKiB0aGlzIGlzIGVxdWl2YWxlbnQgdG8gY2hhbmdlIHRoZSBzcGFjZSB3aGVyZSB0aGUgb2JqZWN0IGlzIGRyYXduLlxuICAgICAqIEFkZGluZyB0byBhbiBvYmplY3QgYSB0cmFuc2Zvcm0gdGhhdCBzY2FsZSBieSAyIGlzIGxpa2Ugc2NhbGluZyBpdCBieSAyLlxuICAgICAqIFRoaXMgaXMgdXNlZCB3aGVuIHJlbW92aW5nIGFuIG9iamVjdCBmcm9tIGFuIGFjdGl2ZSBzZWxlY3Rpb24gZm9yIGV4YW1wbGUuXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgdGhlIG9iamVjdCB5b3Ugd2FudCB0byB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0cmFuc2Zvcm0gdGhlIGRlc3RpbmF0aW9uIHRyYW5zZm9ybVxuICAgICAqL1xuICAgIGFkZFRyYW5zZm9ybVRvT2JqZWN0OiBmdW5jdGlvbihvYmplY3QsIHRyYW5zZm9ybSkge1xuICAgICAgZmFicmljLnV0aWwuYXBwbHlUcmFuc2Zvcm1Ub09iamVjdChcbiAgICAgICAgb2JqZWN0LFxuICAgICAgICBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzKHRyYW5zZm9ybSwgb2JqZWN0LmNhbGNPd25NYXRyaXgoKSlcbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRpc2NhcmQgYW4gb2JqZWN0IHRyYW5zZm9ybSBzdGF0ZSBhbmQgYXBwbHkgdGhlIG9uZSBmcm9tIHRoZSBtYXRyaXguXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgdGhlIG9iamVjdCB5b3Ugd2FudCB0byB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0cmFuc2Zvcm0gdGhlIGRlc3RpbmF0aW9uIHRyYW5zZm9ybVxuICAgICAqL1xuICAgIGFwcGx5VHJhbnNmb3JtVG9PYmplY3Q6IGZ1bmN0aW9uKG9iamVjdCwgdHJhbnNmb3JtKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGZhYnJpYy51dGlsLnFyRGVjb21wb3NlKHRyYW5zZm9ybSksXG4gICAgICAgICAgY2VudGVyID0gbmV3IGZhYnJpYy5Qb2ludChvcHRpb25zLnRyYW5zbGF0ZVgsIG9wdGlvbnMudHJhbnNsYXRlWSk7XG4gICAgICBvYmplY3QuZmxpcFggPSBmYWxzZTtcbiAgICAgIG9iamVjdC5mbGlwWSA9IGZhbHNlO1xuICAgICAgb2JqZWN0LnNldCgnc2NhbGVYJywgb3B0aW9ucy5zY2FsZVgpO1xuICAgICAgb2JqZWN0LnNldCgnc2NhbGVZJywgb3B0aW9ucy5zY2FsZVkpO1xuICAgICAgb2JqZWN0LnNrZXdYID0gb3B0aW9ucy5za2V3WDtcbiAgICAgIG9iamVjdC5za2V3WSA9IG9wdGlvbnMuc2tld1k7XG4gICAgICBvYmplY3QuYW5nbGUgPSBvcHRpb25zLmFuZ2xlO1xuICAgICAgb2JqZWN0LnNldFBvc2l0aW9uQnlPcmlnaW4oY2VudGVyLCAnY2VudGVyJywgJ2NlbnRlcicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBnaXZlbiBhIHdpZHRoIGFuZCBoZWlnaHQsIHJldHVybiB0aGUgc2l6ZSBvZiB0aGUgYm91bmRpbmcgYm94XG4gICAgICogdGhhdCBjYW4gY29udGFpbnMgdGhlIGJveCB3aXRoIHdpZHRoL2hlaWdodCB3aXRoIGFwcGxpZWQgdHJhbnNmb3JtXG4gICAgICogZGVzY3JpYmVkIGluIG9wdGlvbnMuXG4gICAgICogVXNlIHRvIGNhbGN1bGF0ZSB0aGUgYm94ZXMgYXJvdW5kIG9iamVjdHMgZm9yIGNvbnRyb2xzLlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnNjYWxlWFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnNjYWxlWVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnNrZXdYXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuc2tld1lcbiAgICAgKiBAcmV0dXJuIHtPYmplY3QueH0gd2lkdGggb2YgY29udGFpbmluZ1xuICAgICAqIEByZXR1cm4ge09iamVjdC55fSBoZWlnaHQgb2YgY29udGFpbmluZ1xuICAgICAqL1xuICAgIHNpemVBZnRlclRyYW5zZm9ybTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xuICAgICAgdmFyIGRpbVggPSB3aWR0aCAvIDIsIGRpbVkgPSBoZWlnaHQgLyAyLFxuICAgICAgICAgIHBvaW50cyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgeDogLWRpbVgsXG4gICAgICAgICAgICAgIHk6IC1kaW1ZXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB4OiBkaW1YLFxuICAgICAgICAgICAgICB5OiAtZGltWVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgeDogLWRpbVgsXG4gICAgICAgICAgICAgIHk6IGRpbVlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHg6IGRpbVgsXG4gICAgICAgICAgICAgIHk6IGRpbVlcbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgIHRyYW5zZm9ybU1hdHJpeCA9IGZhYnJpYy51dGlsLmNhbGNEaW1lbnNpb25zTWF0cml4KG9wdGlvbnMpLFxuICAgICAgICAgIGJib3ggPSBmYWJyaWMudXRpbC5tYWtlQm91bmRpbmdCb3hGcm9tUG9pbnRzKHBvaW50cywgdHJhbnNmb3JtTWF0cml4KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGJib3gud2lkdGgsXG4gICAgICAgIHk6IGJib3guaGVpZ2h0LFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIDIgY2xpcCBwYXRocyBpbnRvIG9uZSB2aXN1YWxseSBlcXVhbCBjbGlwIHBhdGhcbiAgICAgKlxuICAgICAqICoqSU1QT1JUQU5UKio6XFxcbiAgICAgKiBEb2VzICoqTk9UKiogY2xvbmUgdGhlIGFyZ3VtZW50cywgY2xvbmUgdGhlbSBwcm9pciBpZiBuZWNlc3NhcnkuXG4gICAgICpcbiAgICAgKiBDcmVhdGVzIGEgd3JhcHBlciAoZ3JvdXApIHRoYXQgY29udGFpbnMgb25lIGNsaXAgcGF0aCBhbmQgaXMgY2xpcHBlZCBieSB0aGUgb3RoZXIgc28gY29udGVudCBpcyBrZXB0IHdoZXJlIGJvdGggb3ZlcmxhcC5cbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgaWYgYm90aCB0aGUgY2xpcCBwYXRocyBtYXkgaGF2ZSBuZXN0ZWQgY2xpcCBwYXRocyBvZiB0aGVpciBvd24sIHNvIGFzc2lnbmluZyBvbmUgdG8gdGhlIG90aGVyJ3MgY2xpcCBwYXRoIHByb3BlcnR5IGlzIG5vdCBwb3NzaWJsZS5cbiAgICAgKlxuICAgICAqIEluIG9yZGVyIHRvIGhhbmRsZSB0aGUgYGludmVydGVkYCBwcm9wZXJ0eSB3ZSBmb2xsb3cgbG9naWMgZGVzY3JpYmVkIGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XFxcbiAgICAgKiAqKigxKSoqIGJvdGggY2xpcCBwYXRocyBhcmUgaW52ZXJ0ZWQgLSB0aGUgY2xpcCBwYXRocyBwYXNzIHRoZSBpbnZlcnRlZCBwcm9wIHRvIHRoZSB3cmFwcGVyIGFuZCBsb29zZSBpdCB0aGVtc2VsdmVzLlxcXG4gICAgICogKiooMikqKiBvbmUgaXMgaW52ZXJ0ZWQgYW5kIHRoZSBvdGhlciBpc24ndCAtIHRoZSB3cmFwcGVyIHNob3VsZG4ndCBiZWNvbWUgaW52ZXJ0ZWQgYW5kIHRoZSBpbnZlcnRlZCBjbGlwIHBhdGggbXVzdCBjbGlwIHRoZSBub24gaW52ZXJ0ZWQgb25lIHRvIHByb2R1Y2UgYW4gaWRlbnRpY2FsIHZpc3VhbCBlZmZlY3QuXFxcbiAgICAgKiAqKigzKSoqIGJvdGggY2xpcCBwYXRocyBhcmUgbm90IGludmVydGVkIC0gd3JhcHBlciBhbmQgY2xpcCBwYXRocyByZW1haW4gdW5jaGFuZ2VkLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBjMVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gYzJcbiAgICAgKiBAcmV0dXJucyB7ZmFicmljLk9iamVjdH0gbWVyZ2VkIGNsaXAgcGF0aFxuICAgICAqL1xuICAgIG1lcmdlQ2xpcFBhdGhzOiBmdW5jdGlvbiAoYzEsIGMyKSB7XG4gICAgICB2YXIgYSA9IGMxLCBiID0gYzI7XG4gICAgICBpZiAoYS5pbnZlcnRlZCAmJiAhYi5pbnZlcnRlZCkge1xuICAgICAgICAvLyAgY2FzZSAoMilcbiAgICAgICAgYSA9IGMyO1xuICAgICAgICBiID0gYzE7XG4gICAgICB9XG4gICAgICAvLyAgYGJgIGJlY29tZXMgYGFgJ3MgY2xpcCBwYXRoIHNvIHdlIHRyYW5zZm9ybSBgYmAgdG8gYGFgIGNvb3JkaW5hdGUgcGxhbmVcbiAgICAgIGZhYnJpYy51dGlsLmFwcGx5VHJhbnNmb3JtVG9PYmplY3QoXG4gICAgICAgIGIsXG4gICAgICAgIGZhYnJpYy51dGlsLm11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMoXG4gICAgICAgICAgZmFicmljLnV0aWwuaW52ZXJ0VHJhbnNmb3JtKGEuY2FsY1RyYW5zZm9ybU1hdHJpeCgpKSxcbiAgICAgICAgICBiLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgLy8gIGFzc2lnbiB0aGUgYGludmVydGVkYCBwcm9wIHRvIHRoZSB3cmFwcGluZyBncm91cFxuICAgICAgdmFyIGludmVydGVkID0gYS5pbnZlcnRlZCAmJiBiLmludmVydGVkO1xuICAgICAgaWYgKGludmVydGVkKSB7XG4gICAgICAgIC8vICBjYXNlICgxKVxuICAgICAgICBhLmludmVydGVkID0gYi5pbnZlcnRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuR3JvdXAoW2FdLCB7IGNsaXBQYXRoOiBiLCBpbnZlcnRlZDogaW52ZXJ0ZWQgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcmV2U3R5bGUgZmlyc3Qgc3R5bGUgdG8gY29tcGFyZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzU3R5bGUgc2Vjb25kIHN0eWxlIHRvIGNvbXBhcmVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvclRleHRTcGFucyB3aGV0aGVyIHRvIGNoZWNrIG92ZXJsaW5lLCB1bmRlcmxpbmUsIGFuZCBsaW5lLXRocm91Z2ggcHJvcGVydGllc1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHN0eWxlIGNoYW5nZWRcbiAgICAgKi9cbiAgICBoYXNTdHlsZUNoYW5nZWQ6IGZ1bmN0aW9uKHByZXZTdHlsZSwgdGhpc1N0eWxlLCBmb3JUZXh0U3BhbnMpIHtcbiAgICAgIGZvclRleHRTcGFucyA9IGZvclRleHRTcGFucyB8fCBmYWxzZTtcbiAgICAgIHJldHVybiAocHJldlN0eWxlLmZpbGwgIT09IHRoaXNTdHlsZS5maWxsIHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5zdHJva2UgIT09IHRoaXNTdHlsZS5zdHJva2UgfHxcbiAgICAgICAgICAgICAgcHJldlN0eWxlLnN0cm9rZVdpZHRoICE9PSB0aGlzU3R5bGUuc3Ryb2tlV2lkdGggfHxcbiAgICAgICAgICAgICAgcHJldlN0eWxlLmZvbnRTaXplICE9PSB0aGlzU3R5bGUuZm9udFNpemUgfHxcbiAgICAgICAgICAgICAgcHJldlN0eWxlLmZvbnRGYW1pbHkgIT09IHRoaXNTdHlsZS5mb250RmFtaWx5IHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS5mb250V2VpZ2h0ICE9PSB0aGlzU3R5bGUuZm9udFdlaWdodCB8fFxuICAgICAgICAgICAgICBwcmV2U3R5bGUuZm9udFN0eWxlICE9PSB0aGlzU3R5bGUuZm9udFN0eWxlIHx8XG4gICAgICAgICAgICAgIHByZXZTdHlsZS50ZXh0QmFja2dyb3VuZENvbG9yICE9PSB0aGlzU3R5bGUudGV4dEJhY2tncm91bmRDb2xvciB8fFxuICAgICAgICAgICAgICBwcmV2U3R5bGUuZGVsdGFZICE9PSB0aGlzU3R5bGUuZGVsdGFZKSB8fFxuICAgICAgICAgICAgICAoZm9yVGV4dFNwYW5zICYmXG4gICAgICAgICAgICAgICAgKHByZXZTdHlsZS5vdmVybGluZSAhPT0gdGhpc1N0eWxlLm92ZXJsaW5lIHx8XG4gICAgICAgICAgICAgICAgcHJldlN0eWxlLnVuZGVybGluZSAhPT0gdGhpc1N0eWxlLnVuZGVybGluZSB8fFxuICAgICAgICAgICAgICAgIHByZXZTdHlsZS5saW5ldGhyb3VnaCAhPT0gdGhpc1N0eWxlLmxpbmV0aHJvdWdoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFycmF5IGZvcm0gb2YgYSB0ZXh0IG9iamVjdCdzIGlubGluZSBzdHlsZXMgcHJvcGVydHkgd2l0aCBzdHlsZXMgZ3JvdXBlZCBpbiByYW5nZXNcbiAgICAgKiByYXRoZXIgdGhhbiBwZXIgY2hhcmFjdGVyLiBUaGlzIGZvcm1hdCBpcyBsZXNzIHZlcmJvc2UsIGFuZCBpcyBiZXR0ZXIgc3VpdGVkIGZvciBzdG9yYWdlXG4gICAgICogc28gaXQgaXMgdXNlZCBpbiBzZXJpYWxpemF0aW9uIChub3QgZHVyaW5nIHJ1bnRpbWUpLlxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXMgcGVyIGNoYXJhY3RlciBzdHlsZXMgZm9yIGEgdGV4dCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCB0aGUgdGV4dCBzdHJpbmcgdGhhdCB0aGUgc3R5bGVzIGFyZSBhcHBsaWVkIHRvXG4gICAgICogQHJldHVybiB7e3N0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyLCBzdHlsZTogb2JqZWN0fVtdfVxuICAgICAqL1xuICAgIHN0eWxlc1RvQXJyYXk6IGZ1bmN0aW9uKHN0eWxlcywgdGV4dCkge1xuICAgICAgLy8gY2xvbmUgc3R5bGUgc3RydWN0dXJlIHRvIHByZXZlbnQgbXV0YXRpb25cbiAgICAgIHZhciBzdHlsZXMgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUoc3R5bGVzLCB0cnVlKSxcbiAgICAgICAgICB0ZXh0TGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKSxcbiAgICAgICAgICBjaGFySW5kZXggPSAtMSwgcHJldlN0eWxlID0ge30sIHN0eWxlc0FycmF5ID0gW107XG4gICAgICAvL2xvb3AgdGhyb3VnaCBlYWNoIHRleHRMaW5lXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXN0eWxlc1tpXSkge1xuICAgICAgICAgIC8vbm8gc3R5bGVzIGV4aXN0IGZvciB0aGlzIGxpbmUsIHNvIGFkZCB0aGUgbGluZSdzIGxlbmd0aCB0byB0aGUgY2hhckluZGV4IHRvdGFsXG4gICAgICAgICAgY2hhckluZGV4ICs9IHRleHRMaW5lc1tpXS5sZW5ndGg7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy9sb29wIHRocm91Z2ggZWFjaCBjaGFyYWN0ZXIgb2YgdGhlIGN1cnJlbnQgbGluZVxuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IHRleHRMaW5lc1tpXS5sZW5ndGg7IGMrKykge1xuICAgICAgICAgIGNoYXJJbmRleCsrO1xuICAgICAgICAgIHZhciB0aGlzU3R5bGUgPSBzdHlsZXNbaV1bY107XG4gICAgICAgICAgLy9jaGVjayBpZiBzdHlsZSBleGlzdHMgZm9yIHRoaXMgY2hhcmFjdGVyXG4gICAgICAgICAgaWYgKHRoaXNTdHlsZSAmJiBPYmplY3Qua2V5cyh0aGlzU3R5bGUpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBzdHlsZUNoYW5nZWQgPSBmYWJyaWMudXRpbC5oYXNTdHlsZUNoYW5nZWQocHJldlN0eWxlLCB0aGlzU3R5bGUsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHN0eWxlQ2hhbmdlZCkge1xuICAgICAgICAgICAgICBzdHlsZXNBcnJheS5wdXNoKHtcbiAgICAgICAgICAgICAgICBzdGFydDogY2hhckluZGV4LFxuICAgICAgICAgICAgICAgIGVuZDogY2hhckluZGV4ICsgMSxcbiAgICAgICAgICAgICAgICBzdHlsZTogdGhpc1N0eWxlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vaWYgc3R5bGUgaXMgdGhlIHNhbWUgYXMgcHJldmlvdXMgY2hhcmFjdGVyLCBpbmNyZWFzZSBlbmQgaW5kZXhcbiAgICAgICAgICAgICAgc3R5bGVzQXJyYXlbc3R5bGVzQXJyYXkubGVuZ3RoIC0gMV0uZW5kKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHByZXZTdHlsZSA9IHRoaXNTdHlsZSB8fCB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eWxlc0FycmF5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvYmplY3QgZm9ybSBvZiB0aGUgc3R5bGVzIHByb3BlcnR5IHdpdGggc3R5bGVzIHRoYXQgYXJlIGFzc2lnbmVkIHBlclxuICAgICAqIGNoYXJhY3RlciByYXRoZXIgdGhhbiBncm91cGVkIGJ5IHJhbmdlLiBUaGlzIGZvcm1hdCBpcyBtb3JlIHZlcmJvc2UsIGFuZCBpc1xuICAgICAqIG9ubHkgdXNlZCBkdXJpbmcgcnVudGltZSAobm90IGZvciBzZXJpYWxpemF0aW9uL3N0b3JhZ2UpXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gc3R5bGVzIHRoZSBzZXJpYWxpemVkIGZvcm0gb2YgYSB0ZXh0IG9iamVjdCdzIHN0eWxlc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IHRoZSB0ZXh0IHN0cmluZyB0aGF0IHRoZSBzdHlsZXMgYXJlIGFwcGxpZWQgdG9cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgc3R5bGVzRnJvbUFycmF5OiBmdW5jdGlvbihzdHlsZXMsIHRleHQpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShzdHlsZXMpKSB7XG4gICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgICB9XG4gICAgICB2YXIgdGV4dExpbmVzID0gdGV4dC5zcGxpdCgnXFxuJyksXG4gICAgICAgICAgY2hhckluZGV4ID0gLTEsIHN0eWxlSW5kZXggPSAwLCBzdHlsZXNPYmplY3QgPSB7fTtcbiAgICAgIC8vbG9vcCB0aHJvdWdoIGVhY2ggdGV4dExpbmVcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dExpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vbG9vcCB0aHJvdWdoIGVhY2ggY2hhcmFjdGVyIG9mIHRoZSBjdXJyZW50IGxpbmVcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCB0ZXh0TGluZXNbaV0ubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICBjaGFySW5kZXgrKztcbiAgICAgICAgICAvL2NoZWNrIGlmIHRoZXJlJ3MgYSBzdHlsZSBjb2xsZWN0aW9uIHRoYXQgaW5jbHVkZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyXG4gICAgICAgICAgaWYgKHN0eWxlc1tzdHlsZUluZGV4XVxuICAgICAgICAgICAgJiYgc3R5bGVzW3N0eWxlSW5kZXhdLnN0YXJ0IDw9IGNoYXJJbmRleFxuICAgICAgICAgICAgJiYgY2hhckluZGV4IDwgc3R5bGVzW3N0eWxlSW5kZXhdLmVuZCkge1xuICAgICAgICAgICAgLy9jcmVhdGUgb2JqZWN0IGZvciBsaW5lIGluZGV4IGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICAgIHN0eWxlc09iamVjdFtpXSA9IHN0eWxlc09iamVjdFtpXSB8fCB7fTtcbiAgICAgICAgICAgIC8vYXNzaWduIGEgc3R5bGUgYXQgdGhpcyBjaGFyYWN0ZXIncyBpbmRleFxuICAgICAgICAgICAgc3R5bGVzT2JqZWN0W2ldW2NdID0gT2JqZWN0LmFzc2lnbih7fSwgc3R5bGVzW3N0eWxlSW5kZXhdLnN0eWxlKTtcbiAgICAgICAgICAgIC8vaWYgY2hhcmFjdGVyIGlzIGF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgc3R5bGUgY29sbGVjdGlvbiwgbW92ZSB0byB0aGUgbmV4dFxuICAgICAgICAgICAgaWYgKGNoYXJJbmRleCA9PT0gc3R5bGVzW3N0eWxlSW5kZXhdLmVuZCAtIDEpIHtcbiAgICAgICAgICAgICAgc3R5bGVJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0eWxlc09iamVjdDtcbiAgICB9XG4gIH07XG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgX2pvaW4gPSBBcnJheS5wcm90b3R5cGUuam9pbixcbiAgICAgIGNvbW1hbmRMZW5ndGhzID0ge1xuICAgICAgICBtOiAyLFxuICAgICAgICBsOiAyLFxuICAgICAgICBoOiAxLFxuICAgICAgICB2OiAxLFxuICAgICAgICBjOiA2LFxuICAgICAgICBzOiA0LFxuICAgICAgICBxOiA0LFxuICAgICAgICB0OiAyLFxuICAgICAgICBhOiA3XG4gICAgICB9LFxuICAgICAgcmVwZWF0ZWRDb21tYW5kcyA9IHtcbiAgICAgICAgbTogJ2wnLFxuICAgICAgICBNOiAnTCdcbiAgICAgIH07XG4gIGZ1bmN0aW9uIHNlZ21lbnRUb0Jlemllcih0aDIsIHRoMywgY29zVGgsIHNpblRoLCByeCwgcnksIGN4MSwgY3kxLCBtVCwgZnJvbVgsIGZyb21ZKSB7XG4gICAgdmFyIGNvc3RoMiA9IGZhYnJpYy51dGlsLmNvcyh0aDIpLFxuICAgICAgICBzaW50aDIgPSBmYWJyaWMudXRpbC5zaW4odGgyKSxcbiAgICAgICAgY29zdGgzID0gZmFicmljLnV0aWwuY29zKHRoMyksXG4gICAgICAgIHNpbnRoMyA9IGZhYnJpYy51dGlsLnNpbih0aDMpLFxuICAgICAgICB0b1ggPSBjb3NUaCAqIHJ4ICogY29zdGgzIC0gc2luVGggKiByeSAqIHNpbnRoMyArIGN4MSxcbiAgICAgICAgdG9ZID0gc2luVGggKiByeCAqIGNvc3RoMyArIGNvc1RoICogcnkgKiBzaW50aDMgKyBjeTEsXG4gICAgICAgIGNwMVggPSBmcm9tWCArIG1UICogKCAtY29zVGggKiByeCAqIHNpbnRoMiAtIHNpblRoICogcnkgKiBjb3N0aDIpLFxuICAgICAgICBjcDFZID0gZnJvbVkgKyBtVCAqICggLXNpblRoICogcnggKiBzaW50aDIgKyBjb3NUaCAqIHJ5ICogY29zdGgyKSxcbiAgICAgICAgY3AyWCA9IHRvWCArIG1UICogKCBjb3NUaCAqIHJ4ICogc2ludGgzICsgc2luVGggKiByeSAqIGNvc3RoMyksXG4gICAgICAgIGNwMlkgPSB0b1kgKyBtVCAqICggc2luVGggKiByeCAqIHNpbnRoMyAtIGNvc1RoICogcnkgKiBjb3N0aDMpO1xuXG4gICAgcmV0dXJuIFsnQycsXG4gICAgICBjcDFYLCBjcDFZLFxuICAgICAgY3AyWCwgY3AyWSxcbiAgICAgIHRvWCwgdG9ZXG4gICAgXTtcbiAgfVxuXG4gIC8qIEFkYXB0ZWQgZnJvbSBodHRwOi8vZHhyLm1vemlsbGEub3JnL21vemlsbGEtY2VudHJhbC9zb3VyY2UvY29udGVudC9zdmcvY29udGVudC9zcmMvbnNTVkdQYXRoRGF0YVBhcnNlci5jcHBcbiAgICogYnkgQW5kcmVhIEJvZ2F6emkgY29kZSBpcyB1bmRlciBNUEwuIGlmIHlvdSBkb24ndCBoYXZlIGEgY29weSBvZiB0aGUgbGljZW5zZSB5b3UgY2FuIHRha2UgaXQgaGVyZVxuICAgKiBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC9cbiAgICovXG4gIGZ1bmN0aW9uIGFyY1RvU2VnbWVudHModG9YLCB0b1ksIHJ4LCByeSwgbGFyZ2UsIHN3ZWVwLCByb3RhdGVYKSB7XG4gICAgdmFyIFBJID0gTWF0aC5QSSwgdGggPSByb3RhdGVYICogUEkgLyAxODAsXG4gICAgICAgIHNpblRoID0gZmFicmljLnV0aWwuc2luKHRoKSxcbiAgICAgICAgY29zVGggPSBmYWJyaWMudXRpbC5jb3ModGgpLFxuICAgICAgICBmcm9tWCA9IDAsIGZyb21ZID0gMDtcblxuICAgIHJ4ID0gTWF0aC5hYnMocngpO1xuICAgIHJ5ID0gTWF0aC5hYnMocnkpO1xuXG4gICAgdmFyIHB4ID0gLWNvc1RoICogdG9YICogMC41IC0gc2luVGggKiB0b1kgKiAwLjUsXG4gICAgICAgIHB5ID0gLWNvc1RoICogdG9ZICogMC41ICsgc2luVGggKiB0b1ggKiAwLjUsXG4gICAgICAgIHJ4MiA9IHJ4ICogcngsIHJ5MiA9IHJ5ICogcnksIHB5MiA9IHB5ICogcHksIHB4MiA9IHB4ICogcHgsXG4gICAgICAgIHBsID0gcngyICogcnkyIC0gcngyICogcHkyIC0gcnkyICogcHgyLFxuICAgICAgICByb290ID0gMDtcblxuICAgIGlmIChwbCA8IDApIHtcbiAgICAgIHZhciBzID0gTWF0aC5zcXJ0KDEgLSBwbCAvIChyeDIgKiByeTIpKTtcbiAgICAgIHJ4ICo9IHM7XG4gICAgICByeSAqPSBzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJvb3QgPSAobGFyZ2UgPT09IHN3ZWVwID8gLTEuMCA6IDEuMCkgKlxuICAgICAgICAgICAgICBNYXRoLnNxcnQoIHBsIC8gKHJ4MiAqIHB5MiArIHJ5MiAqIHB4MikpO1xuICAgIH1cblxuICAgIHZhciBjeCA9IHJvb3QgKiByeCAqIHB5IC8gcnksXG4gICAgICAgIGN5ID0gLXJvb3QgKiByeSAqIHB4IC8gcngsXG4gICAgICAgIGN4MSA9IGNvc1RoICogY3ggLSBzaW5UaCAqIGN5ICsgdG9YICogMC41LFxuICAgICAgICBjeTEgPSBzaW5UaCAqIGN4ICsgY29zVGggKiBjeSArIHRvWSAqIDAuNSxcbiAgICAgICAgbVRoZXRhID0gY2FsY1ZlY3RvckFuZ2xlKDEsIDAsIChweCAtIGN4KSAvIHJ4LCAocHkgLSBjeSkgLyByeSksXG4gICAgICAgIGR0aGV0YSA9IGNhbGNWZWN0b3JBbmdsZSgocHggLSBjeCkgLyByeCwgKHB5IC0gY3kpIC8gcnksICgtcHggLSBjeCkgLyByeCwgKC1weSAtIGN5KSAvIHJ5KTtcblxuICAgIGlmIChzd2VlcCA9PT0gMCAmJiBkdGhldGEgPiAwKSB7XG4gICAgICBkdGhldGEgLT0gMiAqIFBJO1xuICAgIH1cbiAgICBlbHNlIGlmIChzd2VlcCA9PT0gMSAmJiBkdGhldGEgPCAwKSB7XG4gICAgICBkdGhldGEgKz0gMiAqIFBJO1xuICAgIH1cblxuICAgIC8vIENvbnZlcnQgaW50byBjdWJpYyBiZXppZXIgc2VnbWVudHMgPD0gOTBkZWdcbiAgICB2YXIgc2VnbWVudHMgPSBNYXRoLmNlaWwoTWF0aC5hYnMoZHRoZXRhIC8gUEkgKiAyKSksXG4gICAgICAgIHJlc3VsdCA9IFtdLCBtRGVsdGEgPSBkdGhldGEgLyBzZWdtZW50cyxcbiAgICAgICAgbVQgPSA4IC8gMyAqIE1hdGguc2luKG1EZWx0YSAvIDQpICogTWF0aC5zaW4obURlbHRhIC8gNCkgLyBNYXRoLnNpbihtRGVsdGEgLyAyKSxcbiAgICAgICAgdGgzID0gbVRoZXRhICsgbURlbHRhO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50czsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSBzZWdtZW50VG9CZXppZXIobVRoZXRhLCB0aDMsIGNvc1RoLCBzaW5UaCwgcngsIHJ5LCBjeDEsIGN5MSwgbVQsIGZyb21YLCBmcm9tWSk7XG4gICAgICBmcm9tWCA9IHJlc3VsdFtpXVs1XTtcbiAgICAgIGZyb21ZID0gcmVzdWx0W2ldWzZdO1xuICAgICAgbVRoZXRhID0gdGgzO1xuICAgICAgdGgzICs9IG1EZWx0YTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qXG4gICAqIFByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGNhbGNWZWN0b3JBbmdsZSh1eCwgdXksIHZ4LCB2eSkge1xuICAgIHZhciB0YSA9IE1hdGguYXRhbjIodXksIHV4KSxcbiAgICAgICAgdGIgPSBNYXRoLmF0YW4yKHZ5LCB2eCk7XG4gICAgaWYgKHRiID49IHRhKSB7XG4gICAgICByZXR1cm4gdGIgLSB0YTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gMiAqIE1hdGguUEkgLSAodGEgLSB0Yik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBib3VuZGluZyBib3ggb2YgYSBiZXppZXJjdXJ2ZVxuICAgKiBAcGFyYW0ge051bWJlcn0geDAgc3RhcnRpbmcgcG9pbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkwXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MSBmaXJzdCBjb250cm9sIHBvaW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5MVxuICAgKiBAcGFyYW0ge051bWJlcn0geDIgc2Vjb25kbyBjb250cm9sIHBvaW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5MlxuICAgKiBAcGFyYW0ge051bWJlcn0geDMgZW5kIG9mIGJlemllclxuICAgKiBAcGFyYW0ge051bWJlcn0geTNcbiAgICovXG4gIC8vIHRha2VuIGZyb20gaHR0cDovL2pzYmluLmNvbS9pdm9taXEvNTYvZWRpdCAgbm8gY3JlZGl0cyBhdmFpbGFibGUgZm9yIHRoYXQuXG4gIC8vIFRPRE86IGNhbiB3ZSBub3JtYWxpemUgdGhpcyB3aXRoIHRoZSBzdGFydGluZyBwb2ludHMgc2V0IGF0IDAgYW5kIHRoZW4gdHJhbnNsYXRlZCB0aGUgYmJveD9cbiAgZnVuY3Rpb24gZ2V0Qm91bmRzT2ZDdXJ2ZSh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICB2YXIgYXJnc1N0cmluZztcbiAgICBpZiAoZmFicmljLmNhY2hlc0JvdW5kc09mQ3VydmUpIHtcbiAgICAgIGFyZ3NTdHJpbmcgPSBfam9pbi5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICBpZiAoZmFicmljLmJvdW5kc09mQ3VydmVDYWNoZVthcmdzU3RyaW5nXSkge1xuICAgICAgICByZXR1cm4gZmFicmljLmJvdW5kc09mQ3VydmVDYWNoZVthcmdzU3RyaW5nXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3FydCA9IE1hdGguc3FydCxcbiAgICAgICAgbWluID0gTWF0aC5taW4sIG1heCA9IE1hdGgubWF4LFxuICAgICAgICBhYnMgPSBNYXRoLmFicywgdHZhbHVlcyA9IFtdLFxuICAgICAgICBib3VuZHMgPSBbW10sIFtdXSxcbiAgICAgICAgYSwgYiwgYywgdCwgdDEsIHQyLCBiMmFjLCBzcXJ0YjJhYztcblxuICAgIGIgPSA2ICogeDAgLSAxMiAqIHgxICsgNiAqIHgyO1xuICAgIGEgPSAtMyAqIHgwICsgOSAqIHgxIC0gOSAqIHgyICsgMyAqIHgzO1xuICAgIGMgPSAzICogeDEgLSAzICogeDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7ICsraSkge1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIGIgPSA2ICogeTAgLSAxMiAqIHkxICsgNiAqIHkyO1xuICAgICAgICBhID0gLTMgKiB5MCArIDkgKiB5MSAtIDkgKiB5MiArIDMgKiB5MztcbiAgICAgICAgYyA9IDMgKiB5MSAtIDMgKiB5MDtcbiAgICAgIH1cblxuICAgICAgaWYgKGFicyhhKSA8IDFlLTEyKSB7XG4gICAgICAgIGlmIChhYnMoYikgPCAxZS0xMikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHQgPSAtYyAvIGI7XG4gICAgICAgIGlmICgwIDwgdCAmJiB0IDwgMSkge1xuICAgICAgICAgIHR2YWx1ZXMucHVzaCh0KTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGIyYWMgPSBiICogYiAtIDQgKiBjICogYTtcbiAgICAgIGlmIChiMmFjIDwgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHNxcnRiMmFjID0gc3FydChiMmFjKTtcbiAgICAgIHQxID0gKC1iICsgc3FydGIyYWMpIC8gKDIgKiBhKTtcbiAgICAgIGlmICgwIDwgdDEgJiYgdDEgPCAxKSB7XG4gICAgICAgIHR2YWx1ZXMucHVzaCh0MSk7XG4gICAgICB9XG4gICAgICB0MiA9ICgtYiAtIHNxcnRiMmFjKSAvICgyICogYSk7XG4gICAgICBpZiAoMCA8IHQyICYmIHQyIDwgMSkge1xuICAgICAgICB0dmFsdWVzLnB1c2godDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB4LCB5LCBqID0gdHZhbHVlcy5sZW5ndGgsIGpsZW4gPSBqLCBtdDtcbiAgICB3aGlsZSAoai0tKSB7XG4gICAgICB0ID0gdHZhbHVlc1tqXTtcbiAgICAgIG10ID0gMSAtIHQ7XG4gICAgICB4ID0gKG10ICogbXQgKiBtdCAqIHgwKSArICgzICogbXQgKiBtdCAqIHQgKiB4MSkgKyAoMyAqIG10ICogdCAqIHQgKiB4MikgKyAodCAqIHQgKiB0ICogeDMpO1xuICAgICAgYm91bmRzWzBdW2pdID0geDtcblxuICAgICAgeSA9IChtdCAqIG10ICogbXQgKiB5MCkgKyAoMyAqIG10ICogbXQgKiB0ICogeTEpICsgKDMgKiBtdCAqIHQgKiB0ICogeTIpICsgKHQgKiB0ICogdCAqIHkzKTtcbiAgICAgIGJvdW5kc1sxXVtqXSA9IHk7XG4gICAgfVxuXG4gICAgYm91bmRzWzBdW2psZW5dID0geDA7XG4gICAgYm91bmRzWzFdW2psZW5dID0geTA7XG4gICAgYm91bmRzWzBdW2psZW4gKyAxXSA9IHgzO1xuICAgIGJvdW5kc1sxXVtqbGVuICsgMV0gPSB5MztcbiAgICB2YXIgcmVzdWx0ID0gW1xuICAgICAge1xuICAgICAgICB4OiBtaW4uYXBwbHkobnVsbCwgYm91bmRzWzBdKSxcbiAgICAgICAgeTogbWluLmFwcGx5KG51bGwsIGJvdW5kc1sxXSlcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHg6IG1heC5hcHBseShudWxsLCBib3VuZHNbMF0pLFxuICAgICAgICB5OiBtYXguYXBwbHkobnVsbCwgYm91bmRzWzFdKVxuICAgICAgfVxuICAgIF07XG4gICAgaWYgKGZhYnJpYy5jYWNoZXNCb3VuZHNPZkN1cnZlKSB7XG4gICAgICBmYWJyaWMuYm91bmRzT2ZDdXJ2ZUNhY2hlW2FyZ3NTdHJpbmddID0gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFyYyB0byBhIGJ1bmNoIG9mIGJlemllciBjdXJ2ZXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZ4IHN0YXJ0aW5nIHBvaW50IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZ5IHN0YXJ0aW5nIHBvaW50IHlcbiAgICogQHBhcmFtIHtBcnJheX0gY29vcmRzIEFyYyBjb21tYW5kXG4gICAqL1xuICBmdW5jdGlvbiBmcm9tQXJjVG9CZXppZXJzKGZ4LCBmeSwgY29vcmRzKSB7XG4gICAgdmFyIHJ4ID0gY29vcmRzWzFdLFxuICAgICAgICByeSA9IGNvb3Jkc1syXSxcbiAgICAgICAgcm90ID0gY29vcmRzWzNdLFxuICAgICAgICBsYXJnZSA9IGNvb3Jkc1s0XSxcbiAgICAgICAgc3dlZXAgPSBjb29yZHNbNV0sXG4gICAgICAgIHR4ID0gY29vcmRzWzZdLFxuICAgICAgICB0eSA9IGNvb3Jkc1s3XSxcbiAgICAgICAgc2Vnc05vcm0gPSBhcmNUb1NlZ21lbnRzKHR4IC0gZngsIHR5IC0gZnksIHJ4LCByeSwgbGFyZ2UsIHN3ZWVwLCByb3QpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlZ3NOb3JtLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzZWdzTm9ybVtpXVsxXSArPSBmeDtcbiAgICAgIHNlZ3NOb3JtW2ldWzJdICs9IGZ5O1xuICAgICAgc2Vnc05vcm1baV1bM10gKz0gZng7XG4gICAgICBzZWdzTm9ybVtpXVs0XSArPSBmeTtcbiAgICAgIHNlZ3NOb3JtW2ldWzVdICs9IGZ4O1xuICAgICAgc2Vnc05vcm1baV1bNl0gKz0gZnk7XG4gICAgfVxuICAgIHJldHVybiBzZWdzTm9ybTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiB0YWtlIGEgcGFyc2VkIFNWRyBwYXRoIGFuZCBtYWtlIGl0IHNpbXBsZXIgZm9yIGZhYnJpY0pTIGxvZ2ljLlxuICAgKiBzaW1wbGlmaWNhdGlvbiBjb25zaXN0IG9mOiBvbmx5IFVQUEVSQ0FTRSBhYnNvbHV0ZSBjb21tYW5kcyAoIHJlbGF0aXZlIGNvbnZlcnRlZCB0byBhYnNvbHV0ZSApXG4gICAqIFMgY29udmVydGVkIGluIEMsIFQgY29udmVydGVkIGluIFEsIEEgY29udmVydGVkIGluIEMuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggdGhlIGFycmF5IG9mIGNvbW1hbmRzIG9mIGEgcGFyc2VkIHN2ZyBwYXRoIGZvciBmYWJyaWMuUGF0aFxuICAgKiBAcmV0dXJuIHtBcnJheX0gdGhlIHNpbXBsaWZpZWQgYXJyYXkgb2YgY29tbWFuZHMgb2YgYSBwYXJzZWQgc3ZnIHBhdGggZm9yIGZhYnJpYy5QYXRoXG4gICAqL1xuICBmdW5jdGlvbiBtYWtlUGF0aFNpbXBsZXIocGF0aCkge1xuICAgIC8vIHggYW5kIHkgcmVwcmVzZW50IHRoZSBsYXN0IHBvaW50IG9mIHRoZSBwYXRoLiB0aGUgcHJldmlvdXMgY29tbWFuZCBwb2ludC5cbiAgICAvLyB3ZSBhZGQgdGhlbSB0byBlYWNoIHJlbGF0aXZlIGNvbW1hbmQgdG8gbWFrZSBpdCBhbiBhYnNvbHV0ZSBjb21tZW50LlxuICAgIC8vIHdlIGFsc28gc3dhcCB0aGUgdiBWIGggSCB3aXRoIEwsIGJlY2F1c2UgYXJlIGVhc2llciB0byB0cmFuc2Zvcm0uXG4gICAgdmFyIHggPSAwLCB5ID0gMCwgbGVuID0gcGF0aC5sZW5ndGgsXG4gICAgICAgIC8vIHgxIGFuZCB5MSByZXByZXNlbnQgdGhlIGxhc3QgcG9pbnQgb2YgdGhlIHN1YnBhdGguIHRoZSBzdWJwYXRoIGlzIHN0YXJ0ZWQgd2l0aFxuICAgICAgICAvLyBtIG9yIE0gY29tbWFuZC4gV2hlbiBhIHogb3IgWiBjb21tYW5kIGlzIGRyYXduLCB4IGFuZCB5IG5lZWQgdG8gYmUgcmVzZXR0ZWQgdG9cbiAgICAgICAgLy8gdGhlIGxhc3QgeDEgYW5kIHkxLlxuICAgICAgICB4MSA9IDAsIHkxID0gMCwgY3VycmVudCwgaSwgY29udmVydGVkLFxuICAgICAgICAvLyBwcmV2aW91cyB3aWxsIGhvc3QgdGhlIGxldHRlciBvZiB0aGUgcHJldmlvdXMgY29tbWFuZCwgdG8gaGFuZGxlIFMgYW5kIFQuXG4gICAgICAgIC8vIGNvbnRyb2xYIGFuZCBjb250cm9sWSB3aWxsIGhvc3QgdGhlIHByZXZpb3VzIHJlZmxlY3RlZCBjb250cm9sIHBvaW50XG4gICAgICAgIGRlc3RpbmF0aW9uUGF0aCA9IFtdLCBwcmV2aW91cywgY29udHJvbFgsIGNvbnRyb2xZO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgY29udmVydGVkID0gZmFsc2U7XG4gICAgICBjdXJyZW50ID0gcGF0aFtpXS5zbGljZSgwKTtcbiAgICAgIHN3aXRjaCAoY3VycmVudFswXSkgeyAvLyBmaXJzdCBsZXR0ZXJcbiAgICAgICAgY2FzZSAnbCc6IC8vIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgICBjdXJyZW50WzBdID0gJ0wnO1xuICAgICAgICAgIGN1cnJlbnRbMV0gKz0geDtcbiAgICAgICAgICBjdXJyZW50WzJdICs9IHk7XG4gICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICB5ID0gY3VycmVudFsyXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaCc6IC8vIGhvcml6b250YWwgbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICAgIGN1cnJlbnRbMV0gKz0geDtcbiAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgIGN1cnJlbnRbMF0gPSAnTCc7XG4gICAgICAgICAgY3VycmVudFsyXSA9IHk7XG4gICAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3YnOiAvLyB2ZXJ0aWNhbCBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgICAgY3VycmVudFsxXSArPSB5O1xuICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgY2FzZSAnVic6XG4gICAgICAgICAgY3VycmVudFswXSA9ICdMJztcbiAgICAgICAgICB5ID0gY3VycmVudFsxXTtcbiAgICAgICAgICBjdXJyZW50WzFdID0geDtcbiAgICAgICAgICBjdXJyZW50WzJdID0geTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbSc6IC8vIG1vdmVUbywgcmVsYXRpdmVcbiAgICAgICAgICBjdXJyZW50WzBdID0gJ00nO1xuICAgICAgICAgIGN1cnJlbnRbMV0gKz0geDtcbiAgICAgICAgICBjdXJyZW50WzJdICs9IHk7XG4gICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICB5ID0gY3VycmVudFsyXTtcbiAgICAgICAgICB4MSA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgeTEgPSBjdXJyZW50WzJdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjJzogLy8gYmV6aWVyQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgICBjdXJyZW50WzBdID0gJ0MnO1xuICAgICAgICAgIGN1cnJlbnRbMV0gKz0geDtcbiAgICAgICAgICBjdXJyZW50WzJdICs9IHk7XG4gICAgICAgICAgY3VycmVudFszXSArPSB4O1xuICAgICAgICAgIGN1cnJlbnRbNF0gKz0geTtcbiAgICAgICAgICBjdXJyZW50WzVdICs9IHg7XG4gICAgICAgICAgY3VycmVudFs2XSArPSB5O1xuICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzNdO1xuICAgICAgICAgIGNvbnRyb2xZID0gY3VycmVudFs0XTtcbiAgICAgICAgICB4ID0gY3VycmVudFs1XTtcbiAgICAgICAgICB5ID0gY3VycmVudFs2XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncyc6IC8vIHNob3J0aGFuZCBjdWJpYyBiZXppZXJDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAgIGN1cnJlbnRbMF0gPSAnUyc7XG4gICAgICAgICAgY3VycmVudFsxXSArPSB4O1xuICAgICAgICAgIGN1cnJlbnRbMl0gKz0geTtcbiAgICAgICAgICBjdXJyZW50WzNdICs9IHg7XG4gICAgICAgICAgY3VycmVudFs0XSArPSB5O1xuICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgY2FzZSAnUyc6XG4gICAgICAgICAgLy8gd291bGQgYmUgc1NjQyBidXQgc2luY2Ugd2UgYXJlIHN3YXBwaW5nIHNTYyBmb3IgQywgd2UgY2hlY2sganVzdCB0aGF0LlxuICAgICAgICAgIGlmIChwcmV2aW91cyA9PT0gJ0MnKSB7XG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50c1xuICAgICAgICAgICAgY29udHJvbFggPSAyICogeCAtIGNvbnRyb2xYO1xuICAgICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNvbW1hbmQgb3IgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIG5vdCBhIEMsIGMsIFMsIG9yIHMsXG4gICAgICAgICAgICAvLyB0aGUgY29udHJvbCBwb2ludCBpcyBjb2luY2lkZW50IHdpdGggdGhlIGN1cnJlbnQgcG9pbnRcbiAgICAgICAgICAgIGNvbnRyb2xYID0geDtcbiAgICAgICAgICAgIGNvbnRyb2xZID0geTtcbiAgICAgICAgICB9XG4gICAgICAgICAgeCA9IGN1cnJlbnRbM107XG4gICAgICAgICAgeSA9IGN1cnJlbnRbNF07XG4gICAgICAgICAgY3VycmVudFswXSA9ICdDJztcbiAgICAgICAgICBjdXJyZW50WzVdID0gY3VycmVudFszXTtcbiAgICAgICAgICBjdXJyZW50WzZdID0gY3VycmVudFs0XTtcbiAgICAgICAgICBjdXJyZW50WzNdID0gY3VycmVudFsxXTtcbiAgICAgICAgICBjdXJyZW50WzRdID0gY3VycmVudFsyXTtcbiAgICAgICAgICBjdXJyZW50WzFdID0gY29udHJvbFg7XG4gICAgICAgICAgY3VycmVudFsyXSA9IGNvbnRyb2xZO1xuICAgICAgICAgIC8vIGN1cnJlbnRbM10gYW5kIGN1cnJlbnRbNF0gYXJlIE5PVyB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG4gICAgICAgICAgLy8gd2Uga2VlcCBpdCBmb3IgdGhlIG5leHQgcmVmbGVjdGlvbi5cbiAgICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbM107XG4gICAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzRdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdxJzogLy8gcXVhZHJhdGljQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgICBjdXJyZW50WzBdID0gJ1EnO1xuICAgICAgICAgIGN1cnJlbnRbMV0gKz0geDtcbiAgICAgICAgICBjdXJyZW50WzJdICs9IHk7XG4gICAgICAgICAgY3VycmVudFszXSArPSB4O1xuICAgICAgICAgIGN1cnJlbnRbNF0gKz0geTtcbiAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgIGNvbnRyb2xYID0gY3VycmVudFsxXTtcbiAgICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbMl07XG4gICAgICAgICAgeCA9IGN1cnJlbnRbM107XG4gICAgICAgICAgeSA9IGN1cnJlbnRbNF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3QnOiAvLyBzaG9ydGhhbmQgcXVhZHJhdGljQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgICBjdXJyZW50WzBdID0gJ1QnO1xuICAgICAgICAgIGN1cnJlbnRbMV0gKz0geDtcbiAgICAgICAgICBjdXJyZW50WzJdICs9IHk7XG4gICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICBjYXNlICdUJzpcbiAgICAgICAgICBpZiAocHJldmlvdXMgPT09ICdRJykge1xuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludFxuICAgICAgICAgICAgY29udHJvbFggPSAyICogeCAtIGNvbnRyb2xYO1xuICAgICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNvbW1hbmQgb3IgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIG5vdCBhIFEsIHEsIFQgb3IgdCxcbiAgICAgICAgICAgIC8vIGFzc3VtZSB0aGUgY29udHJvbCBwb2ludCBpcyBjb2luY2lkZW50IHdpdGggdGhlIGN1cnJlbnQgcG9pbnRcbiAgICAgICAgICAgIGNvbnRyb2xYID0geDtcbiAgICAgICAgICAgIGNvbnRyb2xZID0geTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudFswXSA9ICdRJztcbiAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICB5ID0gY3VycmVudFsyXTtcbiAgICAgICAgICBjdXJyZW50WzFdID0gY29udHJvbFg7XG4gICAgICAgICAgY3VycmVudFsyXSA9IGNvbnRyb2xZO1xuICAgICAgICAgIGN1cnJlbnRbM10gPSB4O1xuICAgICAgICAgIGN1cnJlbnRbNF0gPSB5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICBjdXJyZW50WzBdID0gJ0EnO1xuICAgICAgICAgIGN1cnJlbnRbNl0gKz0geDtcbiAgICAgICAgICBjdXJyZW50WzddICs9IHk7XG4gICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICBjb252ZXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgIGRlc3RpbmF0aW9uUGF0aCA9IGRlc3RpbmF0aW9uUGF0aC5jb25jYXQoZnJvbUFyY1RvQmV6aWVycyh4LCB5LCBjdXJyZW50KSk7XG4gICAgICAgICAgeCA9IGN1cnJlbnRbNl07XG4gICAgICAgICAgeSA9IGN1cnJlbnRbN107XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3onOlxuICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgICB4ID0geDE7XG4gICAgICAgICAgeSA9IHkxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgfVxuICAgICAgaWYgKCFjb252ZXJ0ZWQpIHtcbiAgICAgICAgZGVzdGluYXRpb25QYXRoLnB1c2goY3VycmVudCk7XG4gICAgICB9XG4gICAgICBwcmV2aW91cyA9IGN1cnJlbnRbMF07XG4gICAgfVxuICAgIHJldHVybiBkZXN0aW5hdGlvblBhdGg7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGMgbGVuZ3RoIGZyb20gcG9pbnQgeDEseTEgdG8geDIseTJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgxIHN0YXJ0aW5nIHBvaW50IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkxIHN0YXJ0aW5nIHBvaW50IHlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgyIHN0YXJ0aW5nIHBvaW50IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkyIHN0YXJ0aW5nIHBvaW50IHlcbiAgICogQHJldHVybiB7TnVtYmVyfSBsZW5ndGggb2Ygc2VnbWVudFxuICAgKi9cbiAgZnVuY3Rpb24gY2FsY0xpbmVMZW5ndGgoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh4MiAtIHgxKSAqICh4MiAtIHgxKSArICh5MiAtIHkxKSAqICh5MiAtIHkxKSk7XG4gIH1cblxuICAvLyBmdW5jdGlvbnMgZm9yIHRoZSBDdWJpYyBiZWl6ZXJcbiAgLy8gdGFrZW4gZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2tvbnZhanMva29udmEvYmxvYi83LjAuNS9zcmMvc2hhcGVzL1BhdGgudHMjTDM1MFxuICBmdW5jdGlvbiBDQjEodCkge1xuICAgIHJldHVybiB0ICogdCAqIHQ7XG4gIH1cbiAgZnVuY3Rpb24gQ0IyKHQpIHtcbiAgICByZXR1cm4gMyAqIHQgKiB0ICogKDEgLSB0KTtcbiAgfVxuICBmdW5jdGlvbiBDQjModCkge1xuICAgIHJldHVybiAzICogdCAqICgxIC0gdCkgKiAoMSAtIHQpO1xuICB9XG4gIGZ1bmN0aW9uIENCNCh0KSB7XG4gICAgcmV0dXJuICgxIC0gdCkgKiAoMSAtIHQpICogKDEgLSB0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBvaW50T25DdWJpY0Jlemllckl0ZXJhdG9yKHAxeCwgcDF5LCBwMngsIHAyeSwgcDN4LCBwM3ksIHA0eCwgcDR5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHBjdCkge1xuICAgICAgdmFyIGMxID0gQ0IxKHBjdCksIGMyID0gQ0IyKHBjdCksIGMzID0gQ0IzKHBjdCksIGM0ID0gQ0I0KHBjdCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBwNHggKiBjMSArIHAzeCAqIGMyICsgcDJ4ICogYzMgKyBwMXggKiBjNCxcbiAgICAgICAgeTogcDR5ICogYzEgKyBwM3kgKiBjMiArIHAyeSAqIGMzICsgcDF5ICogYzRcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRhbmdlbnRDdWJpY0l0ZXJhdG9yKHAxeCwgcDF5LCBwMngsIHAyeSwgcDN4LCBwM3ksIHA0eCwgcDR5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwY3QpIHtcbiAgICAgIHZhciBpbnZUID0gMSAtIHBjdCxcbiAgICAgICAgICB0YW5nZW50WCA9ICgzICogaW52VCAqIGludlQgKiAocDJ4IC0gcDF4KSkgKyAoNiAqIGludlQgKiBwY3QgKiAocDN4IC0gcDJ4KSkgK1xuICAgICAgICAgICgzICogcGN0ICogcGN0ICogKHA0eCAtIHAzeCkpLFxuICAgICAgICAgIHRhbmdlbnRZID0gKDMgKiBpbnZUICogaW52VCAqIChwMnkgLSBwMXkpKSArICg2ICogaW52VCAqIHBjdCAqIChwM3kgLSBwMnkpKSArXG4gICAgICAgICAgKDMgKiBwY3QgKiBwY3QgKiAocDR5IC0gcDN5KSk7XG4gICAgICByZXR1cm4gTWF0aC5hdGFuMih0YW5nZW50WSwgdGFuZ2VudFgpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBRQjEodCkge1xuICAgIHJldHVybiB0ICogdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIFFCMih0KSB7XG4gICAgcmV0dXJuIDIgKiB0ICogKDEgLSB0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFFCMyh0KSB7XG4gICAgcmV0dXJuICgxIC0gdCkgKiAoMSAtIHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UG9pbnRPblF1YWRyYXRpY0Jlemllckl0ZXJhdG9yKHAxeCwgcDF5LCBwMngsIHAyeSwgcDN4LCBwM3kpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ocGN0KSB7XG4gICAgICB2YXIgYzEgPSBRQjEocGN0KSwgYzIgPSBRQjIocGN0KSwgYzMgPSBRQjMocGN0KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHAzeCAqIGMxICsgcDJ4ICogYzIgKyBwMXggKiBjMyxcbiAgICAgICAgeTogcDN5ICogYzEgKyBwMnkgKiBjMiArIHAxeSAqIGMzXG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRUYW5nZW50UXVhZHJhdGljSXRlcmF0b3IocDF4LCBwMXksIHAyeCwgcDJ5LCBwM3gsIHAzeSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAocGN0KSB7XG4gICAgICB2YXIgaW52VCA9IDEgLSBwY3QsXG4gICAgICAgICAgdGFuZ2VudFggPSAoMiAqIGludlQgKiAocDJ4IC0gcDF4KSkgKyAoMiAqIHBjdCAqIChwM3ggLSBwMngpKSxcbiAgICAgICAgICB0YW5nZW50WSA9ICgyICogaW52VCAqIChwMnkgLSBwMXkpKSArICgyICogcGN0ICogKHAzeSAtIHAyeSkpO1xuICAgICAgcmV0dXJuIE1hdGguYXRhbjIodGFuZ2VudFksIHRhbmdlbnRYKTtcbiAgICB9O1xuICB9XG5cblxuICAvLyB0aGlzIHdpbGwgcnVuIG92ZXIgYSBwYXRoIHNlZ21lbnQgKCBhIGN1YmljIG9yIHF1YWRyYXRpYyBzZWdtZW50KSBhbmQgYXBwcm94aW1hdGUgaXRcbiAgLy8gd2l0aCAxMDAgc2VnZW1udHMuIFRoaXMgd2lsbCBnb29kIGVub3VnaCB0byBjYWxjdWxhdGUgdGhlIGxlbmd0aCBvZiB0aGUgY3VydmVcbiAgZnVuY3Rpb24gcGF0aEl0ZXJhdG9yKGl0ZXJhdG9yLCB4MSwgeTEpIHtcbiAgICB2YXIgdGVtcFAgPSB7IHg6IHgxLCB5OiB5MSB9LCBwLCB0bXBMZW4gPSAwLCBwZXJjO1xuICAgIGZvciAocGVyYyA9IDE7IHBlcmMgPD0gMTAwOyBwZXJjICs9IDEpIHtcbiAgICAgIHAgPSBpdGVyYXRvcihwZXJjIC8gMTAwKTtcbiAgICAgIHRtcExlbiArPSBjYWxjTGluZUxlbmd0aCh0ZW1wUC54LCB0ZW1wUC55LCBwLngsIHAueSk7XG4gICAgICB0ZW1wUCA9IHA7XG4gICAgfVxuICAgIHJldHVybiB0bXBMZW47XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBwYXRoSW5mbywgYW5kIGEgZGlzdGFuY2UgaW4gcGl4ZWxzLCBmaW5kIHRoZSBwZXJjZW50YWdlIGZyb20gMCB0byAxXG4gICAqIHRoYXQgY29ycmVzcG9uZCB0byB0aGF0IHBpeGVscyBydW4gb3ZlciB0aGUgcGF0aC5cbiAgICogVGhlIHBlcmNlbnRhZ2Ugd2lsbCBiZSB0aGVuIHVzZWQgdG8gZmluZCB0aGUgY29ycmVjdCBwb2ludCBvbiB0aGUgY2FudmFzIGZvciB0aGUgcGF0aC5cbiAgICogQHBhcmFtIHtBcnJheX0gc2VnSW5mbyBmYWJyaWNKUyBjb2xsZWN0aW9uIG9mIGluZm9ybWF0aW9uIG9uIGEgcGFyc2VkIHBhdGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRpc3RhbmNlIGZyb20gc3RhcnRpbmcgcG9pbnQsIGluIHBpeGVscy5cbiAgICogQHJldHVybiB7T2JqZWN0fSBpbmZvIG9iamVjdCB3aXRoIHggYW5kIHkgKCB0aGUgcG9pbnQgb24gY2FudmFzICkgYW5kIGFuZ2xlLCB0aGUgdGFuZ2VudCBvbiB0aGF0IHBvaW50O1xuICAgKi9cbiAgZnVuY3Rpb24gZmluZFBlcmNlbnRhZ2VGb3JEaXN0YW5jZShzZWdJbmZvLCBkaXN0YW5jZSkge1xuICAgIHZhciBwZXJjID0gMCwgdG1wTGVuID0gMCwgaXRlcmF0b3IgPSBzZWdJbmZvLml0ZXJhdG9yLCB0ZW1wUCA9IHsgeDogc2VnSW5mby54LCB5OiBzZWdJbmZvLnkgfSxcbiAgICAgICAgcCwgbmV4dExlbiwgbmV4dFN0ZXAgPSAwLjAxLCBhbmdsZUZpbmRlciA9IHNlZ0luZm8uYW5nbGVGaW5kZXIsIGxhc3RQZXJjO1xuICAgIC8vIG5leHRTdGVwID4gMC4wMDAxIGNvdmVycyAwLjAwMDE1NjI1IHRoYXQgMS82NHRoIG9mIDEvMTAwXG4gICAgLy8gdGhlIHBhdGhcbiAgICB3aGlsZSAodG1wTGVuIDwgZGlzdGFuY2UgJiYgbmV4dFN0ZXAgPiAwLjAwMDEpIHtcbiAgICAgIHAgPSBpdGVyYXRvcihwZXJjKTtcbiAgICAgIGxhc3RQZXJjID0gcGVyYztcbiAgICAgIG5leHRMZW4gPSBjYWxjTGluZUxlbmd0aCh0ZW1wUC54LCB0ZW1wUC55LCBwLngsIHAueSk7XG4gICAgICAvLyBjb21wYXJlIHRtcExlbiBlYWNoIGN5Y2xlIHdpdGggZGlzdGFuY2UsIGRlY2lkZSBuZXh0IHBlcmMgdG8gdGVzdC5cbiAgICAgIGlmICgobmV4dExlbiArIHRtcExlbikgPiBkaXN0YW5jZSkge1xuICAgICAgICAvLyB3ZSBkaXNjYXJkIHRoaXMgc3RlcCBhbmQgd2UgbWFrZSBzbWFsbGVyIHN0ZXBzLlxuICAgICAgICBwZXJjIC09IG5leHRTdGVwO1xuICAgICAgICBuZXh0U3RlcCAvPSAyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRlbXBQID0gcDtcbiAgICAgICAgcGVyYyArPSBuZXh0U3RlcDtcbiAgICAgICAgdG1wTGVuICs9IG5leHRMZW47XG4gICAgICB9XG4gICAgfVxuICAgIHAuYW5nbGUgPSBhbmdsZUZpbmRlcihsYXN0UGVyYyk7XG4gICAgcmV0dXJuIHA7XG4gIH1cblxuICAvKipcbiAgICogUnVuIG92ZXIgYSBwYXJzZWQgYW5kIHNpbXBsaWZlZCBwYXRoIGFuZCBleHRyYWMgc29tZSBpbmZvcm1hdGlvbnMuXG4gICAqIGluZm9ybWF0aW9ucyBhcmUgbGVuZ3RoIG9mIGVhY2ggY29tbWFuZCBhbmQgc3RhcnRpbmcgcG9pbnRcbiAgICogQHBhcmFtIHtBcnJheX0gcGF0aCBmYWJyaWNKUyBwYXJzZWQgcGF0aCBjb21tYW5kc1xuICAgKiBAcmV0dXJuIHtBcnJheX0gcGF0aCBjb21tYW5kcyBpbmZvcm1hdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIGdldFBhdGhTZWdtZW50c0luZm8ocGF0aCkge1xuICAgIHZhciB0b3RhbExlbmd0aCA9IDAsIGxlbiA9IHBhdGgubGVuZ3RoLCBjdXJyZW50LFxuICAgICAgICAvL3gyIGFuZCB5MiBhcmUgdGhlIGNvb3JkcyBvZiBzZWdtZW50IHN0YXJ0XG4gICAgICAgIC8veDEgYW5kIHkxIGFyZSB0aGUgY29vcmRzIG9mIHRoZSBjdXJyZW50IHBvaW50XG4gICAgICAgIHgxID0gMCwgeTEgPSAwLCB4MiA9IDAsIHkyID0gMCwgaW5mbyA9IFtdLCBpdGVyYXRvciwgdGVtcEluZm8sIGFuZ2xlRmluZGVyO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGN1cnJlbnQgPSBwYXRoW2ldO1xuICAgICAgdGVtcEluZm8gPSB7XG4gICAgICAgIHg6IHgxLFxuICAgICAgICB5OiB5MSxcbiAgICAgICAgY29tbWFuZDogY3VycmVudFswXSxcbiAgICAgIH07XG4gICAgICBzd2l0Y2ggKGN1cnJlbnRbMF0pIHsgLy9maXJzdCBsZXR0ZXJcbiAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgdGVtcEluZm8ubGVuZ3RoID0gMDtcbiAgICAgICAgICB4MiA9IHgxID0gY3VycmVudFsxXTtcbiAgICAgICAgICB5MiA9IHkxID0gY3VycmVudFsyXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgdGVtcEluZm8ubGVuZ3RoID0gY2FsY0xpbmVMZW5ndGgoeDEsIHkxLCBjdXJyZW50WzFdLCBjdXJyZW50WzJdKTtcbiAgICAgICAgICB4MSA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgeTEgPSBjdXJyZW50WzJdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICBpdGVyYXRvciA9IGdldFBvaW50T25DdWJpY0Jlemllckl0ZXJhdG9yKFxuICAgICAgICAgICAgeDEsXG4gICAgICAgICAgICB5MSxcbiAgICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICAgIGN1cnJlbnRbNF0sXG4gICAgICAgICAgICBjdXJyZW50WzVdLFxuICAgICAgICAgICAgY3VycmVudFs2XVxuICAgICAgICAgICk7XG4gICAgICAgICAgYW5nbGVGaW5kZXIgPSBnZXRUYW5nZW50Q3ViaWNJdGVyYXRvcihcbiAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgeTEsXG4gICAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgICBjdXJyZW50WzRdLFxuICAgICAgICAgICAgY3VycmVudFs1XSxcbiAgICAgICAgICAgIGN1cnJlbnRbNl1cbiAgICAgICAgICApO1xuICAgICAgICAgIHRlbXBJbmZvLml0ZXJhdG9yID0gaXRlcmF0b3I7XG4gICAgICAgICAgdGVtcEluZm8uYW5nbGVGaW5kZXIgPSBhbmdsZUZpbmRlcjtcbiAgICAgICAgICB0ZW1wSW5mby5sZW5ndGggPSBwYXRoSXRlcmF0b3IoaXRlcmF0b3IsIHgxLCB5MSk7XG4gICAgICAgICAgeDEgPSBjdXJyZW50WzVdO1xuICAgICAgICAgIHkxID0gY3VycmVudFs2XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgaXRlcmF0b3IgPSBnZXRQb2ludE9uUXVhZHJhdGljQmV6aWVySXRlcmF0b3IoXG4gICAgICAgICAgICB4MSxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgY3VycmVudFsxXSxcbiAgICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgICAgY3VycmVudFs0XVxuICAgICAgICAgICk7XG4gICAgICAgICAgYW5nbGVGaW5kZXIgPSBnZXRUYW5nZW50UXVhZHJhdGljSXRlcmF0b3IoXG4gICAgICAgICAgICB4MSxcbiAgICAgICAgICAgIHkxLFxuICAgICAgICAgICAgY3VycmVudFsxXSxcbiAgICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgICAgY3VycmVudFs0XVxuICAgICAgICAgICk7XG4gICAgICAgICAgdGVtcEluZm8uaXRlcmF0b3IgPSBpdGVyYXRvcjtcbiAgICAgICAgICB0ZW1wSW5mby5hbmdsZUZpbmRlciA9IGFuZ2xlRmluZGVyO1xuICAgICAgICAgIHRlbXBJbmZvLmxlbmd0aCA9IHBhdGhJdGVyYXRvcihpdGVyYXRvciwgeDEsIHkxKTtcbiAgICAgICAgICB4MSA9IGN1cnJlbnRbM107XG4gICAgICAgICAgeTEgPSBjdXJyZW50WzRdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgLy8gd2UgYWRkIHRob3NlIGluIG9yZGVyIHRvIGVhc2UgY2FsY3VsYXRpb25zIGxhdGVyXG4gICAgICAgICAgdGVtcEluZm8uZGVzdFggPSB4MjtcbiAgICAgICAgICB0ZW1wSW5mby5kZXN0WSA9IHkyO1xuICAgICAgICAgIHRlbXBJbmZvLmxlbmd0aCA9IGNhbGNMaW5lTGVuZ3RoKHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgICAgICB4MSA9IHgyO1xuICAgICAgICAgIHkxID0geTI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0b3RhbExlbmd0aCArPSB0ZW1wSW5mby5sZW5ndGg7XG4gICAgICBpbmZvLnB1c2godGVtcEluZm8pO1xuICAgIH1cbiAgICBpbmZvLnB1c2goeyBsZW5ndGg6IHRvdGFsTGVuZ3RoLCB4OiB4MSwgeTogeTEgfSk7XG4gICAgcmV0dXJuIGluZm87XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQb2ludE9uUGF0aChwYXRoLCBkaXN0YW5jZSwgaW5mb3MpIHtcbiAgICBpZiAoIWluZm9zKSB7XG4gICAgICBpbmZvcyA9IGdldFBhdGhTZWdtZW50c0luZm8ocGF0aCk7XG4gICAgfVxuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoKGRpc3RhbmNlIC0gaW5mb3NbaV0ubGVuZ3RoID4gMCkgJiYgaSA8IChpbmZvcy5sZW5ndGggLSAyKSkge1xuICAgICAgZGlzdGFuY2UgLT0gaW5mb3NbaV0ubGVuZ3RoO1xuICAgICAgaSsrO1xuICAgIH1cbiAgICAvLyB2YXIgZGlzdGFuY2UgPSBpbmZvc1tpbmZvcy5sZW5ndGggLSAxXSAqIHBlcmM7XG4gICAgdmFyIHNlZ0luZm8gPSBpbmZvc1tpXSwgc2VnUGVyY2VudCA9IGRpc3RhbmNlIC8gc2VnSW5mby5sZW5ndGgsXG4gICAgICAgIGNvbW1hbmQgPSBzZWdJbmZvLmNvbW1hbmQsIHNlZ21lbnQgPSBwYXRoW2ldLCBpbmZvO1xuXG4gICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICBjYXNlICdNJzpcbiAgICAgICAgcmV0dXJuIHsgeDogc2VnSW5mby54LCB5OiBzZWdJbmZvLnksIGFuZ2xlOiAwIH07XG4gICAgICBjYXNlICdaJzpcbiAgICAgIGNhc2UgJ3onOlxuICAgICAgICBpbmZvID0gbmV3IGZhYnJpYy5Qb2ludChzZWdJbmZvLngsIHNlZ0luZm8ueSkubGVycChcbiAgICAgICAgICBuZXcgZmFicmljLlBvaW50KHNlZ0luZm8uZGVzdFgsIHNlZ0luZm8uZGVzdFkpLFxuICAgICAgICAgIHNlZ1BlcmNlbnRcbiAgICAgICAgKTtcbiAgICAgICAgaW5mby5hbmdsZSA9IE1hdGguYXRhbjIoc2VnSW5mby5kZXN0WSAtIHNlZ0luZm8ueSwgc2VnSW5mby5kZXN0WCAtIHNlZ0luZm8ueCk7XG4gICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgY2FzZSAnTCc6XG4gICAgICAgIGluZm8gPSBuZXcgZmFicmljLlBvaW50KHNlZ0luZm8ueCwgc2VnSW5mby55KS5sZXJwKFxuICAgICAgICAgIG5ldyBmYWJyaWMuUG9pbnQoc2VnbWVudFsxXSwgc2VnbWVudFsyXSksXG4gICAgICAgICAgc2VnUGVyY2VudFxuICAgICAgICApO1xuICAgICAgICBpbmZvLmFuZ2xlID0gTWF0aC5hdGFuMihzZWdtZW50WzJdIC0gc2VnSW5mby55LCBzZWdtZW50WzFdIC0gc2VnSW5mby54KTtcbiAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICBjYXNlICdDJzpcbiAgICAgICAgcmV0dXJuIGZpbmRQZXJjZW50YWdlRm9yRGlzdGFuY2Uoc2VnSW5mbywgZGlzdGFuY2UpO1xuICAgICAgY2FzZSAnUSc6XG4gICAgICAgIHJldHVybiBmaW5kUGVyY2VudGFnZUZvckRpc3RhbmNlKHNlZ0luZm8sIGRpc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhTdHJpbmdcbiAgICogQHJldHVybiB7KHN0cmluZ3xudW1iZXIpW11bXX0gQW4gYXJyYXkgb2YgU1ZHIHBhdGggY29tbWFuZHNcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+VXNhZ2U8L2NhcHRpb24+XG4gICAqIHBhcnNlUGF0aCgnTSAzIDQgUSAzIDUgMiAxIDQgMCBRIDkgMTIgMiAxIDQgMCcpID09PSBbXG4gICAqICAgWydNJywgMywgNF0sXG4gICAqICAgWydRJywgMywgNSwgMiwgMSwgNCwgMF0sXG4gICAqICAgWydRJywgOSwgMTIsIDIsIDEsIDQsIDBdLFxuICAgKiBdO1xuICAgKlxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGhTdHJpbmcpIHtcbiAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgIGNvb3JkcyA9IFtdLFxuICAgICAgICBjdXJyZW50UGF0aCxcbiAgICAgICAgcGFyc2VkLFxuICAgICAgICByZSA9IGZhYnJpYy5yZVBhdGhDb21tYW5kLFxuICAgICAgICByTnVtYmVyID0gJ1stK10/KD86XFxcXGQqXFxcXC5cXFxcZCt8XFxcXGQrXFxcXC4/KSg/OltlRV1bLStdP1xcXFxkKyk/XFxcXHMqJyxcbiAgICAgICAgck51bWJlckNvbW1hV3NwID0gJygnICsgck51bWJlciArICcpJyArIGZhYnJpYy5jb21tYVdzcCxcbiAgICAgICAgckZsYWdDb21tYVdzcCA9ICcoWzAxXSknICsgZmFicmljLmNvbW1hV3NwICsgJz8nLFxuICAgICAgICByQXJjU2VxID0gck51bWJlckNvbW1hV3NwICsgJz8nICsgck51bWJlckNvbW1hV3NwICsgJz8nICsgck51bWJlckNvbW1hV3NwICsgckZsYWdDb21tYVdzcCArIHJGbGFnQ29tbWFXc3AgK1xuICAgICAgICAgIHJOdW1iZXJDb21tYVdzcCArICc/KCcgKyByTnVtYmVyICsgJyknLFxuICAgICAgICByZWdBcmNBcmd1bWVudFNlcXVlbmNlID0gbmV3IFJlZ0V4cChyQXJjU2VxLCAnZycpLFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgY29vcmRzU3RyLFxuICAgICAgICAvLyBvbmUgb2YgY29tbWFuZHMgKG0sTSxsLEwscSxRLGMsQyxldGMuKSBmb2xsb3dlZCBieSBub24tY29tbWFuZCBjaGFyYWN0ZXJzIChpLmUuIGNvbW1hbmQgdmFsdWVzKVxuICAgICAgICBwYXRoO1xuICAgIGlmICghcGF0aFN0cmluZyB8fCAhcGF0aFN0cmluZy5tYXRjaCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcGF0aCA9IHBhdGhTdHJpbmcubWF0Y2goL1ttemxodmNzcXRhXVtebXpsaHZjc3F0YV0qL2dpKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBjb29yZHNQYXJzZWQsIGxlbiA9IHBhdGgubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGN1cnJlbnRQYXRoID0gcGF0aFtpXTtcblxuICAgICAgY29vcmRzU3RyID0gY3VycmVudFBhdGguc2xpY2UoMSkudHJpbSgpO1xuICAgICAgY29vcmRzLmxlbmd0aCA9IDA7XG5cbiAgICAgIHZhciBjb21tYW5kID0gY3VycmVudFBhdGguY2hhckF0KDApO1xuICAgICAgY29vcmRzUGFyc2VkID0gW2NvbW1hbmRdO1xuXG4gICAgICBpZiAoY29tbWFuZC50b0xvd2VyQ2FzZSgpID09PSAnYScpIHtcbiAgICAgICAgLy8gYXJjcyBoYXZlIHNwZWNpYWwgZmxhZ3MgdGhhdCBhcHBhcmVudGx5IGRvbid0IHJlcXVpcmUgc3BhY2VzIHNvIGhhbmRsZSBzcGVjaWFsXG4gICAgICAgIGZvciAodmFyIGFyZ3M7IChhcmdzID0gcmVnQXJjQXJndW1lbnRTZXF1ZW5jZS5leGVjKGNvb3Jkc1N0cikpOykge1xuICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgYXJncy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29vcmRzLnB1c2goYXJnc1tqXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IHJlLmV4ZWMoY29vcmRzU3RyKSkpIHtcbiAgICAgICAgICBjb29yZHMucHVzaChtYXRjaFswXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGpsZW4gPSBjb29yZHMubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICAgIHBhcnNlZCA9IHBhcnNlRmxvYXQoY29vcmRzW2pdKTtcbiAgICAgICAgaWYgKCFpc05hTihwYXJzZWQpKSB7XG4gICAgICAgICAgY29vcmRzUGFyc2VkLnB1c2gocGFyc2VkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29tbWFuZExlbmd0aCA9IGNvbW1hbmRMZW5ndGhzW2NvbW1hbmQudG9Mb3dlckNhc2UoKV0sXG4gICAgICAgICAgcmVwZWF0ZWRDb21tYW5kID0gcmVwZWF0ZWRDb21tYW5kc1tjb21tYW5kXSB8fCBjb21tYW5kO1xuXG4gICAgICBpZiAoY29vcmRzUGFyc2VkLmxlbmd0aCAtIDEgPiBjb21tYW5kTGVuZ3RoKSB7XG4gICAgICAgIGZvciAodmFyIGsgPSAxLCBrbGVuID0gY29vcmRzUGFyc2VkLmxlbmd0aDsgayA8IGtsZW47IGsgKz0gY29tbWFuZExlbmd0aCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKFtjb21tYW5kXS5jb25jYXQoY29vcmRzUGFyc2VkLnNsaWNlKGssIGsgKyBjb21tYW5kTGVuZ3RoKSkpO1xuICAgICAgICAgIGNvbW1hbmQgPSByZXBlYXRlZENvbW1hbmQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaChjb29yZHNQYXJzZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqXG4gICAqIENvbnZlcnRzIHBvaW50cyB0byBhIHNtb290aCBTVkcgcGF0aFxuICAgKiBAcGFyYW0ge3sgeDogbnVtYmVyLHk6IG51bWJlciB9W119IHBvaW50cyBBcnJheSBvZiBwb2ludHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtjb3JyZWN0aW9uXSBBcHBseSBhIGNvcnJlY3Rpb24gdG8gdGhlIHBhdGggKHVzdWFsbHkgd2UgdXNlIGB3aWR0aCAvIDEwMDBgKS4gSWYgdmFsdWUgaXMgdW5kZWZpbmVkIDAgaXMgdXNlZCBhcyB0aGUgY29ycmVjdGlvbiB2YWx1ZS5cbiAgICogQHJldHVybiB7KHN0cmluZ3xudW1iZXIpW11bXX0gQW4gYXJyYXkgb2YgU1ZHIHBhdGggY29tbWFuZHNcbiAgICovXG4gIGZ1bmN0aW9uIGdldFNtb290aFBhdGhGcm9tUG9pbnRzKHBvaW50cywgY29ycmVjdGlvbikge1xuICAgIHZhciBwYXRoID0gW10sIGksXG4gICAgICAgIHAxID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpLFxuICAgICAgICBwMiA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRzWzFdLngsIHBvaW50c1sxXS55KSxcbiAgICAgICAgbGVuID0gcG9pbnRzLmxlbmd0aCwgbXVsdFNpZ25YID0gMSwgbXVsdFNpZ25ZID0gMCwgbWFueVBvaW50cyA9IGxlbiA+IDI7XG4gICAgY29ycmVjdGlvbiA9IGNvcnJlY3Rpb24gfHwgMDtcblxuICAgIGlmIChtYW55UG9pbnRzKSB7XG4gICAgICBtdWx0U2lnblggPSBwb2ludHNbMl0ueCA8IHAyLnggPyAtMSA6IHBvaW50c1syXS54ID09PSBwMi54ID8gMCA6IDE7XG4gICAgICBtdWx0U2lnblkgPSBwb2ludHNbMl0ueSA8IHAyLnkgPyAtMSA6IHBvaW50c1syXS55ID09PSBwMi55ID8gMCA6IDE7XG4gICAgfVxuICAgIHBhdGgucHVzaChbJ00nLCBwMS54IC0gbXVsdFNpZ25YICogY29ycmVjdGlvbiwgcDEueSAtIG11bHRTaWduWSAqIGNvcnJlY3Rpb25dKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghcDEuZXEocDIpKSB7XG4gICAgICAgIHZhciBtaWRQb2ludCA9IHAxLm1pZFBvaW50RnJvbShwMik7XG4gICAgICAgIC8vIHAxIGlzIG91ciBiZXppZXIgY29udHJvbCBwb2ludFxuICAgICAgICAvLyBtaWRwb2ludCBpcyBvdXIgZW5kcG9pbnRcbiAgICAgICAgLy8gc3RhcnQgcG9pbnQgaXMgcChpLTEpIHZhbHVlLlxuICAgICAgICBwYXRoLnB1c2goWydRJywgcDEueCwgcDEueSwgbWlkUG9pbnQueCwgbWlkUG9pbnQueV0pO1xuICAgICAgfVxuICAgICAgcDEgPSBwb2ludHNbaV07XG4gICAgICBpZiAoKGkgKyAxKSA8IHBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgcDIgPSBwb2ludHNbaSArIDFdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWFueVBvaW50cykge1xuICAgICAgbXVsdFNpZ25YID0gcDEueCA+IHBvaW50c1tpIC0gMl0ueCA/IDEgOiBwMS54ID09PSBwb2ludHNbaSAtIDJdLnggPyAwIDogLTE7XG4gICAgICBtdWx0U2lnblkgPSBwMS55ID4gcG9pbnRzW2kgLSAyXS55ID8gMSA6IHAxLnkgPT09IHBvaW50c1tpIC0gMl0ueSA/IDAgOiAtMTtcbiAgICB9XG4gICAgcGF0aC5wdXNoKFsnTCcsIHAxLnggKyBtdWx0U2lnblggKiBjb3JyZWN0aW9uLCBwMS55ICsgbXVsdFNpZ25ZICogY29ycmVjdGlvbl0pO1xuICAgIHJldHVybiBwYXRoO1xuICB9XG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gYSBwYXRoIGJ5IHRyYW5zZm9ybWluZyBlYWNoIHNlZ21lbnQuXG4gICAqIGl0IGhhcyB0byBiZSBhIHNpbXBsaWZpZWQgcGF0aCBvciBpdCB3b24ndCB3b3JrLlxuICAgKiBXQVJOSU5HOiB0aGlzIGRlcGVuZHMgZnJvbSBwYXRoT2Zmc2V0IGZvciBjb3JyZWN0IG9wZXJhdGlvblxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoIGZhYnJpY0pTIHBhcnNlZCBhbmQgc2ltcGxpZmllZCBwYXRoIGNvbW1hbmRzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHRyYW5zZm9ybSBtYXRyaXggdGhhdCByZXByZXNlbnQgdGhlIHRyYW5zZm9ybWF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcGF0aE9mZnNldF0gdGhlIGZhYnJpYy5QYXRoIHBhdGhPZmZzZXRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBhdGhPZmZzZXQueFxuICAgKiBAcGFyYW0ge051bWJlcn0gcGF0aE9mZnNldC55XG4gICAqIEByZXR1cm5zIHtBcnJheX0gdGhlIHRyYW5zZm9ybWVkIHBhdGhcbiAgICovXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybVBhdGgocGF0aCwgdHJhbnNmb3JtLCBwYXRoT2Zmc2V0KSB7XG4gICAgaWYgKHBhdGhPZmZzZXQpIHtcbiAgICAgIHRyYW5zZm9ybSA9IGZhYnJpYy51dGlsLm11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMoXG4gICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgWzEsIDAsIDAsIDEsIC1wYXRoT2Zmc2V0LngsIC1wYXRoT2Zmc2V0LnldXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aC5tYXAoZnVuY3Rpb24ocGF0aFNlZ21lbnQpIHtcbiAgICAgIHZhciBuZXdTZWdtZW50ID0gcGF0aFNlZ21lbnQuc2xpY2UoMCksIHBvaW50ID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBhdGhTZWdtZW50Lmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgICAgICBwb2ludC54ID0gcGF0aFNlZ21lbnRbaV07XG4gICAgICAgIHBvaW50LnkgPSBwYXRoU2VnbWVudFtpICsgMV07XG4gICAgICAgIHBvaW50ID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQocG9pbnQsIHRyYW5zZm9ybSk7XG4gICAgICAgIG5ld1NlZ21lbnRbaV0gPSBwb2ludC54O1xuICAgICAgICBuZXdTZWdtZW50W2kgKyAxXSA9IHBvaW50Lnk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3U2VnbWVudDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBKb2luIHBhdGggY29tbWFuZHMgdG8gZ28gYmFjayB0byBzdmcgZm9ybWF0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhdGhEYXRhIGZhYnJpY0pTIHBhcnNlZCBwYXRoIGNvbW1hbmRzXG4gICAqIEByZXR1cm4ge1N0cmluZ30gam9pbmVkIHBhdGggJ00gMCAwIEwgMjAgMzAnXG4gICAqL1xuICBmYWJyaWMudXRpbC5qb2luUGF0aCA9IGZ1bmN0aW9uKHBhdGhEYXRhKSB7XG4gICAgcmV0dXJuIHBhdGhEYXRhLm1hcChmdW5jdGlvbiAoc2VnbWVudCkgeyByZXR1cm4gc2VnbWVudC5qb2luKCcgJyk7IH0pLmpvaW4oJyAnKTtcbiAgfTtcbiAgZmFicmljLnV0aWwucGFyc2VQYXRoID0gcGFyc2VQYXRoO1xuICBmYWJyaWMudXRpbC5tYWtlUGF0aFNpbXBsZXIgPSBtYWtlUGF0aFNpbXBsZXI7XG4gIGZhYnJpYy51dGlsLmdldFNtb290aFBhdGhGcm9tUG9pbnRzID0gZ2V0U21vb3RoUGF0aEZyb21Qb2ludHM7XG4gIGZhYnJpYy51dGlsLmdldFBhdGhTZWdtZW50c0luZm8gPSBnZXRQYXRoU2VnbWVudHNJbmZvO1xuICBmYWJyaWMudXRpbC5nZXRCb3VuZHNPZkN1cnZlID0gZ2V0Qm91bmRzT2ZDdXJ2ZTtcbiAgZmFicmljLnV0aWwuZ2V0UG9pbnRPblBhdGggPSBnZXRQb2ludE9uUGF0aDtcbiAgZmFicmljLnV0aWwudHJhbnNmb3JtUGF0aCA9IHRyYW5zZm9ybVBhdGg7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgLyoqXG4gICAqIEludm9rZXMgbWV0aG9kIG9uIGFsbCBpdGVtcyBpbiBhIGdpdmVuIGFycmF5XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5hcnJheVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBBcnJheSB0byBpdGVyYXRlIG92ZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCBOYW1lIG9mIGEgbWV0aG9kIHRvIGludm9rZVxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGZ1bmN0aW9uIGludm9rZShhcnJheSwgbWV0aG9kKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMiksIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gYXJncy5sZW5ndGggPyBhcnJheVtpXVttZXRob2RdLmFwcGx5KGFycmF5W2ldLCBhcmdzKSA6IGFycmF5W2ldW21ldGhvZF0uY2FsbChhcnJheVtpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgbWF4aW11bSB2YWx1ZSBpbiBhcnJheSAobm90IG5lY2Vzc2FyaWx5IFwiZmlyc3RcIiBvbmUpXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5hcnJheVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBBcnJheSB0byBpdGVyYXRlIG92ZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGJ5UHJvcGVydHlcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIGZ1bmN0aW9uIG1heChhcnJheSwgYnlQcm9wZXJ0eSkge1xuICAgIHJldHVybiBmaW5kKGFycmF5LCBieVByb3BlcnR5LCBmdW5jdGlvbih2YWx1ZTEsIHZhbHVlMikge1xuICAgICAgcmV0dXJuIHZhbHVlMSA+PSB2YWx1ZTI7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgbWluaW11bSB2YWx1ZSBpbiBhcnJheSAobm90IG5lY2Vzc2FyaWx5IFwiZmlyc3RcIiBvbmUpXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5hcnJheVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBBcnJheSB0byBpdGVyYXRlIG92ZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGJ5UHJvcGVydHlcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIGZ1bmN0aW9uIG1pbihhcnJheSwgYnlQcm9wZXJ0eSkge1xuICAgIHJldHVybiBmaW5kKGFycmF5LCBieVByb3BlcnR5LCBmdW5jdGlvbih2YWx1ZTEsIHZhbHVlMikge1xuICAgICAgcmV0dXJuIHZhbHVlMSA8IHZhbHVlMjtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmlsbChhcnJheSwgdmFsdWUpIHtcbiAgICB2YXIgayA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAoay0tKSB7XG4gICAgICBhcnJheVtrXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGZpbmQoYXJyYXksIGJ5UHJvcGVydHksIGNvbmRpdGlvbikge1xuICAgIGlmICghYXJyYXkgfHwgYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGkgPSBhcnJheS5sZW5ndGggLSAxLFxuICAgICAgICByZXN1bHQgPSBieVByb3BlcnR5ID8gYXJyYXlbaV1bYnlQcm9wZXJ0eV0gOiBhcnJheVtpXTtcbiAgICBpZiAoYnlQcm9wZXJ0eSkge1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpZiAoY29uZGl0aW9uKGFycmF5W2ldW2J5UHJvcGVydHldLCByZXN1bHQpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gYXJyYXlbaV1bYnlQcm9wZXJ0eV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmIChjb25kaXRpb24oYXJyYXlbaV0sIHJlc3VsdCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBhcnJheVtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lc3BhY2UgZmFicmljLnV0aWwuYXJyYXlcbiAgICovXG4gIGZhYnJpYy51dGlsLmFycmF5ID0ge1xuICAgIGZpbGw6IGZpbGwsXG4gICAgaW52b2tlOiBpbnZva2UsXG4gICAgbWluOiBtaW4sXG4gICAgbWF4OiBtYXhcbiAgfTtcblxufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiBDb3BpZXMgYWxsIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBvbmUganMgb2JqZWN0IHRvIGFub3RoZXJcbiAgICogdGhpcyBkb2VzIG5vdCBhbmQgY2Fubm90IGNvbXBldGUgd2l0aCBnZW5lcmljIHV0aWxzLlxuICAgKiBEb2VzIG5vdCBjbG9uZSBvciBleHRlbmQgZmFicmljLk9iamVjdCBzdWJjbGFzc2VzLlxuICAgKiBUaGlzIGlzIG1vc3RseSBmb3IgaW50ZXJuYWwgdXNlIGFuZCBoYXMgZXh0cmEgaGFuZGxpbmcgZm9yIGZhYnJpY0pTIG9iamVjdHNcbiAgICogaXQgc2tpcHMgdGhlIGNhbnZhcyBhbmQgZ3JvdXAgcHJvcGVydGllcyBpbiBkZWVwIGNsb25pbmcuXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5vYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlc3RpbmF0aW9uIFdoZXJlIHRvIGNvcHkgdG9cbiAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBXaGVyZSB0byBjb3B5IGZyb21cbiAgICogQHBhcmFtIHtCb29sZWFufSBbZGVlcF0gV2hldGhlciB0byBleHRlbmQgbmVzdGVkIG9iamVjdHNcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cblxuICBmdW5jdGlvbiBleHRlbmQoZGVzdGluYXRpb24sIHNvdXJjZSwgZGVlcCkge1xuICAgIC8vIEpTY3JpcHQgRG9udEVudW0gYnVnIGlzIG5vdCB0YWtlbiBjYXJlIG9mXG4gICAgLy8gdGhlIGRlZXAgY2xvbmUgaXMgZm9yIGludGVybmFsIHVzZSwgaXMgbm90IG1lYW50IHRvIGF2b2lkXG4gICAgLy8gamF2YXNjcmlwdCB0cmFwcyBvciBjbG9uaW5nIGh0bWwgZWxlbWVudCBvciBzZWxmIHJlZmVyZW5jZWQgb2JqZWN0cy5cbiAgICBpZiAoZGVlcCkge1xuICAgICAgaWYgKCFmYWJyaWMuaXNMaWtlbHlOb2RlICYmIHNvdXJjZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgLy8gYXZvaWQgY2xvbmluZyBkZWVwIGltYWdlcywgY2FudmFzZXMsXG4gICAgICAgIGRlc3RpbmF0aW9uID0gc291cmNlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc291cmNlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZGVzdGluYXRpb24gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGRlc3RpbmF0aW9uW2ldID0gZXh0ZW5kKHsgfSwgc291cmNlW2ldLCBkZWVwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc291cmNlICYmIHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHNvdXJjZSkge1xuICAgICAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJ2NhbnZhcycgfHwgcHJvcGVydHkgPT09ICdncm91cCcpIHtcbiAgICAgICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGNsb25lIHRoaXMgcHJvcHMgYXQgYWxsLlxuICAgICAgICAgICAgLy8gd2Ugd2FudCB0byBrZWVwIHRoZSBrZXlzIGluIHRoZSBjb3B5XG4gICAgICAgICAgICBkZXN0aW5hdGlvbltwcm9wZXJ0eV0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbltwcm9wZXJ0eV0gPSBleHRlbmQoeyB9LCBzb3VyY2VbcHJvcGVydHldLCBkZWVwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyB0aGlzIHNvdW5kcyBvZGQgZm9yIGFuIGV4dGVuZCBidXQgaXMgb2sgZm9yIHJlY3Vyc2l2ZSB1c2VcbiAgICAgICAgZGVzdGluYXRpb24gPSBzb3VyY2U7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gc291cmNlKSB7XG4gICAgICAgIGRlc3RpbmF0aW9uW3Byb3BlcnR5XSA9IHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0aW5hdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGVtcHR5IG9iamVjdCBhbmQgY29waWVzIGFsbCBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYW5vdGhlciBvYmplY3QgdG8gaXRcbiAgICogVGhpcyBtZXRob2QgaXMgbW9zdGx5IGZvciBpbnRlcm5hbCB1c2UsIGFuZCBub3QgaW50ZW5kZWQgZm9yIGR1cGxpY2F0aW5nIHNoYXBlcyBpbiBjYW52YXMuIFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwub2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNsb25lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RlZXBdIFdoZXRoZXIgdG8gY2xvbmUgbmVzdGVkIG9iamVjdHNcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cblxuICAvL1RPRE86IHRoaXMgZnVuY3Rpb24gcmV0dXJuIGFuIGVtcHR5IG9iamVjdCBpZiB5b3UgdHJ5IHRvIGNsb25lIG51bGxcbiAgZnVuY3Rpb24gY2xvbmUob2JqZWN0LCBkZWVwKSB7XG4gICAgcmV0dXJuIGV4dGVuZCh7IH0sIG9iamVjdCwgZGVlcCk7XG4gIH1cblxuICAvKiogQG5hbWVzcGFjZSBmYWJyaWMudXRpbC5vYmplY3QgKi9cbiAgZmFicmljLnV0aWwub2JqZWN0ID0ge1xuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIGNsb25lOiBjbG9uZVxuICB9O1xuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy51dGlsLCBmYWJyaWMuT2JzZXJ2YWJsZSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICAvKipcbiAgICogQ2FtZWxpemVzIGEgc3RyaW5nXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5zdHJpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBTdHJpbmcgdG8gY2FtZWxpemVcbiAgICogQHJldHVybiB7U3RyaW5nfSBDYW1lbGl6ZWQgdmVyc2lvbiBvZiBhIHN0cmluZ1xuICAgKi9cbiAgZnVuY3Rpb24gY2FtZWxpemUoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC8tKyguKT8vZywgZnVuY3Rpb24obWF0Y2gsIGNoYXJhY3Rlcikge1xuICAgICAgcmV0dXJuIGNoYXJhY3RlciA/IGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpIDogJyc7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FwaXRhbGl6ZXMgYSBzdHJpbmdcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLnN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFN0cmluZyB0byBjYXBpdGFsaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZpcnN0TGV0dGVyT25seV0gSWYgdHJ1ZSBvbmx5IGZpcnN0IGxldHRlciBpcyBjYXBpdGFsaXplZFxuICAgKiBhbmQgb3RoZXIgbGV0dGVycyBzdGF5IHVudG91Y2hlZCwgaWYgZmFsc2UgZmlyc3QgbGV0dGVyIGlzIGNhcGl0YWxpemVkXG4gICAqIGFuZCBvdGhlciBsZXR0ZXJzIGFyZSBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IENhcGl0YWxpemVkIHZlcnNpb24gb2YgYSBzdHJpbmdcbiAgICovXG4gIGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nLCBmaXJzdExldHRlck9ubHkpIHtcbiAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICtcbiAgICAgIChmaXJzdExldHRlck9ubHkgPyBzdHJpbmcuc2xpY2UoMSkgOiBzdHJpbmcuc2xpY2UoMSkudG9Mb3dlckNhc2UoKSk7XG4gIH1cblxuICAvKipcbiAgICogRXNjYXBlcyBYTUwgaW4gYSBzdHJpbmdcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLnN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFN0cmluZyB0byBlc2NhcGVcbiAgICogQHJldHVybiB7U3RyaW5nfSBFc2NhcGVkIHZlcnNpb24gb2YgYSBzdHJpbmdcbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZVhtbChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JylcbiAgICAgIC5yZXBsYWNlKC8nL2csICcmYXBvczsnKVxuICAgICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXZpZGUgYSBzdHJpbmcgaW4gdGhlIHVzZXIgcGVyY2VpdmVkIHNpbmdsZSB1bml0c1xuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0c3RyaW5nIFN0cmluZyB0byBlc2NhcGVcbiAgICogQHJldHVybiB7QXJyYXl9IGFycmF5IGNvbnRhaW5pbmcgdGhlIGdyYXBoZW1lc1xuICAgKi9cbiAgZnVuY3Rpb24gZ3JhcGhlbWVTcGxpdCh0ZXh0c3RyaW5nKSB7XG4gICAgdmFyIGkgPSAwLCBjaHIsIGdyYXBoZW1lcyA9IFtdO1xuICAgIGZvciAoaSA9IDAsIGNocjsgaSA8IHRleHRzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICgoY2hyID0gZ2V0V2hvbGVDaGFyKHRleHRzdHJpbmcsIGkpKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBncmFwaGVtZXMucHVzaChjaHIpO1xuICAgIH1cbiAgICByZXR1cm4gZ3JhcGhlbWVzO1xuICB9XG5cbiAgLy8gdGFrZW4gZnJvbSBtZG4gaW4gdGhlIGNoYXJBdCBkb2MgcGFnZS5cbiAgZnVuY3Rpb24gZ2V0V2hvbGVDaGFyKHN0ciwgaSkge1xuICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoaXNOYU4oY29kZSkpIHtcbiAgICAgIHJldHVybiAnJzsgLy8gUG9zaXRpb24gbm90IGZvdW5kXG4gICAgfVxuICAgIGlmIChjb2RlIDwgMHhEODAwIHx8IGNvZGUgPiAweERGRkYpIHtcbiAgICAgIHJldHVybiBzdHIuY2hhckF0KGkpO1xuICAgIH1cblxuICAgIC8vIEhpZ2ggc3Vycm9nYXRlIChjb3VsZCBjaGFuZ2UgbGFzdCBoZXggdG8gMHhEQjdGIHRvIHRyZWF0IGhpZ2ggcHJpdmF0ZVxuICAgIC8vIHN1cnJvZ2F0ZXMgYXMgc2luZ2xlIGNoYXJhY3RlcnMpXG4gICAgaWYgKDB4RDgwMCA8PSBjb2RlICYmIGNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICBpZiAoc3RyLmxlbmd0aCA8PSAoaSArIDEpKSB7XG4gICAgICAgIHRocm93ICdIaWdoIHN1cnJvZ2F0ZSB3aXRob3V0IGZvbGxvd2luZyBsb3cgc3Vycm9nYXRlJztcbiAgICAgIH1cbiAgICAgIHZhciBuZXh0ID0gc3RyLmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgaWYgKDB4REMwMCA+IG5leHQgfHwgbmV4dCA+IDB4REZGRikge1xuICAgICAgICB0aHJvdyAnSGlnaCBzdXJyb2dhdGUgd2l0aG91dCBmb2xsb3dpbmcgbG93IHN1cnJvZ2F0ZSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyLmNoYXJBdChpKSArIHN0ci5jaGFyQXQoaSArIDEpO1xuICAgIH1cbiAgICAvLyBMb3cgc3Vycm9nYXRlICgweERDMDAgPD0gY29kZSAmJiBjb2RlIDw9IDB4REZGRilcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgdGhyb3cgJ0xvdyBzdXJyb2dhdGUgd2l0aG91dCBwcmVjZWRpbmcgaGlnaCBzdXJyb2dhdGUnO1xuICAgIH1cbiAgICB2YXIgcHJldiA9IHN0ci5jaGFyQ29kZUF0KGkgLSAxKTtcblxuICAgIC8vIChjb3VsZCBjaGFuZ2UgbGFzdCBoZXggdG8gMHhEQjdGIHRvIHRyZWF0IGhpZ2ggcHJpdmF0ZVxuICAgIC8vIHN1cnJvZ2F0ZXMgYXMgc2luZ2xlIGNoYXJhY3RlcnMpXG4gICAgaWYgKDB4RDgwMCA+IHByZXYgfHwgcHJldiA+IDB4REJGRikge1xuICAgICAgdGhyb3cgJ0xvdyBzdXJyb2dhdGUgd2l0aG91dCBwcmVjZWRpbmcgaGlnaCBzdXJyb2dhdGUnO1xuICAgIH1cbiAgICAvLyBXZSBjYW4gcGFzcyBvdmVyIGxvdyBzdXJyb2dhdGVzIG5vdyBhcyB0aGUgc2Vjb25kIGNvbXBvbmVudFxuICAgIC8vIGluIGEgcGFpciB3aGljaCB3ZSBoYXZlIGFscmVhZHkgcHJvY2Vzc2VkXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cblxuICAvKipcbiAgICogU3RyaW5nIHV0aWxpdGllc1xuICAgKiBAbmFtZXNwYWNlIGZhYnJpYy51dGlsLnN0cmluZ1xuICAgKi9cbiAgZmFicmljLnV0aWwuc3RyaW5nID0ge1xuICAgIGNhbWVsaXplOiBjYW1lbGl6ZSxcbiAgICBjYXBpdGFsaXplOiBjYXBpdGFsaXplLFxuICAgIGVzY2FwZVhtbDogZXNjYXBlWG1sLFxuICAgIGdyYXBoZW1lU3BsaXQ6IGdyYXBoZW1lU3BsaXRcbiAgfTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZSwgZW1wdHlGdW5jdGlvbiA9IGZ1bmN0aW9uKCkgeyB9LFxuXG4gICAgICBJU19ET05URU5VTV9CVUdHWSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiB7IHRvU3RyaW5nOiAxIH0pIHtcbiAgICAgICAgICBpZiAocCA9PT0gJ3RvU3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pKCksXG5cbiAgICAgIC8qKiBAaWdub3JlICovXG4gICAgICBhZGRNZXRob2RzID0gZnVuY3Rpb24oa2xhc3MsIHNvdXJjZSwgcGFyZW50KSB7XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHNvdXJjZSkge1xuXG4gICAgICAgICAgaWYgKHByb3BlcnR5IGluIGtsYXNzLnByb3RvdHlwZSAmJlxuICAgICAgICAgICAgICB0eXBlb2Yga2xhc3MucHJvdG90eXBlW3Byb3BlcnR5XSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAoc291cmNlW3Byb3BlcnR5XSArICcnKS5pbmRleE9mKCdjYWxsU3VwZXInKSA+IC0xKSB7XG5cbiAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZVtwcm9wZXJ0eV0gPSAoZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHN1cGVyY2xhc3MgPSB0aGlzLmNvbnN0cnVjdG9yLnN1cGVyY2xhc3M7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcmNsYXNzID0gcGFyZW50O1xuICAgICAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLnN1cGVyY2xhc3MgPSBzdXBlcmNsYXNzO1xuXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5ICE9PSAnaW5pdGlhbGl6ZScpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KShwcm9wZXJ0eSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAga2xhc3MucHJvdG90eXBlW3Byb3BlcnR5XSA9IHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKElTX0RPTlRFTlVNX0JVR0dZKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSB7XG4gICAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZS50b1N0cmluZyA9IHNvdXJjZS50b1N0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzb3VyY2UudmFsdWVPZiAhPT0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mKSB7XG4gICAgICAgICAgICAgIGtsYXNzLnByb3RvdHlwZS52YWx1ZU9mID0gc291cmNlLnZhbHVlT2Y7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gIGZ1bmN0aW9uIFN1YmNsYXNzKCkgeyB9XG5cbiAgZnVuY3Rpb24gY2FsbFN1cGVyKG1ldGhvZE5hbWUpIHtcbiAgICB2YXIgcGFyZW50TWV0aG9kID0gbnVsbCxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgLy8gY2xpbWIgcHJvdG90eXBlIGNoYWluIHRvIGZpbmQgbWV0aG9kIG5vdCBlcXVhbCB0byBjYWxsZWUncyBtZXRob2RcbiAgICB3aGlsZSAoX3RoaXMuY29uc3RydWN0b3Iuc3VwZXJjbGFzcykge1xuICAgICAgdmFyIHN1cGVyQ2xhc3NNZXRob2QgPSBfdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcmNsYXNzLnByb3RvdHlwZVttZXRob2ROYW1lXTtcbiAgICAgIGlmIChfdGhpc1ttZXRob2ROYW1lXSAhPT0gc3VwZXJDbGFzc01ldGhvZCkge1xuICAgICAgICBwYXJlbnRNZXRob2QgPSBzdXBlckNsYXNzTWV0aG9kO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgX3RoaXMgPSBfdGhpcy5jb25zdHJ1Y3Rvci5zdXBlcmNsYXNzLnByb3RvdHlwZTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmVudE1ldGhvZCkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKCd0cmllZCB0byBjYWxsU3VwZXIgJyArIG1ldGhvZE5hbWUgKyAnLCBtZXRob2Qgbm90IGZvdW5kIGluIHByb3RvdHlwZSBjaGFpbicsIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpXG4gICAgICA/IHBhcmVudE1ldGhvZC5hcHBseSh0aGlzLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpXG4gICAgICA6IHBhcmVudE1ldGhvZC5jYWxsKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmb3IgY3JlYXRpb24gb2YgXCJjbGFzc2VzXCIuXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcGFyZW50XSBvcHRpb25hbCBcIkNsYXNzXCIgdG8gaW5oZXJpdCBmcm9tXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gUHJvcGVydGllcyBzaGFyZWQgYnkgYWxsIGluc3RhbmNlcyBvZiB0aGlzIGNsYXNzXG4gICAqICAgICAgICAgICAgICAgICAgKGJlIGNhcmVmdWwgbW9kaWZ5aW5nIG9iamVjdHMgZGVmaW5lZCBoZXJlIGFzIHRoaXMgd291bGQgYWZmZWN0IGFsbCBpbnN0YW5jZXMpXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVDbGFzcygpIHtcbiAgICB2YXIgcGFyZW50ID0gbnVsbCxcbiAgICAgICAgcHJvcGVydGllcyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgIGlmICh0eXBlb2YgcHJvcGVydGllc1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGFyZW50ID0gcHJvcGVydGllcy5zaGlmdCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBrbGFzcygpIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGtsYXNzLnN1cGVyY2xhc3MgPSBwYXJlbnQ7XG4gICAga2xhc3Muc3ViY2xhc3NlcyA9IFtdO1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgU3ViY2xhc3MucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgICAgIGtsYXNzLnByb3RvdHlwZSA9IG5ldyBTdWJjbGFzcygpO1xuICAgICAgcGFyZW50LnN1YmNsYXNzZXMucHVzaChrbGFzcyk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBwcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBhZGRNZXRob2RzKGtsYXNzLCBwcm9wZXJ0aWVzW2ldLCBwYXJlbnQpO1xuICAgIH1cbiAgICBpZiAoIWtsYXNzLnByb3RvdHlwZS5pbml0aWFsaXplKSB7XG4gICAgICBrbGFzcy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGVtcHR5RnVuY3Rpb247XG4gICAgfVxuICAgIGtsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGtsYXNzO1xuICAgIGtsYXNzLnByb3RvdHlwZS5jYWxsU3VwZXIgPSBjYWxsU3VwZXI7XG4gICAgcmV0dXJuIGtsYXNzO1xuICB9XG5cbiAgZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MgPSBjcmVhdGVDbGFzcztcbn0pKCk7XG5cblxuKGZ1bmN0aW9uICgpIHtcbiAgLy8gc2luY2UgaWUxMSBjYW4gdXNlIGFkZEV2ZW50TGlzdGVuZXIgYnV0IHRoZXkgZG8gbm90IHN1cHBvcnQgb3B0aW9ucywgaSBuZWVkIHRvIGNoZWNrXG4gIHZhciBjb3VsZFVzZUF0dGFjaEV2ZW50ID0gISFmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykuYXR0YWNoRXZlbnQsXG4gICAgICB0b3VjaEV2ZW50cyA9IFsndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnLCAndG91Y2hlbmQnXTtcbiAgLyoqXG4gICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdG8gYW4gZWxlbWVudFxuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIGVsZW1lbnQgJiYgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgY291bGRVc2VBdHRhY2hFdmVudCA/IGZhbHNlIDogb3B0aW9ucyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIgZnJvbSBhbiBlbGVtZW50XG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGZhYnJpYy51dGlsLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgZWxlbWVudCAmJiBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBjb3VsZFVzZUF0dGFjaEV2ZW50ID8gZmFsc2UgOiBvcHRpb25zKTtcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRUb3VjaEluZm8oZXZlbnQpIHtcbiAgICB2YXIgdG91Y2hQcm9wID0gZXZlbnQuY2hhbmdlZFRvdWNoZXM7XG4gICAgaWYgKHRvdWNoUHJvcCAmJiB0b3VjaFByb3BbMF0pIHtcbiAgICAgIHJldHVybiB0b3VjaFByb3BbMF07XG4gICAgfVxuICAgIHJldHVybiBldmVudDtcbiAgfVxuXG4gIGZhYnJpYy51dGlsLmdldFBvaW50ZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBlbGVtZW50ID0gZXZlbnQudGFyZ2V0LFxuICAgICAgICBzY3JvbGwgPSBmYWJyaWMudXRpbC5nZXRTY3JvbGxMZWZ0VG9wKGVsZW1lbnQpLFxuICAgICAgICBfZXZ0ID0gZ2V0VG91Y2hJbmZvKGV2ZW50KTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogX2V2dC5jbGllbnRYICsgc2Nyb2xsLmxlZnQsXG4gICAgICB5OiBfZXZ0LmNsaWVudFkgKyBzY3JvbGwudG9wXG4gICAgfTtcbiAgfTtcblxuICBmYWJyaWMudXRpbC5pc1RvdWNoRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xuICAgIHJldHVybiB0b3VjaEV2ZW50cy5pbmRleE9mKGV2ZW50LnR5cGUpID4gLTEgfHwgZXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCc7XG4gIH07XG59KSgpO1xuXG5cbihmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIENyb3NzLWJyb3dzZXIgd3JhcHBlciBmb3Igc2V0dGluZyBlbGVtZW50J3Mgc3R5bGVcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlc1xuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gRWxlbWVudCB0aGF0IHdhcyBwYXNzZWQgYXMgYSBmaXJzdCBhcmd1bWVudFxuICAgKi9cbiAgZnVuY3Rpb24gc2V0U3R5bGUoZWxlbWVudCwgc3R5bGVzKSB7XG4gICAgdmFyIGVsZW1lbnRTdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG4gICAgaWYgKCFlbGVtZW50U3R5bGUpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHN0eWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCArPSAnOycgKyBzdHlsZXM7XG4gICAgICByZXR1cm4gc3R5bGVzLmluZGV4T2YoJ29wYWNpdHknKSA+IC0xXG4gICAgICAgID8gc2V0T3BhY2l0eShlbGVtZW50LCBzdHlsZXMubWF0Y2goL29wYWNpdHk6XFxzKihcXGQ/XFwuP1xcZCopLylbMV0pXG4gICAgICAgIDogZWxlbWVudDtcbiAgICB9XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAocHJvcGVydHkgPT09ICdvcGFjaXR5Jykge1xuICAgICAgICBzZXRPcGFjaXR5KGVsZW1lbnQsIHN0eWxlc1twcm9wZXJ0eV0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkUHJvcGVydHkgPSAocHJvcGVydHkgPT09ICdmbG9hdCcgfHwgcHJvcGVydHkgPT09ICdjc3NGbG9hdCcpXG4gICAgICAgICAgPyAodHlwZW9mIGVsZW1lbnRTdHlsZS5zdHlsZUZsb2F0ID09PSAndW5kZWZpbmVkJyA/ICdjc3NGbG9hdCcgOiAnc3R5bGVGbG9hdCcpXG4gICAgICAgICAgOiBwcm9wZXJ0eTtcbiAgICAgICAgZWxlbWVudFN0eWxlLnNldFByb3BlcnR5KG5vcm1hbGl6ZWRQcm9wZXJ0eSwgc3R5bGVzW3Byb3BlcnR5XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgdmFyIHBhcnNlRWwgPSBmYWJyaWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICBzdXBwb3J0c09wYWNpdHkgPSB0eXBlb2YgcGFyc2VFbC5zdHlsZS5vcGFjaXR5ID09PSAnc3RyaW5nJyxcbiAgICAgIHN1cHBvcnRzRmlsdGVycyA9IHR5cGVvZiBwYXJzZUVsLnN0eWxlLmZpbHRlciA9PT0gJ3N0cmluZycsXG4gICAgICByZU9wYWNpdHkgPSAvYWxwaGFcXHMqXFwoXFxzKm9wYWNpdHlcXHMqPVxccyooW15cXCldKylcXCkvLFxuXG4gICAgICAvKiogQGlnbm9yZSAqL1xuICAgICAgc2V0T3BhY2l0eSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBlbGVtZW50OyB9O1xuXG4gIGlmIChzdXBwb3J0c09wYWNpdHkpIHtcbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIHNldE9wYWNpdHkgPSBmdW5jdGlvbihlbGVtZW50LCB2YWx1ZSkge1xuICAgICAgZWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gdmFsdWU7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9O1xuICB9XG4gIGVsc2UgaWYgKHN1cHBvcnRzRmlsdGVycykge1xuICAgIC8qKiBAaWdub3JlICovXG4gICAgc2V0T3BhY2l0eSA9IGZ1bmN0aW9uKGVsZW1lbnQsIHZhbHVlKSB7XG4gICAgICB2YXIgZXMgPSBlbGVtZW50LnN0eWxlO1xuICAgICAgaWYgKGVsZW1lbnQuY3VycmVudFN0eWxlICYmICFlbGVtZW50LmN1cnJlbnRTdHlsZS5oYXNMYXlvdXQpIHtcbiAgICAgICAgZXMuem9vbSA9IDE7XG4gICAgICB9XG4gICAgICBpZiAocmVPcGFjaXR5LnRlc3QoZXMuZmlsdGVyKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID49IDAuOTk5OSA/ICcnIDogKCdhbHBoYShvcGFjaXR5PScgKyAodmFsdWUgKiAxMDApICsgJyknKTtcbiAgICAgICAgZXMuZmlsdGVyID0gZXMuZmlsdGVyLnJlcGxhY2UocmVPcGFjaXR5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZXMuZmlsdGVyICs9ICcgYWxwaGEob3BhY2l0eT0nICsgKHZhbHVlICogMTAwKSArICcpJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG4gIH1cblxuICBmYWJyaWMudXRpbC5zZXRTdHlsZSA9IHNldFN0eWxlO1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgX3NsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gIC8qKlxuICAgKiBUYWtlcyBpZCBhbmQgcmV0dXJucyBhbiBlbGVtZW50IHdpdGggdGhhdCBpZCAoaWYgb25lIGV4aXN0cyBpbiBhIGRvY3VtZW50KVxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGlkXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fG51bGx9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRCeUlkKGlkKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgPyBmYWJyaWMuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIDogaWQ7XG4gIH1cblxuICB2YXIgc2xpY2VDYW5Db252ZXJ0Tm9kZWxpc3RzLFxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZXJ0cyBhbiBhcnJheS1saWtlIG9iamVjdCAoZS5nLiBhcmd1bWVudHMgb3IgTm9kZUxpc3QpIHRvIGFuIGFycmF5XG4gICAgICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcnJheUxpa2VcbiAgICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAgICovXG4gICAgICB0b0FycmF5ID0gZnVuY3Rpb24oYXJyYXlMaWtlKSB7XG4gICAgICAgIHJldHVybiBfc2xpY2UuY2FsbChhcnJheUxpa2UsIDApO1xuICAgICAgfTtcblxuICB0cnkge1xuICAgIHNsaWNlQ2FuQ29udmVydE5vZGVsaXN0cyA9IHRvQXJyYXkoZmFicmljLmRvY3VtZW50LmNoaWxkTm9kZXMpIGluc3RhbmNlb2YgQXJyYXk7XG4gIH1cbiAgY2F0Y2ggKGVycikgeyB9XG5cbiAgaWYgKCFzbGljZUNhbkNvbnZlcnROb2RlbGlzdHMpIHtcbiAgICB0b0FycmF5ID0gZnVuY3Rpb24oYXJyYXlMaWtlKSB7XG4gICAgICB2YXIgYXJyID0gbmV3IEFycmF5KGFycmF5TGlrZS5sZW5ndGgpLCBpID0gYXJyYXlMaWtlLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgYXJyW2ldID0gYXJyYXlMaWtlW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgc3BlY2lmaWVkIGVsZW1lbnQgd2l0aCBzcGVjaWZpZWQgYXR0cmlidXRlc1xuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRhZ05hbWUgVHlwZSBvZiBhbiBlbGVtZW50IHRvIGNyZWF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXNdIEF0dHJpYnV0ZXMgdG8gc2V0IG9uIGFuIGVsZW1lbnRcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IE5ld2x5IGNyZWF0ZWQgZWxlbWVudFxuICAgKi9cbiAgZnVuY3Rpb24gbWFrZUVsZW1lbnQodGFnTmFtZSwgYXR0cmlidXRlcykge1xuICAgIHZhciBlbCA9IGZhYnJpYy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgIGZvciAodmFyIHByb3AgaW4gYXR0cmlidXRlcykge1xuICAgICAgaWYgKHByb3AgPT09ICdjbGFzcycpIHtcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gYXR0cmlidXRlc1twcm9wXTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHByb3AgPT09ICdmb3InKSB7XG4gICAgICAgIGVsLmh0bWxGb3IgPSBhdHRyaWJ1dGVzW3Byb3BdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShwcm9wLCBhdHRyaWJ1dGVzW3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgY2xhc3MgdG8gYW4gZWxlbWVudFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIGFkZCBjbGFzcyB0b1xuICAgKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lIENsYXNzIHRvIGFkZCB0byBhbiBlbGVtZW50XG4gICAqL1xuICBmdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICBpZiAoZWxlbWVudCAmJiAoJyAnICsgZWxlbWVudC5jbGFzc05hbWUgKyAnICcpLmluZGV4T2YoJyAnICsgY2xhc3NOYW1lICsgJyAnKSA9PT0gLTEpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NOYW1lICs9IChlbGVtZW50LmNsYXNzTmFtZSA/ICcgJyA6ICcnKSArIGNsYXNzTmFtZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV3JhcHMgZWxlbWVudCB3aXRoIGFub3RoZXIgZWxlbWVudFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHdyYXBcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxTdHJpbmd9IHdyYXBwZXIgRWxlbWVudCB0byB3cmFwIHdpdGhcbiAgICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzXSBBdHRyaWJ1dGVzIHRvIHNldCBvbiBhIHdyYXBwZXJcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9IHdyYXBwZXJcbiAgICovXG4gIGZ1bmN0aW9uIHdyYXBFbGVtZW50KGVsZW1lbnQsIHdyYXBwZXIsIGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAodHlwZW9mIHdyYXBwZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICB3cmFwcGVyID0gbWFrZUVsZW1lbnQod3JhcHBlciwgYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQod3JhcHBlciwgZWxlbWVudCk7XG4gICAgfVxuICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgcmV0dXJuIHdyYXBwZXI7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBlbGVtZW50IHNjcm9sbCBvZmZzZXRzXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gb3BlcmF0ZSBvblxuICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCB3aXRoIGxlZnQvdG9wIHZhbHVlc1xuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U2Nyb2xsTGVmdFRvcChlbGVtZW50KSB7XG5cbiAgICB2YXIgbGVmdCA9IDAsXG4gICAgICAgIHRvcCA9IDAsXG4gICAgICAgIGRvY0VsZW1lbnQgPSBmYWJyaWMuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICBib2R5ID0gZmFicmljLmRvY3VtZW50LmJvZHkgfHwge1xuICAgICAgICAgIHNjcm9sbExlZnQ6IDAsIHNjcm9sbFRvcDogMFxuICAgICAgICB9O1xuXG4gICAgLy8gV2hpbGUgbG9vcCBjaGVja3MgKGFuZCB0aGVuIHNldHMgZWxlbWVudCB0bykgLnBhcmVudE5vZGUgT1IgLmhvc3RcbiAgICAvLyAgdG8gYWNjb3VudCBmb3IgU2hhZG93RE9NLiBXZSBzdGlsbCB3YW50IHRvIHRyYXZlcnNlIHVwIG91dCBvZiBTaGFkb3dET00sXG4gICAgLy8gIGJ1dCB0aGUgLnBhcmVudE5vZGUgb2YgYSByb290IFNoYWRvd0RPTSBub2RlIHdpbGwgYWx3YXlzIGJlIG51bGwsIGluc3RlYWRcbiAgICAvLyAgaXQgc2hvdWxkIGJlIGFjY2Vzc2VkIHRocm91Z2ggLmhvc3QuIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNDc2NTUyOC80MzgzOTM4XG4gICAgd2hpbGUgKGVsZW1lbnQgJiYgKGVsZW1lbnQucGFyZW50Tm9kZSB8fCBlbGVtZW50Lmhvc3QpKSB7XG5cbiAgICAgIC8vIFNldCBlbGVtZW50IHRvIGVsZW1lbnQgcGFyZW50LCBvciAnaG9zdCcgaW4gY2FzZSBvZiBTaGFkb3dET01cbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGUgfHwgZWxlbWVudC5ob3N0O1xuXG4gICAgICBpZiAoZWxlbWVudCA9PT0gZmFicmljLmRvY3VtZW50KSB7XG4gICAgICAgIGxlZnQgPSBib2R5LnNjcm9sbExlZnQgfHwgZG9jRWxlbWVudC5zY3JvbGxMZWZ0IHx8IDA7XG4gICAgICAgIHRvcCA9IGJvZHkuc2Nyb2xsVG9wIHx8ICBkb2NFbGVtZW50LnNjcm9sbFRvcCB8fCAwO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxlZnQgKz0gZWxlbWVudC5zY3JvbGxMZWZ0IHx8IDA7XG4gICAgICAgIHRvcCArPSBlbGVtZW50LnNjcm9sbFRvcCB8fCAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSA9PT0gMSAmJiBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IGxlZnQ6IGxlZnQsIHRvcDogdG9wIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBvZmZzZXQgZm9yIGEgZ2l2ZW4gZWxlbWVudFxuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBnZXQgb2Zmc2V0IGZvclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCB3aXRoIFwibGVmdFwiIGFuZCBcInRvcFwiIHByb3BlcnRpZXNcbiAgICovXG4gIGZ1bmN0aW9uIGdldEVsZW1lbnRPZmZzZXQoZWxlbWVudCkge1xuICAgIHZhciBkb2NFbGVtLFxuICAgICAgICBkb2MgPSBlbGVtZW50ICYmIGVsZW1lbnQub3duZXJEb2N1bWVudCxcbiAgICAgICAgYm94ID0geyBsZWZ0OiAwLCB0b3A6IDAgfSxcbiAgICAgICAgb2Zmc2V0ID0geyBsZWZ0OiAwLCB0b3A6IDAgfSxcbiAgICAgICAgc2Nyb2xsTGVmdFRvcCxcbiAgICAgICAgb2Zmc2V0QXR0cmlidXRlcyA9IHtcbiAgICAgICAgICBib3JkZXJMZWZ0V2lkdGg6ICdsZWZ0JyxcbiAgICAgICAgICBib3JkZXJUb3BXaWR0aDogICd0b3AnLFxuICAgICAgICAgIHBhZGRpbmdMZWZ0OiAgICAgJ2xlZnQnLFxuICAgICAgICAgIHBhZGRpbmdUb3A6ICAgICAgJ3RvcCdcbiAgICAgICAgfTtcblxuICAgIGlmICghZG9jKSB7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIGZvciAodmFyIGF0dHIgaW4gb2Zmc2V0QXR0cmlidXRlcykge1xuICAgICAgb2Zmc2V0W29mZnNldEF0dHJpYnV0ZXNbYXR0cl1dICs9IHBhcnNlSW50KGdldEVsZW1lbnRTdHlsZShlbGVtZW50LCBhdHRyKSwgMTApIHx8IDA7XG4gICAgfVxuXG4gICAgZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgaWYgKCB0eXBlb2YgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgYm94ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG5cbiAgICBzY3JvbGxMZWZ0VG9wID0gZ2V0U2Nyb2xsTGVmdFRvcChlbGVtZW50KTtcblxuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBib3gubGVmdCArIHNjcm9sbExlZnRUb3AubGVmdCAtIChkb2NFbGVtLmNsaWVudExlZnQgfHwgMCkgKyBvZmZzZXQubGVmdCxcbiAgICAgIHRvcDogYm94LnRvcCArIHNjcm9sbExlZnRUb3AudG9wIC0gKGRvY0VsZW0uY2xpZW50VG9wIHx8IDApICArIG9mZnNldC50b3BcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgc3R5bGUgYXR0cmlidXRlIHZhbHVlIG9mIGEgZ2l2ZW4gZWxlbWVudFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIGdldCBzdHlsZSBhdHRyaWJ1dGUgZm9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyIFN0eWxlIGF0dHJpYnV0ZSB0byBnZXQgZm9yIGVsZW1lbnRcbiAgICogQHJldHVybiB7U3RyaW5nfSBTdHlsZSBhdHRyaWJ1dGUgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAqL1xuICB2YXIgZ2V0RWxlbWVudFN0eWxlO1xuICBpZiAoZmFicmljLmRvY3VtZW50LmRlZmF1bHRWaWV3ICYmIGZhYnJpYy5kb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgZ2V0RWxlbWVudFN0eWxlID0gZnVuY3Rpb24oZWxlbWVudCwgYXR0cikge1xuICAgICAgdmFyIHN0eWxlID0gZmFicmljLmRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gICAgICByZXR1cm4gc3R5bGUgPyBzdHlsZVthdHRyXSA6IHVuZGVmaW5lZDtcbiAgICB9O1xuICB9XG4gIGVsc2Uge1xuICAgIGdldEVsZW1lbnRTdHlsZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHIpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGVsZW1lbnQuc3R5bGVbYXR0cl07XG4gICAgICBpZiAoIXZhbHVlICYmIGVsZW1lbnQuY3VycmVudFN0eWxlKSB7XG4gICAgICAgIHZhbHVlID0gZWxlbWVudC5jdXJyZW50U3R5bGVbYXR0cl07XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0eWxlID0gZmFicmljLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSxcbiAgICAgICAgc2VsZWN0UHJvcCA9ICd1c2VyU2VsZWN0JyBpbiBzdHlsZVxuICAgICAgICAgID8gJ3VzZXJTZWxlY3QnXG4gICAgICAgICAgOiAnTW96VXNlclNlbGVjdCcgaW4gc3R5bGVcbiAgICAgICAgICAgID8gJ01velVzZXJTZWxlY3QnXG4gICAgICAgICAgICA6ICdXZWJraXRVc2VyU2VsZWN0JyBpbiBzdHlsZVxuICAgICAgICAgICAgICA/ICdXZWJraXRVc2VyU2VsZWN0J1xuICAgICAgICAgICAgICA6ICdLaHRtbFVzZXJTZWxlY3QnIGluIHN0eWxlXG4gICAgICAgICAgICAgICAgPyAnS2h0bWxVc2VyU2VsZWN0J1xuICAgICAgICAgICAgICAgIDogJyc7XG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBlbGVtZW50IHVuc2VsZWN0YWJsZVxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBtYWtlIHVuc2VsZWN0YWJsZVxuICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBFbGVtZW50IHRoYXQgd2FzIHBhc3NlZCBpblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1ha2VFbGVtZW50VW5zZWxlY3RhYmxlKGVsZW1lbnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudC5vbnNlbGVjdHN0YXJ0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBlbGVtZW50Lm9uc2VsZWN0c3RhcnQgPSBmYWJyaWMudXRpbC5mYWxzZUZ1bmN0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdFByb3ApIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZVtzZWxlY3RQcm9wXSA9ICdub25lJztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LnVuc2VsZWN0YWJsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZWxlbWVudC51bnNlbGVjdGFibGUgPSAnb24nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFrZXMgZWxlbWVudCBzZWxlY3RhYmxlXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIG1ha2Ugc2VsZWN0YWJsZVxuICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBFbGVtZW50IHRoYXQgd2FzIHBhc3NlZCBpblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1ha2VFbGVtZW50U2VsZWN0YWJsZShlbGVtZW50KSB7XG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnQub25zZWxlY3RzdGFydCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZWxlbWVudC5vbnNlbGVjdHN0YXJ0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3RQcm9wKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGVbc2VsZWN0UHJvcF0gPSAnJztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LnVuc2VsZWN0YWJsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZWxlbWVudC51bnNlbGVjdGFibGUgPSAnJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIGZhYnJpYy51dGlsLm1ha2VFbGVtZW50VW5zZWxlY3RhYmxlID0gbWFrZUVsZW1lbnRVbnNlbGVjdGFibGU7XG4gICAgZmFicmljLnV0aWwubWFrZUVsZW1lbnRTZWxlY3RhYmxlID0gbWFrZUVsZW1lbnRTZWxlY3RhYmxlO1xuICB9KSgpO1xuXG4gIGZ1bmN0aW9uIGdldE5vZGVDYW52YXMoZWxlbWVudCkge1xuICAgIHZhciBpbXBsID0gZmFicmljLmpzZG9tSW1wbEZvcldyYXBwZXIoZWxlbWVudCk7XG4gICAgcmV0dXJuIGltcGwuX2NhbnZhcyB8fCBpbXBsLl9pbWFnZTtcbiAgfTtcblxuICBmdW5jdGlvbiBjbGVhblVwSnNkb21Ob2RlKGVsZW1lbnQpIHtcbiAgICBpZiAoIWZhYnJpYy5pc0xpa2VseU5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGltcGwgPSBmYWJyaWMuanNkb21JbXBsRm9yV3JhcHBlcihlbGVtZW50KTtcbiAgICBpZiAoaW1wbCkge1xuICAgICAgaW1wbC5faW1hZ2UgPSBudWxsO1xuICAgICAgaW1wbC5fY2FudmFzID0gbnVsbDtcbiAgICAgIC8vIHVuc3VyZSBpZiBuZWNlc3NhcnlcbiAgICAgIGltcGwuX2N1cnJlbnRTcmMgPSBudWxsO1xuICAgICAgaW1wbC5fYXR0cmlidXRlcyA9IG51bGw7XG4gICAgICBpbXBsLl9jbGFzc0xpc3QgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEltYWdlU21vb3RoaW5nKGN0eCwgdmFsdWUpIHtcbiAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCB8fCBjdHgud2Via2l0SW1hZ2VTbW9vdGhpbmdFbmFibGVkXG4gICAgICB8fCBjdHgubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkIHx8IGN0eC5tc0ltYWdlU21vb3RoaW5nRW5hYmxlZCB8fCBjdHgub0ltYWdlU21vb3RoaW5nRW5hYmxlZDtcbiAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogc2V0SW1hZ2VTbW9vdGhpbmcgc2V0cyB0aGUgY29udGV4dCBpbWFnZVNtb290aGluZ0VuYWJsZWQgcHJvcGVydHkuXG4gICAqIFVzZWQgYnkgY2FudmFzIGFuZCBieSBJbWFnZU9iamVjdC5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKiBAcGFyYW0ge0hUTUxSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCB0byBzZXQgb25cbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSB0cnVlIG9yIGZhbHNlXG4gICAqL1xuICBmYWJyaWMudXRpbC5zZXRJbWFnZVNtb290aGluZyA9IHNldEltYWdlU21vb3RoaW5nO1xuICBmYWJyaWMudXRpbC5nZXRCeUlkID0gZ2V0QnlJZDtcbiAgZmFicmljLnV0aWwudG9BcnJheSA9IHRvQXJyYXk7XG4gIGZhYnJpYy51dGlsLmFkZENsYXNzID0gYWRkQ2xhc3M7XG4gIGZhYnJpYy51dGlsLm1ha2VFbGVtZW50ID0gbWFrZUVsZW1lbnQ7XG4gIGZhYnJpYy51dGlsLndyYXBFbGVtZW50ID0gd3JhcEVsZW1lbnQ7XG4gIGZhYnJpYy51dGlsLmdldFNjcm9sbExlZnRUb3AgPSBnZXRTY3JvbGxMZWZ0VG9wO1xuICBmYWJyaWMudXRpbC5nZXRFbGVtZW50T2Zmc2V0ID0gZ2V0RWxlbWVudE9mZnNldDtcbiAgZmFicmljLnV0aWwuZ2V0Tm9kZUNhbnZhcyA9IGdldE5vZGVDYW52YXM7XG4gIGZhYnJpYy51dGlsLmNsZWFuVXBKc2RvbU5vZGUgPSBjbGVhblVwSnNkb21Ob2RlO1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICBmdW5jdGlvbiBhZGRQYXJhbVRvVXJsKHVybCwgcGFyYW0pIHtcbiAgICByZXR1cm4gdXJsICsgKC9cXD8vLnRlc3QodXJsKSA/ICcmJyA6ICc/JykgKyBwYXJhbTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Rm4oKSB7IH1cblxuICAvKipcbiAgICogQ3Jvc3MtYnJvd3NlciBhYnN0cmFjdGlvbiBmb3Igc2VuZGluZyBYTUxIdHRwUmVxdWVzdFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBVUkwgdG8gc2VuZCBYTUxIdHRwUmVxdWVzdCB0b1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXRob2Q9XCJHRVRcIl1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBhcmFtZXRlcnNdIHBhcmFtZXRlcnMgdG8gYXBwZW5kIHRvIHVybCBpbiBHRVQgb3IgaW4gYm9keVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYm9keV0gYm9keSB0byBzZW5kIHdpdGggUE9TVCBvciBQVVQgcmVxdWVzdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLm9uQ29tcGxldGUgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gcmVxdWVzdCBpcyBjb21wbGV0ZWRcbiAgICogQHJldHVybiB7WE1MSHR0cFJlcXVlc3R9IHJlcXVlc3RcbiAgICovXG4gIGZ1bmN0aW9uIHJlcXVlc3QodXJsLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG5cbiAgICB2YXIgbWV0aG9kID0gb3B0aW9ucy5tZXRob2QgPyBvcHRpb25zLm1ldGhvZC50b1VwcGVyQ2FzZSgpIDogJ0dFVCcsXG4gICAgICAgIG9uQ29tcGxldGUgPSBvcHRpb25zLm9uQ29tcGxldGUgfHwgZnVuY3Rpb24oKSB7IH0sXG4gICAgICAgIHhociA9IG5ldyBmYWJyaWMud2luZG93LlhNTEh0dHBSZXF1ZXN0KCksXG4gICAgICAgIGJvZHkgPSBvcHRpb25zLmJvZHkgfHwgb3B0aW9ucy5wYXJhbWV0ZXJzO1xuXG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgb25Db21wbGV0ZSh4aHIpO1xuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZW1wdHlGbjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKG1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgIGJvZHkgPSBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnBhcmFtZXRlcnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHVybCA9IGFkZFBhcmFtVG9VcmwodXJsLCBvcHRpb25zLnBhcmFtZXRlcnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcblxuICAgIGlmIChtZXRob2QgPT09ICdQT1NUJyB8fCBtZXRob2QgPT09ICdQVVQnKSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpO1xuICAgIH1cblxuICAgIHhoci5zZW5kKGJvZHkpO1xuICAgIHJldHVybiB4aHI7XG4gIH1cblxuICBmYWJyaWMudXRpbC5yZXF1ZXN0ID0gcmVxdWVzdDtcbn0pKCk7XG5cblxuLyoqXG4gKiBXcmFwcGVyIGFyb3VuZCBgY29uc29sZS5sb2dgICh3aGVuIGF2YWlsYWJsZSlcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlc10gVmFsdWVzIHRvIGxvZ1xuICovXG5mYWJyaWMubG9nID0gY29uc29sZS5sb2c7XG5cbi8qKlxuICogV3JhcHBlciBhcm91bmQgYGNvbnNvbGUud2FybmAgKHdoZW4gYXZhaWxhYmxlKVxuICogQHBhcmFtIHsqfSBbdmFsdWVzXSBWYWx1ZXMgdG8gbG9nIGFzIGEgd2FybmluZ1xuICovXG5mYWJyaWMud2FybiA9IGNvbnNvbGUud2FybjtcblxuXG4oZnVuY3Rpb24gKCkge1xuXG4gIHZhciBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmU7XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IEFuaW1hdGlvbk9wdGlvbnNcbiAgICogQW5pbWF0aW9uIG9mIGEgdmFsdWUgb3IgbGlzdCBvZiB2YWx1ZXMuXG4gICAqIFdoZW4gdXNpbmcgbGlzdHMsIHRoaW5rIG9mIHNvbWV0aGluZyBsaWtlIHRoaXM6XG4gICAqIGZhYnJpYy51dGlsLmFuaW1hdGUoe1xuICAgKiAgIHN0YXJ0VmFsdWU6IFsxLCAyLCAzXSxcbiAgICogICBlbmRWYWx1ZTogWzIsIDQsIDZdLFxuICAgKiAgIG9uQ2hhbmdlOiBmdW5jdGlvbihbYSwgYiwgY10pIHtcbiAgICogICAgIGNhbnZhcy56b29tVG9Qb2ludCh7eDogYiwgeTogY30sIGEpXG4gICAqICAgICBjYW52YXMucmVuZGVyQWxsKClcbiAgICogICB9XG4gICAqIH0pO1xuICAgKiBAZXhhbXBsZVxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbb25DaGFuZ2VdIENhbGxiYWNrOyBpbnZva2VkIG9uIGV2ZXJ5IHZhbHVlIGNoYW5nZVxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbb25Db21wbGV0ZV0gQ2FsbGJhY2s7IGludm9rZWQgd2hlbiB2YWx1ZSBjaGFuZ2UgaXMgY29tcGxldGVkXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIE5vdGU6IHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBhbmQgYnlWYWx1ZSBtdXN0IG1hdGNoIHRoZSB0eXBlXG4gICAqIHZhciBhbmltYXRpb25PcHRpb25zID0geyBzdGFydFZhbHVlOiAwLCBlbmRWYWx1ZTogMSwgYnlWYWx1ZTogMC4yNSB9XG4gICAqIHZhciBhbmltYXRpb25PcHRpb25zID0geyBzdGFydFZhbHVlOiBbMCwgMV0sIGVuZFZhbHVlOiBbMSwgMl0sIGJ5VmFsdWU6IFswLjI1LCAwLjI1XSB9XG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyIHwgbnVtYmVyW119IFtzdGFydFZhbHVlPTBdIFN0YXJ0aW5nIHZhbHVlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyIHwgbnVtYmVyW119IFtlbmRWYWx1ZT0xMDBdIEVuZGluZyB2YWx1ZVxuICAgKiBAcHJvcGVydHkge251bWJlciB8IG51bWJlcltdfSBbYnlWYWx1ZT0xMDBdIFZhbHVlIHRvIG1vZGlmeSB0aGUgcHJvcGVydHkgYnlcbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2Vhc2luZ10gRWFzaW5nIGZ1bmN0aW9uXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZHVyYXRpb249NTAwXSBEdXJhdGlvbiBvZiBjaGFuZ2UgKGluIG1zKVxuICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbYWJvcnRdIEFkZGl0aW9uYWwgZnVuY3Rpb24gd2l0aCBsb2dpYy4gSWYgcmV0dXJucyB0cnVlLCBhbmltYXRpb24gYWJvcnRzLlxuICAgKlxuICAgKiBAdHlwZWRlZiB7KCkgPT4gdm9pZH0gQ2FuY2VsRnVuY3Rpb25cbiAgICpcbiAgICogQHR5cGVkZWYge09iamVjdH0gQW5pbWF0aW9uQ3VycmVudFN0YXRlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyIHwgbnVtYmVyW119IGN1cnJlbnRWYWx1ZSB2YWx1ZSBpbiByYW5nZSBbYHN0YXJ0VmFsdWVgLCBgZW5kVmFsdWVgXVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gY29tcGxldGlvblJhdGUgdmFsdWUgaW4gcmFuZ2UgWzAsIDFdXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkdXJhdGlvblJhdGUgdmFsdWUgaW4gcmFuZ2UgWzAsIDFdXG4gICAqXG4gICAqIEB0eXBlZGVmIHsoQW5pbWF0aW9uT3B0aW9ucyAmIEFuaW1hdGlvbkN1cnJlbnRTdGF0ZSAmIHsgY2FuY2VsOiBDYW5jZWxGdW5jdGlvbiB9fSBBbmltYXRpb25Db250ZXh0XG4gICAqL1xuXG4gIC8qKlxuICAgKiBBcnJheSBob2xkaW5nIGFsbCBydW5uaW5nIGFuaW1hdGlvbnNcbiAgICogQG1lbWJlcm9mIGZhYnJpY1xuICAgKiBAdHlwZSB7QW5pbWF0aW9uQ29udGV4dFtdfVxuICAgKi9cbiAgdmFyIFJVTk5JTkdfQU5JTUFUSU9OUyA9IFtdO1xuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKFJVTk5JTkdfQU5JTUFUSU9OUywge1xuXG4gICAgLyoqXG4gICAgICogY2FuY2VsIGFsbCBydW5uaW5nIGFuaW1hdGlvbnMgYXQgdGhlIG5leHQgcmVxdWVzdEFuaW1GcmFtZVxuICAgICAqIEByZXR1cm5zIHtBbmltYXRpb25Db250ZXh0W119XG4gICAgICovXG4gICAgY2FuY2VsQWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYW5pbWF0aW9ucyA9IHRoaXMuc3BsaWNlKDApO1xuICAgICAgYW5pbWF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhbmltYXRpb24pIHtcbiAgICAgICAgYW5pbWF0aW9uLmNhbmNlbCgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FuY2VsIGFsbCBydW5uaW5nIGFuaW1hdGlvbnMgYXR0YWNoZWQgdG8gY2FudmFzIGF0IHRoZSBuZXh0IHJlcXVlc3RBbmltRnJhbWVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5DYW52YXN9IGNhbnZhc1xuICAgICAqIEByZXR1cm5zIHtBbmltYXRpb25Db250ZXh0W119XG4gICAgICovXG4gICAgY2FuY2VsQnlDYW52YXM6IGZ1bmN0aW9uIChjYW52YXMpIHtcbiAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBjYW5jZWxsZWQgPSB0aGlzLmZpbHRlcihmdW5jdGlvbiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgYW5pbWF0aW9uLnRhcmdldCA9PT0gJ29iamVjdCcgJiYgYW5pbWF0aW9uLnRhcmdldC5jYW52YXMgPT09IGNhbnZhcztcbiAgICAgIH0pO1xuICAgICAgY2FuY2VsbGVkLmZvckVhY2goZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuICAgICAgICBhbmltYXRpb24uY2FuY2VsKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjYW5jZWxsZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbmNlbCBhbGwgcnVubmluZyBhbmltYXRpb25zIGZvciB0YXJnZXQgYXQgdGhlIG5leHQgcmVxdWVzdEFuaW1GcmFtZVxuICAgICAqIEBwYXJhbSB7Kn0gdGFyZ2V0XG4gICAgICogQHJldHVybnMge0FuaW1hdGlvbkNvbnRleHRbXX1cbiAgICAgKi9cbiAgICBjYW5jZWxCeVRhcmdldDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgdmFyIGNhbmNlbGxlZCA9IHRoaXMuZmluZEFuaW1hdGlvbnNCeVRhcmdldCh0YXJnZXQpO1xuICAgICAgY2FuY2VsbGVkLmZvckVhY2goZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuICAgICAgICBhbmltYXRpb24uY2FuY2VsKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjYW5jZWxsZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW5jZWxGdW5jdGlvbn0gY2FuY2VsRnVuYyB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgYnkgYW5pbWF0ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZmluZEFuaW1hdGlvbkluZGV4OiBmdW5jdGlvbiAoY2FuY2VsRnVuYykge1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZXhPZih0aGlzLmZpbmRBbmltYXRpb24oY2FuY2VsRnVuYykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FuY2VsRnVuY3Rpb259IGNhbmNlbEZ1bmMgdGhlIGZ1bmN0aW9uIHJldHVybmVkIGJ5IGFuaW1hdGVcbiAgICAgKiBAcmV0dXJucyB7QW5pbWF0aW9uQ29udGV4dCB8IHVuZGVmaW5lZH0gYW5pbWF0aW9uJ3Mgb3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBmaW5kQW5pbWF0aW9uOiBmdW5jdGlvbiAoY2FuY2VsRnVuYykge1xuICAgICAgcmV0dXJuIHRoaXMuZmluZChmdW5jdGlvbiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIHJldHVybiBhbmltYXRpb24uY2FuY2VsID09PSBjYW5jZWxGdW5jO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXQgdGhlIG9iamVjdCB0aGF0IGlzIGFzc2lnbmVkIHRvIHRoZSB0YXJnZXQgcHJvcGVydHkgb2YgdGhlIGFuaW1hdGlvbiBjb250ZXh0XG4gICAgICogQHJldHVybnMge0FuaW1hdGlvbkNvbnRleHRbXX0gYXJyYXkgb2YgYW5pbWF0aW9uIG9wdGlvbnMgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0YXJnZXRcbiAgICAgKi9cbiAgICBmaW5kQW5pbWF0aW9uc0J5VGFyZ2V0OiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuICAgICAgICByZXR1cm4gYW5pbWF0aW9uLnRhcmdldCA9PT0gdGFyZ2V0O1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiBub29wKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmF1bHRFYXNpbmcodCwgYiwgYywgZCkge1xuICAgIHJldHVybiAtYyAqIE1hdGguY29zKHQgLyBkICogKE1hdGguUEkgLyAyKSkgKyBjICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2VzIHZhbHVlIGZyb20gb25lIHRvIGFub3RoZXIgd2l0aGluIGNlcnRhaW4gcGVyaW9kIG9mIHRpbWUsIGludm9raW5nIGNhbGxiYWNrcyBhcyB2YWx1ZSBpcyBiZWluZyBjaGFuZ2VkLlxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWxcbiAgICogQHBhcmFtIHtBbmltYXRpb25PcHRpb25zfSBbb3B0aW9uc10gQW5pbWF0aW9uIG9wdGlvbnNcbiAgICogQGV4YW1wbGVcbiAgICogLy8gTm90ZTogc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGFuZCBieVZhbHVlIG11c3QgbWF0Y2ggdGhlIHR5cGVcbiAgICogZmFicmljLnV0aWwuYW5pbWF0ZSh7IHN0YXJ0VmFsdWU6IDAsIGVuZFZhbHVlOiAxLCBieVZhbHVlOiAwLjI1IH0pXG4gICAqIGZhYnJpYy51dGlsLmFuaW1hdGUoeyBzdGFydFZhbHVlOiBbMCwgMV0sIGVuZFZhbHVlOiBbMSwgMl0sIGJ5VmFsdWU6IFswLjI1LCAwLjI1XSB9KVxuICAgKiBAcmV0dXJucyB7Q2FuY2VsRnVuY3Rpb259IGNhbmNlbCBmdW5jdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gYW5pbWF0ZShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICB2YXIgY2FuY2VsID0gZmFsc2UsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIHJlbW92ZUZyb21SZWdpc3RyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSBmYWJyaWMucnVubmluZ0FuaW1hdGlvbnMuaW5kZXhPZihjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gaW5kZXggPiAtMSAmJiBmYWJyaWMucnVubmluZ0FuaW1hdGlvbnMuc3BsaWNlKGluZGV4LCAxKVswXTtcbiAgICAgICAgfTtcblxuICAgIGNvbnRleHQgPSBleHRlbmQoY2xvbmUob3B0aW9ucyksIHtcbiAgICAgIGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjYW5jZWwgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmVtb3ZlRnJvbVJlZ2lzdHJ5KCk7XG4gICAgICB9LFxuICAgICAgY3VycmVudFZhbHVlOiAnc3RhcnRWYWx1ZScgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhcnRWYWx1ZSA6IDAsXG4gICAgICBjb21wbGV0aW9uUmF0ZTogMCxcbiAgICAgIGR1cmF0aW9uUmF0ZTogMFxuICAgIH0pO1xuICAgIGZhYnJpYy5ydW5uaW5nQW5pbWF0aW9ucy5wdXNoKGNvbnRleHQpO1xuXG4gICAgcmVxdWVzdEFuaW1GcmFtZShmdW5jdGlvbih0aW1lc3RhbXApIHtcbiAgICAgIHZhciBzdGFydCA9IHRpbWVzdGFtcCB8fCArbmV3IERhdGUoKSxcbiAgICAgICAgICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gfHwgNTAwLFxuICAgICAgICAgIGZpbmlzaCA9IHN0YXJ0ICsgZHVyYXRpb24sIHRpbWUsXG4gICAgICAgICAgb25DaGFuZ2UgPSBvcHRpb25zLm9uQ2hhbmdlIHx8IG5vb3AsXG4gICAgICAgICAgYWJvcnQgPSBvcHRpb25zLmFib3J0IHx8IG5vb3AsXG4gICAgICAgICAgb25Db21wbGV0ZSA9IG9wdGlvbnMub25Db21wbGV0ZSB8fCBub29wLFxuICAgICAgICAgIGVhc2luZyA9IG9wdGlvbnMuZWFzaW5nIHx8IGRlZmF1bHRFYXNpbmcsXG4gICAgICAgICAgaXNNYW55ID0gJ3N0YXJ0VmFsdWUnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXJ0VmFsdWUubGVuZ3RoID4gMCA6IGZhbHNlLFxuICAgICAgICAgIHN0YXJ0VmFsdWUgPSAnc3RhcnRWYWx1ZScgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhcnRWYWx1ZSA6IDAsXG4gICAgICAgICAgZW5kVmFsdWUgPSAnZW5kVmFsdWUnIGluIG9wdGlvbnMgPyBvcHRpb25zLmVuZFZhbHVlIDogMTAwLFxuICAgICAgICAgIGJ5VmFsdWUgPSBvcHRpb25zLmJ5VmFsdWUgfHwgKGlzTWFueSA/IHN0YXJ0VmFsdWUubWFwKGZ1bmN0aW9uKHZhbHVlLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5kVmFsdWVbaV0gLSBzdGFydFZhbHVlW2ldO1xuICAgICAgICAgIH0pIDogZW5kVmFsdWUgLSBzdGFydFZhbHVlKTtcblxuICAgICAgb3B0aW9ucy5vblN0YXJ0ICYmIG9wdGlvbnMub25TdGFydCgpO1xuXG4gICAgICAoZnVuY3Rpb24gdGljayh0aWNrdGltZSkge1xuICAgICAgICB0aW1lID0gdGlja3RpbWUgfHwgK25ldyBEYXRlKCk7XG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IHRpbWUgPiBmaW5pc2ggPyBkdXJhdGlvbiA6ICh0aW1lIC0gc3RhcnQpLFxuICAgICAgICAgICAgdGltZVBlcmMgPSBjdXJyZW50VGltZSAvIGR1cmF0aW9uLFxuICAgICAgICAgICAgY3VycmVudCA9IGlzTWFueSA/IHN0YXJ0VmFsdWUubWFwKGZ1bmN0aW9uKF92YWx1ZSwgaSkge1xuICAgICAgICAgICAgICByZXR1cm4gZWFzaW5nKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlW2ldLCBieVZhbHVlW2ldLCBkdXJhdGlvbik7XG4gICAgICAgICAgICB9KSA6IGVhc2luZyhjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgYnlWYWx1ZSwgZHVyYXRpb24pLFxuICAgICAgICAgICAgdmFsdWVQZXJjID0gaXNNYW55ID8gTWF0aC5hYnMoKGN1cnJlbnRbMF0gLSBzdGFydFZhbHVlWzBdKSAvIGJ5VmFsdWVbMF0pXG4gICAgICAgICAgICAgIDogTWF0aC5hYnMoKGN1cnJlbnQgLSBzdGFydFZhbHVlKSAvIGJ5VmFsdWUpO1xuICAgICAgICAvLyAgdXBkYXRlIGNvbnRleHRcbiAgICAgICAgY29udGV4dC5jdXJyZW50VmFsdWUgPSBpc01hbnkgPyBjdXJyZW50LnNsaWNlKCkgOiBjdXJyZW50O1xuICAgICAgICBjb250ZXh0LmNvbXBsZXRpb25SYXRlID0gdmFsdWVQZXJjO1xuICAgICAgICBjb250ZXh0LmR1cmF0aW9uUmF0ZSA9IHRpbWVQZXJjO1xuICAgICAgICBpZiAoY2FuY2VsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhYm9ydChjdXJyZW50LCB2YWx1ZVBlcmMsIHRpbWVQZXJjKSkge1xuICAgICAgICAgIHJlbW92ZUZyb21SZWdpc3RyeSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZSA+IGZpbmlzaCkge1xuICAgICAgICAgIC8vICB1cGRhdGUgY29udGV4dFxuICAgICAgICAgIGNvbnRleHQuY3VycmVudFZhbHVlID0gaXNNYW55ID8gZW5kVmFsdWUuc2xpY2UoKSA6IGVuZFZhbHVlO1xuICAgICAgICAgIGNvbnRleHQuY29tcGxldGlvblJhdGUgPSAxO1xuICAgICAgICAgIGNvbnRleHQuZHVyYXRpb25SYXRlID0gMTtcbiAgICAgICAgICAvLyAgZXhlY3V0ZSBjYWxsYmFja3NcbiAgICAgICAgICBvbkNoYW5nZShpc01hbnkgPyBlbmRWYWx1ZS5zbGljZSgpIDogZW5kVmFsdWUsIDEsIDEpO1xuICAgICAgICAgIG9uQ29tcGxldGUoZW5kVmFsdWUsIDEsIDEpO1xuICAgICAgICAgIHJlbW92ZUZyb21SZWdpc3RyeSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBvbkNoYW5nZShjdXJyZW50LCB2YWx1ZVBlcmMsIHRpbWVQZXJjKTtcbiAgICAgICAgICByZXF1ZXN0QW5pbUZyYW1lKHRpY2spO1xuICAgICAgICB9XG4gICAgICB9KShzdGFydCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29udGV4dC5jYW5jZWw7XG4gIH1cblxuICB2YXIgX3JlcXVlc3RBbmltRnJhbWUgPSBmYWJyaWMud2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWJyaWMud2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWJyaWMud2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWJyaWMud2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmYWJyaWMud2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWJyaWMud2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgdmFyIF9jYW5jZWxBbmltRnJhbWUgPSBmYWJyaWMud2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IGZhYnJpYy53aW5kb3cuY2xlYXJUaW1lb3V0O1xuXG4gIC8qKlxuICAgKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgcG9seWZpbGwgYmFzZWQgb24gaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cbiAgICogSW4gb3JkZXIgdG8gZ2V0IGEgcHJlY2lzZSBzdGFydCB0aW1lLCBgcmVxdWVzdEFuaW1GcmFtZWAgc2hvdWxkIGJlIGNhbGxlZCBhcyBhbiBlbnRyeSBpbnRvIHRoZSBtZXRob2RcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZVxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnQgb3B0aW9uYWwgRWxlbWVudCB0byBhc3NvY2lhdGUgd2l0aCBhbmltYXRpb25cbiAgICovXG4gIGZ1bmN0aW9uIHJlcXVlc3RBbmltRnJhbWUoKSB7XG4gICAgcmV0dXJuIF9yZXF1ZXN0QW5pbUZyYW1lLmFwcGx5KGZhYnJpYy53aW5kb3csIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWxBbmltRnJhbWUoKSB7XG4gICAgcmV0dXJuIF9jYW5jZWxBbmltRnJhbWUuYXBwbHkoZmFicmljLndpbmRvdywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZhYnJpYy51dGlsLmFuaW1hdGUgPSBhbmltYXRlO1xuICBmYWJyaWMudXRpbC5yZXF1ZXN0QW5pbUZyYW1lID0gcmVxdWVzdEFuaW1GcmFtZTtcbiAgZmFicmljLnV0aWwuY2FuY2VsQW5pbUZyYW1lID0gY2FuY2VsQW5pbUZyYW1lO1xuICBmYWJyaWMucnVubmluZ0FuaW1hdGlvbnMgPSBSVU5OSU5HX0FOSU1BVElPTlM7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgLy8gQ2FsY3VsYXRlIGFuIGluLWJldHdlZW4gY29sb3IuIFJldHVybnMgYSBcInJnYmEoKVwiIHN0cmluZy5cbiAgLy8gQ3JlZGl0OiBFZHdpbiBNYXJ0aW4gPGVkd2luQGJpdHN0b3JtLm9yZz5cbiAgLy8gICAgICAgICBodHRwOi8vd3d3LmJpdHN0b3JtLm9yZy9qcXVlcnkvY29sb3ItYW5pbWF0aW9uL2pxdWVyeS5hbmltYXRlLWNvbG9ycy5qc1xuICBmdW5jdGlvbiBjYWxjdWxhdGVDb2xvcihiZWdpbiwgZW5kLCBwb3MpIHtcbiAgICB2YXIgY29sb3IgPSAncmdiYSgnXG4gICAgICAgICsgcGFyc2VJbnQoKGJlZ2luWzBdICsgcG9zICogKGVuZFswXSAtIGJlZ2luWzBdKSksIDEwKSArICcsJ1xuICAgICAgICArIHBhcnNlSW50KChiZWdpblsxXSArIHBvcyAqIChlbmRbMV0gLSBiZWdpblsxXSkpLCAxMCkgKyAnLCdcbiAgICAgICAgKyBwYXJzZUludCgoYmVnaW5bMl0gKyBwb3MgKiAoZW5kWzJdIC0gYmVnaW5bMl0pKSwgMTApO1xuXG4gICAgY29sb3IgKz0gJywnICsgKGJlZ2luICYmIGVuZCA/IHBhcnNlRmxvYXQoYmVnaW5bM10gKyBwb3MgKiAoZW5kWzNdIC0gYmVnaW5bM10pKSA6IDEpO1xuICAgIGNvbG9yICs9ICcpJztcbiAgICByZXR1cm4gY29sb3I7XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlcyB0aGUgY29sb3IgZnJvbSBvbmUgdG8gYW5vdGhlciB3aXRoaW4gY2VydGFpbiBwZXJpb2Qgb2YgdGltZSwgaW52b2tpbmcgY2FsbGJhY2tzIGFzIHZhbHVlIGlzIGJlaW5nIGNoYW5nZWQuXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZnJvbUNvbG9yIFRoZSBzdGFydGluZyBjb2xvciBpbiBoZXggb3IgcmdiKGEpIGZvcm1hdC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHRvQ29sb3IgVGhlIHN0YXJ0aW5nIGNvbG9yIGluIGhleCBvciByZ2IoYSkgZm9ybWF0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2R1cmF0aW9uXSBEdXJhdGlvbiBvZiBjaGFuZ2UgKGluIG1zKS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbmltYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkNoYW5nZV0gQ2FsbGJhY2s7IGludm9rZWQgb24gZXZlcnkgdmFsdWUgY2hhbmdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uQ29tcGxldGVdIENhbGxiYWNrOyBpbnZva2VkIHdoZW4gdmFsdWUgY2hhbmdlIGlzIGNvbXBsZXRlZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jb2xvckVhc2luZ10gRWFzaW5nIGZ1bmN0aW9uLiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBvbmx5IHRha2UgdHdvIGFyZ3VtZW50cyAoY3VycmVudFRpbWUsIGR1cmF0aW9uKS4gVGh1cyB0aGUgcmVndWxhciBhbmltYXRpb24gZWFzaW5nIGZ1bmN0aW9ucyBjYW5ub3QgYmUgdXNlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuYWJvcnRdIEFkZGl0aW9uYWwgZnVuY3Rpb24gd2l0aCBsb2dpYy4gSWYgcmV0dXJucyB0cnVlLCBvbkNvbXBsZXRlIGlzIGNhbGxlZC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBhYm9ydCBmdW5jdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gYW5pbWF0ZUNvbG9yKGZyb21Db2xvciwgdG9Db2xvciwgZHVyYXRpb24sIG9wdGlvbnMpIHtcbiAgICB2YXIgc3RhcnRDb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IoZnJvbUNvbG9yKS5nZXRTb3VyY2UoKSxcbiAgICAgICAgZW5kQ29sb3IgPSBuZXcgZmFicmljLkNvbG9yKHRvQ29sb3IpLmdldFNvdXJjZSgpLFxuICAgICAgICBvcmlnaW5hbE9uQ29tcGxldGUgPSBvcHRpb25zLm9uQ29tcGxldGUsXG4gICAgICAgIG9yaWdpbmFsT25DaGFuZ2UgPSBvcHRpb25zLm9uQ2hhbmdlO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgcmV0dXJuIGZhYnJpYy51dGlsLmFuaW1hdGUoZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChvcHRpb25zLCB7XG4gICAgICBkdXJhdGlvbjogZHVyYXRpb24gfHwgNTAwLFxuICAgICAgc3RhcnRWYWx1ZTogc3RhcnRDb2xvcixcbiAgICAgIGVuZFZhbHVlOiBlbmRDb2xvcixcbiAgICAgIGJ5VmFsdWU6IGVuZENvbG9yLFxuICAgICAgZWFzaW5nOiBmdW5jdGlvbiAoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGJ5VmFsdWUsIGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBwb3NWYWx1ZSA9IG9wdGlvbnMuY29sb3JFYXNpbmdcbiAgICAgICAgICA/IG9wdGlvbnMuY29sb3JFYXNpbmcoY3VycmVudFRpbWUsIGR1cmF0aW9uKVxuICAgICAgICAgIDogMSAtIE1hdGguY29zKGN1cnJlbnRUaW1lIC8gZHVyYXRpb24gKiAoTWF0aC5QSSAvIDIpKTtcbiAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZUNvbG9yKHN0YXJ0VmFsdWUsIGJ5VmFsdWUsIHBvc1ZhbHVlKTtcbiAgICAgIH0sXG4gICAgICAvLyBoYXMgdG8gdGFrZSBpbiBhY2NvdW50IGZvciBjb2xvciByZXN0b3Jpbmc7XG4gICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbihjdXJyZW50LCB2YWx1ZVBlcmMsIHRpbWVQZXJjKSB7XG4gICAgICAgIGlmIChvcmlnaW5hbE9uQ29tcGxldGUpIHtcbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWxPbkNvbXBsZXRlKFxuICAgICAgICAgICAgY2FsY3VsYXRlQ29sb3IoZW5kQ29sb3IsIGVuZENvbG9yLCAwKSxcbiAgICAgICAgICAgIHZhbHVlUGVyYyxcbiAgICAgICAgICAgIHRpbWVQZXJjXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbihjdXJyZW50LCB2YWx1ZVBlcmMsIHRpbWVQZXJjKSB7XG4gICAgICAgIGlmIChvcmlnaW5hbE9uQ2hhbmdlKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbE9uQ2hhbmdlKFxuICAgICAgICAgICAgICBjYWxjdWxhdGVDb2xvcihjdXJyZW50LCBjdXJyZW50LCAwKSxcbiAgICAgICAgICAgICAgdmFsdWVQZXJjLFxuICAgICAgICAgICAgICB0aW1lUGVyY1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3JpZ2luYWxPbkNoYW5nZShjdXJyZW50LCB2YWx1ZVBlcmMsIHRpbWVQZXJjKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuXG4gIGZhYnJpYy51dGlsLmFuaW1hdGVDb2xvciA9IGFuaW1hdGVDb2xvcjtcblxufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplKGEsIGMsIHAsIHMpIHtcbiAgICBpZiAoYSA8IE1hdGguYWJzKGMpKSB7XG4gICAgICBhID0gYztcbiAgICAgIHMgPSBwIC8gNDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvL2hhbmRsZSB0aGUgMC8wIGNhc2U6XG4gICAgICBpZiAoYyA9PT0gMCAmJiBhID09PSAwKSB7XG4gICAgICAgIHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbigxKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oYyAvIGEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBhOiBhLCBjOiBjLCBwOiBwLCBzOiBzIH07XG4gIH1cblxuICBmdW5jdGlvbiBlbGFzdGljKG9wdHMsIHQsIGQpIHtcbiAgICByZXR1cm4gb3B0cy5hICpcbiAgICAgIE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICpcbiAgICAgIE1hdGguc2luKCAodCAqIGQgLSBvcHRzLnMpICogKDIgKiBNYXRoLlBJKSAvIG9wdHMucCApO1xuICB9XG5cbiAgLyoqXG4gICAqIEN1YmljIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRDdWJpYyh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqIHQgKyAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQ3ViaWMgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dEN1YmljKHQsIGIsIGMsIGQpIHtcbiAgICB0IC89IGQgLyAyO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIGMgLyAyICogdCAqIHQgKiB0ICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIGMgLyAyICogKCh0IC09IDIpICogdCAqIHQgKyAyKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogUXVhcnRpYyBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJblF1YXJ0KHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqIHQgKiB0ICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWFydGljIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRRdWFydCh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIC1jICogKCh0ID0gdCAvIGQgLSAxKSAqIHQgKiB0ICogdCAtIDEpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWFydGljIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRRdWFydCh0LCBiLCBjLCBkKSB7XG4gICAgdCAvPSBkIC8gMjtcbiAgICBpZiAodCA8IDEpIHtcbiAgICAgIHJldHVybiBjIC8gMiAqIHQgKiB0ICogdCAqIHQgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gLWMgLyAyICogKCh0IC09IDIpICogdCAqIHQgKiB0IC0gMikgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1aW50aWMgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5RdWludCh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKiB0ICogdCAqIHQgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1aW50aWMgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dFF1aW50KHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAqICgodCA9IHQgLyBkIC0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1aW50aWMgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dFF1aW50KHQsIGIsIGMsIGQpIHtcbiAgICB0IC89IGQgLyAyO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIGMgLyAyICogdCAqIHQgKiB0ICogdCAqIHQgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gYyAvIDIgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgKiB0ICsgMikgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbnVzb2lkYWwgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5TaW5lKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gLWMgKiBNYXRoLmNvcyh0IC8gZCAqIChNYXRoLlBJIC8gMikpICsgYyArIGI7XG4gIH1cblxuICAvKipcbiAgICogU2ludXNvaWRhbCBlYXNpbmcgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlT3V0U2luZSh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgKiBNYXRoLnNpbih0IC8gZCAqIChNYXRoLlBJIC8gMikpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW51c29pZGFsIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRTaW5lKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gLWMgLyAyICogKE1hdGguY29zKE1hdGguUEkgKiB0IC8gZCkgLSAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogRXhwb25lbnRpYWwgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5FeHBvKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gKHQgPT09IDApID8gYiA6IGMgKiBNYXRoLnBvdygyLCAxMCAqICh0IC8gZCAtIDEpKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogRXhwb25lbnRpYWwgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dEV4cG8odCwgYiwgYywgZCkge1xuICAgIHJldHVybiAodCA9PT0gZCkgPyBiICsgYyA6IGMgKiAoLU1hdGgucG93KDIsIC0xMCAqIHQgLyBkKSArIDEpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvbmVudGlhbCBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0RXhwbyh0LCBiLCBjLCBkKSB7XG4gICAgaWYgKHQgPT09IDApIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICBpZiAodCA9PT0gZCkge1xuICAgICAgcmV0dXJuIGIgKyBjO1xuICAgIH1cbiAgICB0IC89IGQgLyAyO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIGMgLyAyICogTWF0aC5wb3coMiwgMTAgKiAodCAtIDEpKSArIGI7XG4gICAgfVxuICAgIHJldHVybiBjIC8gMiAqICgtTWF0aC5wb3coMiwgLTEwICogLS10KSArIDIpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaXJjdWxhciBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbkNpcmModCwgYiwgYywgZCkge1xuICAgIHJldHVybiAtYyAqIChNYXRoLnNxcnQoMSAtICh0IC89IGQpICogdCkgLSAxKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQ2lyY3VsYXIgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dENpcmModCwgYiwgYywgZCkge1xuICAgIHJldHVybiBjICogTWF0aC5zcXJ0KDEgLSAodCA9IHQgLyBkIC0gMSkgKiB0KSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQ2lyY3VsYXIgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dENpcmModCwgYiwgYywgZCkge1xuICAgIHQgLz0gZCAvIDI7XG4gICAgaWYgKHQgPCAxKSB7XG4gICAgICByZXR1cm4gLWMgLyAyICogKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSkgKyBiO1xuICAgIH1cbiAgICByZXR1cm4gYyAvIDIgKiAoTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsYXN0aWMgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5FbGFzdGljKHQsIGIsIGMsIGQpIHtcbiAgICB2YXIgcyA9IDEuNzAxNTgsIHAgPSAwLCBhID0gYztcbiAgICBpZiAodCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIHQgLz0gZDtcbiAgICBpZiAodCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGIgKyBjO1xuICAgIH1cbiAgICBpZiAoIXApIHtcbiAgICAgIHAgPSBkICogMC4zO1xuICAgIH1cbiAgICB2YXIgb3B0cyA9IG5vcm1hbGl6ZShhLCBjLCBwLCBzKTtcbiAgICByZXR1cm4gLWVsYXN0aWMob3B0cywgdCwgZCkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsYXN0aWMgZWFzaW5nIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZU91dEVsYXN0aWModCwgYiwgYywgZCkge1xuICAgIHZhciBzID0gMS43MDE1OCwgcCA9IDAsIGEgPSBjO1xuICAgIGlmICh0ID09PSAwKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgdCAvPSBkO1xuICAgIGlmICh0ID09PSAxKSB7XG4gICAgICByZXR1cm4gYiArIGM7XG4gICAgfVxuICAgIGlmICghcCkge1xuICAgICAgcCA9IGQgKiAwLjM7XG4gICAgfVxuICAgIHZhciBvcHRzID0gbm9ybWFsaXplKGEsIGMsIHAsIHMpO1xuICAgIHJldHVybiBvcHRzLmEgKiBNYXRoLnBvdygyLCAtMTAgKiB0KSAqIE1hdGguc2luKCh0ICogZCAtIG9wdHMucykgKiAoMiAqIE1hdGguUEkpIC8gb3B0cy5wICkgKyBvcHRzLmMgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsYXN0aWMgZWFzaW5nIGluIGFuZCBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbk91dEVsYXN0aWModCwgYiwgYywgZCkge1xuICAgIHZhciBzID0gMS43MDE1OCwgcCA9IDAsIGEgPSBjO1xuICAgIGlmICh0ID09PSAwKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG4gICAgdCAvPSBkIC8gMjtcbiAgICBpZiAodCA9PT0gMikge1xuICAgICAgcmV0dXJuIGIgKyBjO1xuICAgIH1cbiAgICBpZiAoIXApIHtcbiAgICAgIHAgPSBkICogKDAuMyAqIDEuNSk7XG4gICAgfVxuICAgIHZhciBvcHRzID0gbm9ybWFsaXplKGEsIGMsIHAsIHMpO1xuICAgIGlmICh0IDwgMSkge1xuICAgICAgcmV0dXJuIC0wLjUgKiBlbGFzdGljKG9wdHMsIHQsIGQpICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIG9wdHMuYSAqIE1hdGgucG93KDIsIC0xMCAqICh0IC09IDEpKSAqXG4gICAgICBNYXRoLnNpbigodCAqIGQgLSBvcHRzLnMpICogKDIgKiBNYXRoLlBJKSAvIG9wdHMucCApICogMC41ICsgb3B0cy5jICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYWNrd2FyZHMgZWFzaW5nIGluXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5CYWNrKHQsIGIsIGMsIGQsIHMpIHtcbiAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzID0gMS43MDE1ODtcbiAgICB9XG4gICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKSArIGI7XG4gIH1cblxuICAvKipcbiAgICogQmFja3dhcmRzIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRCYWNrKHQsIGIsIGMsIGQsIHMpIHtcbiAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzID0gMS43MDE1ODtcbiAgICB9XG4gICAgcmV0dXJuIGMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMSkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEJhY2t3YXJkcyBlYXNpbmcgaW4gYW5kIG91dFxuICAgKiBAbWVtYmVyT2YgZmFicmljLnV0aWwuZWFzZVxuICAgKi9cbiAgZnVuY3Rpb24gZWFzZUluT3V0QmFjayh0LCBiLCBjLCBkLCBzKSB7XG4gICAgaWYgKHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcyA9IDEuNzAxNTg7XG4gICAgfVxuICAgIHQgLz0gZCAvIDI7XG4gICAgaWYgKHQgPCAxKSB7XG4gICAgICByZXR1cm4gYyAvIDIgKiAodCAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0IC0gcykpICsgYjtcbiAgICB9XG4gICAgcmV0dXJuIGMgLyAyICogKCh0IC09IDIpICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgKyBzKSArIDIpICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBCb3VuY2luZyBlYXNpbmcgaW5cbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VJbkJvdW5jZSh0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgLSBlYXNlT3V0Qm91bmNlIChkIC0gdCwgMCwgYywgZCkgKyBiO1xuICB9XG5cbiAgLyoqXG4gICAqIEJvdW5jaW5nIGVhc2luZyBvdXRcbiAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZ1bmN0aW9uIGVhc2VPdXRCb3VuY2UodCwgYiwgYywgZCkge1xuICAgIGlmICgodCAvPSBkKSA8ICgxIC8gMi43NSkpIHtcbiAgICAgIHJldHVybiBjICogKDcuNTYyNSAqIHQgKiB0KSArIGI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHQgPCAoMiAvIDIuNzUpKSB7XG4gICAgICByZXR1cm4gYyAqICg3LjU2MjUgKiAodCAtPSAoMS41IC8gMi43NSkpICogdCArIDAuNzUpICsgYjtcbiAgICB9XG4gICAgZWxzZSBpZiAodCA8ICgyLjUgLyAyLjc1KSkge1xuICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogKHQgLT0gKDIuMjUgLyAyLjc1KSkgKiB0ICsgMC45Mzc1KSArIGI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogKHQgLT0gKDIuNjI1IC8gMi43NSkpICogdCArIDAuOTg0Mzc1KSArIGI7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJvdW5jaW5nIGVhc2luZyBpbiBhbmQgb3V0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAqL1xuICBmdW5jdGlvbiBlYXNlSW5PdXRCb3VuY2UodCwgYiwgYywgZCkge1xuICAgIGlmICh0IDwgZCAvIDIpIHtcbiAgICAgIHJldHVybiBlYXNlSW5Cb3VuY2UgKHQgKiAyLCAwLCBjLCBkKSAqIDAuNSArIGI7XG4gICAgfVxuICAgIHJldHVybiBlYXNlT3V0Qm91bmNlKHQgKiAyIC0gZCwgMCwgYywgZCkgKiAwLjUgKyBjICogMC41ICsgYjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFYXNpbmcgZnVuY3Rpb25zXG4gICAqIFNlZSA8YSBocmVmPVwiaHR0cDovL2dpem1hLmNvbS9lYXNpbmcvXCI+RWFzaW5nIEVxdWF0aW9ucyBieSBSb2JlcnQgUGVubmVyPC9hPlxuICAgKiBAbmFtZXNwYWNlIGZhYnJpYy51dGlsLmVhc2VcbiAgICovXG4gIGZhYnJpYy51dGlsLmVhc2UgPSB7XG5cbiAgICAvKipcbiAgICAgKiBRdWFkcmF0aWMgZWFzaW5nIGluXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICAgKi9cbiAgICBlYXNlSW5RdWFkOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCArIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFF1YWRyYXRpYyBlYXNpbmcgb3V0XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICAgKi9cbiAgICBlYXNlT3V0UXVhZDogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgcmV0dXJuIC1jICogKHQgLz0gZCkgKiAodCAtIDIpICsgYjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUXVhZHJhdGljIGVhc2luZyBpbiBhbmQgb3V0XG4gICAgICogQG1lbWJlck9mIGZhYnJpYy51dGlsLmVhc2VcbiAgICAgKi9cbiAgICBlYXNlSW5PdXRRdWFkOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICB0IC89IChkIC8gMik7XG4gICAgICBpZiAodCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGMgLyAyICogdCAqIHQgKyBiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC1jIC8gMiAqICgoLS10KSAqICh0IC0gMikgLSAxKSArIGI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEN1YmljIGVhc2luZyBpblxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMudXRpbC5lYXNlXG4gICAgICovXG4gICAgZWFzZUluQ3ViaWM6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogdCArIGI7XG4gICAgfSxcblxuICAgIGVhc2VPdXRDdWJpYzogZWFzZU91dEN1YmljLFxuICAgIGVhc2VJbk91dEN1YmljOiBlYXNlSW5PdXRDdWJpYyxcbiAgICBlYXNlSW5RdWFydDogZWFzZUluUXVhcnQsXG4gICAgZWFzZU91dFF1YXJ0OiBlYXNlT3V0UXVhcnQsXG4gICAgZWFzZUluT3V0UXVhcnQ6IGVhc2VJbk91dFF1YXJ0LFxuICAgIGVhc2VJblF1aW50OiBlYXNlSW5RdWludCxcbiAgICBlYXNlT3V0UXVpbnQ6IGVhc2VPdXRRdWludCxcbiAgICBlYXNlSW5PdXRRdWludDogZWFzZUluT3V0UXVpbnQsXG4gICAgZWFzZUluU2luZTogZWFzZUluU2luZSxcbiAgICBlYXNlT3V0U2luZTogZWFzZU91dFNpbmUsXG4gICAgZWFzZUluT3V0U2luZTogZWFzZUluT3V0U2luZSxcbiAgICBlYXNlSW5FeHBvOiBlYXNlSW5FeHBvLFxuICAgIGVhc2VPdXRFeHBvOiBlYXNlT3V0RXhwbyxcbiAgICBlYXNlSW5PdXRFeHBvOiBlYXNlSW5PdXRFeHBvLFxuICAgIGVhc2VJbkNpcmM6IGVhc2VJbkNpcmMsXG4gICAgZWFzZU91dENpcmM6IGVhc2VPdXRDaXJjLFxuICAgIGVhc2VJbk91dENpcmM6IGVhc2VJbk91dENpcmMsXG4gICAgZWFzZUluRWxhc3RpYzogZWFzZUluRWxhc3RpYyxcbiAgICBlYXNlT3V0RWxhc3RpYzogZWFzZU91dEVsYXN0aWMsXG4gICAgZWFzZUluT3V0RWxhc3RpYzogZWFzZUluT3V0RWxhc3RpYyxcbiAgICBlYXNlSW5CYWNrOiBlYXNlSW5CYWNrLFxuICAgIGVhc2VPdXRCYWNrOiBlYXNlT3V0QmFjayxcbiAgICBlYXNlSW5PdXRCYWNrOiBlYXNlSW5PdXRCYWNrLFxuICAgIGVhc2VJbkJvdW5jZTogZWFzZUluQm91bmNlLFxuICAgIGVhc2VPdXRCb3VuY2U6IGVhc2VPdXRCb3VuY2UsXG4gICAgZWFzZUluT3V0Qm91bmNlOiBlYXNlSW5PdXRCb3VuY2VcbiAgfTtcblxufSkoKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBAbmFtZSBmYWJyaWNcbiAgICogQG5hbWVzcGFjZVxuICAgKi9cblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUsXG4gICAgICB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZCxcbiAgICAgIHBhcnNlVW5pdCA9IGZhYnJpYy51dGlsLnBhcnNlVW5pdCxcbiAgICAgIG11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMgPSBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzLFxuXG4gICAgICBzdmdWYWxpZFRhZ05hbWVzID0gWydwYXRoJywgJ2NpcmNsZScsICdwb2x5Z29uJywgJ3BvbHlsaW5lJywgJ2VsbGlwc2UnLCAncmVjdCcsICdsaW5lJyxcbiAgICAgICAgJ2ltYWdlJywgJ3RleHQnXSxcbiAgICAgIHN2Z1ZpZXdCb3hFbGVtZW50cyA9IFsnc3ltYm9sJywgJ2ltYWdlJywgJ21hcmtlcicsICdwYXR0ZXJuJywgJ3ZpZXcnLCAnc3ZnJ10sXG4gICAgICBzdmdJbnZhbGlkQW5jZXN0b3JzID0gWydwYXR0ZXJuJywgJ2RlZnMnLCAnc3ltYm9sJywgJ21ldGFkYXRhJywgJ2NsaXBQYXRoJywgJ21hc2snLCAnZGVzYyddLFxuICAgICAgc3ZnVmFsaWRQYXJlbnRzID0gWydzeW1ib2wnLCAnZycsICdhJywgJ3N2ZycsICdjbGlwUGF0aCcsICdkZWZzJ10sXG5cbiAgICAgIGF0dHJpYnV0ZXNNYXAgPSB7XG4gICAgICAgIGN4OiAgICAgICAgICAgICAgICAgICAnbGVmdCcsXG4gICAgICAgIHg6ICAgICAgICAgICAgICAgICAgICAnbGVmdCcsXG4gICAgICAgIHI6ICAgICAgICAgICAgICAgICAgICAncmFkaXVzJyxcbiAgICAgICAgY3k6ICAgICAgICAgICAgICAgICAgICd0b3AnLFxuICAgICAgICB5OiAgICAgICAgICAgICAgICAgICAgJ3RvcCcsXG4gICAgICAgIGRpc3BsYXk6ICAgICAgICAgICAgICAndmlzaWJsZScsXG4gICAgICAgIHZpc2liaWxpdHk6ICAgICAgICAgICAndmlzaWJsZScsXG4gICAgICAgIHRyYW5zZm9ybTogICAgICAgICAgICAndHJhbnNmb3JtTWF0cml4JyxcbiAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6ICAgICAgICdmaWxsT3BhY2l0eScsXG4gICAgICAgICdmaWxsLXJ1bGUnOiAgICAgICAgICAnZmlsbFJ1bGUnLFxuICAgICAgICAnZm9udC1mYW1pbHknOiAgICAgICAgJ2ZvbnRGYW1pbHknLFxuICAgICAgICAnZm9udC1zaXplJzogICAgICAgICAgJ2ZvbnRTaXplJyxcbiAgICAgICAgJ2ZvbnQtc3R5bGUnOiAgICAgICAgICdmb250U3R5bGUnLFxuICAgICAgICAnZm9udC13ZWlnaHQnOiAgICAgICAgJ2ZvbnRXZWlnaHQnLFxuICAgICAgICAnbGV0dGVyLXNwYWNpbmcnOiAgICAgJ2NoYXJTcGFjaW5nJyxcbiAgICAgICAgJ3BhaW50LW9yZGVyJzogICAgICAgICdwYWludEZpcnN0JyxcbiAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiAgICdzdHJva2VEYXNoQXJyYXknLFxuICAgICAgICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAgJ3N0cm9rZURhc2hPZmZzZXQnLFxuICAgICAgICAnc3Ryb2tlLWxpbmVjYXAnOiAgICAgJ3N0cm9rZUxpbmVDYXAnLFxuICAgICAgICAnc3Ryb2tlLWxpbmVqb2luJzogICAgJ3N0cm9rZUxpbmVKb2luJyxcbiAgICAgICAgJ3N0cm9rZS1taXRlcmxpbWl0JzogICdzdHJva2VNaXRlckxpbWl0JyxcbiAgICAgICAgJ3N0cm9rZS1vcGFjaXR5JzogICAgICdzdHJva2VPcGFjaXR5JyxcbiAgICAgICAgJ3N0cm9rZS13aWR0aCc6ICAgICAgICdzdHJva2VXaWR0aCcsXG4gICAgICAgICd0ZXh0LWRlY29yYXRpb24nOiAgICAndGV4dERlY29yYXRpb24nLFxuICAgICAgICAndGV4dC1hbmNob3InOiAgICAgICAgJ3RleHRBbmNob3InLFxuICAgICAgICBvcGFjaXR5OiAgICAgICAgICAgICAgJ29wYWNpdHknLFxuICAgICAgICAnY2xpcC1wYXRoJzogICAgICAgICAgJ2NsaXBQYXRoJyxcbiAgICAgICAgJ2NsaXAtcnVsZSc6ICAgICAgICAgICdjbGlwUnVsZScsXG4gICAgICAgICd2ZWN0b3ItZWZmZWN0JzogICAgICAnc3Ryb2tlVW5pZm9ybScsXG4gICAgICAgICdpbWFnZS1yZW5kZXJpbmcnOiAgICAnaW1hZ2VTbW9vdGhpbmcnLFxuICAgICAgfSxcblxuICAgICAgY29sb3JBdHRyaWJ1dGVzID0ge1xuICAgICAgICBzdHJva2U6ICdzdHJva2VPcGFjaXR5JyxcbiAgICAgICAgZmlsbDogICAnZmlsbE9wYWNpdHknXG4gICAgICB9LFxuXG4gICAgICBmU2l6ZSA9ICdmb250LXNpemUnLCBjUGF0aCA9ICdjbGlwLXBhdGgnO1xuXG4gIGZhYnJpYy5zdmdWYWxpZFRhZ05hbWVzUmVnRXggPSBnZXRTdmdSZWdleChzdmdWYWxpZFRhZ05hbWVzKTtcbiAgZmFicmljLnN2Z1ZpZXdCb3hFbGVtZW50c1JlZ0V4ID0gZ2V0U3ZnUmVnZXgoc3ZnVmlld0JveEVsZW1lbnRzKTtcbiAgZmFicmljLnN2Z0ludmFsaWRBbmNlc3RvcnNSZWdFeCA9IGdldFN2Z1JlZ2V4KHN2Z0ludmFsaWRBbmNlc3RvcnMpO1xuICBmYWJyaWMuc3ZnVmFsaWRQYXJlbnRzUmVnRXggPSBnZXRTdmdSZWdleChzdmdWYWxpZFBhcmVudHMpO1xuXG4gIGZhYnJpYy5jc3NSdWxlcyA9IHsgfTtcbiAgZmFicmljLmdyYWRpZW50RGVmcyA9IHsgfTtcbiAgZmFicmljLmNsaXBQYXRocyA9IHsgfTtcblxuICBmdW5jdGlvbiBub3JtYWxpemVBdHRyKGF0dHIpIHtcbiAgICAvLyB0cmFuc2Zvcm0gYXR0cmlidXRlIG5hbWVzXG4gICAgaWYgKGF0dHIgaW4gYXR0cmlidXRlc01hcCkge1xuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXNNYXBbYXR0cl07XG4gICAgfVxuICAgIHJldHVybiBhdHRyO1xuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUoYXR0ciwgdmFsdWUsIHBhcmVudEF0dHJpYnV0ZXMsIGZvbnRTaXplKSB7XG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHZhbHVlKSwgcGFyc2VkO1xuXG4gICAgaWYgKChhdHRyID09PSAnZmlsbCcgfHwgYXR0ciA9PT0gJ3N0cm9rZScpICYmIHZhbHVlID09PSAnbm9uZScpIHtcbiAgICAgIHZhbHVlID0gJyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICdzdHJva2VVbmlmb3JtJykge1xuICAgICAgcmV0dXJuICh2YWx1ZSA9PT0gJ25vbi1zY2FsaW5nLXN0cm9rZScpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAnc3Ryb2tlRGFzaEFycmF5Jykge1xuICAgICAgaWYgKHZhbHVlID09PSAnbm9uZScpIHtcbiAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvLC9nLCAnICcpLnNwbGl0KC9cXHMrLykubWFwKHBhcnNlRmxvYXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAndHJhbnNmb3JtTWF0cml4Jykge1xuICAgICAgaWYgKHBhcmVudEF0dHJpYnV0ZXMgJiYgcGFyZW50QXR0cmlidXRlcy50cmFuc2Zvcm1NYXRyaXgpIHtcbiAgICAgICAgdmFsdWUgPSBtdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzKFxuICAgICAgICAgIHBhcmVudEF0dHJpYnV0ZXMudHJhbnNmb3JtTWF0cml4LCBmYWJyaWMucGFyc2VUcmFuc2Zvcm1BdHRyaWJ1dGUodmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGZhYnJpYy5wYXJzZVRyYW5zZm9ybUF0dHJpYnV0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICd2aXNpYmxlJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZSAhPT0gJ25vbmUnICYmIHZhbHVlICE9PSAnaGlkZGVuJztcbiAgICAgIC8vIGRpc3BsYXk9bm9uZSBvbiBwYXJlbnQgZWxlbWVudCBhbHdheXMgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGNoaWxkIGVsZW1lbnRcbiAgICAgIGlmIChwYXJlbnRBdHRyaWJ1dGVzICYmIHBhcmVudEF0dHJpYnV0ZXMudmlzaWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ29wYWNpdHknKSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgaWYgKHBhcmVudEF0dHJpYnV0ZXMgJiYgdHlwZW9mIHBhcmVudEF0dHJpYnV0ZXMub3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFsdWUgKj0gcGFyZW50QXR0cmlidXRlcy5vcGFjaXR5O1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhdHRyID09PSAndGV4dEFuY2hvcicgLyogdGV4dC1hbmNob3IgKi8pIHtcbiAgICAgIHZhbHVlID0gdmFsdWUgPT09ICdzdGFydCcgPyAnbGVmdCcgOiB2YWx1ZSA9PT0gJ2VuZCcgPyAncmlnaHQnIDogJ2NlbnRlcic7XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICdjaGFyU3BhY2luZycpIHtcbiAgICAgIC8vIHBhcnNlVW5pdCByZXR1cm5zIHB4IGFuZCB3ZSBjb252ZXJ0IGl0IHRvIGVtXG4gICAgICBwYXJzZWQgPSBwYXJzZVVuaXQodmFsdWUsIGZvbnRTaXplKSAvIGZvbnRTaXplICogMTAwMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXR0ciA9PT0gJ3BhaW50Rmlyc3QnKSB7XG4gICAgICB2YXIgZmlsbEluZGV4ID0gdmFsdWUuaW5kZXhPZignZmlsbCcpO1xuICAgICAgdmFyIHN0cm9rZUluZGV4ID0gdmFsdWUuaW5kZXhPZignc3Ryb2tlJyk7XG4gICAgICB2YXIgdmFsdWUgPSAnZmlsbCc7XG4gICAgICBpZiAoZmlsbEluZGV4ID4gLTEgJiYgc3Ryb2tlSW5kZXggPiAtMSAmJiBzdHJva2VJbmRleCA8IGZpbGxJbmRleCkge1xuICAgICAgICB2YWx1ZSA9ICdzdHJva2UnO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmlsbEluZGV4ID09PSAtMSAmJiBzdHJva2VJbmRleCA+IC0xKSB7XG4gICAgICAgIHZhbHVlID0gJ3N0cm9rZSc7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICdocmVmJyB8fCBhdHRyID09PSAneGxpbms6aHJlZicgfHwgYXR0ciA9PT0gJ2ZvbnQnKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGF0dHIgPT09ICdpbWFnZVNtb290aGluZycpIHtcbiAgICAgIHJldHVybiAodmFsdWUgPT09ICdvcHRpbWl6ZVF1YWxpdHknKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBwYXJzZWQgPSBpc0FycmF5ID8gdmFsdWUubWFwKHBhcnNlVW5pdCkgOiBwYXJzZVVuaXQodmFsdWUsIGZvbnRTaXplKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKCFpc0FycmF5ICYmIGlzTmFOKHBhcnNlZCkgPyB2YWx1ZSA6IHBhcnNlZCk7XG4gIH1cblxuICAvKipcbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgZnVuY3Rpb24gZ2V0U3ZnUmVnZXgoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoJ14oJyArIGFyci5qb2luKCd8JykgKyAnKVxcXFxiJywgJ2knKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlcyBBcnJheSBvZiBhdHRyaWJ1dGVzIHRvIHBhcnNlXG4gICAqL1xuICBmdW5jdGlvbiBfc2V0U3Ryb2tlRmlsbE9wYWNpdHkoYXR0cmlidXRlcykge1xuICAgIGZvciAodmFyIGF0dHIgaW4gY29sb3JBdHRyaWJ1dGVzKSB7XG5cbiAgICAgIGlmICh0eXBlb2YgYXR0cmlidXRlc1tjb2xvckF0dHJpYnV0ZXNbYXR0cl1dID09PSAndW5kZWZpbmVkJyB8fCBhdHRyaWJ1dGVzW2F0dHJdID09PSAnJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzW2F0dHJdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoIWZhYnJpYy5PYmplY3QucHJvdG90eXBlW2F0dHJdKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYXR0cmlidXRlc1thdHRyXSA9IGZhYnJpYy5PYmplY3QucHJvdG90eXBlW2F0dHJdO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXR0cmlidXRlc1thdHRyXS5pbmRleE9mKCd1cmwoJykgPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IoYXR0cmlidXRlc1thdHRyXSk7XG4gICAgICBhdHRyaWJ1dGVzW2F0dHJdID0gY29sb3Iuc2V0QWxwaGEodG9GaXhlZChjb2xvci5nZXRBbHBoYSgpICogYXR0cmlidXRlc1tjb2xvckF0dHJpYnV0ZXNbYXR0cl1dLCAyKSkudG9SZ2JhKCk7XG4gICAgfVxuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0TXVsdGlwbGVOb2Rlcyhkb2MsIG5vZGVOYW1lcykge1xuICAgIHZhciBub2RlTmFtZSwgbm9kZUFycmF5ID0gW10sIG5vZGVMaXN0LCBpLCBsZW47XG4gICAgZm9yIChpID0gMCwgbGVuID0gbm9kZU5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBub2RlTmFtZSA9IG5vZGVOYW1lc1tpXTtcbiAgICAgIG5vZGVMaXN0ID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKG5vZGVOYW1lKTtcbiAgICAgIG5vZGVBcnJheSA9IG5vZGVBcnJheS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobm9kZUxpc3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVBcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgXCJ0cmFuc2Zvcm1cIiBhdHRyaWJ1dGUsIHJldHVybmluZyBhbiBhcnJheSBvZiB2YWx1ZXNcbiAgICogQHN0YXRpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlVmFsdWUgU3RyaW5nIGNvbnRhaW5pbmcgYXR0cmlidXRlIHZhbHVlXG4gICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiA2IGVsZW1lbnRzIHJlcHJlc2VudGluZyB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcbiAgICovXG4gIGZhYnJpYy5wYXJzZVRyYW5zZm9ybUF0dHJpYnV0ZSA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiByb3RhdGVNYXRyaXgobWF0cml4LCBhcmdzKSB7XG4gICAgICB2YXIgY29zID0gZmFicmljLnV0aWwuY29zKGFyZ3NbMF0pLCBzaW4gPSBmYWJyaWMudXRpbC5zaW4oYXJnc1swXSksXG4gICAgICAgICAgeCA9IDAsIHkgPSAwO1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIHggPSBhcmdzWzFdO1xuICAgICAgICB5ID0gYXJnc1syXTtcbiAgICAgIH1cblxuICAgICAgbWF0cml4WzBdID0gY29zO1xuICAgICAgbWF0cml4WzFdID0gc2luO1xuICAgICAgbWF0cml4WzJdID0gLXNpbjtcbiAgICAgIG1hdHJpeFszXSA9IGNvcztcbiAgICAgIG1hdHJpeFs0XSA9IHggLSAoY29zICogeCAtIHNpbiAqIHkpO1xuICAgICAgbWF0cml4WzVdID0geSAtIChzaW4gKiB4ICsgY29zICogeSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhbGVNYXRyaXgobWF0cml4LCBhcmdzKSB7XG4gICAgICB2YXIgbXVsdGlwbGllclggPSBhcmdzWzBdLFxuICAgICAgICAgIG11bHRpcGxpZXJZID0gKGFyZ3MubGVuZ3RoID09PSAyKSA/IGFyZ3NbMV0gOiBhcmdzWzBdO1xuXG4gICAgICBtYXRyaXhbMF0gPSBtdWx0aXBsaWVyWDtcbiAgICAgIG1hdHJpeFszXSA9IG11bHRpcGxpZXJZO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNrZXdNYXRyaXgobWF0cml4LCBhcmdzLCBwb3MpIHtcbiAgICAgIG1hdHJpeFtwb3NdID0gTWF0aC50YW4oZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucyhhcmdzWzBdKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhbnNsYXRlTWF0cml4KG1hdHJpeCwgYXJncykge1xuICAgICAgbWF0cml4WzRdID0gYXJnc1swXTtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBtYXRyaXhbNV0gPSBhcmdzWzFdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlkZW50aXR5IG1hdHJpeFxuICAgIHZhciBpTWF0cml4ID0gZmFicmljLmlNYXRyaXgsXG5cbiAgICAgICAgLy8gPT0gYmVnaW4gdHJhbnNmb3JtIHJlZ2V4cFxuICAgICAgICBudW1iZXIgPSBmYWJyaWMucmVOdW0sXG5cbiAgICAgICAgY29tbWFXc3AgPSBmYWJyaWMuY29tbWFXc3AsXG5cbiAgICAgICAgc2tld1ggPSAnKD86KHNrZXdYKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKlxcXFwpKScsXG5cbiAgICAgICAgc2tld1kgPSAnKD86KHNrZXdZKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKlxcXFwpKScsXG5cbiAgICAgICAgcm90YXRlID0gJyg/Oihyb3RhdGUpXFxcXHMqXFxcXChcXFxccyooJyArIG51bWJlciArICcpKD86JyArXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hV3NwICsgJygnICsgbnVtYmVyICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFXc3AgKyAnKCcgKyBudW1iZXIgKyAnKSk/XFxcXHMqXFxcXCkpJyxcblxuICAgICAgICBzY2FsZSA9ICcoPzooc2NhbGUpXFxcXHMqXFxcXChcXFxccyooJyArIG51bWJlciArICcpKD86JyArXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hV3NwICsgJygnICsgbnVtYmVyICsgJykpP1xcXFxzKlxcXFwpKScsXG5cbiAgICAgICAgdHJhbnNsYXRlID0gJyg/Oih0cmFuc2xhdGUpXFxcXHMqXFxcXChcXFxccyooJyArIG51bWJlciArICcpKD86JyArXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hV3NwICsgJygnICsgbnVtYmVyICsgJykpP1xcXFxzKlxcXFwpKScsXG5cbiAgICAgICAgbWF0cml4ID0gJyg/OihtYXRyaXgpXFxcXHMqXFxcXChcXFxccyonICtcbiAgICAgICAgICAgICAgICAgICcoJyArIG51bWJlciArICcpJyArIGNvbW1hV3NwICtcbiAgICAgICAgICAgICAgICAgICcoJyArIG51bWJlciArICcpJyArIGNvbW1hV3NwICtcbiAgICAgICAgICAgICAgICAgICcoJyArIG51bWJlciArICcpJyArIGNvbW1hV3NwICtcbiAgICAgICAgICAgICAgICAgICcoJyArIG51bWJlciArICcpJyArIGNvbW1hV3NwICtcbiAgICAgICAgICAgICAgICAgICcoJyArIG51bWJlciArICcpJyArIGNvbW1hV3NwICtcbiAgICAgICAgICAgICAgICAgICcoJyArIG51bWJlciArICcpJyArXG4gICAgICAgICAgICAgICAgICAnXFxcXHMqXFxcXCkpJyxcblxuICAgICAgICB0cmFuc2Zvcm0gPSAnKD86JyArXG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeCArICd8JyArXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZSArICd8JyArXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlICsgJ3wnICtcbiAgICAgICAgICAgICAgICAgICAgcm90YXRlICsgJ3wnICtcbiAgICAgICAgICAgICAgICAgICAgc2tld1ggKyAnfCcgK1xuICAgICAgICAgICAgICAgICAgICBza2V3WSArXG4gICAgICAgICAgICAgICAgICAgICcpJyxcblxuICAgICAgICB0cmFuc2Zvcm1zID0gJyg/OicgKyB0cmFuc2Zvcm0gKyAnKD86JyArIGNvbW1hV3NwICsgJyonICsgdHJhbnNmb3JtICsgJykqJyArICcpJyxcblxuICAgICAgICB0cmFuc2Zvcm1MaXN0ID0gJ15cXFxccyooPzonICsgdHJhbnNmb3JtcyArICc/KVxcXFxzKiQnLFxuXG4gICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9jb29yZHMuaHRtbCNUcmFuc2Zvcm1BdHRyaWJ1dGVcbiAgICAgICAgcmVUcmFuc2Zvcm1MaXN0ID0gbmV3IFJlZ0V4cCh0cmFuc2Zvcm1MaXN0KSxcbiAgICAgICAgLy8gPT0gZW5kIHRyYW5zZm9ybSByZWdleHBcblxuICAgICAgICByZVRyYW5zZm9ybSA9IG5ldyBSZWdFeHAodHJhbnNmb3JtLCAnZycpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGF0dHJpYnV0ZVZhbHVlKSB7XG5cbiAgICAgIC8vIHN0YXJ0IHdpdGggaWRlbnRpdHkgbWF0cml4XG4gICAgICB2YXIgbWF0cml4ID0gaU1hdHJpeC5jb25jYXQoKSxcbiAgICAgICAgICBtYXRyaWNlcyA9IFtdO1xuXG4gICAgICAvLyByZXR1cm4gaWYgbm8gYXJndW1lbnQgd2FzIGdpdmVuIG9yXG4gICAgICAvLyBhbiBhcmd1bWVudCBkb2VzIG5vdCBtYXRjaCB0cmFuc2Zvcm0gYXR0cmlidXRlIHJlZ2V4cFxuICAgICAgaWYgKCFhdHRyaWJ1dGVWYWx1ZSB8fCAoYXR0cmlidXRlVmFsdWUgJiYgIXJlVHJhbnNmb3JtTGlzdC50ZXN0KGF0dHJpYnV0ZVZhbHVlKSkpIHtcbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICAgIH1cblxuICAgICAgYXR0cmlidXRlVmFsdWUucmVwbGFjZShyZVRyYW5zZm9ybSwgZnVuY3Rpb24obWF0Y2gpIHtcblxuICAgICAgICB2YXIgbSA9IG5ldyBSZWdFeHAodHJhbnNmb3JtKS5leGVjKG1hdGNoKS5maWx0ZXIoZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgIC8vIG1hdGNoICE9PSAnJyAmJiBtYXRjaCAhPSBudWxsXG4gICAgICAgICAgICAgIHJldHVybiAoISFtYXRjaCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IG1bMV0sXG4gICAgICAgICAgICBhcmdzID0gbS5zbGljZSgyKS5tYXAocGFyc2VGbG9hdCk7XG5cbiAgICAgICAgc3dpdGNoIChvcGVyYXRpb24pIHtcbiAgICAgICAgICBjYXNlICd0cmFuc2xhdGUnOlxuICAgICAgICAgICAgdHJhbnNsYXRlTWF0cml4KG1hdHJpeCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdyb3RhdGUnOlxuICAgICAgICAgICAgYXJnc1swXSA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMoYXJnc1swXSk7XG4gICAgICAgICAgICByb3RhdGVNYXRyaXgobWF0cml4LCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3NjYWxlJzpcbiAgICAgICAgICAgIHNjYWxlTWF0cml4KG1hdHJpeCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdza2V3WCc6XG4gICAgICAgICAgICBza2V3TWF0cml4KG1hdHJpeCwgYXJncywgMik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdza2V3WSc6XG4gICAgICAgICAgICBza2V3TWF0cml4KG1hdHJpeCwgYXJncywgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdtYXRyaXgnOlxuICAgICAgICAgICAgbWF0cml4ID0gYXJncztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc25hcHNob3QgY3VycmVudCBtYXRyaXggaW50byBtYXRyaWNlcyBhcnJheVxuICAgICAgICBtYXRyaWNlcy5wdXNoKG1hdHJpeC5jb25jYXQoKSk7XG4gICAgICAgIC8vIHJlc2V0XG4gICAgICAgIG1hdHJpeCA9IGlNYXRyaXguY29uY2F0KCk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGNvbWJpbmVkTWF0cml4ID0gbWF0cmljZXNbMF07XG4gICAgICB3aGlsZSAobWF0cmljZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBtYXRyaWNlcy5zaGlmdCgpO1xuICAgICAgICBjb21iaW5lZE1hdHJpeCA9IGZhYnJpYy51dGlsLm11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMoY29tYmluZWRNYXRyaXgsIG1hdHJpY2VzWzBdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21iaW5lZE1hdHJpeDtcbiAgICB9O1xuICB9KSgpO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VTdHlsZVN0cmluZyhzdHlsZSwgb1N0eWxlKSB7XG4gICAgdmFyIGF0dHIsIHZhbHVlO1xuICAgIHN0eWxlLnJlcGxhY2UoLztcXHMqJC8sICcnKS5zcGxpdCgnOycpLmZvckVhY2goZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICB2YXIgcGFpciA9IGNodW5rLnNwbGl0KCc6Jyk7XG5cbiAgICAgIGF0dHIgPSBwYWlyWzBdLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFsdWUgPSAgcGFpclsxXS50cmltKCk7XG5cbiAgICAgIG9TdHlsZVthdHRyXSA9IHZhbHVlO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZVN0eWxlT2JqZWN0KHN0eWxlLCBvU3R5bGUpIHtcbiAgICB2YXIgYXR0ciwgdmFsdWU7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgICAgaWYgKHR5cGVvZiBzdHlsZVtwcm9wXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGF0dHIgPSBwcm9wLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YWx1ZSA9IHN0eWxlW3Byb3BdO1xuXG4gICAgICBvU3R5bGVbYXR0cl0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGdldEdsb2JhbFN0eWxlc0ZvckVsZW1lbnQoZWxlbWVudCwgc3ZnVWlkKSB7XG4gICAgdmFyIHN0eWxlcyA9IHsgfTtcbiAgICBmb3IgKHZhciBydWxlIGluIGZhYnJpYy5jc3NSdWxlc1tzdmdVaWRdKSB7XG4gICAgICBpZiAoZWxlbWVudE1hdGNoZXNSdWxlKGVsZW1lbnQsIHJ1bGUuc3BsaXQoJyAnKSkpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gZmFicmljLmNzc1J1bGVzW3N2Z1VpZF1bcnVsZV0pIHtcbiAgICAgICAgICBzdHlsZXNbcHJvcGVydHldID0gZmFicmljLmNzc1J1bGVzW3N2Z1VpZF1bcnVsZV1bcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHlsZXM7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVzUnVsZShlbGVtZW50LCBzZWxlY3RvcnMpIHtcbiAgICB2YXIgZmlyc3RNYXRjaGluZywgcGFyZW50TWF0Y2hpbmcgPSB0cnVlO1xuICAgIC8vc3RhcnQgZnJvbSByaWdodG1vc3Qgc2VsZWN0b3IuXG4gICAgZmlyc3RNYXRjaGluZyA9IHNlbGVjdG9yTWF0Y2hlcyhlbGVtZW50LCBzZWxlY3RvcnMucG9wKCkpO1xuICAgIGlmIChmaXJzdE1hdGNoaW5nICYmIHNlbGVjdG9ycy5sZW5ndGgpIHtcbiAgICAgIHBhcmVudE1hdGNoaW5nID0gZG9lc1NvbWVQYXJlbnRNYXRjaChlbGVtZW50LCBzZWxlY3RvcnMpO1xuICAgIH1cbiAgICByZXR1cm4gZmlyc3RNYXRjaGluZyAmJiBwYXJlbnRNYXRjaGluZyAmJiAoc2VsZWN0b3JzLmxlbmd0aCA9PT0gMCk7XG4gIH1cblxuICBmdW5jdGlvbiBkb2VzU29tZVBhcmVudE1hdGNoKGVsZW1lbnQsIHNlbGVjdG9ycykge1xuICAgIHZhciBzZWxlY3RvciwgcGFyZW50TWF0Y2hpbmcgPSB0cnVlO1xuICAgIHdoaWxlIChlbGVtZW50LnBhcmVudE5vZGUgJiYgZWxlbWVudC5wYXJlbnROb2RlLm5vZGVUeXBlID09PSAxICYmIHNlbGVjdG9ycy5sZW5ndGgpIHtcbiAgICAgIGlmIChwYXJlbnRNYXRjaGluZykge1xuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9ycy5wb3AoKTtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICBwYXJlbnRNYXRjaGluZyA9IHNlbGVjdG9yTWF0Y2hlcyhlbGVtZW50LCBzZWxlY3Rvcik7XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RvcnMubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBzZWxlY3Rvck1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLFxuICAgICAgICBjbGFzc05hbWVzID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJyksXG4gICAgICAgIGlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lkJyksIG1hdGNoZXIsIGk7XG4gICAgLy8gaSBjaGVjayBpZiBhIHNlbGVjdG9yIG1hdGNoZXMgc2xpY2luZyBhd2F5IHBhcnQgZnJvbSBpdC5cbiAgICAvLyBpZiBpIGdldCBlbXB0eSBzdHJpbmcgaSBzaG91bGQgbWF0Y2hcbiAgICBtYXRjaGVyID0gbmV3IFJlZ0V4cCgnXicgKyBub2RlTmFtZSwgJ2knKTtcbiAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UobWF0Y2hlciwgJycpO1xuICAgIGlmIChpZCAmJiBzZWxlY3Rvci5sZW5ndGgpIHtcbiAgICAgIG1hdGNoZXIgPSBuZXcgUmVnRXhwKCcjJyArIGlkICsgJyg/IVthLXpBLVpcXFxcLV0rKScsICdpJyk7XG4gICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UobWF0Y2hlciwgJycpO1xuICAgIH1cbiAgICBpZiAoY2xhc3NOYW1lcyAmJiBzZWxlY3Rvci5sZW5ndGgpIHtcbiAgICAgIGNsYXNzTmFtZXMgPSBjbGFzc05hbWVzLnNwbGl0KCcgJyk7XG4gICAgICBmb3IgKGkgPSBjbGFzc05hbWVzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICBtYXRjaGVyID0gbmV3IFJlZ0V4cCgnXFxcXC4nICsgY2xhc3NOYW1lc1tpXSArICcoPyFbYS16QS1aXFxcXC1dKyknLCAnaScpO1xuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UobWF0Y2hlciwgJycpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0b3IubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHRvIHN1cHBvcnQgSUU4IG1pc3NpbmcgZ2V0RWxlbWVudEJ5SWQgb24gU1ZHZG9jdW1lbnQgYW5kIG9uIG5vZGUgeG1sRE9NXG4gICAqL1xuICBmdW5jdGlvbiBlbGVtZW50QnlJZChkb2MsIGlkKSB7XG4gICAgdmFyIGVsO1xuICAgIGRvYy5nZXRFbGVtZW50QnlJZCAmJiAoZWwgPSBkb2MuZ2V0RWxlbWVudEJ5SWQoaWQpKTtcbiAgICBpZiAoZWwpIHtcbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG4gICAgdmFyIG5vZGUsIGksIGxlbiwgbm9kZWxpc3QgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlbGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbm9kZSA9IG5vZGVsaXN0W2ldO1xuICAgICAgaWYgKGlkID09PSBub2RlLmdldEF0dHJpYnV0ZSgnaWQnKSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlVXNlRGlyZWN0aXZlcyhkb2MpIHtcbiAgICB2YXIgbm9kZWxpc3QgPSBfZ2V0TXVsdGlwbGVOb2Rlcyhkb2MsIFsndXNlJywgJ3N2Zzp1c2UnXSksIGkgPSAwO1xuICAgIHdoaWxlIChub2RlbGlzdC5sZW5ndGggJiYgaSA8IG5vZGVsaXN0Lmxlbmd0aCkge1xuICAgICAgdmFyIGVsID0gbm9kZWxpc3RbaV0sXG4gICAgICAgICAgeGxpbmtBdHRyaWJ1dGUgPSBlbC5nZXRBdHRyaWJ1dGUoJ3hsaW5rOmhyZWYnKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcblxuICAgICAgaWYgKHhsaW5rQXR0cmlidXRlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHhsaW5rID0geGxpbmtBdHRyaWJ1dGUuc2xpY2UoMSksXG4gICAgICAgICAgeCA9IGVsLmdldEF0dHJpYnV0ZSgneCcpIHx8IDAsXG4gICAgICAgICAgeSA9IGVsLmdldEF0dHJpYnV0ZSgneScpIHx8IDAsXG4gICAgICAgICAgZWwyID0gZWxlbWVudEJ5SWQoZG9jLCB4bGluaykuY2xvbmVOb2RlKHRydWUpLFxuICAgICAgICAgIGN1cnJlbnRUcmFucyA9IChlbDIuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKSB8fCAnJykgKyAnIHRyYW5zbGF0ZSgnICsgeCArICcsICcgKyB5ICsgJyknLFxuICAgICAgICAgIHBhcmVudE5vZGUsXG4gICAgICAgICAgb2xkTGVuZ3RoID0gbm9kZWxpc3QubGVuZ3RoLCBhdHRyLFxuICAgICAgICAgIGosXG4gICAgICAgICAgYXR0cnMsXG4gICAgICAgICAgbGVuLFxuICAgICAgICAgIG5hbWVzcGFjZSA9IGZhYnJpYy5zdmdOUztcblxuICAgICAgYXBwbHlWaWV3Ym94VHJhbnNmb3JtKGVsMik7XG4gICAgICBpZiAoL15zdmckL2kudGVzdChlbDIubm9kZU5hbWUpKSB7XG4gICAgICAgIHZhciBlbDMgPSBlbDIub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlLCAnZycpO1xuICAgICAgICBmb3IgKGogPSAwLCBhdHRycyA9IGVsMi5hdHRyaWJ1dGVzLCBsZW4gPSBhdHRycy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgIGF0dHIgPSBhdHRycy5pdGVtKGopO1xuICAgICAgICAgIGVsMy5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIGF0dHIubm9kZU5hbWUsIGF0dHIubm9kZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbDIuZmlyc3RDaGlsZCAhPSBudWxsXG4gICAgICAgIHdoaWxlIChlbDIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGVsMy5hcHBlbmRDaGlsZChlbDIuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWwyID0gZWwzO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGogPSAwLCBhdHRycyA9IGVsLmF0dHJpYnV0ZXMsIGxlbiA9IGF0dHJzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIGF0dHIgPSBhdHRycy5pdGVtKGopO1xuICAgICAgICBpZiAoYXR0ci5ub2RlTmFtZSA9PT0gJ3gnIHx8IGF0dHIubm9kZU5hbWUgPT09ICd5JyB8fFxuICAgICAgICAgIGF0dHIubm9kZU5hbWUgPT09ICd4bGluazpocmVmJyB8fCBhdHRyLm5vZGVOYW1lID09PSAnaHJlZicpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdHRyLm5vZGVOYW1lID09PSAndHJhbnNmb3JtJykge1xuICAgICAgICAgIGN1cnJlbnRUcmFucyA9IGF0dHIubm9kZVZhbHVlICsgJyAnICsgY3VycmVudFRyYW5zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGVsMi5zZXRBdHRyaWJ1dGUoYXR0ci5ub2RlTmFtZSwgYXR0ci5ub2RlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVsMi5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIGN1cnJlbnRUcmFucyk7XG4gICAgICBlbDIuc2V0QXR0cmlidXRlKCdpbnN0YW50aWF0ZWRfYnlfdXNlJywgJzEnKTtcbiAgICAgIGVsMi5yZW1vdmVBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICBwYXJlbnROb2RlID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIHBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGVsMiwgZWwpO1xuICAgICAgLy8gc29tZSBicm93c2VycyBkbyBub3Qgc2hvcnRlbiBub2RlbGlzdCBhZnRlciByZXBsYWNlQ2hpbGQgKElFOClcbiAgICAgIGlmIChub2RlbGlzdC5sZW5ndGggPT09IG9sZExlbmd0aCkge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2Nvb3Jkcy5odG1sI1ZpZXdCb3hBdHRyaWJ1dGVcbiAgLy8gbWF0Y2hlcywgZS5nLjogKzE0LjU2ZS0xMiwgZXRjLlxuICB2YXIgcmVWaWV3Qm94QXR0clZhbHVlID0gbmV3IFJlZ0V4cChcbiAgICAnXicgK1xuICAgICdcXFxccyooJyArIGZhYnJpYy5yZU51bSArICcrKVxcXFxzKiw/JyArXG4gICAgJ1xcXFxzKignICsgZmFicmljLnJlTnVtICsgJyspXFxcXHMqLD8nICtcbiAgICAnXFxcXHMqKCcgKyBmYWJyaWMucmVOdW0gKyAnKylcXFxccyosPycgK1xuICAgICdcXFxccyooJyArIGZhYnJpYy5yZU51bSArICcrKVxcXFxzKicgK1xuICAgICckJ1xuICApO1xuXG4gIC8qKlxuICAgKiBBZGQgYSA8Zz4gZWxlbWVudCB0aGF0IGVudmVsb3AgYWxsIGNoaWxkIGVsZW1lbnRzIGFuZCBtYWtlcyB0aGUgdmlld2JveCB0cmFuc2Zvcm1NYXRyaXggZGVzY2VuZCBvbiBhbGwgZWxlbWVudHNcbiAgICovXG4gIGZ1bmN0aW9uIGFwcGx5Vmlld2JveFRyYW5zZm9ybShlbGVtZW50KSB7XG4gICAgaWYgKCFmYWJyaWMuc3ZnVmlld0JveEVsZW1lbnRzUmVnRXgudGVzdChlbGVtZW50Lm5vZGVOYW1lKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICB2YXIgdmlld0JveEF0dHIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndmlld0JveCcpLFxuICAgICAgICBzY2FsZVggPSAxLFxuICAgICAgICBzY2FsZVkgPSAxLFxuICAgICAgICBtaW5YID0gMCxcbiAgICAgICAgbWluWSA9IDAsXG4gICAgICAgIHZpZXdCb3hXaWR0aCwgdmlld0JveEhlaWdodCwgbWF0cml4LCBlbCxcbiAgICAgICAgd2lkdGhBdHRyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyksXG4gICAgICAgIGhlaWdodEF0dHIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaGVpZ2h0JyksXG4gICAgICAgIHggPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgneCcpIHx8IDAsXG4gICAgICAgIHkgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgneScpIHx8IDAsXG4gICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW8gPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycpIHx8ICcnLFxuICAgICAgICBtaXNzaW5nVmlld0JveCA9ICghdmlld0JveEF0dHIgfHwgISh2aWV3Qm94QXR0ciA9IHZpZXdCb3hBdHRyLm1hdGNoKHJlVmlld0JveEF0dHJWYWx1ZSkpKSxcbiAgICAgICAgbWlzc2luZ0RpbUF0dHIgPSAoIXdpZHRoQXR0ciB8fCAhaGVpZ2h0QXR0ciB8fCB3aWR0aEF0dHIgPT09ICcxMDAlJyB8fCBoZWlnaHRBdHRyID09PSAnMTAwJScpLFxuICAgICAgICB0b0JlUGFyc2VkID0gbWlzc2luZ1ZpZXdCb3ggJiYgbWlzc2luZ0RpbUF0dHIsXG4gICAgICAgIHBhcnNlZERpbSA9IHsgfSwgdHJhbnNsYXRlTWF0cml4ID0gJycsIHdpZHRoRGlmZiA9IDAsIGhlaWdodERpZmYgPSAwO1xuXG4gICAgcGFyc2VkRGltLndpZHRoID0gMDtcbiAgICBwYXJzZWREaW0uaGVpZ2h0ID0gMDtcbiAgICBwYXJzZWREaW0udG9CZVBhcnNlZCA9IHRvQmVQYXJzZWQ7XG5cbiAgICBpZiAobWlzc2luZ1ZpZXdCb3gpIHtcbiAgICAgIGlmICgoKHggfHwgeSkgJiYgZWxlbWVudC5wYXJlbnROb2RlICYmIGVsZW1lbnQucGFyZW50Tm9kZS5ub2RlTmFtZSAhPT0gJyNkb2N1bWVudCcpKSB7XG4gICAgICAgIHRyYW5zbGF0ZU1hdHJpeCA9ICcgdHJhbnNsYXRlKCcgKyBwYXJzZVVuaXQoeCkgKyAnICcgKyBwYXJzZVVuaXQoeSkgKyAnKSAnO1xuICAgICAgICBtYXRyaXggPSAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpIHx8ICcnKSArIHRyYW5zbGF0ZU1hdHJpeDtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIG1hdHJpeCk7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd4Jyk7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd5Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRvQmVQYXJzZWQpIHtcbiAgICAgIHJldHVybiBwYXJzZWREaW07XG4gICAgfVxuXG4gICAgaWYgKG1pc3NpbmdWaWV3Qm94KSB7XG4gICAgICBwYXJzZWREaW0ud2lkdGggPSBwYXJzZVVuaXQod2lkdGhBdHRyKTtcbiAgICAgIHBhcnNlZERpbS5oZWlnaHQgPSBwYXJzZVVuaXQoaGVpZ2h0QXR0cik7XG4gICAgICAvLyBzZXQgYSB0cmFuc2Zvcm0gZm9yIGVsZW1lbnRzIHRoYXQgaGF2ZSB4IHkgYW5kIGFyZSBpbm5lcihvbmx5KSBTVkdzXG4gICAgICByZXR1cm4gcGFyc2VkRGltO1xuICAgIH1cbiAgICBtaW5YID0gLXBhcnNlRmxvYXQodmlld0JveEF0dHJbMV0pO1xuICAgIG1pblkgPSAtcGFyc2VGbG9hdCh2aWV3Qm94QXR0clsyXSk7XG4gICAgdmlld0JveFdpZHRoID0gcGFyc2VGbG9hdCh2aWV3Qm94QXR0clszXSk7XG4gICAgdmlld0JveEhlaWdodCA9IHBhcnNlRmxvYXQodmlld0JveEF0dHJbNF0pO1xuICAgIHBhcnNlZERpbS5taW5YID0gbWluWDtcbiAgICBwYXJzZWREaW0ubWluWSA9IG1pblk7XG4gICAgcGFyc2VkRGltLnZpZXdCb3hXaWR0aCA9IHZpZXdCb3hXaWR0aDtcbiAgICBwYXJzZWREaW0udmlld0JveEhlaWdodCA9IHZpZXdCb3hIZWlnaHQ7XG4gICAgaWYgKCFtaXNzaW5nRGltQXR0cikge1xuICAgICAgcGFyc2VkRGltLndpZHRoID0gcGFyc2VVbml0KHdpZHRoQXR0cik7XG4gICAgICBwYXJzZWREaW0uaGVpZ2h0ID0gcGFyc2VVbml0KGhlaWdodEF0dHIpO1xuICAgICAgc2NhbGVYID0gcGFyc2VkRGltLndpZHRoIC8gdmlld0JveFdpZHRoO1xuICAgICAgc2NhbGVZID0gcGFyc2VkRGltLmhlaWdodCAvIHZpZXdCb3hIZWlnaHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcGFyc2VkRGltLndpZHRoID0gdmlld0JveFdpZHRoO1xuICAgICAgcGFyc2VkRGltLmhlaWdodCA9IHZpZXdCb3hIZWlnaHQ7XG4gICAgfVxuXG4gICAgLy8gZGVmYXVsdCBpcyB0byBwcmVzZXJ2ZSBhc3BlY3QgcmF0aW9cbiAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvID0gZmFicmljLnV0aWwucGFyc2VQcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0cmlidXRlKHByZXNlcnZlQXNwZWN0UmF0aW8pO1xuICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvLmFsaWduWCAhPT0gJ25vbmUnKSB7XG4gICAgICAvL3RyYW5zbGF0ZSBhbGwgY29udGFpbmVyIGZvciB0aGUgZWZmZWN0IG9mIE1pZCwgTWluLCBNYXhcbiAgICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvLm1lZXRPclNsaWNlID09PSAnbWVldCcpIHtcbiAgICAgICAgc2NhbGVZID0gc2NhbGVYID0gKHNjYWxlWCA+IHNjYWxlWSA/IHNjYWxlWSA6IHNjYWxlWCk7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSBhZGRpdGlvbmFsIHRyYW5zbGF0aW9uIHRvIG1vdmUgdGhlIHZpZXdib3hcbiAgICAgIH1cbiAgICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvLm1lZXRPclNsaWNlID09PSAnc2xpY2UnKSB7XG4gICAgICAgIHNjYWxlWSA9IHNjYWxlWCA9IChzY2FsZVggPiBzY2FsZVkgPyBzY2FsZVggOiBzY2FsZVkpO1xuICAgICAgICAvLyBjYWxjdWxhdGUgYWRkaXRpb25hbCB0cmFuc2xhdGlvbiB0byBtb3ZlIHRoZSB2aWV3Ym94XG4gICAgICB9XG4gICAgICB3aWR0aERpZmYgPSBwYXJzZWREaW0ud2lkdGggLSB2aWV3Qm94V2lkdGggKiBzY2FsZVg7XG4gICAgICBoZWlnaHREaWZmID0gcGFyc2VkRGltLmhlaWdodCAtIHZpZXdCb3hIZWlnaHQgKiBzY2FsZVg7XG4gICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpby5hbGlnblggPT09ICdNaWQnKSB7XG4gICAgICAgIHdpZHRoRGlmZiAvPSAyO1xuICAgICAgfVxuICAgICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW8uYWxpZ25ZID09PSAnTWlkJykge1xuICAgICAgICBoZWlnaHREaWZmIC89IDI7XG4gICAgICB9XG4gICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpby5hbGlnblggPT09ICdNaW4nKSB7XG4gICAgICAgIHdpZHRoRGlmZiA9IDA7XG4gICAgICB9XG4gICAgICBpZiAocHJlc2VydmVBc3BlY3RSYXRpby5hbGlnblkgPT09ICdNaW4nKSB7XG4gICAgICAgIGhlaWdodERpZmYgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzY2FsZVggPT09IDEgJiYgc2NhbGVZID09PSAxICYmIG1pblggPT09IDAgJiYgbWluWSA9PT0gMCAmJiB4ID09PSAwICYmIHkgPT09IDApIHtcbiAgICAgIHJldHVybiBwYXJzZWREaW07XG4gICAgfVxuICAgIGlmICgoeCB8fCB5KSAmJiBlbGVtZW50LnBhcmVudE5vZGUubm9kZU5hbWUgIT09ICcjZG9jdW1lbnQnKSB7XG4gICAgICB0cmFuc2xhdGVNYXRyaXggPSAnIHRyYW5zbGF0ZSgnICsgcGFyc2VVbml0KHgpICsgJyAnICsgcGFyc2VVbml0KHkpICsgJykgJztcbiAgICB9XG5cbiAgICBtYXRyaXggPSB0cmFuc2xhdGVNYXRyaXggKyAnIG1hdHJpeCgnICsgc2NhbGVYICtcbiAgICAgICAgICAgICAgICAgICcgMCcgK1xuICAgICAgICAgICAgICAgICAgJyAwICcgK1xuICAgICAgICAgICAgICAgICAgc2NhbGVZICsgJyAnICtcbiAgICAgICAgICAgICAgICAgIChtaW5YICogc2NhbGVYICsgd2lkdGhEaWZmKSArICcgJyArXG4gICAgICAgICAgICAgICAgICAobWluWSAqIHNjYWxlWSArIGhlaWdodERpZmYpICsgJykgJztcbiAgICAvLyBzZWVtcyB1bnVzZWQuXG4gICAgLy8gcGFyc2VkRGltLnZpZXdib3hUcmFuc2Zvcm0gPSBmYWJyaWMucGFyc2VUcmFuc2Zvcm1BdHRyaWJ1dGUobWF0cml4KTtcbiAgICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ3N2ZycpIHtcbiAgICAgIGVsID0gZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhmYWJyaWMuc3ZnTlMsICdnJyk7XG4gICAgICAvLyBlbGVtZW50LmZpcnN0Q2hpbGQgIT0gbnVsbFxuICAgICAgd2hpbGUgKGVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgICBlbC5hcHBlbmRDaGlsZChlbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChlbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZWwgPSBlbGVtZW50O1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCd4Jyk7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3knKTtcbiAgICAgIG1hdHJpeCA9IGVsLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJykgKyBtYXRyaXg7XG4gICAgfVxuICAgIGVsLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgbWF0cml4KTtcbiAgICByZXR1cm4gcGFyc2VkRGltO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzQW5jZXN0b3JXaXRoTm9kZU5hbWUoZWxlbWVudCwgbm9kZU5hbWUpIHtcbiAgICB3aGlsZSAoZWxlbWVudCAmJiAoZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZSkpIHtcbiAgICAgIGlmIChlbGVtZW50Lm5vZGVOYW1lICYmIG5vZGVOYW1lLnRlc3QoZWxlbWVudC5ub2RlTmFtZS5yZXBsYWNlKCdzdmc6JywgJycpKVxuICAgICAgICAmJiAhZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2luc3RhbnRpYXRlZF9ieV91c2UnKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBTVkcgZG9jdW1lbnQsIGNvbnZlcnRzIGl0IHRvIGFuIGFycmF5IG9mIGNvcnJlc3BvbmRpbmcgZmFicmljLiogaW5zdGFuY2VzIGFuZCBwYXNzZXMgdGhlbSB0byBhIGNhbGxiYWNrXG4gICAqIEBzdGF0aWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICogQHBhcmFtIHtTVkdEb2N1bWVudH0gZG9jIFNWRyBkb2N1bWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBjYWxsIHdoZW4gcGFyc2luZyBpcyBmaW5pc2hlZDtcbiAgICogSXQncyBiZWluZyBwYXNzZWQgYW4gYXJyYXkgb2YgZWxlbWVudHMgKHBhcnNlZCBmcm9tIGEgZG9jdW1lbnQpLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2YgU1ZHIGVsZW1lbnRzLCBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyc2luZ09wdGlvbnNdIG9wdGlvbnMgZm9yIHBhcnNpbmcgZG9jdW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtwYXJzaW5nT3B0aW9ucy5jcm9zc09yaWdpbl0gY3Jvc3NPcmlnaW4gc2V0dGluZ3NcbiAgICovXG4gIGZhYnJpYy5wYXJzZVNWR0RvY3VtZW50ID0gZnVuY3Rpb24oZG9jLCBjYWxsYmFjaywgcmV2aXZlciwgcGFyc2luZ09wdGlvbnMpIHtcbiAgICBpZiAoIWRvYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBhcnNlVXNlRGlyZWN0aXZlcyhkb2MpO1xuXG4gICAgdmFyIHN2Z1VpZCA9ICBmYWJyaWMuT2JqZWN0Ll9fdWlkKyssIGksIGxlbixcbiAgICAgICAgb3B0aW9ucyA9IGFwcGx5Vmlld2JveFRyYW5zZm9ybShkb2MpLFxuICAgICAgICBkZXNjZW5kYW50cyA9IGZhYnJpYy51dGlsLnRvQXJyYXkoZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJykpO1xuICAgIG9wdGlvbnMuY3Jvc3NPcmlnaW4gPSBwYXJzaW5nT3B0aW9ucyAmJiBwYXJzaW5nT3B0aW9ucy5jcm9zc09yaWdpbjtcbiAgICBvcHRpb25zLnN2Z1VpZCA9IHN2Z1VpZDtcblxuICAgIGlmIChkZXNjZW5kYW50cy5sZW5ndGggPT09IDAgJiYgZmFicmljLmlzTGlrZWx5Tm9kZSkge1xuICAgICAgLy8gd2UncmUgbGlrZWx5IGluIG5vZGUsIHdoZXJlIFwibzMteG1sXCIgbGlicmFyeSBmYWlscyB0byBnRUJUTihcIipcIilcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hamF4b3JnL25vZGUtbzMteG1sL2lzc3Vlcy8yMVxuICAgICAgZGVzY2VuZGFudHMgPSBkb2Muc2VsZWN0Tm9kZXMoJy8vKltuYW1lKC4pIT1cInN2Z1wiXScpO1xuICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gZGVzY2VuZGFudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gZGVzY2VuZGFudHNbaV07XG4gICAgICB9XG4gICAgICBkZXNjZW5kYW50cyA9IGFycjtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudHMgPSBkZXNjZW5kYW50cy5maWx0ZXIoZnVuY3Rpb24oZWwpIHtcbiAgICAgIGFwcGx5Vmlld2JveFRyYW5zZm9ybShlbCk7XG4gICAgICByZXR1cm4gZmFicmljLnN2Z1ZhbGlkVGFnTmFtZXNSZWdFeC50ZXN0KGVsLm5vZGVOYW1lLnJlcGxhY2UoJ3N2ZzonLCAnJykpICYmXG4gICAgICAgICAgICAhaGFzQW5jZXN0b3JXaXRoTm9kZU5hbWUoZWwsIGZhYnJpYy5zdmdJbnZhbGlkQW5jZXN0b3JzUmVnRXgpOyAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc3RydWN0Lmh0bWwjRGVmc0VsZW1lbnRcbiAgICB9KTtcbiAgICBpZiAoIWVsZW1lbnRzIHx8IChlbGVtZW50cyAmJiAhZWxlbWVudHMubGVuZ3RoKSkge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soW10sIHt9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNsaXBQYXRocyA9IHsgfTtcbiAgICBkZXNjZW5kYW50cy5maWx0ZXIoZnVuY3Rpb24oZWwpIHtcbiAgICAgIHJldHVybiBlbC5ub2RlTmFtZS5yZXBsYWNlKCdzdmc6JywgJycpID09PSAnY2xpcFBhdGgnO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24oZWwpIHtcbiAgICAgIHZhciBpZCA9IGVsLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgIGNsaXBQYXRoc1tpZF0gPSBmYWJyaWMudXRpbC50b0FycmF5KGVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJykpLmZpbHRlcihmdW5jdGlvbihlbCkge1xuICAgICAgICByZXR1cm4gZmFicmljLnN2Z1ZhbGlkVGFnTmFtZXNSZWdFeC50ZXN0KGVsLm5vZGVOYW1lLnJlcGxhY2UoJ3N2ZzonLCAnJykpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZmFicmljLmdyYWRpZW50RGVmc1tzdmdVaWRdID0gZmFicmljLmdldEdyYWRpZW50RGVmcyhkb2MpO1xuICAgIGZhYnJpYy5jc3NSdWxlc1tzdmdVaWRdID0gZmFicmljLmdldENTU1J1bGVzKGRvYyk7XG4gICAgZmFicmljLmNsaXBQYXRoc1tzdmdVaWRdID0gY2xpcFBhdGhzO1xuICAgIC8vIFByZWNlZGVuY2Ugb2YgcnVsZXM6ICAgc3R5bGUgPiBjbGFzcyA+IGF0dHJpYnV0ZVxuICAgIGZhYnJpYy5wYXJzZUVsZW1lbnRzKGVsZW1lbnRzLCBmdW5jdGlvbihpbnN0YW5jZXMsIGVsZW1lbnRzKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soaW5zdGFuY2VzLCBvcHRpb25zLCBlbGVtZW50cywgZGVzY2VuZGFudHMpO1xuICAgICAgICBkZWxldGUgZmFicmljLmdyYWRpZW50RGVmc1tzdmdVaWRdO1xuICAgICAgICBkZWxldGUgZmFicmljLmNzc1J1bGVzW3N2Z1VpZF07XG4gICAgICAgIGRlbGV0ZSBmYWJyaWMuY2xpcFBhdGhzW3N2Z1VpZF07XG4gICAgICB9XG4gICAgfSwgY2xvbmUob3B0aW9ucyksIHJldml2ZXIsIHBhcnNpbmdPcHRpb25zKTtcbiAgfTtcblxuICBmdW5jdGlvbiByZWN1cnNpdmVseVBhcnNlR3JhZGllbnRzWGxpbmsoZG9jLCBncmFkaWVudCkge1xuICAgIHZhciBncmFkaWVudHNBdHRycyA9IFsnZ3JhZGllbnRUcmFuc2Zvcm0nLCAneDEnLCAneDInLCAneTEnLCAneTInLCAnZ3JhZGllbnRVbml0cycsICdjeCcsICdjeScsICdyJywgJ2Z4JywgJ2Z5J10sXG4gICAgICAgIHhsaW5rQXR0ciA9ICd4bGluazpocmVmJyxcbiAgICAgICAgeExpbmsgPSBncmFkaWVudC5nZXRBdHRyaWJ1dGUoeGxpbmtBdHRyKS5zbGljZSgxKSxcbiAgICAgICAgcmVmZXJlbmNlZEdyYWRpZW50ID0gZWxlbWVudEJ5SWQoZG9jLCB4TGluayk7XG4gICAgaWYgKHJlZmVyZW5jZWRHcmFkaWVudCAmJiByZWZlcmVuY2VkR3JhZGllbnQuZ2V0QXR0cmlidXRlKHhsaW5rQXR0cikpIHtcbiAgICAgIHJlY3Vyc2l2ZWx5UGFyc2VHcmFkaWVudHNYbGluayhkb2MsIHJlZmVyZW5jZWRHcmFkaWVudCk7XG4gICAgfVxuICAgIGdyYWRpZW50c0F0dHJzLmZvckVhY2goZnVuY3Rpb24oYXR0cikge1xuICAgICAgaWYgKHJlZmVyZW5jZWRHcmFkaWVudCAmJiAhZ3JhZGllbnQuaGFzQXR0cmlidXRlKGF0dHIpICYmIHJlZmVyZW5jZWRHcmFkaWVudC5oYXNBdHRyaWJ1dGUoYXR0cikpIHtcbiAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlKGF0dHIsIHJlZmVyZW5jZWRHcmFkaWVudC5nZXRBdHRyaWJ1dGUoYXR0cikpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghZ3JhZGllbnQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB2YXIgcmVmZXJlbmNlQ2xvbmUgPSByZWZlcmVuY2VkR3JhZGllbnQuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgd2hpbGUgKHJlZmVyZW5jZUNsb25lLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZ3JhZGllbnQuYXBwZW5kQ2hpbGQocmVmZXJlbmNlQ2xvbmUuZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGdyYWRpZW50LnJlbW92ZUF0dHJpYnV0ZSh4bGlua0F0dHIpO1xuICB9XG5cbiAgdmFyIHJlRm9udERlY2xhcmF0aW9uID0gbmV3IFJlZ0V4cChcbiAgICAnKG5vcm1hbHxpdGFsaWMpP1xcXFxzKihub3JtYWx8c21hbGwtY2Fwcyk/XFxcXHMqJyArXG4gICAgJyhub3JtYWx8Ym9sZHxib2xkZXJ8bGlnaHRlcnwxMDB8MjAwfDMwMHw0MDB8NTAwfDYwMHw3MDB8ODAwfDkwMCk/XFxcXHMqKCcgK1xuICAgICAgZmFicmljLnJlTnVtICtcbiAgICAnKD86cHh8Y218bW18ZW18cHR8cGN8aW4pKikoPzpcXFxcLyhub3JtYWx8JyArIGZhYnJpYy5yZU51bSArICcpKT9cXFxccysoLiopJyk7XG5cbiAgZXh0ZW5kKGZhYnJpYywge1xuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIHNob3J0IGZvbnQgZGVjbGFyYXRpb24sIGJ1aWxkaW5nIGFkZGluZyBpdHMgcHJvcGVydGllcyB0byBhIHN0eWxlIG9iamVjdFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIGZvbnQgZGVjbGFyYXRpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb1N0eWxlIGRlZmluaXRpb25cbiAgICAgKi9cbiAgICBwYXJzZUZvbnREZWNsYXJhdGlvbjogZnVuY3Rpb24odmFsdWUsIG9TdHlsZSkge1xuICAgICAgdmFyIG1hdGNoID0gdmFsdWUubWF0Y2gocmVGb250RGVjbGFyYXRpb24pO1xuXG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBmb250U3R5bGUgPSBtYXRjaFsxXSxcbiAgICAgICAgICAvLyBmb250IHZhcmlhbnQgaXMgbm90IHVzZWRcbiAgICAgICAgICAvLyBmb250VmFyaWFudCA9IG1hdGNoWzJdLFxuICAgICAgICAgIGZvbnRXZWlnaHQgPSBtYXRjaFszXSxcbiAgICAgICAgICBmb250U2l6ZSA9IG1hdGNoWzRdLFxuICAgICAgICAgIGxpbmVIZWlnaHQgPSBtYXRjaFs1XSxcbiAgICAgICAgICBmb250RmFtaWx5ID0gbWF0Y2hbNl07XG5cbiAgICAgIGlmIChmb250U3R5bGUpIHtcbiAgICAgICAgb1N0eWxlLmZvbnRTdHlsZSA9IGZvbnRTdHlsZTtcbiAgICAgIH1cbiAgICAgIGlmIChmb250V2VpZ2h0KSB7XG4gICAgICAgIG9TdHlsZS5mb250V2VpZ2h0ID0gaXNOYU4ocGFyc2VGbG9hdChmb250V2VpZ2h0KSkgPyBmb250V2VpZ2h0IDogcGFyc2VGbG9hdChmb250V2VpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGlmIChmb250U2l6ZSkge1xuICAgICAgICBvU3R5bGUuZm9udFNpemUgPSBwYXJzZVVuaXQoZm9udFNpemUpO1xuICAgICAgfVxuICAgICAgaWYgKGZvbnRGYW1pbHkpIHtcbiAgICAgICAgb1N0eWxlLmZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVIZWlnaHQpIHtcbiAgICAgICAgb1N0eWxlLmxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0ID09PSAnbm9ybWFsJyA/IDEgOiBsaW5lSGVpZ2h0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYW4gU1ZHIGRvY3VtZW50LCByZXR1cm5pbmcgYWxsIG9mIHRoZSBncmFkaWVudCBkZWNsYXJhdGlvbnMgZm91bmQgaW4gaXRcbiAgICAgKiBAc3RhdGljXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7U1ZHRG9jdW1lbnR9IGRvYyBTVkcgZG9jdW1lbnQgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEdyYWRpZW50IGRlZmluaXRpb25zOyBrZXkgY29ycmVzcG9uZHMgdG8gZWxlbWVudCBpZCwgdmFsdWUgLS0gdG8gZ3JhZGllbnQgZGVmaW5pdGlvbiBlbGVtZW50XG4gICAgICovXG4gICAgZ2V0R3JhZGllbnREZWZzOiBmdW5jdGlvbihkb2MpIHtcbiAgICAgIHZhciB0YWdBcnJheSA9IFtcbiAgICAgICAgICAgICdsaW5lYXJHcmFkaWVudCcsXG4gICAgICAgICAgICAncmFkaWFsR3JhZGllbnQnLFxuICAgICAgICAgICAgJ3N2ZzpsaW5lYXJHcmFkaWVudCcsXG4gICAgICAgICAgICAnc3ZnOnJhZGlhbEdyYWRpZW50J10sXG4gICAgICAgICAgZWxMaXN0ID0gX2dldE11bHRpcGxlTm9kZXMoZG9jLCB0YWdBcnJheSksXG4gICAgICAgICAgZWwsIGogPSAwLCBncmFkaWVudERlZnMgPSB7IH07XG4gICAgICBqID0gZWxMaXN0Lmxlbmd0aDtcbiAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgZWwgPSBlbExpc3Rbal07XG4gICAgICAgIGlmIChlbC5nZXRBdHRyaWJ1dGUoJ3hsaW5rOmhyZWYnKSkge1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5UGFyc2VHcmFkaWVudHNYbGluayhkb2MsIGVsKTtcbiAgICAgICAgfVxuICAgICAgICBncmFkaWVudERlZnNbZWwuZ2V0QXR0cmlidXRlKCdpZCcpXSA9IGVsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdyYWRpZW50RGVmcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBvYmplY3Qgb2YgYXR0cmlidXRlcycgbmFtZS92YWx1ZSwgZ2l2ZW4gZWxlbWVudCBhbmQgYW4gYXJyYXkgb2YgYXR0cmlidXRlIG5hbWVzO1xuICAgICAqIFBhcnNlcyBwYXJlbnQgXCJnXCIgbm9kZXMgcmVjdXJzaXZlbHkgdXB3YXJkcy5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXR0cmlidXRlcyBBcnJheSBvZiBhdHRyaWJ1dGVzIHRvIHBhcnNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyBwYXJzZWQgYXR0cmlidXRlcycgbmFtZXMvdmFsdWVzXG4gICAgICovXG4gICAgcGFyc2VBdHRyaWJ1dGVzOiBmdW5jdGlvbihlbGVtZW50LCBhdHRyaWJ1dGVzLCBzdmdVaWQpIHtcblxuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlLFxuICAgICAgICAgIHBhcmVudEF0dHJpYnV0ZXMgPSB7IH0sXG4gICAgICAgICAgZm9udFNpemUsIHBhcmVudEZvbnRTaXplO1xuXG4gICAgICBpZiAodHlwZW9mIHN2Z1VpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc3ZnVWlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N2Z1VpZCcpO1xuICAgICAgfVxuICAgICAgLy8gaWYgdGhlcmUncyBhIHBhcmVudCBjb250YWluZXIgKGBnYCBvciBgYWAgb3IgYHN5bWJvbGAgbm9kZSksIHBhcnNlIGl0cyBhdHRyaWJ1dGVzIHJlY3Vyc2l2ZWx5IHVwd2FyZHNcbiAgICAgIGlmIChlbGVtZW50LnBhcmVudE5vZGUgJiYgZmFicmljLnN2Z1ZhbGlkUGFyZW50c1JlZ0V4LnRlc3QoZWxlbWVudC5wYXJlbnROb2RlLm5vZGVOYW1lKSkge1xuICAgICAgICBwYXJlbnRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LnBhcmVudE5vZGUsIGF0dHJpYnV0ZXMsIHN2Z1VpZCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBvd25BdHRyaWJ1dGVzID0gYXR0cmlidXRlcy5yZWR1Y2UoZnVuY3Rpb24obWVtbywgYXR0cikge1xuICAgICAgICB2YWx1ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHIpO1xuICAgICAgICBpZiAodmFsdWUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgIG1lbW9bYXR0cl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgIH0sIHsgfSk7XG4gICAgICAvLyBhZGQgdmFsdWVzIHBhcnNlZCBmcm9tIHN0eWxlLCB3aGljaCB0YWtlIHByZWNlZGVuY2Ugb3ZlciBhdHRyaWJ1dGVzXG4gICAgICAvLyAoc2VlOiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc3R5bGluZy5odG1sI1VzaW5nUHJlc2VudGF0aW9uQXR0cmlidXRlcylcbiAgICAgIHZhciBjc3NBdHRycyA9IGV4dGVuZChcbiAgICAgICAgZ2V0R2xvYmFsU3R5bGVzRm9yRWxlbWVudChlbGVtZW50LCBzdmdVaWQpLFxuICAgICAgICBmYWJyaWMucGFyc2VTdHlsZUF0dHJpYnV0ZShlbGVtZW50KVxuICAgICAgKTtcbiAgICAgIG93bkF0dHJpYnV0ZXMgPSBleHRlbmQoXG4gICAgICAgIG93bkF0dHJpYnV0ZXMsXG4gICAgICAgIGNzc0F0dHJzXG4gICAgICApO1xuICAgICAgaWYgKGNzc0F0dHJzW2NQYXRoXSkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShjUGF0aCwgY3NzQXR0cnNbY1BhdGhdKTtcbiAgICAgIH1cbiAgICAgIGZvbnRTaXplID0gcGFyZW50Rm9udFNpemUgPSBwYXJlbnRBdHRyaWJ1dGVzLmZvbnRTaXplIHx8IGZhYnJpYy5UZXh0LkRFRkFVTFRfU1ZHX0ZPTlRfU0laRTtcbiAgICAgIGlmIChvd25BdHRyaWJ1dGVzW2ZTaXplXSkge1xuICAgICAgICAvLyBsb29rcyBsaWtlIHRoZSBtaW5pbXVtIHNob3VsZCBiZSA5cHggd2hlbiBkZWFsaW5nIHdpdGggZW1zLiB0aGlzIGlzIHdoYXQgbG9va3MgbGlrZSBpbiBicm93c2Vycy5cbiAgICAgICAgb3duQXR0cmlidXRlc1tmU2l6ZV0gPSBmb250U2l6ZSA9IHBhcnNlVW5pdChvd25BdHRyaWJ1dGVzW2ZTaXplXSwgcGFyZW50Rm9udFNpemUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9ybWFsaXplZEF0dHIsIG5vcm1hbGl6ZWRWYWx1ZSwgbm9ybWFsaXplZFN0eWxlID0ge307XG4gICAgICBmb3IgKHZhciBhdHRyIGluIG93bkF0dHJpYnV0ZXMpIHtcbiAgICAgICAgbm9ybWFsaXplZEF0dHIgPSBub3JtYWxpemVBdHRyKGF0dHIpO1xuICAgICAgICBub3JtYWxpemVkVmFsdWUgPSBub3JtYWxpemVWYWx1ZShub3JtYWxpemVkQXR0ciwgb3duQXR0cmlidXRlc1thdHRyXSwgcGFyZW50QXR0cmlidXRlcywgZm9udFNpemUpO1xuICAgICAgICBub3JtYWxpemVkU3R5bGVbbm9ybWFsaXplZEF0dHJdID0gbm9ybWFsaXplZFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKG5vcm1hbGl6ZWRTdHlsZSAmJiBub3JtYWxpemVkU3R5bGUuZm9udCkge1xuICAgICAgICBmYWJyaWMucGFyc2VGb250RGVjbGFyYXRpb24obm9ybWFsaXplZFN0eWxlLmZvbnQsIG5vcm1hbGl6ZWRTdHlsZSk7XG4gICAgICB9XG4gICAgICB2YXIgbWVyZ2VkQXR0cnMgPSBleHRlbmQocGFyZW50QXR0cmlidXRlcywgbm9ybWFsaXplZFN0eWxlKTtcbiAgICAgIHJldHVybiBmYWJyaWMuc3ZnVmFsaWRQYXJlbnRzUmVnRXgudGVzdChlbGVtZW50Lm5vZGVOYW1lKSA/IG1lcmdlZEF0dHJzIDogX3NldFN0cm9rZUZpbGxPcGFjaXR5KG1lcmdlZEF0dHJzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhbiBhcnJheSBvZiBzdmcgZWxlbWVudHMgdG8gY29ycmVzcG9uZGluZyBmYWJyaWMuKiBpbnN0YW5jZXNcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGVsZW1lbnRzIEFycmF5IG9mIGVsZW1lbnRzIHRvIHBhcnNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQmVpbmcgcGFzc2VkIGFuIGFycmF5IG9mIGZhYnJpYyBpbnN0YW5jZXMgKHRyYW5zZm9ybWVkIGZyb20gU1ZHIGVsZW1lbnRzKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2YgU1ZHIGVsZW1lbnRzLCBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAgICovXG4gICAgcGFyc2VFbGVtZW50czogZnVuY3Rpb24oZWxlbWVudHMsIGNhbGxiYWNrLCBvcHRpb25zLCByZXZpdmVyLCBwYXJzaW5nT3B0aW9ucykge1xuICAgICAgbmV3IGZhYnJpYy5FbGVtZW50c1BhcnNlcihlbGVtZW50cywgY2FsbGJhY2ssIG9wdGlvbnMsIHJldml2ZXIsIHBhcnNpbmdPcHRpb25zKS5wYXJzZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgXCJzdHlsZVwiIGF0dHJpYnV0ZSwgcmV0dW5pbmcgYW4gb2JqZWN0IHdpdGggdmFsdWVzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0cyB3aXRoIHZhbHVlcyBwYXJzZWQgZnJvbSBzdHlsZSBhdHRyaWJ1dGUgb2YgYW4gZWxlbWVudFxuICAgICAqL1xuICAgIHBhcnNlU3R5bGVBdHRyaWJ1dGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvU3R5bGUgPSB7IH0sXG4gICAgICAgICAgc3R5bGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3R5bGUnKTtcblxuICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICByZXR1cm4gb1N0eWxlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHN0eWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXJzZVN0eWxlU3RyaW5nKHN0eWxlLCBvU3R5bGUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHBhcnNlU3R5bGVPYmplY3Qoc3R5bGUsIG9TdHlsZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvU3R5bGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBcInBvaW50c1wiIGF0dHJpYnV0ZSwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHZhbHVlc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBvaW50cyBwb2ludHMgYXR0cmlidXRlIHN0cmluZ1xuICAgICAqIEByZXR1cm4ge0FycmF5fSBhcnJheSBvZiBwb2ludHNcbiAgICAgKi9cbiAgICBwYXJzZVBvaW50c0F0dHJpYnV0ZTogZnVuY3Rpb24ocG9pbnRzKSB7XG5cbiAgICAgIC8vIHBvaW50cyBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQgYW5kIG11c3Qgbm90IGJlIGVtcHR5XG4gICAgICBpZiAoIXBvaW50cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gcmVwbGFjZSBjb21tYXMgd2l0aCB3aGl0ZXNwYWNlIGFuZCByZW1vdmUgYm9va2VuZGluZyB3aGl0ZXNwYWNlXG4gICAgICBwb2ludHMgPSBwb2ludHMucmVwbGFjZSgvLC9nLCAnICcpLnRyaW0oKTtcblxuICAgICAgcG9pbnRzID0gcG9pbnRzLnNwbGl0KC9cXHMrLyk7XG4gICAgICB2YXIgcGFyc2VkUG9pbnRzID0gW10sIGksIGxlbjtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICAgIHBhcnNlZFBvaW50cy5wdXNoKHtcbiAgICAgICAgICB4OiBwYXJzZUZsb2F0KHBvaW50c1tpXSksXG4gICAgICAgICAgeTogcGFyc2VGbG9hdChwb2ludHNbaSArIDFdKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gb2RkIG51bWJlciBvZiBwb2ludHMgaXMgYW4gZXJyb3JcbiAgICAgIC8vIGlmIChwYXJzZWRQb2ludHMubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgLy8gICByZXR1cm4gbnVsbDtcbiAgICAgIC8vIH1cblxuICAgICAgcmV0dXJuIHBhcnNlZFBvaW50cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBDU1MgcnVsZXMgZm9yIGEgZ2l2ZW4gU1ZHIGRvY3VtZW50XG4gICAgICogQHN0YXRpY1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge1NWR0RvY3VtZW50fSBkb2MgU1ZHIGRvY3VtZW50IHRvIHBhcnNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDU1MgcnVsZXMgb2YgdGhpcyBkb2N1bWVudFxuICAgICAqL1xuICAgIGdldENTU1J1bGVzOiBmdW5jdGlvbihkb2MpIHtcbiAgICAgIHZhciBzdHlsZXMgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3N0eWxlJyksIGksIGxlbixcbiAgICAgICAgICBhbGxSdWxlcyA9IHsgfSwgcnVsZXM7XG5cbiAgICAgIC8vIHZlcnkgY3J1ZGUgcGFyc2luZyBvZiBzdHlsZSBjb250ZW50c1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gc3R5bGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBzdHlsZUNvbnRlbnRzID0gc3R5bGVzW2ldLnRleHRDb250ZW50O1xuXG4gICAgICAgIC8vIHJlbW92ZSBjb21tZW50c1xuICAgICAgICBzdHlsZUNvbnRlbnRzID0gc3R5bGVDb250ZW50cy5yZXBsYWNlKC9cXC9cXCpbXFxzXFxTXSo/XFwqXFwvL2csICcnKTtcbiAgICAgICAgaWYgKHN0eWxlQ29udGVudHMudHJpbSgpID09PSAnJykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlY292ZXJzIGFsbCB0aGUgcnVsZSBpbiB0aGlzIGZvcm0gYGJvZHkgeyBzdHlsZSBjb2RlLi4uIH1gXG4gICAgICAgIC8vIHJ1bGVzID0gc3R5bGVDb250ZW50cy5tYXRjaCgvW157XSpcXHtbXFxzXFxTXSo/XFx9L2cpO1xuICAgICAgICBydWxlcyA9IHN0eWxlQ29udGVudHMuc3BsaXQoJ30nKTtcbiAgICAgICAgLy8gcmVtb3ZlIGVtcHR5IHJ1bGVzLlxuICAgICAgICBydWxlcyA9IHJ1bGVzLmZpbHRlcihmdW5jdGlvbihydWxlKSB7IHJldHVybiBydWxlLnRyaW0oKTsgfSk7XG4gICAgICAgIC8vIGF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBob3BlZnVsbHkgYW4gYXJyYXkgb2YgcnVsZXMgYGJvZHkgeyBzdHlsZSBjb2RlLi4uIGBcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvb3AtZnVuY1xuICAgICAgICBydWxlcy5mb3JFYWNoKGZ1bmN0aW9uKHJ1bGUpIHtcblxuICAgICAgICAgIHZhciBtYXRjaCA9IHJ1bGUuc3BsaXQoJ3snKSxcbiAgICAgICAgICAgICAgcnVsZU9iaiA9IHsgfSwgZGVjbGFyYXRpb24gPSBtYXRjaFsxXS50cmltKCksXG4gICAgICAgICAgICAgIHByb3BlcnR5VmFsdWVQYWlycyA9IGRlY2xhcmF0aW9uLnNwbGl0KCc7JykuZmlsdGVyKGZ1bmN0aW9uKHBhaXIpIHsgcmV0dXJuIHBhaXIudHJpbSgpOyB9KTtcblxuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHByb3BlcnR5VmFsdWVQYWlycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhaXIgPSBwcm9wZXJ0eVZhbHVlUGFpcnNbaV0uc3BsaXQoJzonKSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHBhaXJbMF0udHJpbSgpLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFpclsxXS50cmltKCk7XG4gICAgICAgICAgICBydWxlT2JqW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBydWxlID0gbWF0Y2hbMF0udHJpbSgpO1xuICAgICAgICAgIHJ1bGUuc3BsaXQoJywnKS5mb3JFYWNoKGZ1bmN0aW9uKF9ydWxlKSB7XG4gICAgICAgICAgICBfcnVsZSA9IF9ydWxlLnJlcGxhY2UoL15zdmcvaSwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgIGlmIChfcnVsZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsbFJ1bGVzW19ydWxlXSkge1xuICAgICAgICAgICAgICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGFsbFJ1bGVzW19ydWxlXSwgcnVsZU9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgYWxsUnVsZXNbX3J1bGVdID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKHJ1bGVPYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhbGxSdWxlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGFrZXMgdXJsIGNvcnJlc3BvbmRpbmcgdG8gYW4gU1ZHIGRvY3VtZW50LCBhbmQgcGFyc2VzIGl0IGludG8gYSBzZXQgb2YgZmFicmljIG9iamVjdHMuXG4gICAgICogTm90ZSB0aGF0IFNWRyBpcyBmZXRjaGVkIHZpYSBYTUxIdHRwUmVxdWVzdCwgc28gaXQgbmVlZHMgdG8gY29uZm9ybSB0byBTT1AgKFNhbWUgT3JpZ2luIFBvbGljeSlcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIFNWRyBlbGVtZW50cywgY2FsbGVkIGFmdGVyIGVhY2ggZmFicmljIG9iamVjdCBjcmVhdGVkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT2JqZWN0IGNvbnRhaW5pbmcgb3B0aW9ucyBmb3IgcGFyc2luZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jcm9zc09yaWdpbl0gY3Jvc3NPcmlnaW4gY3Jvc3NPcmlnaW4gc2V0dGluZyB0byB1c2UgZm9yIGV4dGVybmFsIHJlc291cmNlc1xuICAgICAqL1xuICAgIGxvYWRTVkdGcm9tVVJMOiBmdW5jdGlvbih1cmwsIGNhbGxiYWNrLCByZXZpdmVyLCBvcHRpb25zKSB7XG5cbiAgICAgIHVybCA9IHVybC5yZXBsYWNlKC9eXFxuXFxzKi8sICcnKS50cmltKCk7XG4gICAgICBuZXcgZmFicmljLnV0aWwucmVxdWVzdCh1cmwsIHtcbiAgICAgICAgbWV0aG9kOiAnZ2V0JyxcbiAgICAgICAgb25Db21wbGV0ZTogb25Db21wbGV0ZVxuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIG9uQ29tcGxldGUocikge1xuXG4gICAgICAgIHZhciB4bWwgPSByLnJlc3BvbnNlWE1MO1xuICAgICAgICBpZiAoIXhtbCB8fCAheG1sLmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZhYnJpYy5wYXJzZVNWR0RvY3VtZW50KHhtbC5kb2N1bWVudEVsZW1lbnQsIGZ1bmN0aW9uIChyZXN1bHRzLCBfb3B0aW9ucywgZWxlbWVudHMsIGFsbEVsZW1lbnRzKSB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socmVzdWx0cywgX29wdGlvbnMsIGVsZW1lbnRzLCBhbGxFbGVtZW50cyk7XG4gICAgICAgIH0sIHJldml2ZXIsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBzdHJpbmcgY29ycmVzcG9uZGluZyB0byBhbiBTVkcgZG9jdW1lbnQsIGFuZCBwYXJzZXMgaXQgaW50byBhIHNldCBvZiBmYWJyaWMgb2JqZWN0c1xuICAgICAqIEBtZW1iZXJPZiBmYWJyaWNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2YgU1ZHIGVsZW1lbnRzLCBjYWxsZWQgYWZ0ZXIgZWFjaCBmYWJyaWMgb2JqZWN0IGNyZWF0ZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPYmplY3QgY29udGFpbmluZyBvcHRpb25zIGZvciBwYXJzaW5nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNyb3NzT3JpZ2luXSBjcm9zc09yaWdpbiBjcm9zc09yaWdpbiBzZXR0aW5nIHRvIHVzZSBmb3IgZXh0ZXJuYWwgcmVzb3VyY2VzXG4gICAgICovXG4gICAgbG9hZFNWR0Zyb21TdHJpbmc6IGZ1bmN0aW9uKHN0cmluZywgY2FsbGJhY2ssIHJldml2ZXIsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBwYXJzZXIgPSBuZXcgZmFicmljLndpbmRvdy5ET01QYXJzZXIoKSxcbiAgICAgICAgICBkb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHN0cmluZy50cmltKCksICd0ZXh0L3htbCcpO1xuICAgICAgZmFicmljLnBhcnNlU1ZHRG9jdW1lbnQoZG9jLmRvY3VtZW50RWxlbWVudCwgZnVuY3Rpb24gKHJlc3VsdHMsIF9vcHRpb25zLCBlbGVtZW50cywgYWxsRWxlbWVudHMpIHtcbiAgICAgICAgY2FsbGJhY2socmVzdWx0cywgX29wdGlvbnMsIGVsZW1lbnRzLCBhbGxFbGVtZW50cyk7XG4gICAgICB9LCByZXZpdmVyLCBvcHRpb25zKTtcbiAgICB9XG4gIH0pO1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuZmFicmljLkVsZW1lbnRzUGFyc2VyID0gZnVuY3Rpb24oZWxlbWVudHMsIGNhbGxiYWNrLCBvcHRpb25zLCByZXZpdmVyLCBwYXJzaW5nT3B0aW9ucywgZG9jKSB7XG4gIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLnJldml2ZXIgPSByZXZpdmVyO1xuICB0aGlzLnN2Z1VpZCA9IChvcHRpb25zICYmIG9wdGlvbnMuc3ZnVWlkKSB8fCAwO1xuICB0aGlzLnBhcnNpbmdPcHRpb25zID0gcGFyc2luZ09wdGlvbnM7XG4gIHRoaXMucmVnZXhVcmwgPSAvXnVybFxcKFsnXCJdPyMoW14nXCJdKylbJ1wiXT9cXCkvZztcbiAgdGhpcy5kb2MgPSBkb2M7XG59O1xuXG4oZnVuY3Rpb24ocHJvdG8pIHtcbiAgcHJvdG8ucGFyc2UgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluc3RhbmNlcyA9IG5ldyBBcnJheSh0aGlzLmVsZW1lbnRzLmxlbmd0aCk7XG4gICAgdGhpcy5udW1FbGVtZW50cyA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuICAgIHRoaXMuY3JlYXRlT2JqZWN0cygpO1xuICB9O1xuXG4gIHByb3RvLmNyZWF0ZU9iamVjdHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50LCBpKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3ZnVWlkJywgX3RoaXMuc3ZnVWlkKTtcbiAgICAgIF90aGlzLmNyZWF0ZU9iamVjdChlbGVtZW50LCBpKTtcbiAgICB9KTtcbiAgfTtcblxuICBwcm90by5maW5kVGFnID0gZnVuY3Rpb24oZWwpIHtcbiAgICByZXR1cm4gZmFicmljW2ZhYnJpYy51dGlsLnN0cmluZy5jYXBpdGFsaXplKGVsLnRhZ05hbWUucmVwbGFjZSgnc3ZnOicsICcnKSldO1xuICB9O1xuXG4gIHByb3RvLmNyZWF0ZU9iamVjdCA9IGZ1bmN0aW9uKGVsLCBpbmRleCkge1xuICAgIHZhciBrbGFzcyA9IHRoaXMuZmluZFRhZyhlbCk7XG4gICAgaWYgKGtsYXNzICYmIGtsYXNzLmZyb21FbGVtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICBrbGFzcy5mcm9tRWxlbWVudChlbCwgdGhpcy5jcmVhdGVDYWxsYmFjayhpbmRleCwgZWwpLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICBmYWJyaWMubG9nKGVycik7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jaGVja0lmRG9uZSgpO1xuICAgIH1cbiAgfTtcblxuICBwcm90by5jcmVhdGVDYWxsYmFjayA9IGZ1bmN0aW9uKGluZGV4LCBlbCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgdmFyIF9vcHRpb25zO1xuICAgICAgX3RoaXMucmVzb2x2ZUdyYWRpZW50KG9iaiwgZWwsICdmaWxsJyk7XG4gICAgICBfdGhpcy5yZXNvbHZlR3JhZGllbnQob2JqLCBlbCwgJ3N0cm9rZScpO1xuICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIGZhYnJpYy5JbWFnZSAmJiBvYmouX29yaWdpbmFsRWxlbWVudCkge1xuICAgICAgICBfb3B0aW9ucyA9IG9iai5wYXJzZVByZXNlcnZlQXNwZWN0UmF0aW9BdHRyaWJ1dGUoZWwpO1xuICAgICAgfVxuICAgICAgb2JqLl9yZW1vdmVUcmFuc2Zvcm1NYXRyaXgoX29wdGlvbnMpO1xuICAgICAgX3RoaXMucmVzb2x2ZUNsaXBQYXRoKG9iaiwgZWwpO1xuICAgICAgX3RoaXMucmV2aXZlciAmJiBfdGhpcy5yZXZpdmVyKGVsLCBvYmopO1xuICAgICAgX3RoaXMuaW5zdGFuY2VzW2luZGV4XSA9IG9iajtcbiAgICAgIF90aGlzLmNoZWNrSWZEb25lKCk7XG4gICAgfTtcbiAgfTtcblxuICBwcm90by5leHRyYWN0UHJvcGVydHlEZWZpbml0aW9uID0gZnVuY3Rpb24ob2JqLCBwcm9wZXJ0eSwgc3RvcmFnZSkge1xuICAgIHZhciB2YWx1ZSA9IG9ialtwcm9wZXJ0eV0sIHJlZ2V4ID0gdGhpcy5yZWdleFVybDtcbiAgICBpZiAoIXJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlZ2V4Lmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIGlkID0gcmVnZXguZXhlYyh2YWx1ZSlbMV07XG4gICAgcmVnZXgubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gZmFicmljW3N0b3JhZ2VdW3RoaXMuc3ZnVWlkXVtpZF07XG4gIH07XG5cbiAgcHJvdG8ucmVzb2x2ZUdyYWRpZW50ID0gZnVuY3Rpb24ob2JqLCBlbCwgcHJvcGVydHkpIHtcbiAgICB2YXIgZ3JhZGllbnREZWYgPSB0aGlzLmV4dHJhY3RQcm9wZXJ0eURlZmluaXRpb24ob2JqLCBwcm9wZXJ0eSwgJ2dyYWRpZW50RGVmcycpO1xuICAgIGlmIChncmFkaWVudERlZikge1xuICAgICAgdmFyIG9wYWNpdHlBdHRyID0gZWwuZ2V0QXR0cmlidXRlKHByb3BlcnR5ICsgJy1vcGFjaXR5Jyk7XG4gICAgICB2YXIgZ3JhZGllbnQgPSBmYWJyaWMuR3JhZGllbnQuZnJvbUVsZW1lbnQoZ3JhZGllbnREZWYsIG9iaiwgb3BhY2l0eUF0dHIsIHRoaXMub3B0aW9ucyk7XG4gICAgICBvYmouc2V0KHByb3BlcnR5LCBncmFkaWVudCk7XG4gICAgfVxuICB9O1xuXG4gIHByb3RvLmNyZWF0ZUNsaXBQYXRoQ2FsbGJhY2sgPSBmdW5jdGlvbihvYmosIGNvbnRhaW5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbihfbmV3T2JqKSB7XG4gICAgICBfbmV3T2JqLl9yZW1vdmVUcmFuc2Zvcm1NYXRyaXgoKTtcbiAgICAgIF9uZXdPYmouZmlsbFJ1bGUgPSBfbmV3T2JqLmNsaXBSdWxlO1xuICAgICAgY29udGFpbmVyLnB1c2goX25ld09iaik7XG4gICAgfTtcbiAgfTtcblxuICBwcm90by5yZXNvbHZlQ2xpcFBhdGggPSBmdW5jdGlvbihvYmosIHVzaW5nRWxlbWVudCkge1xuICAgIHZhciBjbGlwUGF0aCA9IHRoaXMuZXh0cmFjdFByb3BlcnR5RGVmaW5pdGlvbihvYmosICdjbGlwUGF0aCcsICdjbGlwUGF0aHMnKSxcbiAgICAgICAgZWxlbWVudCwga2xhc3MsIG9ialRyYW5zZm9ybUludiwgY29udGFpbmVyLCBnVHJhbnNmb3JtLCBvcHRpb25zO1xuICAgIGlmIChjbGlwUGF0aCkge1xuICAgICAgY29udGFpbmVyID0gW107XG4gICAgICBvYmpUcmFuc2Zvcm1JbnYgPSBmYWJyaWMudXRpbC5pbnZlcnRUcmFuc2Zvcm0ob2JqLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSk7XG4gICAgICAvLyBtb3ZlIHRoZSBjbGlwUGF0aCB0YWcgYXMgc2libGluZyB0byB0aGUgcmVhbCBlbGVtZW50IHRoYXQgaXMgdXNpbmcgaXRcbiAgICAgIHZhciBjbGlwUGF0aFRhZyA9IGNsaXBQYXRoWzBdLnBhcmVudE5vZGU7XG4gICAgICB2YXIgY2xpcFBhdGhPd25lciA9IHVzaW5nRWxlbWVudDtcbiAgICAgIHdoaWxlIChjbGlwUGF0aE93bmVyLnBhcmVudE5vZGUgJiYgY2xpcFBhdGhPd25lci5nZXRBdHRyaWJ1dGUoJ2NsaXAtcGF0aCcpICE9PSBvYmouY2xpcFBhdGgpIHtcbiAgICAgICAgY2xpcFBhdGhPd25lciA9IGNsaXBQYXRoT3duZXIucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIGNsaXBQYXRoT3duZXIucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChjbGlwUGF0aFRhZyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVsZW1lbnQgPSBjbGlwUGF0aFtpXTtcbiAgICAgICAga2xhc3MgPSB0aGlzLmZpbmRUYWcoZWxlbWVudCk7XG4gICAgICAgIGtsYXNzLmZyb21FbGVtZW50KFxuICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgdGhpcy5jcmVhdGVDbGlwUGF0aENhbGxiYWNrKG9iaiwgY29udGFpbmVyKSxcbiAgICAgICAgICB0aGlzLm9wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb250YWluZXIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNsaXBQYXRoID0gY29udGFpbmVyWzBdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNsaXBQYXRoID0gbmV3IGZhYnJpYy5Hcm91cChjb250YWluZXIpO1xuICAgICAgfVxuICAgICAgZ1RyYW5zZm9ybSA9IGZhYnJpYy51dGlsLm11bHRpcGx5VHJhbnNmb3JtTWF0cmljZXMoXG4gICAgICAgIG9ialRyYW5zZm9ybUludixcbiAgICAgICAgY2xpcFBhdGguY2FsY1RyYW5zZm9ybU1hdHJpeCgpXG4gICAgICApO1xuICAgICAgaWYgKGNsaXBQYXRoLmNsaXBQYXRoKSB7XG4gICAgICAgIHRoaXMucmVzb2x2ZUNsaXBQYXRoKGNsaXBQYXRoLCBjbGlwUGF0aE93bmVyKTtcbiAgICAgIH1cbiAgICAgIHZhciBvcHRpb25zID0gZmFicmljLnV0aWwucXJEZWNvbXBvc2UoZ1RyYW5zZm9ybSk7XG4gICAgICBjbGlwUGF0aC5mbGlwWCA9IGZhbHNlO1xuICAgICAgY2xpcFBhdGguZmxpcFkgPSBmYWxzZTtcbiAgICAgIGNsaXBQYXRoLnNldCgnc2NhbGVYJywgb3B0aW9ucy5zY2FsZVgpO1xuICAgICAgY2xpcFBhdGguc2V0KCdzY2FsZVknLCBvcHRpb25zLnNjYWxlWSk7XG4gICAgICBjbGlwUGF0aC5hbmdsZSA9IG9wdGlvbnMuYW5nbGU7XG4gICAgICBjbGlwUGF0aC5za2V3WCA9IG9wdGlvbnMuc2tld1g7XG4gICAgICBjbGlwUGF0aC5za2V3WSA9IDA7XG4gICAgICBjbGlwUGF0aC5zZXRQb3NpdGlvbkJ5T3JpZ2luKHsgeDogb3B0aW9ucy50cmFuc2xhdGVYLCB5OiBvcHRpb25zLnRyYW5zbGF0ZVkgfSwgJ2NlbnRlcicsICdjZW50ZXInKTtcbiAgICAgIG9iai5jbGlwUGF0aCA9IGNsaXBQYXRoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGlmIGNsaXAtcGF0aCBkb2VzIG5vdCByZXNvbHZlIHRvIGFueSBlbGVtZW50LCBkZWxldGUgdGhlIHByb3BlcnR5LlxuICAgICAgZGVsZXRlIG9iai5jbGlwUGF0aDtcbiAgICB9XG4gIH07XG5cbiAgcHJvdG8uY2hlY2tJZkRvbmUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoLS10aGlzLm51bUVsZW1lbnRzID09PSAwKSB7XG4gICAgICB0aGlzLmluc3RhbmNlcyA9IHRoaXMuaW5zdGFuY2VzLmZpbHRlcihmdW5jdGlvbihlbCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCwgZXFlcWVxXG4gICAgICAgIHJldHVybiBlbCAhPSBudWxsO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmNhbGxiYWNrKHRoaXMuaW5zdGFuY2VzLCB0aGlzLmVsZW1lbnRzKTtcbiAgICB9XG4gIH07XG59KShmYWJyaWMuRWxlbWVudHNQYXJzZXIucHJvdG90eXBlKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qIEFkYXB0YXRpb24gb2Ygd29yayBvZiBLZXZpbiBMaW5kc2V5IChrZXZpbkBrZXZsaW5kZXYuY29tKSAqL1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KTtcblxuICBpZiAoZmFicmljLlBvaW50KSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5Qb2ludCBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBmYWJyaWMuUG9pbnQgPSBQb2ludDtcblxuICAvKipcbiAgICogUG9pbnQgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5Qb2ludFxuICAgKiBAbWVtYmVyT2YgZmFicmljXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHRoaXNBcmdcbiAgICovXG4gIGZ1bmN0aW9uIFBvaW50KHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cblxuICBQb2ludC5wcm90b3R5cGUgPSAvKiogQGxlbmRzIGZhYnJpYy5Qb2ludC5wcm90b3R5cGUgKi8ge1xuXG4gICAgdHlwZTogJ3BvaW50JyxcblxuICAgIGNvbnN0cnVjdG9yOiBQb2ludCxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW5vdGhlciBwb2ludCB0byB0aGlzIG9uZSBhbmQgcmV0dXJucyBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSBuZXcgUG9pbnQgaW5zdGFuY2Ugd2l0aCBhZGRlZCB2YWx1ZXNcbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCArIHRoYXQueCwgdGhpcy55ICsgdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbm90aGVyIHBvaW50IHRvIHRoaXMgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgYWRkRXF1YWxzOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgdGhpcy54ICs9IHRoYXQueDtcbiAgICAgIHRoaXMueSArPSB0aGF0Lnk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyB2YWx1ZSB0byB0aGlzIHBvaW50IGFuZCByZXR1cm5zIGEgbmV3IG9uZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IG5ldyBQb2ludCB3aXRoIGFkZGVkIHZhbHVlXG4gICAgICovXG4gICAgc2NhbGFyQWRkOiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCArIHNjYWxhciwgdGhpcy55ICsgc2NhbGFyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyB2YWx1ZSB0byB0aGlzIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzY2FsYXJBZGRFcXVhbHM6IGZ1bmN0aW9uIChzY2FsYXIpIHtcbiAgICAgIHRoaXMueCArPSBzY2FsYXI7XG4gICAgICB0aGlzLnkgKz0gc2NhbGFyO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyBhbm90aGVyIHBvaW50IGZyb20gdGhpcyBwb2ludCBhbmQgcmV0dXJucyBhIG5ldyBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gbmV3IFBvaW50IG9iamVjdCB3aXRoIHN1YnRyYWN0ZWQgdmFsdWVzXG4gICAgICovXG4gICAgc3VidHJhY3Q6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAtIHRoYXQueCwgdGhpcy55IC0gdGhhdC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3RzIGFub3RoZXIgcG9pbnQgZnJvbSB0aGlzIHBvaW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc3VidHJhY3RFcXVhbHM6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICB0aGlzLnggLT0gdGhhdC54O1xuICAgICAgdGhpcy55IC09IHRoYXQueTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdmFsdWUgZnJvbSB0aGlzIHBvaW50IGFuZCByZXR1cm5zIGEgbmV3IG9uZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgc2NhbGFyU3VidHJhY3Q6IGZ1bmN0aW9uIChzY2FsYXIpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54IC0gc2NhbGFyLCB0aGlzLnkgLSBzY2FsYXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdmFsdWUgZnJvbSB0aGlzIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzY2FsYXJTdWJ0cmFjdEVxdWFsczogZnVuY3Rpb24gKHNjYWxhcikge1xuICAgICAgdGhpcy54IC09IHNjYWxhcjtcbiAgICAgIHRoaXMueSAtPSBzY2FsYXI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0aGlzIHBvaW50IGJ5IGEgdmFsdWUgYW5kIHJldHVybnMgYSBuZXcgb25lXG4gICAgICogVE9ETzogcmVuYW1lIGluIHNjYWxhck11bHRpcGx5IGluIDIuMFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgbXVsdGlwbHk6IGZ1bmN0aW9uIChzY2FsYXIpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54ICogc2NhbGFyLCB0aGlzLnkgKiBzY2FsYXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIHRoaXMgcG9pbnQgYnkgYSB2YWx1ZVxuICAgICAqIFRPRE86IHJlbmFtZSBpbiBzY2FsYXJNdWx0aXBseUVxdWFscyBpbiAyLjBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIG11bHRpcGx5RXF1YWxzOiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICB0aGlzLnggKj0gc2NhbGFyO1xuICAgICAgdGhpcy55ICo9IHNjYWxhcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIHRoaXMgcG9pbnQgYnkgYSB2YWx1ZSBhbmQgcmV0dXJucyBhIG5ldyBvbmVcbiAgICAgKiBUT0RPOiByZW5hbWUgaW4gc2NhbGFyRGl2aWRlIGluIDIuMFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgZGl2aWRlOiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAvIHNjYWxhciwgdGhpcy55IC8gc2NhbGFyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyB0aGlzIHBvaW50IGJ5IGEgdmFsdWVcbiAgICAgKiBUT0RPOiByZW5hbWUgaW4gc2NhbGFyRGl2aWRlRXF1YWxzIGluIDIuMFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZGl2aWRlRXF1YWxzOiBmdW5jdGlvbiAoc2NhbGFyKSB7XG4gICAgICB0aGlzLnggLz0gc2NhbGFyO1xuICAgICAgdGhpcy55IC89IHNjYWxhcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBwb2ludCBpcyBlcXVhbCB0byBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBlcTogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiAodGhpcy54ID09PSB0aGF0LnggJiYgdGhpcy55ID09PSB0aGF0LnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBwb2ludCBpcyBsZXNzIHRoYW4gYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgbHQ6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gKHRoaXMueCA8IHRoYXQueCAmJiB0aGlzLnkgPCB0aGF0LnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBwb2ludCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgbHRlOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuICh0aGlzLnggPD0gdGhhdC54ICYmIHRoaXMueSA8PSB0aGF0LnkpO1xuICAgIH0sXG5cbiAgICAvKipcblxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHBvaW50IGlzIGdyZWF0ZXIgYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ3Q6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gKHRoaXMueCA+IHRoYXQueCAmJiB0aGlzLnkgPiB0aGF0LnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBwb2ludCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ3RlOiBmdW5jdGlvbiAodGhhdCkge1xuICAgICAgcmV0dXJuICh0aGlzLnggPj0gdGhhdC54ICYmIHRoaXMueSA+PSB0aGF0LnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG5ldyBwb2ludCB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIGxpbmVhciBpbnRlcnBvbGF0aW9uIHdpdGggdGhpcyBvbmUgYW5kIGFub3RoZXIgb25lXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHRoYXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdCAsIHBvc2l0aW9uIG9mIGludGVycG9sYXRpb24sIGJldHdlZW4gMCBhbmQgMSBkZWZhdWx0IDAuNVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBsZXJwOiBmdW5jdGlvbiAodGhhdCwgdCkge1xuICAgICAgaWYgKHR5cGVvZiB0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0ID0gMC41O1xuICAgICAgfVxuICAgICAgdCA9IE1hdGgubWF4KE1hdGgubWluKDEsIHQpLCAwKTtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54ICsgKHRoYXQueCAtIHRoaXMueCkgKiB0LCB0aGlzLnkgKyAodGhhdC55IC0gdGhpcy55KSAqIHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGRpc3RhbmNlIGZyb20gdGhpcyBwb2ludCBhbmQgYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBkaXN0YW5jZUZyb206IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICB2YXIgZHggPSB0aGlzLnggLSB0aGF0LngsXG4gICAgICAgICAgZHkgPSB0aGlzLnkgLSB0aGF0Lnk7XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcG9pbnQgYmV0d2VlbiB0aGlzIHBvaW50IGFuZCBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIG1pZFBvaW50RnJvbTogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiB0aGlzLmxlcnAodGhhdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgcG9pbnQgd2hpY2ggaXMgdGhlIG1pbiBvZiB0aGlzIGFuZCBhbm90aGVyIG9uZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSB0aGF0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIG1pbjogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQoTWF0aC5taW4odGhpcy54LCB0aGF0LngpLCBNYXRoLm1pbih0aGlzLnksIHRoYXQueSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHBvaW50IHdoaWNoIGlzIHRoZSBtYXggb2YgdGhpcyBhbmQgYW5vdGhlciBvbmVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICBtYXg6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KE1hdGgubWF4KHRoaXMueCwgdGhhdC54KSwgTWF0aC5tYXgodGhpcy55LCB0aGF0LnkpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBwb2ludFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMueCArICcsJyArIHRoaXMueTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB4L3kgb2YgdGhpcyBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0WFk6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICB0aGlzLnggPSB4O1xuICAgICAgdGhpcy55ID0geTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHggb2YgdGhpcyBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldFg6IGZ1bmN0aW9uICh4KSB7XG4gICAgICB0aGlzLnggPSB4O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgeSBvZiB0aGlzIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0WTogZnVuY3Rpb24gKHkpIHtcbiAgICAgIHRoaXMueSA9IHk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB4L3kgb2YgdGhpcyBwb2ludCBmcm9tIGFub3RoZXIgcG9pbnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRGcm9tUG9pbnQ6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICB0aGlzLnggPSB0aGF0Lng7XG4gICAgICB0aGlzLnkgPSB0aGF0Lnk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3dhcHMgeC95IG9mIHRoaXMgcG9pbnQgYW5kIGFub3RoZXIgcG9pbnRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gdGhhdFxuICAgICAqL1xuICAgIHN3YXA6IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgICB2YXIgeCA9IHRoaXMueCxcbiAgICAgICAgICB5ID0gdGhpcy55O1xuICAgICAgdGhpcy54ID0gdGhhdC54O1xuICAgICAgdGhpcy55ID0gdGhhdC55O1xuICAgICAgdGhhdC54ID0geDtcbiAgICAgIHRoYXQueSA9IHk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBhIGNsb25lZCBpbnN0YW5jZSBvZiB0aGUgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyogQWRhcHRhdGlvbiBvZiB3b3JrIG9mIEtldmluIExpbmRzZXkgKGtldmluQGtldmxpbmRldi5jb20pICovXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KTtcblxuICBpZiAoZmFicmljLkludGVyc2VjdGlvbikge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuSW50ZXJzZWN0aW9uIGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcnNlY3Rpb24gY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbnRlcnNlY3Rpb25cbiAgICogQG1lbWJlck9mIGZhYnJpY1xuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIEludGVyc2VjdGlvbihzdGF0dXMpIHtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLnBvaW50cyA9IFtdO1xuICB9XG5cbiAgZmFicmljLkludGVyc2VjdGlvbiA9IEludGVyc2VjdGlvbjtcblxuICBmYWJyaWMuSW50ZXJzZWN0aW9uLnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgZmFicmljLkludGVyc2VjdGlvbi5wcm90b3R5cGUgKi8ge1xuXG4gICAgY29uc3RydWN0b3I6IEludGVyc2VjdGlvbixcblxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgYSBwb2ludCB0byBpbnRlcnNlY3Rpb25cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSW50ZXJzZWN0aW9ufSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGFwcGVuZFBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIHRoaXMucG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgcG9pbnRzIHRvIGludGVyc2VjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50c1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JbnRlcnNlY3Rpb259IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgYXBwZW5kUG9pbnRzOiBmdW5jdGlvbiAocG9pbnRzKSB7XG4gICAgICB0aGlzLnBvaW50cyA9IHRoaXMucG9pbnRzLmNvbmNhdChwb2ludHMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgb25lIGxpbmUgaW50ZXJzZWN0cyBhbm90aGVyXG4gICAqIFRPRE86IHJlbmFtZSBpbiBpbnRlcnNlY3RTZWdtZW50U2VnbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBhMVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gYTJcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGIxXG4gICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBiMlxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW50ZXJzZWN0aW9ufVxuICAgKi9cbiAgZmFicmljLkludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lTGluZSA9IGZ1bmN0aW9uIChhMSwgYTIsIGIxLCBiMikge1xuICAgIHZhciByZXN1bHQsXG4gICAgICAgIHVhVCA9IChiMi54IC0gYjEueCkgKiAoYTEueSAtIGIxLnkpIC0gKGIyLnkgLSBiMS55KSAqIChhMS54IC0gYjEueCksXG4gICAgICAgIHViVCA9IChhMi54IC0gYTEueCkgKiAoYTEueSAtIGIxLnkpIC0gKGEyLnkgLSBhMS55KSAqIChhMS54IC0gYjEueCksXG4gICAgICAgIHVCID0gKGIyLnkgLSBiMS55KSAqIChhMi54IC0gYTEueCkgLSAoYjIueCAtIGIxLngpICogKGEyLnkgLSBhMS55KTtcbiAgICBpZiAodUIgIT09IDApIHtcbiAgICAgIHZhciB1YSA9IHVhVCAvIHVCLFxuICAgICAgICAgIHViID0gdWJUIC8gdUI7XG4gICAgICBpZiAoMCA8PSB1YSAmJiB1YSA8PSAxICYmIDAgPD0gdWIgJiYgdWIgPD0gMSkge1xuICAgICAgICByZXN1bHQgPSBuZXcgSW50ZXJzZWN0aW9uKCdJbnRlcnNlY3Rpb24nKTtcbiAgICAgICAgcmVzdWx0LmFwcGVuZFBvaW50KG5ldyBmYWJyaWMuUG9pbnQoYTEueCArIHVhICogKGEyLnggLSBhMS54KSwgYTEueSArIHVhICogKGEyLnkgLSBhMS55KSkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBJbnRlcnNlY3Rpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAodWFUID09PSAwIHx8IHViVCA9PT0gMCkge1xuICAgICAgICByZXN1bHQgPSBuZXcgSW50ZXJzZWN0aW9uKCdDb2luY2lkZW50Jyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gbmV3IEludGVyc2VjdGlvbignUGFyYWxsZWwnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGxpbmUgaW50ZXJzZWN0cyBwb2x5Z29uXG4gICAqIFRPRE86IHJlbmFtZSBpbiBpbnRlcnNlY3RTZWdtZW50UG9seWdvblxuICAgKiBmaXggZGV0ZWN0aW9uIG9mIGNvaW5jaWRlbnRcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gYTFcbiAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IGEyXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50c1xuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW50ZXJzZWN0aW9ufVxuICAgKi9cbiAgZmFicmljLkludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lUG9seWdvbiA9IGZ1bmN0aW9uKGExLCBhMiwgcG9pbnRzKSB7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBJbnRlcnNlY3Rpb24oKSxcbiAgICAgICAgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgYjEsIGIyLCBpbnRlciwgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYjEgPSBwb2ludHNbaV07XG4gICAgICBiMiA9IHBvaW50c1soaSArIDEpICUgbGVuZ3RoXTtcbiAgICAgIGludGVyID0gSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVMaW5lKGExLCBhMiwgYjEsIGIyKTtcblxuICAgICAgcmVzdWx0LmFwcGVuZFBvaW50cyhpbnRlci5wb2ludHMpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LnBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgICByZXN1bHQuc3RhdHVzID0gJ0ludGVyc2VjdGlvbic7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBwb2x5Z29uIGludGVyc2VjdHMgYW5vdGhlciBwb2x5Z29uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzMVxuICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMyXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbnRlcnNlY3Rpb259XG4gICAqL1xuICBmYWJyaWMuSW50ZXJzZWN0aW9uLmludGVyc2VjdFBvbHlnb25Qb2x5Z29uID0gZnVuY3Rpb24gKHBvaW50czEsIHBvaW50czIpIHtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEludGVyc2VjdGlvbigpLFxuICAgICAgICBsZW5ndGggPSBwb2ludHMxLmxlbmd0aCwgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGExID0gcG9pbnRzMVtpXSxcbiAgICAgICAgICBhMiA9IHBvaW50czFbKGkgKyAxKSAlIGxlbmd0aF0sXG4gICAgICAgICAgaW50ZXIgPSBJbnRlcnNlY3Rpb24uaW50ZXJzZWN0TGluZVBvbHlnb24oYTEsIGEyLCBwb2ludHMyKTtcblxuICAgICAgcmVzdWx0LmFwcGVuZFBvaW50cyhpbnRlci5wb2ludHMpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LnBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgICByZXN1bHQuc3RhdHVzID0gJ0ludGVyc2VjdGlvbic7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBwb2x5Z29uIGludGVyc2VjdHMgcmVjdGFuZ2xlXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzXG4gICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSByMVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcjJcbiAgICogQHJldHVybiB7ZmFicmljLkludGVyc2VjdGlvbn1cbiAgICovXG4gIGZhYnJpYy5JbnRlcnNlY3Rpb24uaW50ZXJzZWN0UG9seWdvblJlY3RhbmdsZSA9IGZ1bmN0aW9uIChwb2ludHMsIHIxLCByMikge1xuICAgIHZhciBtaW4gPSByMS5taW4ocjIpLFxuICAgICAgICBtYXggPSByMS5tYXgocjIpLFxuICAgICAgICB0b3BSaWdodCA9IG5ldyBmYWJyaWMuUG9pbnQobWF4LngsIG1pbi55KSxcbiAgICAgICAgYm90dG9tTGVmdCA9IG5ldyBmYWJyaWMuUG9pbnQobWluLngsIG1heC55KSxcbiAgICAgICAgaW50ZXIxID0gSW50ZXJzZWN0aW9uLmludGVyc2VjdExpbmVQb2x5Z29uKG1pbiwgdG9wUmlnaHQsIHBvaW50cyksXG4gICAgICAgIGludGVyMiA9IEludGVyc2VjdGlvbi5pbnRlcnNlY3RMaW5lUG9seWdvbih0b3BSaWdodCwgbWF4LCBwb2ludHMpLFxuICAgICAgICBpbnRlcjMgPSBJbnRlcnNlY3Rpb24uaW50ZXJzZWN0TGluZVBvbHlnb24obWF4LCBib3R0b21MZWZ0LCBwb2ludHMpLFxuICAgICAgICBpbnRlcjQgPSBJbnRlcnNlY3Rpb24uaW50ZXJzZWN0TGluZVBvbHlnb24oYm90dG9tTGVmdCwgbWluLCBwb2ludHMpLFxuICAgICAgICByZXN1bHQgPSBuZXcgSW50ZXJzZWN0aW9uKCk7XG5cbiAgICByZXN1bHQuYXBwZW5kUG9pbnRzKGludGVyMS5wb2ludHMpO1xuICAgIHJlc3VsdC5hcHBlbmRQb2ludHMoaW50ZXIyLnBvaW50cyk7XG4gICAgcmVzdWx0LmFwcGVuZFBvaW50cyhpbnRlcjMucG9pbnRzKTtcbiAgICByZXN1bHQuYXBwZW5kUG9pbnRzKGludGVyNC5wb2ludHMpO1xuXG4gICAgaWYgKHJlc3VsdC5wb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgcmVzdWx0LnN0YXR1cyA9ICdJbnRlcnNlY3Rpb24nO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSk7XG5cbiAgaWYgKGZhYnJpYy5Db2xvcikge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuQ29sb3IgaXMgYWxyZWFkeSBkZWZpbmVkLicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xvciBjbGFzc1xuICAgKiBUaGUgcHVycG9zZSBvZiB7QGxpbmsgZmFicmljLkNvbG9yfSBpcyB0byBhYnN0cmFjdCBhbmQgZW5jYXBzdWxhdGUgY29tbW9uIGNvbG9yIG9wZXJhdGlvbnM7XG4gICAqIHtAbGluayBmYWJyaWMuQ29sb3J9IGlzIGEgY29uc3RydWN0b3IgYW5kIGNyZWF0ZXMgaW5zdGFuY2VzIG9mIHtAbGluayBmYWJyaWMuQ29sb3J9IG9iamVjdHMuXG4gICAqXG4gICAqIEBjbGFzcyBmYWJyaWMuQ29sb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIG9wdGlvbmFsIGluIGhleCBvciByZ2IoYSkgb3IgaHNsIGZvcm1hdCBvciBmcm9tIGtub3duIGNvbG9yIGxpc3RcbiAgICogQHJldHVybiB7ZmFicmljLkNvbG9yfSB0aGlzQXJnXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0yLyNjb2xvcnN9XG4gICAqL1xuICBmdW5jdGlvbiBDb2xvcihjb2xvcikge1xuICAgIGlmICghY29sb3IpIHtcbiAgICAgIHRoaXMuc2V0U291cmNlKFswLCAwLCAwLCAxXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5fdHJ5UGFyc2luZ0NvbG9yKGNvbG9yKTtcbiAgICB9XG4gIH1cblxuICBmYWJyaWMuQ29sb3IgPSBDb2xvcjtcblxuICBmYWJyaWMuQ29sb3IucHJvdG90eXBlID0gLyoqIEBsZW5kcyBmYWJyaWMuQ29sb3IucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGNvbG9yIENvbG9yIHZhbHVlIHRvIHBhcnNlXG4gICAgICovXG4gICAgX3RyeVBhcnNpbmdDb2xvcjogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgIHZhciBzb3VyY2U7XG5cbiAgICAgIGlmIChjb2xvciBpbiBDb2xvci5jb2xvck5hbWVNYXApIHtcbiAgICAgICAgY29sb3IgPSBDb2xvci5jb2xvck5hbWVNYXBbY29sb3JdO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29sb3IgPT09ICd0cmFuc3BhcmVudCcpIHtcbiAgICAgICAgc291cmNlID0gWzI1NSwgMjU1LCAyNTUsIDBdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBzb3VyY2UgPSBDb2xvci5zb3VyY2VGcm9tSGV4KGNvbG9yKTtcbiAgICAgIH1cbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHNvdXJjZSA9IENvbG9yLnNvdXJjZUZyb21SZ2IoY29sb3IpO1xuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgc291cmNlID0gQ29sb3Iuc291cmNlRnJvbUhzbChjb2xvcik7XG4gICAgICB9XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAvL2lmIGNvbG9yIGlzIG5vdCByZWNvZ25pemUgbGV0J3MgbWFrZSBibGFjayBhcyBjYW52YXMgZG9lc1xuICAgICAgICBzb3VyY2UgPSBbMCwgMCwgMCwgMV07XG4gICAgICB9XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIHRoaXMuc2V0U291cmNlKHNvdXJjZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkYXB0ZWQgZnJvbSA8YSBocmVmPVwiaHR0cHM6Ly9yYXdnaXRodWIuY29tL21qaWphY2tzb24vbWppamFja3Nvbi5naXRodWIuY29tL21hc3Rlci8yMDA4LzAyL3JnYi10by1oc2wtYW5kLXJnYi10by1oc3YtY29sb3ItbW9kZWwtY29udmVyc2lvbi1hbGdvcml0aG1zLWluLWphdmFzY3JpcHQuaHRtbFwiPmh0dHBzOi8vZ2l0aHViLmNvbS9tamlqYWNrc29uPC9hPlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHIgUmVkIGNvbG9yIHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGcgR3JlZW4gY29sb3IgdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYiBCbHVlIGNvbG9yIHZhbHVlXG4gICAgICogQHJldHVybiB7QXJyYXl9IEhzbCBjb2xvclxuICAgICAqL1xuICAgIF9yZ2JUb0hzbDogZnVuY3Rpb24ociwgZywgYikge1xuICAgICAgciAvPSAyNTU7IGcgLz0gMjU1OyBiIC89IDI1NTtcblxuICAgICAgdmFyIGgsIHMsIGwsXG4gICAgICAgICAgbWF4ID0gZmFicmljLnV0aWwuYXJyYXkubWF4KFtyLCBnLCBiXSksXG4gICAgICAgICAgbWluID0gZmFicmljLnV0aWwuYXJyYXkubWluKFtyLCBnLCBiXSk7XG5cbiAgICAgIGwgPSAobWF4ICsgbWluKSAvIDI7XG5cbiAgICAgIGlmIChtYXggPT09IG1pbikge1xuICAgICAgICBoID0gcyA9IDA7IC8vIGFjaHJvbWF0aWNcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgZCA9IG1heCAtIG1pbjtcbiAgICAgICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xuICAgICAgICBzd2l0Y2ggKG1heCkge1xuICAgICAgICAgIGNhc2UgcjpcbiAgICAgICAgICAgIGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgZzpcbiAgICAgICAgICAgIGggPSAoYiAtIHIpIC8gZCArIDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGI6XG4gICAgICAgICAgICBoID0gKHIgLSBnKSAvIGQgKyA0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaCAvPSA2O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBNYXRoLnJvdW5kKGggKiAzNjApLFxuICAgICAgICBNYXRoLnJvdW5kKHMgKiAxMDApLFxuICAgICAgICBNYXRoLnJvdW5kKGwgKiAxMDApXG4gICAgICBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHNvdXJjZSBvZiB0aGlzIGNvbG9yICh3aGVyZSBzb3VyY2UgaXMgYW4gYXJyYXkgcmVwcmVzZW50YXRpb247IGV4OiBbMjAwLCAyMDAsIDEwMCwgMV0pXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZ2V0U291cmNlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zb3VyY2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgc291cmNlIG9mIHRoaXMgY29sb3IgKHdoZXJlIHNvdXJjZSBpcyBhbiBhcnJheSByZXByZXNlbnRhdGlvbjsgZXg6IFsyMDAsIDIwMCwgMTAwLCAxXSlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2VcbiAgICAgKi9cbiAgICBzZXRTb3VyY2U6IGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbG9yIHJlcHJlc2VudGF0aW9uIGluIFJHQiBmb3JtYXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGV4OiByZ2IoMC0yNTUsMC0yNTUsMC0yNTUpXG4gICAgICovXG4gICAgdG9SZ2I6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCk7XG4gICAgICByZXR1cm4gJ3JnYignICsgc291cmNlWzBdICsgJywnICsgc291cmNlWzFdICsgJywnICsgc291cmNlWzJdICsgJyknO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbG9yIHJlcHJlc2VudGF0aW9uIGluIFJHQkEgZm9ybWF0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBleDogcmdiYSgwLTI1NSwwLTI1NSwwLTI1NSwwLTEpXG4gICAgICovXG4gICAgdG9SZ2JhOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpO1xuICAgICAgcmV0dXJuICdyZ2JhKCcgKyBzb3VyY2VbMF0gKyAnLCcgKyBzb3VyY2VbMV0gKyAnLCcgKyBzb3VyY2VbMl0gKyAnLCcgKyBzb3VyY2VbM10gKyAnKSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29sb3IgcmVwcmVzZW50YXRpb24gaW4gSFNMIGZvcm1hdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gZXg6IGhzbCgwLTM2MCwwJS0xMDAlLDAlLTEwMCUpXG4gICAgICovXG4gICAgdG9Ic2w6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCksXG4gICAgICAgICAgaHNsID0gdGhpcy5fcmdiVG9Ic2woc291cmNlWzBdLCBzb3VyY2VbMV0sIHNvdXJjZVsyXSk7XG5cbiAgICAgIHJldHVybiAnaHNsKCcgKyBoc2xbMF0gKyAnLCcgKyBoc2xbMV0gKyAnJSwnICsgaHNsWzJdICsgJyUpJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb2xvciByZXByZXNlbnRhdGlvbiBpbiBIU0xBIGZvcm1hdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gZXg6IGhzbGEoMC0zNjAsMCUtMTAwJSwwJS0xMDAlLDAtMSlcbiAgICAgKi9cbiAgICB0b0hzbGE6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCksXG4gICAgICAgICAgaHNsID0gdGhpcy5fcmdiVG9Ic2woc291cmNlWzBdLCBzb3VyY2VbMV0sIHNvdXJjZVsyXSk7XG5cbiAgICAgIHJldHVybiAnaHNsYSgnICsgaHNsWzBdICsgJywnICsgaHNsWzFdICsgJyUsJyArIGhzbFsyXSArICclLCcgKyBzb3VyY2VbM10gKyAnKSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29sb3IgcmVwcmVzZW50YXRpb24gaW4gSEVYIGZvcm1hdFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gZXg6IEZGNTU1NVxuICAgICAqL1xuICAgIHRvSGV4OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLCByLCBnLCBiO1xuXG4gICAgICByID0gc291cmNlWzBdLnRvU3RyaW5nKDE2KTtcbiAgICAgIHIgPSAoci5sZW5ndGggPT09IDEpID8gKCcwJyArIHIpIDogcjtcblxuICAgICAgZyA9IHNvdXJjZVsxXS50b1N0cmluZygxNik7XG4gICAgICBnID0gKGcubGVuZ3RoID09PSAxKSA/ICgnMCcgKyBnKSA6IGc7XG5cbiAgICAgIGIgPSBzb3VyY2VbMl0udG9TdHJpbmcoMTYpO1xuICAgICAgYiA9IChiLmxlbmd0aCA9PT0gMSkgPyAoJzAnICsgYikgOiBiO1xuXG4gICAgICByZXR1cm4gci50b1VwcGVyQ2FzZSgpICsgZy50b1VwcGVyQ2FzZSgpICsgYi50b1VwcGVyQ2FzZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbG9yIHJlcHJlc2VudGF0aW9uIGluIEhFWEEgZm9ybWF0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBleDogRkY1NTU1Q0NcbiAgICAgKi9cbiAgICB0b0hleGE6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCksIGE7XG5cbiAgICAgIGEgPSBNYXRoLnJvdW5kKHNvdXJjZVszXSAqIDI1NSk7XG4gICAgICBhID0gYS50b1N0cmluZygxNik7XG4gICAgICBhID0gKGEubGVuZ3RoID09PSAxKSA/ICgnMCcgKyBhKSA6IGE7XG5cbiAgICAgIHJldHVybiB0aGlzLnRvSGV4KCkgKyBhLnRvVXBwZXJDYXNlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdmFsdWUgb2YgYWxwaGEgY2hhbm5lbCBmb3IgdGhpcyBjb2xvclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gMC0xXG4gICAgICovXG4gICAgZ2V0QWxwaGE6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0U291cmNlKClbM107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdmFsdWUgb2YgYWxwaGEgY2hhbm5lbCBmb3IgdGhpcyBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbHBoYSBBbHBoYSB2YWx1ZSAwLTFcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBzZXRBbHBoYTogZnVuY3Rpb24oYWxwaGEpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpO1xuICAgICAgc291cmNlWzNdID0gYWxwaGE7XG4gICAgICB0aGlzLnNldFNvdXJjZShzb3VyY2UpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgY29sb3IgdG8gaXRzIGdyYXlzY2FsZSByZXByZXNlbnRhdGlvblxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn0gdGhpc0FyZ1xuICAgICAqL1xuICAgIHRvR3JheXNjYWxlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZSgpLFxuICAgICAgICAgIGF2ZXJhZ2UgPSBwYXJzZUludCgoc291cmNlWzBdICogMC4zICsgc291cmNlWzFdICogMC41OSArIHNvdXJjZVsyXSAqIDAuMTEpLnRvRml4ZWQoMCksIDEwKSxcbiAgICAgICAgICBjdXJyZW50QWxwaGEgPSBzb3VyY2VbM107XG4gICAgICB0aGlzLnNldFNvdXJjZShbYXZlcmFnZSwgYXZlcmFnZSwgYXZlcmFnZSwgY3VycmVudEFscGhhXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBjb2xvciB0byBpdHMgYmxhY2sgYW5kIHdoaXRlIHJlcHJlc2VudGF0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRocmVzaG9sZFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn0gdGhpc0FyZ1xuICAgICAqL1xuICAgIHRvQmxhY2tXaGl0ZTogZnVuY3Rpb24odGhyZXNob2xkKSB7XG4gICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRTb3VyY2UoKSxcbiAgICAgICAgICBhdmVyYWdlID0gKHNvdXJjZVswXSAqIDAuMyArIHNvdXJjZVsxXSAqIDAuNTkgKyBzb3VyY2VbMl0gKiAwLjExKS50b0ZpeGVkKDApLFxuICAgICAgICAgIGN1cnJlbnRBbHBoYSA9IHNvdXJjZVszXTtcblxuICAgICAgdGhyZXNob2xkID0gdGhyZXNob2xkIHx8IDEyNztcblxuICAgICAgYXZlcmFnZSA9IChOdW1iZXIoYXZlcmFnZSkgPCBOdW1iZXIodGhyZXNob2xkKSkgPyAwIDogMjU1O1xuICAgICAgdGhpcy5zZXRTb3VyY2UoW2F2ZXJhZ2UsIGF2ZXJhZ2UsIGF2ZXJhZ2UsIGN1cnJlbnRBbHBoYV0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE92ZXJsYXlzIGNvbG9yIHdpdGggYW5vdGhlciBjb2xvclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfGZhYnJpYy5Db2xvcn0gb3RoZXJDb2xvclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn0gdGhpc0FyZ1xuICAgICAqL1xuICAgIG92ZXJsYXlXaXRoOiBmdW5jdGlvbihvdGhlckNvbG9yKSB7XG4gICAgICBpZiAoIShvdGhlckNvbG9yIGluc3RhbmNlb2YgQ29sb3IpKSB7XG4gICAgICAgIG90aGVyQ29sb3IgPSBuZXcgQ29sb3Iob3RoZXJDb2xvcik7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICBhbHBoYSA9IHRoaXMuZ2V0QWxwaGEoKSxcbiAgICAgICAgICBvdGhlckFscGhhID0gMC41LFxuICAgICAgICAgIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCksXG4gICAgICAgICAgb3RoZXJTb3VyY2UgPSBvdGhlckNvbG9yLmdldFNvdXJjZSgpLCBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKE1hdGgucm91bmQoKHNvdXJjZVtpXSAqICgxIC0gb3RoZXJBbHBoYSkpICsgKG90aGVyU291cmNlW2ldICogb3RoZXJBbHBoYSkpKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0WzNdID0gYWxwaGE7XG4gICAgICB0aGlzLnNldFNvdXJjZShyZXN1bHQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZWdleCBtYXRjaGluZyBjb2xvciBpbiBSR0Igb3IgUkdCQSBmb3JtYXRzIChleDogcmdiKDAsIDAsIDApLCByZ2JhKDI1NSwgMTAwLCAxMCwgMC41KSwgcmdiYSggMjU1ICwgMTAwICwgMTAgLCAwLjUgKSwgcmdiKDEsMSwxKSwgcmdiYSgxMDAlLCA2MCUsIDEwJSwgMC41KSlcbiAgICogQHN0YXRpY1xuICAgKiBAZmllbGRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgZmFicmljLkNvbG9yLnJlUkdCYSA9IC9ecmdiYT9cXChcXHMqKFxcZHsxLDN9KD86XFwuXFxkKyk/XFwlPylcXHMqLFxccyooXFxkezEsM30oPzpcXC5cXGQrKT9cXCU/KVxccyosXFxzKihcXGR7MSwzfSg/OlxcLlxcZCspP1xcJT8pXFxzKig/OlxccyosXFxzKigoPzpcXGQqXFwuP1xcZCspPylcXHMqKT9cXCkkL2k7XG5cbiAgLyoqXG4gICAqIFJlZ2V4IG1hdGNoaW5nIGNvbG9yIGluIEhTTCBvciBIU0xBIGZvcm1hdHMgKGV4OiBoc2woMjAwLCA4MCUsIDEwJSksIGhzbGEoMzAwLCA1MCUsIDgwJSwgMC41KSwgaHNsYSggMzAwICwgNTAlICwgODAlICwgMC41ICkpXG4gICAqIEBzdGF0aWNcbiAgICogQGZpZWxkXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICovXG4gIGZhYnJpYy5Db2xvci5yZUhTTGEgPSAvXmhzbGE/XFwoXFxzKihcXGR7MSwzfSlcXHMqLFxccyooXFxkezEsM31cXCUpXFxzKixcXHMqKFxcZHsxLDN9XFwlKVxccyooPzpcXHMqLFxccyooXFxkKyg/OlxcLlxcZCspPylcXHMqKT9cXCkkL2k7XG5cbiAgLyoqXG4gICAqIFJlZ2V4IG1hdGNoaW5nIGNvbG9yIGluIEhFWCBmb3JtYXQgKGV4OiAjRkY1NTQ0Q0MsICNGRjU1NTUsIDAxMDE1NSwgYWZmKVxuICAgKiBAc3RhdGljXG4gICAqIEBmaWVsZFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqL1xuICBmYWJyaWMuQ29sb3IucmVIZXggPSAvXiM/KFswLTlhLWZdezh9fFswLTlhLWZdezZ9fFswLTlhLWZdezR9fFswLTlhLWZdezN9KSQvaTtcblxuICAvKipcbiAgICogTWFwIG9mIHRoZSAxNDggY29sb3IgbmFtZXMgd2l0aCBIRVggY29kZVxuICAgKiBAc3RhdGljXG4gICAqIEBmaWVsZFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBzZWU6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yLyNzdmctY29sb3JcbiAgICovXG4gIGZhYnJpYy5Db2xvci5jb2xvck5hbWVNYXAgPSB7XG4gICAgYWxpY2VibHVlOiAgICAgICAgICAgICcjRjBGOEZGJyxcbiAgICBhbnRpcXVld2hpdGU6ICAgICAgICAgJyNGQUVCRDcnLFxuICAgIGFxdWE6ICAgICAgICAgICAgICAgICAnIzAwRkZGRicsXG4gICAgYXF1YW1hcmluZTogICAgICAgICAgICcjN0ZGRkQ0JyxcbiAgICBhenVyZTogICAgICAgICAgICAgICAgJyNGMEZGRkYnLFxuICAgIGJlaWdlOiAgICAgICAgICAgICAgICAnI0Y1RjVEQycsXG4gICAgYmlzcXVlOiAgICAgICAgICAgICAgICcjRkZFNEM0JyxcbiAgICBibGFjazogICAgICAgICAgICAgICAgJyMwMDAwMDAnLFxuICAgIGJsYW5jaGVkYWxtb25kOiAgICAgICAnI0ZGRUJDRCcsXG4gICAgYmx1ZTogICAgICAgICAgICAgICAgICcjMDAwMEZGJyxcbiAgICBibHVldmlvbGV0OiAgICAgICAgICAgJyM4QTJCRTInLFxuICAgIGJyb3duOiAgICAgICAgICAgICAgICAnI0E1MkEyQScsXG4gICAgYnVybHl3b29kOiAgICAgICAgICAgICcjREVCODg3JyxcbiAgICBjYWRldGJsdWU6ICAgICAgICAgICAgJyM1RjlFQTAnLFxuICAgIGNoYXJ0cmV1c2U6ICAgICAgICAgICAnIzdGRkYwMCcsXG4gICAgY2hvY29sYXRlOiAgICAgICAgICAgICcjRDI2OTFFJyxcbiAgICBjb3JhbDogICAgICAgICAgICAgICAgJyNGRjdGNTAnLFxuICAgIGNvcm5mbG93ZXJibHVlOiAgICAgICAnIzY0OTVFRCcsXG4gICAgY29ybnNpbGs6ICAgICAgICAgICAgICcjRkZGOERDJyxcbiAgICBjcmltc29uOiAgICAgICAgICAgICAgJyNEQzE0M0MnLFxuICAgIGN5YW46ICAgICAgICAgICAgICAgICAnIzAwRkZGRicsXG4gICAgZGFya2JsdWU6ICAgICAgICAgICAgICcjMDAwMDhCJyxcbiAgICBkYXJrY3lhbjogICAgICAgICAgICAgJyMwMDhCOEInLFxuICAgIGRhcmtnb2xkZW5yb2Q6ICAgICAgICAnI0I4ODYwQicsXG4gICAgZGFya2dyYXk6ICAgICAgICAgICAgICcjQTlBOUE5JyxcbiAgICBkYXJrZ3JleTogICAgICAgICAgICAgJyNBOUE5QTknLFxuICAgIGRhcmtncmVlbjogICAgICAgICAgICAnIzAwNjQwMCcsXG4gICAgZGFya2toYWtpOiAgICAgICAgICAgICcjQkRCNzZCJyxcbiAgICBkYXJrbWFnZW50YTogICAgICAgICAgJyM4QjAwOEInLFxuICAgIGRhcmtvbGl2ZWdyZWVuOiAgICAgICAnIzU1NkIyRicsXG4gICAgZGFya29yYW5nZTogICAgICAgICAgICcjRkY4QzAwJyxcbiAgICBkYXJrb3JjaGlkOiAgICAgICAgICAgJyM5OTMyQ0MnLFxuICAgIGRhcmtyZWQ6ICAgICAgICAgICAgICAnIzhCMDAwMCcsXG4gICAgZGFya3NhbG1vbjogICAgICAgICAgICcjRTk5NjdBJyxcbiAgICBkYXJrc2VhZ3JlZW46ICAgICAgICAgJyM4RkJDOEYnLFxuICAgIGRhcmtzbGF0ZWJsdWU6ICAgICAgICAnIzQ4M0Q4QicsXG4gICAgZGFya3NsYXRlZ3JheTogICAgICAgICcjMkY0RjRGJyxcbiAgICBkYXJrc2xhdGVncmV5OiAgICAgICAgJyMyRjRGNEYnLFxuICAgIGRhcmt0dXJxdW9pc2U6ICAgICAgICAnIzAwQ0VEMScsXG4gICAgZGFya3Zpb2xldDogICAgICAgICAgICcjOTQwMEQzJyxcbiAgICBkZWVwcGluazogICAgICAgICAgICAgJyNGRjE0OTMnLFxuICAgIGRlZXBza3libHVlOiAgICAgICAgICAnIzAwQkZGRicsXG4gICAgZGltZ3JheTogICAgICAgICAgICAgICcjNjk2OTY5JyxcbiAgICBkaW1ncmV5OiAgICAgICAgICAgICAgJyM2OTY5NjknLFxuICAgIGRvZGdlcmJsdWU6ICAgICAgICAgICAnIzFFOTBGRicsXG4gICAgZmlyZWJyaWNrOiAgICAgICAgICAgICcjQjIyMjIyJyxcbiAgICBmbG9yYWx3aGl0ZTogICAgICAgICAgJyNGRkZBRjAnLFxuICAgIGZvcmVzdGdyZWVuOiAgICAgICAgICAnIzIyOEIyMicsXG4gICAgZnVjaHNpYTogICAgICAgICAgICAgICcjRkYwMEZGJyxcbiAgICBnYWluc2Jvcm86ICAgICAgICAgICAgJyNEQ0RDREMnLFxuICAgIGdob3N0d2hpdGU6ICAgICAgICAgICAnI0Y4RjhGRicsXG4gICAgZ29sZDogICAgICAgICAgICAgICAgICcjRkZENzAwJyxcbiAgICBnb2xkZW5yb2Q6ICAgICAgICAgICAgJyNEQUE1MjAnLFxuICAgIGdyYXk6ICAgICAgICAgICAgICAgICAnIzgwODA4MCcsXG4gICAgZ3JleTogICAgICAgICAgICAgICAgICcjODA4MDgwJyxcbiAgICBncmVlbjogICAgICAgICAgICAgICAgJyMwMDgwMDAnLFxuICAgIGdyZWVueWVsbG93OiAgICAgICAgICAnI0FERkYyRicsXG4gICAgaG9uZXlkZXc6ICAgICAgICAgICAgICcjRjBGRkYwJyxcbiAgICBob3RwaW5rOiAgICAgICAgICAgICAgJyNGRjY5QjQnLFxuICAgIGluZGlhbnJlZDogICAgICAgICAgICAnI0NENUM1QycsXG4gICAgaW5kaWdvOiAgICAgICAgICAgICAgICcjNEIwMDgyJyxcbiAgICBpdm9yeTogICAgICAgICAgICAgICAgJyNGRkZGRjAnLFxuICAgIGtoYWtpOiAgICAgICAgICAgICAgICAnI0YwRTY4QycsXG4gICAgbGF2ZW5kZXI6ICAgICAgICAgICAgICcjRTZFNkZBJyxcbiAgICBsYXZlbmRlcmJsdXNoOiAgICAgICAgJyNGRkYwRjUnLFxuICAgIGxhd25ncmVlbjogICAgICAgICAgICAnIzdDRkMwMCcsXG4gICAgbGVtb25jaGlmZm9uOiAgICAgICAgICcjRkZGQUNEJyxcbiAgICBsaWdodGJsdWU6ICAgICAgICAgICAgJyNBREQ4RTYnLFxuICAgIGxpZ2h0Y29yYWw6ICAgICAgICAgICAnI0YwODA4MCcsXG4gICAgbGlnaHRjeWFuOiAgICAgICAgICAgICcjRTBGRkZGJyxcbiAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogJyNGQUZBRDInLFxuICAgIGxpZ2h0Z3JheTogICAgICAgICAgICAnI0QzRDNEMycsXG4gICAgbGlnaHRncmV5OiAgICAgICAgICAgICcjRDNEM0QzJyxcbiAgICBsaWdodGdyZWVuOiAgICAgICAgICAgJyM5MEVFOTAnLFxuICAgIGxpZ2h0cGluazogICAgICAgICAgICAnI0ZGQjZDMScsXG4gICAgbGlnaHRzYWxtb246ICAgICAgICAgICcjRkZBMDdBJyxcbiAgICBsaWdodHNlYWdyZWVuOiAgICAgICAgJyMyMEIyQUEnLFxuICAgIGxpZ2h0c2t5Ymx1ZTogICAgICAgICAnIzg3Q0VGQScsXG4gICAgbGlnaHRzbGF0ZWdyYXk6ICAgICAgICcjNzc4ODk5JyxcbiAgICBsaWdodHNsYXRlZ3JleTogICAgICAgJyM3Nzg4OTknLFxuICAgIGxpZ2h0c3RlZWxibHVlOiAgICAgICAnI0IwQzRERScsXG4gICAgbGlnaHR5ZWxsb3c6ICAgICAgICAgICcjRkZGRkUwJyxcbiAgICBsaW1lOiAgICAgICAgICAgICAgICAgJyMwMEZGMDAnLFxuICAgIGxpbWVncmVlbjogICAgICAgICAgICAnIzMyQ0QzMicsXG4gICAgbGluZW46ICAgICAgICAgICAgICAgICcjRkFGMEU2JyxcbiAgICBtYWdlbnRhOiAgICAgICAgICAgICAgJyNGRjAwRkYnLFxuICAgIG1hcm9vbjogICAgICAgICAgICAgICAnIzgwMDAwMCcsXG4gICAgbWVkaXVtYXF1YW1hcmluZTogICAgICcjNjZDREFBJyxcbiAgICBtZWRpdW1ibHVlOiAgICAgICAgICAgJyMwMDAwQ0QnLFxuICAgIG1lZGl1bW9yY2hpZDogICAgICAgICAnI0JBNTVEMycsXG4gICAgbWVkaXVtcHVycGxlOiAgICAgICAgICcjOTM3MERCJyxcbiAgICBtZWRpdW1zZWFncmVlbjogICAgICAgJyMzQ0IzNzEnLFxuICAgIG1lZGl1bXNsYXRlYmx1ZTogICAgICAnIzdCNjhFRScsXG4gICAgbWVkaXVtc3ByaW5nZ3JlZW46ICAgICcjMDBGQTlBJyxcbiAgICBtZWRpdW10dXJxdW9pc2U6ICAgICAgJyM0OEQxQ0MnLFxuICAgIG1lZGl1bXZpb2xldHJlZDogICAgICAnI0M3MTU4NScsXG4gICAgbWlkbmlnaHRibHVlOiAgICAgICAgICcjMTkxOTcwJyxcbiAgICBtaW50Y3JlYW06ICAgICAgICAgICAgJyNGNUZGRkEnLFxuICAgIG1pc3R5cm9zZTogICAgICAgICAgICAnI0ZGRTRFMScsXG4gICAgbW9jY2FzaW46ICAgICAgICAgICAgICcjRkZFNEI1JyxcbiAgICBuYXZham93aGl0ZTogICAgICAgICAgJyNGRkRFQUQnLFxuICAgIG5hdnk6ICAgICAgICAgICAgICAgICAnIzAwMDA4MCcsXG4gICAgb2xkbGFjZTogICAgICAgICAgICAgICcjRkRGNUU2JyxcbiAgICBvbGl2ZTogICAgICAgICAgICAgICAgJyM4MDgwMDAnLFxuICAgIG9saXZlZHJhYjogICAgICAgICAgICAnIzZCOEUyMycsXG4gICAgb3JhbmdlOiAgICAgICAgICAgICAgICcjRkZBNTAwJyxcbiAgICBvcmFuZ2VyZWQ6ICAgICAgICAgICAgJyNGRjQ1MDAnLFxuICAgIG9yY2hpZDogICAgICAgICAgICAgICAnI0RBNzBENicsXG4gICAgcGFsZWdvbGRlbnJvZDogICAgICAgICcjRUVFOEFBJyxcbiAgICBwYWxlZ3JlZW46ICAgICAgICAgICAgJyM5OEZCOTgnLFxuICAgIHBhbGV0dXJxdW9pc2U6ICAgICAgICAnI0FGRUVFRScsXG4gICAgcGFsZXZpb2xldHJlZDogICAgICAgICcjREI3MDkzJyxcbiAgICBwYXBheWF3aGlwOiAgICAgICAgICAgJyNGRkVGRDUnLFxuICAgIHBlYWNocHVmZjogICAgICAgICAgICAnI0ZGREFCOScsXG4gICAgcGVydTogICAgICAgICAgICAgICAgICcjQ0Q4NTNGJyxcbiAgICBwaW5rOiAgICAgICAgICAgICAgICAgJyNGRkMwQ0InLFxuICAgIHBsdW06ICAgICAgICAgICAgICAgICAnI0REQTBERCcsXG4gICAgcG93ZGVyYmx1ZTogICAgICAgICAgICcjQjBFMEU2JyxcbiAgICBwdXJwbGU6ICAgICAgICAgICAgICAgJyM4MDAwODAnLFxuICAgIHJlYmVjY2FwdXJwbGU6ICAgICAgICAnIzY2MzM5OScsXG4gICAgcmVkOiAgICAgICAgICAgICAgICAgICcjRkYwMDAwJyxcbiAgICByb3N5YnJvd246ICAgICAgICAgICAgJyNCQzhGOEYnLFxuICAgIHJveWFsYmx1ZTogICAgICAgICAgICAnIzQxNjlFMScsXG4gICAgc2FkZGxlYnJvd246ICAgICAgICAgICcjOEI0NTEzJyxcbiAgICBzYWxtb246ICAgICAgICAgICAgICAgJyNGQTgwNzInLFxuICAgIHNhbmR5YnJvd246ICAgICAgICAgICAnI0Y0QTQ2MCcsXG4gICAgc2VhZ3JlZW46ICAgICAgICAgICAgICcjMkU4QjU3JyxcbiAgICBzZWFzaGVsbDogICAgICAgICAgICAgJyNGRkY1RUUnLFxuICAgIHNpZW5uYTogICAgICAgICAgICAgICAnI0EwNTIyRCcsXG4gICAgc2lsdmVyOiAgICAgICAgICAgICAgICcjQzBDMEMwJyxcbiAgICBza3libHVlOiAgICAgICAgICAgICAgJyM4N0NFRUInLFxuICAgIHNsYXRlYmx1ZTogICAgICAgICAgICAnIzZBNUFDRCcsXG4gICAgc2xhdGVncmF5OiAgICAgICAgICAgICcjNzA4MDkwJyxcbiAgICBzbGF0ZWdyZXk6ICAgICAgICAgICAgJyM3MDgwOTAnLFxuICAgIHNub3c6ICAgICAgICAgICAgICAgICAnI0ZGRkFGQScsXG4gICAgc3ByaW5nZ3JlZW46ICAgICAgICAgICcjMDBGRjdGJyxcbiAgICBzdGVlbGJsdWU6ICAgICAgICAgICAgJyM0NjgyQjQnLFxuICAgIHRhbjogICAgICAgICAgICAgICAgICAnI0QyQjQ4QycsXG4gICAgdGVhbDogICAgICAgICAgICAgICAgICcjMDA4MDgwJyxcbiAgICB0aGlzdGxlOiAgICAgICAgICAgICAgJyNEOEJGRDgnLFxuICAgIHRvbWF0bzogICAgICAgICAgICAgICAnI0ZGNjM0NycsXG4gICAgdHVycXVvaXNlOiAgICAgICAgICAgICcjNDBFMEQwJyxcbiAgICB2aW9sZXQ6ICAgICAgICAgICAgICAgJyNFRTgyRUUnLFxuICAgIHdoZWF0OiAgICAgICAgICAgICAgICAnI0Y1REVCMycsXG4gICAgd2hpdGU6ICAgICAgICAgICAgICAgICcjRkZGRkZGJyxcbiAgICB3aGl0ZXNtb2tlOiAgICAgICAgICAgJyNGNUY1RjUnLFxuICAgIHllbGxvdzogICAgICAgICAgICAgICAnI0ZGRkYwMCcsXG4gICAgeWVsbG93Z3JlZW46ICAgICAgICAgICcjOUFDRDMyJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gcFxuICAgKiBAcGFyYW0ge051bWJlcn0gcVxuICAgKiBAcGFyYW0ge051bWJlcn0gdFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBmdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcbiAgICBpZiAodCA8IDApIHtcbiAgICAgIHQgKz0gMTtcbiAgICB9XG4gICAgaWYgKHQgPiAxKSB7XG4gICAgICB0IC09IDE7XG4gICAgfVxuICAgIGlmICh0IDwgMSAvIDYpIHtcbiAgICAgIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICAgIH1cbiAgICBpZiAodCA8IDEgLyAyKSB7XG4gICAgICByZXR1cm4gcTtcbiAgICB9XG4gICAgaWYgKHQgPCAyIC8gMykge1xuICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2O1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5ldyBjb2xvciBvYmplY3QsIHdoZW4gZ2l2ZW4gYSBjb2xvciBpbiBSR0IgZm9ybWF0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIENvbG9yIHZhbHVlIGV4OiByZ2IoMC0yNTUsMC0yNTUsMC0yNTUpXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn1cbiAgICovXG4gIGZhYnJpYy5Db2xvci5mcm9tUmdiID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICByZXR1cm4gQ29sb3IuZnJvbVNvdXJjZShDb2xvci5zb3VyY2VGcm9tUmdiKGNvbG9yKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYXJyYXkgcmVwcmVzZW50YXRpb24gKGV4OiBbMTAwLCAxMDAsIDIwMCwgMV0pIG9mIGEgY29sb3IgdGhhdCdzIGluIFJHQiBvciBSR0JBIGZvcm1hdFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBDb2xvciB2YWx1ZSBleDogcmdiKDAtMjU1LDAtMjU1LDAtMjU1KSwgcmdiKDAlLTEwMCUsMCUtMTAwJSwwJS0xMDAlKVxuICAgKiBAcmV0dXJuIHtBcnJheX0gc291cmNlXG4gICAqL1xuICBmYWJyaWMuQ29sb3Iuc291cmNlRnJvbVJnYiA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgdmFyIG1hdGNoID0gY29sb3IubWF0Y2goQ29sb3IucmVSR0JhKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhciByID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKSAvICgvJSQvLnRlc3QobWF0Y2hbMV0pID8gMTAwIDogMSkgKiAoLyUkLy50ZXN0KG1hdGNoWzFdKSA/IDI1NSA6IDEpLFxuICAgICAgICAgIGcgPSBwYXJzZUludChtYXRjaFsyXSwgMTApIC8gKC8lJC8udGVzdChtYXRjaFsyXSkgPyAxMDAgOiAxKSAqICgvJSQvLnRlc3QobWF0Y2hbMl0pID8gMjU1IDogMSksXG4gICAgICAgICAgYiA9IHBhcnNlSW50KG1hdGNoWzNdLCAxMCkgLyAoLyUkLy50ZXN0KG1hdGNoWzNdKSA/IDEwMCA6IDEpICogKC8lJC8udGVzdChtYXRjaFszXSkgPyAyNTUgOiAxKTtcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgcGFyc2VJbnQociwgMTApLFxuICAgICAgICBwYXJzZUludChnLCAxMCksXG4gICAgICAgIHBhcnNlSW50KGIsIDEwKSxcbiAgICAgICAgbWF0Y2hbNF0gPyBwYXJzZUZsb2F0KG1hdGNoWzRdKSA6IDFcbiAgICAgIF07XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5ldyBjb2xvciBvYmplY3QsIHdoZW4gZ2l2ZW4gYSBjb2xvciBpbiBSR0JBIGZvcm1hdFxuICAgKiBAc3RhdGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvclxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9XG4gICAqL1xuICBmYWJyaWMuQ29sb3IuZnJvbVJnYmEgPSBDb2xvci5mcm9tUmdiO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5ldyBjb2xvciBvYmplY3QsIHdoZW4gZ2l2ZW4gYSBjb2xvciBpbiBIU0wgZm9ybWF0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBDb2xvciB2YWx1ZSBleDogaHNsKDAtMjYwLDAlLTEwMCUsMCUtMTAwJSlcbiAgICogQG1lbWJlck9mIGZhYnJpYy5Db2xvclxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9XG4gICAqL1xuICBmYWJyaWMuQ29sb3IuZnJvbUhzbCA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgcmV0dXJuIENvbG9yLmZyb21Tb3VyY2UoQ29sb3Iuc291cmNlRnJvbUhzbChjb2xvcikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFycmF5IHJlcHJlc2VudGF0aW9uIChleDogWzEwMCwgMTAwLCAyMDAsIDFdKSBvZiBhIGNvbG9yIHRoYXQncyBpbiBIU0wgb3IgSFNMQSBmb3JtYXQuXG4gICAqIEFkYXB0ZWQgZnJvbSA8YSBocmVmPVwiaHR0cHM6Ly9yYXdnaXRodWIuY29tL21qaWphY2tzb24vbWppamFja3Nvbi5naXRodWIuY29tL21hc3Rlci8yMDA4LzAyL3JnYi10by1oc2wtYW5kLXJnYi10by1oc3YtY29sb3ItbW9kZWwtY29udmVyc2lvbi1hbGdvcml0aG1zLWluLWphdmFzY3JpcHQuaHRtbFwiPmh0dHBzOi8vZ2l0aHViLmNvbS9tamlqYWNrc29uPC9hPlxuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBDb2xvciB2YWx1ZSBleDogaHNsKDAtMzYwLDAlLTEwMCUsMCUtMTAwJSkgb3IgaHNsYSgwLTM2MCwwJS0xMDAlLDAlLTEwMCUsIDAtMSlcbiAgICogQHJldHVybiB7QXJyYXl9IHNvdXJjZVxuICAgKiBAc2VlIGh0dHA6Ly9odHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yLyNoc2wtY29sb3JcbiAgICovXG4gIGZhYnJpYy5Db2xvci5zb3VyY2VGcm9tSHNsID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICB2YXIgbWF0Y2ggPSBjb2xvci5tYXRjaChDb2xvci5yZUhTTGEpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaCA9ICgoKHBhcnNlRmxvYXQobWF0Y2hbMV0pICUgMzYwKSArIDM2MCkgJSAzNjApIC8gMzYwLFxuICAgICAgICBzID0gcGFyc2VGbG9hdChtYXRjaFsyXSkgLyAoLyUkLy50ZXN0KG1hdGNoWzJdKSA/IDEwMCA6IDEpLFxuICAgICAgICBsID0gcGFyc2VGbG9hdChtYXRjaFszXSkgLyAoLyUkLy50ZXN0KG1hdGNoWzNdKSA/IDEwMCA6IDEpLFxuICAgICAgICByLCBnLCBiO1xuXG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIHIgPSBnID0gYiA9IGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHEgPSBsIDw9IDAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcyxcbiAgICAgICAgICBwID0gbCAqIDIgLSBxO1xuXG4gICAgICByID0gaHVlMnJnYihwLCBxLCBoICsgMSAvIDMpO1xuICAgICAgZyA9IGh1ZTJyZ2IocCwgcSwgaCk7XG4gICAgICBiID0gaHVlMnJnYihwLCBxLCBoIC0gMSAvIDMpO1xuICAgIH1cblxuICAgIHJldHVybiBbXG4gICAgICBNYXRoLnJvdW5kKHIgKiAyNTUpLFxuICAgICAgTWF0aC5yb3VuZChnICogMjU1KSxcbiAgICAgIE1hdGgucm91bmQoYiAqIDI1NSksXG4gICAgICBtYXRjaFs0XSA/IHBhcnNlRmxvYXQobWF0Y2hbNF0pIDogMVxuICAgIF07XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbmV3IGNvbG9yIG9iamVjdCwgd2hlbiBnaXZlbiBhIGNvbG9yIGluIEhTTEEgZm9ybWF0XG4gICAqIEBzdGF0aWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ29sb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn1cbiAgICovXG4gIGZhYnJpYy5Db2xvci5mcm9tSHNsYSA9IENvbG9yLmZyb21Ic2w7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbmV3IGNvbG9yIG9iamVjdCwgd2hlbiBnaXZlbiBhIGNvbG9yIGluIEhFWCBmb3JtYXRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBDb2xvciB2YWx1ZSBleDogRkY1NTU1XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Db2xvcn1cbiAgICovXG4gIGZhYnJpYy5Db2xvci5mcm9tSGV4ID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICByZXR1cm4gQ29sb3IuZnJvbVNvdXJjZShDb2xvci5zb3VyY2VGcm9tSGV4KGNvbG9yKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYXJyYXkgcmVwcmVzZW50YXRpb24gKGV4OiBbMTAwLCAxMDAsIDIwMCwgMV0pIG9mIGEgY29sb3IgdGhhdCdzIGluIEhFWCBmb3JtYXRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBleDogRkY1NTU1IG9yIEZGNTU0NENDIChSR0JhKVxuICAgKiBAcmV0dXJuIHtBcnJheX0gc291cmNlXG4gICAqL1xuICBmYWJyaWMuQ29sb3Iuc291cmNlRnJvbUhleCA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgaWYgKGNvbG9yLm1hdGNoKENvbG9yLnJlSGV4KSkge1xuICAgICAgdmFyIHZhbHVlID0gY29sb3Iuc2xpY2UoY29sb3IuaW5kZXhPZignIycpICsgMSksXG4gICAgICAgICAgaXNTaG9ydE5vdGF0aW9uID0gKHZhbHVlLmxlbmd0aCA9PT0gMyB8fCB2YWx1ZS5sZW5ndGggPT09IDQpLFxuICAgICAgICAgIGlzUkdCYSA9ICh2YWx1ZS5sZW5ndGggPT09IDggfHwgdmFsdWUubGVuZ3RoID09PSA0KSxcbiAgICAgICAgICByID0gaXNTaG9ydE5vdGF0aW9uID8gKHZhbHVlLmNoYXJBdCgwKSArIHZhbHVlLmNoYXJBdCgwKSkgOiB2YWx1ZS5zdWJzdHJpbmcoMCwgMiksXG4gICAgICAgICAgZyA9IGlzU2hvcnROb3RhdGlvbiA/ICh2YWx1ZS5jaGFyQXQoMSkgKyB2YWx1ZS5jaGFyQXQoMSkpIDogdmFsdWUuc3Vic3RyaW5nKDIsIDQpLFxuICAgICAgICAgIGIgPSBpc1Nob3J0Tm90YXRpb24gPyAodmFsdWUuY2hhckF0KDIpICsgdmFsdWUuY2hhckF0KDIpKSA6IHZhbHVlLnN1YnN0cmluZyg0LCA2KSxcbiAgICAgICAgICBhID0gaXNSR0JhID8gKGlzU2hvcnROb3RhdGlvbiA/ICh2YWx1ZS5jaGFyQXQoMykgKyB2YWx1ZS5jaGFyQXQoMykpIDogdmFsdWUuc3Vic3RyaW5nKDYsIDgpKSA6ICdGRic7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHBhcnNlSW50KHIsIDE2KSxcbiAgICAgICAgcGFyc2VJbnQoZywgMTYpLFxuICAgICAgICBwYXJzZUludChiLCAxNiksXG4gICAgICAgIHBhcnNlRmxvYXQoKHBhcnNlSW50KGEsIDE2KSAvIDI1NSkudG9GaXhlZCgyKSlcbiAgICAgIF07XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5ldyBjb2xvciBvYmplY3QsIHdoZW4gZ2l2ZW4gY29sb3IgaW4gYXJyYXkgcmVwcmVzZW50YXRpb24gKGV4OiBbMjAwLCAxMDAsIDEwMCwgMC41XSlcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkNvbG9yXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ29sb3J9XG4gICAqL1xuICBmYWJyaWMuQ29sb3IuZnJvbVNvdXJjZSA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgIHZhciBvQ29sb3IgPSBuZXcgQ29sb3IoKTtcbiAgICBvQ29sb3Iuc2V0U291cmNlKHNvdXJjZSk7XG4gICAgcmV0dXJuIG9Db2xvcjtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgc2NhbGVNYXAgPSBbJ2UnLCAnc2UnLCAncycsICdzdycsICd3JywgJ253JywgJ24nLCAnbmUnLCAnZSddLFxuICAgICAgc2tld01hcCA9IFsnbnMnLCAnbmVzdycsICdldycsICdud3NlJ10sXG4gICAgICBjb250cm9scyA9IHt9LFxuICAgICAgTEVGVCA9ICdsZWZ0JywgVE9QID0gJ3RvcCcsIFJJR0hUID0gJ3JpZ2h0JywgQk9UVE9NID0gJ2JvdHRvbScsIENFTlRFUiA9ICdjZW50ZXInLFxuICAgICAgb3Bwb3NpdGUgPSB7XG4gICAgICAgIHRvcDogQk9UVE9NLFxuICAgICAgICBib3R0b206IFRPUCxcbiAgICAgICAgbGVmdDogUklHSFQsXG4gICAgICAgIHJpZ2h0OiBMRUZULFxuICAgICAgICBjZW50ZXI6IENFTlRFUixcbiAgICAgIH0sIHJhZGlhbnNUb0RlZ3JlZXMgPSBmYWJyaWMudXRpbC5yYWRpYW5zVG9EZWdyZWVzLFxuICAgICAgc2lnbiA9IChNYXRoLnNpZ24gfHwgZnVuY3Rpb24oeCkgeyByZXR1cm4gKCh4ID4gMCkgLSAoeCA8IDApKSB8fCAreDsgfSk7XG5cbiAgLyoqXG4gICAqIENvbWJpbmUgY29udHJvbCBwb3NpdGlvbiBhbmQgb2JqZWN0IGFuZ2xlIHRvIGZpbmQgdGhlIGNvbnRyb2wgZGlyZWN0aW9uIGNvbXBhcmVkXG4gICAqIHRvIHRoZSBvYmplY3QgY2VudGVyLlxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCB0aGUgZmFicmljIG9iamVjdCBmb3Igd2hpY2ggd2UgYXJlIHJlbmRlcmluZyBjb250cm9sc1xuICAgKiBAcGFyYW0ge2ZhYnJpYy5Db250cm9sfSBjb250cm9sIHRoZSBjb250cm9sIGNsYXNzXG4gICAqIEByZXR1cm4ge051bWJlcn0gMCAtIDcgYSBxdWFkcmFudCBudW1iZXJcbiAgICovXG4gIGZ1bmN0aW9uIGZpbmRDb3JuZXJRdWFkcmFudChmYWJyaWNPYmplY3QsIGNvbnRyb2wpIHtcbiAgICB2YXIgY29ybmVyQW5nbGUgPSBmYWJyaWNPYmplY3QuYW5nbGUgKyByYWRpYW5zVG9EZWdyZWVzKE1hdGguYXRhbjIoY29udHJvbC55LCBjb250cm9sLngpKSArIDM2MDtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCgoY29ybmVyQW5nbGUgJSAzNjApIC8gNDUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlyZUV2ZW50KGV2ZW50TmFtZSwgb3B0aW9ucykge1xuICAgIHZhciB0YXJnZXQgPSBvcHRpb25zLnRyYW5zZm9ybS50YXJnZXQsXG4gICAgICAgIGNhbnZhcyA9IHRhcmdldC5jYW52YXMsXG4gICAgICAgIGNhbnZhc09wdGlvbnMgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUob3B0aW9ucyk7XG4gICAgY2FudmFzT3B0aW9ucy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgY2FudmFzICYmIGNhbnZhcy5maXJlKCdvYmplY3Q6JyArIGV2ZW50TmFtZSwgY2FudmFzT3B0aW9ucyk7XG4gICAgdGFyZ2V0LmZpcmUoZXZlbnROYW1lLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNwZWN0IGV2ZW50IGFuZCBmYWJyaWNPYmplY3QgcHJvcGVydGllcyB0byB1bmRlcnN0YW5kIGlmIHRoZSBzY2FsaW5nIGFjdGlvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgZnJvbSB0aGUgdXNlciBhY3Rpb25cbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3QgdGhlIGZhYnJpYyBvYmplY3QgYWJvdXQgdG8gc2NhbGVcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBzY2FsZSBpcyBwcm9wb3J0aW9uYWxcbiAgICovXG4gIGZ1bmN0aW9uIHNjYWxlSXNQcm9wb3J0aW9uYWwoZXZlbnREYXRhLCBmYWJyaWNPYmplY3QpIHtcbiAgICB2YXIgY2FudmFzID0gZmFicmljT2JqZWN0LmNhbnZhcywgdW5pU2NhbGVLZXkgPSBjYW52YXMudW5pU2NhbGVLZXksXG4gICAgICAgIHVuaWZvcm1Jc1RvZ2dsZWQgPSBldmVudERhdGFbdW5pU2NhbGVLZXldO1xuICAgIHJldHVybiAoY2FudmFzLnVuaWZvcm1TY2FsaW5nICYmICF1bmlmb3JtSXNUb2dnbGVkKSB8fFxuICAgICghY2FudmFzLnVuaWZvcm1TY2FsaW5nICYmIHVuaWZvcm1Jc1RvZ2dsZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0cmFuc2Zvcm0gaXMgY2VudGVyZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSB0cmFuc2Zvcm0gZGF0YVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRyYW5zZm9ybSBpcyBjZW50ZXJlZFxuICAgKi9cbiAgZnVuY3Rpb24gaXNUcmFuc2Zvcm1DZW50ZXJlZCh0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtLm9yaWdpblggPT09IENFTlRFUiAmJiB0cmFuc2Zvcm0ub3JpZ2luWSA9PT0gQ0VOVEVSO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc3BlY3QgZmFicmljT2JqZWN0IHRvIHVuZGVyc3RhbmQgaWYgdGhlIGN1cnJlbnQgc2NhbGluZyBhY3Rpb24gaXMgYWxsb3dlZFxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCB0aGUgZmFicmljIG9iamVjdCBhYm91dCB0byBzY2FsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYnkgJ3gnIG9yICd5JyBvciAnJ1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNjYWxlUHJvcG9ydGlvbmFsbHkgdHJ1ZSBpZiB3ZSBhcmUgdHJ5aW5nIHRvIHNjYWxlIHByb3BvcnRpb25hbGx5XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc2NhbGluZyBpcyBub3QgYWxsb3dlZCBhdCBjdXJyZW50IGNvbmRpdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIHNjYWxpbmdJc0ZvcmJpZGRlbihmYWJyaWNPYmplY3QsIGJ5LCBzY2FsZVByb3BvcnRpb25hbGx5KSB7XG4gICAgdmFyIGxvY2tYID0gZmFicmljT2JqZWN0LmxvY2tTY2FsaW5nWCwgbG9ja1kgPSBmYWJyaWNPYmplY3QubG9ja1NjYWxpbmdZO1xuICAgIGlmIChsb2NrWCAmJiBsb2NrWSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghYnkgJiYgKGxvY2tYIHx8IGxvY2tZKSAmJiBzY2FsZVByb3BvcnRpb25hbGx5KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGxvY2tYICYmIGJ5ID09PSAneCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobG9ja1kgJiYgYnkgPT09ICd5Jykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm4gdGhlIGNvcnJlY3QgY3Vyc29yIHN0eWxlIGZvciB0aGUgc2NhbGUgYWN0aW9uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSB0aGUgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGNhdXNpbmcgdGhlIHNjYWxlXG4gICAqIEBwYXJhbSB7ZmFicmljLkNvbnRyb2x9IGNvbnRyb2wgdGhlIGNvbnRyb2wgdGhhdCBpcyBpbnRlcmVzdGVkIGluIHRoZSBhY3Rpb25cbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3QgdGhlIGZhYnJpYyBvYmplY3QgdGhhdCBpcyBpbnRlcmVzdGVkIGluIHRoZSBhY3Rpb25cbiAgICogQHJldHVybiB7U3RyaW5nfSBhIHZhbGlkIGNzcyBzdHJpbmcgZm9yIHRoZSBjdXJzb3JcbiAgICovXG4gIGZ1bmN0aW9uIHNjYWxlQ3Vyc29yU3R5bGVIYW5kbGVyKGV2ZW50RGF0YSwgY29udHJvbCwgZmFicmljT2JqZWN0KSB7XG4gICAgdmFyIG5vdEFsbG93ZWQgPSAnbm90LWFsbG93ZWQnLFxuICAgICAgICBzY2FsZVByb3BvcnRpb25hbGx5ID0gc2NhbGVJc1Byb3BvcnRpb25hbChldmVudERhdGEsIGZhYnJpY09iamVjdCksXG4gICAgICAgIGJ5ID0gJyc7XG4gICAgaWYgKGNvbnRyb2wueCAhPT0gMCAmJiBjb250cm9sLnkgPT09IDApIHtcbiAgICAgIGJ5ID0gJ3gnO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb250cm9sLnggPT09IDAgJiYgY29udHJvbC55ICE9PSAwKSB7XG4gICAgICBieSA9ICd5JztcbiAgICB9XG4gICAgaWYgKHNjYWxpbmdJc0ZvcmJpZGRlbihmYWJyaWNPYmplY3QsIGJ5LCBzY2FsZVByb3BvcnRpb25hbGx5KSkge1xuICAgICAgcmV0dXJuIG5vdEFsbG93ZWQ7XG4gICAgfVxuICAgIHZhciBuID0gZmluZENvcm5lclF1YWRyYW50KGZhYnJpY09iamVjdCwgY29udHJvbCk7XG4gICAgcmV0dXJuIHNjYWxlTWFwW25dICsgJy1yZXNpemUnO1xuICB9XG5cbiAgLyoqXG4gICAqIHJldHVybiB0aGUgY29ycmVjdCBjdXJzb3Igc3R5bGUgZm9yIHRoZSBza2V3IGFjdGlvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBjYXVzaW5nIHRoZSBzY2FsZVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Db250cm9sfSBjb250cm9sIHRoZSBjb250cm9sIHRoYXQgaXMgaW50ZXJlc3RlZCBpbiB0aGUgYWN0aW9uXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IHRoZSBmYWJyaWMgb2JqZWN0IHRoYXQgaXMgaW50ZXJlc3RlZCBpbiB0aGUgYWN0aW9uXG4gICAqIEByZXR1cm4ge1N0cmluZ30gYSB2YWxpZCBjc3Mgc3RyaW5nIGZvciB0aGUgY3Vyc29yXG4gICAqL1xuICBmdW5jdGlvbiBza2V3Q3Vyc29yU3R5bGVIYW5kbGVyKGV2ZW50RGF0YSwgY29udHJvbCwgZmFicmljT2JqZWN0KSB7XG4gICAgdmFyIG5vdEFsbG93ZWQgPSAnbm90LWFsbG93ZWQnO1xuICAgIGlmIChjb250cm9sLnggIT09IDAgJiYgZmFicmljT2JqZWN0LmxvY2tTa2V3aW5nWSkge1xuICAgICAgcmV0dXJuIG5vdEFsbG93ZWQ7XG4gICAgfVxuICAgIGlmIChjb250cm9sLnkgIT09IDAgJiYgZmFicmljT2JqZWN0LmxvY2tTa2V3aW5nWCkge1xuICAgICAgcmV0dXJuIG5vdEFsbG93ZWQ7XG4gICAgfVxuICAgIHZhciBuID0gZmluZENvcm5lclF1YWRyYW50KGZhYnJpY09iamVjdCwgY29udHJvbCkgJSA0O1xuICAgIHJldHVybiBza2V3TWFwW25dICsgJy1yZXNpemUnO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbWJpbmUgc2tldyBhbmQgc2NhbGUgc3R5bGUgaGFuZGxlcnMgdG8gY292ZXIgZmFicmljIHN0YW5kYXJkIHVzZSBjYXNlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSB0aGUgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGNhdXNpbmcgdGhlIHNjYWxlXG4gICAqIEBwYXJhbSB7ZmFicmljLkNvbnRyb2x9IGNvbnRyb2wgdGhlIGNvbnRyb2wgdGhhdCBpcyBpbnRlcmVzdGVkIGluIHRoZSBhY3Rpb25cbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3QgdGhlIGZhYnJpYyBvYmplY3QgdGhhdCBpcyBpbnRlcmVzdGVkIGluIHRoZSBhY3Rpb25cbiAgICogQHJldHVybiB7U3RyaW5nfSBhIHZhbGlkIGNzcyBzdHJpbmcgZm9yIHRoZSBjdXJzb3JcbiAgICovXG4gIGZ1bmN0aW9uIHNjYWxlU2tld0N1cnNvclN0eWxlSGFuZGxlcihldmVudERhdGEsIGNvbnRyb2wsIGZhYnJpY09iamVjdCkge1xuICAgIGlmIChldmVudERhdGFbZmFicmljT2JqZWN0LmNhbnZhcy5hbHRBY3Rpb25LZXldKSB7XG4gICAgICByZXR1cm4gY29udHJvbHMuc2tld0N1cnNvclN0eWxlSGFuZGxlcihldmVudERhdGEsIGNvbnRyb2wsIGZhYnJpY09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiBjb250cm9scy5zY2FsZUN1cnNvclN0eWxlSGFuZGxlcihldmVudERhdGEsIGNvbnRyb2wsIGZhYnJpY09iamVjdCk7XG4gIH1cblxuICAvKipcbiAgICogSW5zcGVjdCBldmVudCwgY29udHJvbCBhbmQgZmFicmljT2JqZWN0IHRvIHJldHVybiB0aGUgY29ycmVjdCBhY3Rpb24gbmFtZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBjYXVzaW5nIHRoZSBzY2FsZVxuICAgKiBAcGFyYW0ge2ZhYnJpYy5Db250cm9sfSBjb250cm9sIHRoZSBjb250cm9sIHRoYXQgaXMgaW50ZXJlc3RlZCBpbiB0aGUgYWN0aW9uXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IHRoZSBmYWJyaWMgb2JqZWN0IHRoYXQgaXMgaW50ZXJlc3RlZCBpbiB0aGUgYWN0aW9uXG4gICAqIEByZXR1cm4ge1N0cmluZ30gYW4gYWN0aW9uIG5hbWVcbiAgICovXG4gIGZ1bmN0aW9uIHNjYWxlT3JTa2V3QWN0aW9uTmFtZShldmVudERhdGEsIGNvbnRyb2wsIGZhYnJpY09iamVjdCkge1xuICAgIHZhciBpc0FsdGVybmF0aXZlID0gZXZlbnREYXRhW2ZhYnJpY09iamVjdC5jYW52YXMuYWx0QWN0aW9uS2V5XTtcbiAgICBpZiAoY29udHJvbC54ID09PSAwKSB7XG4gICAgICAvLyB0aGVuIGlzIHNjYWxlWSBvciBza2V3WFxuICAgICAgcmV0dXJuIGlzQWx0ZXJuYXRpdmUgPyAnc2tld1gnIDogJ3NjYWxlWSc7XG4gICAgfVxuICAgIGlmIChjb250cm9sLnkgPT09IDApIHtcbiAgICAgIC8vIHRoZW4gaXMgc2NhbGVZIG9yIHNrZXdYXG4gICAgICByZXR1cm4gaXNBbHRlcm5hdGl2ZSA/ICdza2V3WScgOiAnc2NhbGVYJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmluZCB0aGUgY29ycmVjdCBzdHlsZSBmb3IgdGhlIGNvbnRyb2wgdGhhdCBpcyB1c2VkIGZvciByb3RhdGlvbi5cbiAgICogdGhpcyBmdW5jdGlvbiBpcyB2ZXJ5IHNpbXBsZSBhbmQgaXQganVzdCB0YWtlIGNhcmUgb2Ygbm90LWFsbG93ZWQgb3Igc3RhbmRhcmQgY3Vyc29yXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSB0aGUgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGNhdXNpbmcgdGhlIHNjYWxlXG4gICAqIEBwYXJhbSB7ZmFicmljLkNvbnRyb2x9IGNvbnRyb2wgdGhlIGNvbnRyb2wgdGhhdCBpcyBpbnRlcmVzdGVkIGluIHRoZSBhY3Rpb25cbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3QgdGhlIGZhYnJpYyBvYmplY3QgdGhhdCBpcyBpbnRlcmVzdGVkIGluIHRoZSBhY3Rpb25cbiAgICogQHJldHVybiB7U3RyaW5nfSBhIHZhbGlkIGNzcyBzdHJpbmcgZm9yIHRoZSBjdXJzb3JcbiAgICovXG4gIGZ1bmN0aW9uIHJvdGF0aW9uU3R5bGVIYW5kbGVyKGV2ZW50RGF0YSwgY29udHJvbCwgZmFicmljT2JqZWN0KSB7XG4gICAgaWYgKGZhYnJpY09iamVjdC5sb2NrUm90YXRpb24pIHtcbiAgICAgIHJldHVybiAnbm90LWFsbG93ZWQnO1xuICAgIH1cbiAgICByZXR1cm4gY29udHJvbC5jdXJzb3JTdHlsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1vbkV2ZW50SW5mbyhldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIHJldHVybiB7XG4gICAgICBlOiBldmVudERhdGEsXG4gICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgIHBvaW50ZXI6IHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXAgYW4gYWN0aW9uIGhhbmRsZXIgd2l0aCBzYXZpbmcvcmVzdG9yaW5nIG9iamVjdCBwb3NpdGlvbiBvbiB0aGUgdHJhbnNmb3JtLlxuICAgKiB0aGlzIGlzIHRoZSBjb2RlIHRoYXQgcGVybWl0cyB0byBvYmplY3RzIHRvIGtlZXAgdGhlaXIgcG9zaXRpb24gd2hpbGUgdHJhbnNmb3JtaW5nLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb25IYW5kbGVyIHRoZSBmdW5jdGlvbiB0byB3cmFwXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHdpdGggYW4gYWN0aW9uIGhhbmRsZXIgc2lnbmF0dXJlXG4gICAqL1xuICBmdW5jdGlvbiB3cmFwV2l0aEZpeGVkQW5jaG9yKGFjdGlvbkhhbmRsZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0cmFuc2Zvcm0udGFyZ2V0LCBjZW50ZXJQb2ludCA9IHRhcmdldC5nZXRDZW50ZXJQb2ludCgpLFxuICAgICAgICAgIGNvbnN0cmFpbnQgPSB0YXJnZXQudHJhbnNsYXRlVG9PcmlnaW5Qb2ludChjZW50ZXJQb2ludCwgdHJhbnNmb3JtLm9yaWdpblgsIHRyYW5zZm9ybS5vcmlnaW5ZKSxcbiAgICAgICAgICBhY3Rpb25QZXJmb3JtZWQgPSBhY3Rpb25IYW5kbGVyKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KTtcbiAgICAgIHRhcmdldC5zZXRQb3NpdGlvbkJ5T3JpZ2luKGNvbnN0cmFpbnQsIHRyYW5zZm9ybS5vcmlnaW5YLCB0cmFuc2Zvcm0ub3JpZ2luWSk7XG4gICAgICByZXR1cm4gYWN0aW9uUGVyZm9ybWVkO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogV3JhcCBhbiBhY3Rpb24gaGFuZGxlciB3aXRoIGZpcmluZyBhbiBldmVudCBpZiB0aGUgYWN0aW9uIGlzIHBlcmZvcm1lZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb25IYW5kbGVyIHRoZSBmdW5jdGlvbiB0byB3cmFwXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHdpdGggYW4gYWN0aW9uIGhhbmRsZXIgc2lnbmF0dXJlXG4gICAqL1xuICBmdW5jdGlvbiB3cmFwV2l0aEZpcmVFdmVudChldmVudE5hbWUsIGFjdGlvbkhhbmRsZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICAgIHZhciBhY3Rpb25QZXJmb3JtZWQgPSBhY3Rpb25IYW5kbGVyKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KTtcbiAgICAgIGlmIChhY3Rpb25QZXJmb3JtZWQpIHtcbiAgICAgICAgZmlyZUV2ZW50KGV2ZW50TmFtZSwgY29tbW9uRXZlbnRJbmZvKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWN0aW9uUGVyZm9ybWVkO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyBhIHBvaW50IGRlc2NyaWJlZCBieSB4IGFuZCB5IGluIGEgZGlzdGFuY2UgZnJvbSB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBvYmplY3RcbiAgICogYm91bmRpbmcgYm94LlxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5YXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5ZXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge0ZhYnJpYy5Qb2ludH0gdGhlIG5vcm1hbGl6ZWQgcG9pbnRcbiAgICovXG4gIGZ1bmN0aW9uIGdldExvY2FsUG9pbnQodHJhbnNmb3JtLCBvcmlnaW5YLCBvcmlnaW5ZLCB4LCB5KSB7XG4gICAgdmFyIHRhcmdldCA9IHRyYW5zZm9ybS50YXJnZXQsXG4gICAgICAgIGNvbnRyb2wgPSB0YXJnZXQuY29udHJvbHNbdHJhbnNmb3JtLmNvcm5lcl0sXG4gICAgICAgIHpvb20gPSB0YXJnZXQuY2FudmFzLmdldFpvb20oKSxcbiAgICAgICAgcGFkZGluZyA9IHRhcmdldC5wYWRkaW5nIC8gem9vbSxcbiAgICAgICAgbG9jYWxQb2ludCA9IHRhcmdldC50b0xvY2FsUG9pbnQobmV3IGZhYnJpYy5Qb2ludCh4LCB5KSwgb3JpZ2luWCwgb3JpZ2luWSk7XG4gICAgaWYgKGxvY2FsUG9pbnQueCA+PSBwYWRkaW5nKSB7XG4gICAgICBsb2NhbFBvaW50LnggLT0gcGFkZGluZztcbiAgICB9XG4gICAgaWYgKGxvY2FsUG9pbnQueCA8PSAtcGFkZGluZykge1xuICAgICAgbG9jYWxQb2ludC54ICs9IHBhZGRpbmc7XG4gICAgfVxuICAgIGlmIChsb2NhbFBvaW50LnkgPj0gcGFkZGluZykge1xuICAgICAgbG9jYWxQb2ludC55IC09IHBhZGRpbmc7XG4gICAgfVxuICAgIGlmIChsb2NhbFBvaW50LnkgPD0gcGFkZGluZykge1xuICAgICAgbG9jYWxQb2ludC55ICs9IHBhZGRpbmc7XG4gICAgfVxuICAgIGxvY2FsUG9pbnQueCAtPSBjb250cm9sLm9mZnNldFg7XG4gICAgbG9jYWxQb2ludC55IC09IGNvbnRyb2wub2Zmc2V0WTtcbiAgICByZXR1cm4gbG9jYWxQb2ludDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3QgaWYgdGhlIGZhYnJpYyBvYmplY3QgaXMgZmxpcHBlZCBvbiBvbmUgc2lkZS5cbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvbmUgZmxpcCwgYnV0IG5vdCB0d28uXG4gICAqL1xuICBmdW5jdGlvbiB0YXJnZXRIYXNPbmVGbGlwKHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQuZmxpcFggIT09IHRhcmdldC5mbGlwWTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGNvbXBlbnNhdGUgdGhlIHNjYWxlIGZhY3RvciB3aGVuIHNrZXcgaXMgYXBwbGllZCBvbiBib3RoIGF4ZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBlbnNhdGVTY2FsZUZvclNrZXcodGFyZ2V0LCBvcHBvc2l0ZVNrZXcsIHNjYWxlVG9Db21wZW5zYXRlLCBheGlzLCByZWZlcmVuY2UpIHtcbiAgICBpZiAodGFyZ2V0W29wcG9zaXRlU2tld10gIT09IDApIHtcbiAgICAgIHZhciBuZXdEaW0gPSB0YXJnZXQuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpW2F4aXNdO1xuICAgICAgdmFyIG5ld1ZhbHVlID0gcmVmZXJlbmNlIC8gbmV3RGltICogdGFyZ2V0W3NjYWxlVG9Db21wZW5zYXRlXTtcbiAgICAgIHRhcmdldC5zZXQoc2NhbGVUb0NvbXBlbnNhdGUsIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWN0aW9uIGhhbmRsZXIgZm9yIHNrZXdpbmcgb24gdGhlIFggYXhpc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gc2tld09iamVjdFgoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCxcbiAgICAgICAgLy8gZmluZCBob3cgYmlnIHRoZSBvYmplY3Qgd291bGQgYmUsIGlmIHRoZXJlIHdhcyBubyBza2V3WC4gdGFrZXMgaW4gYWNjb3VudCBzY2FsaW5nXG4gICAgICAgIGRpbU5vU2tldyA9IHRhcmdldC5fZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zKDAsIHRhcmdldC5za2V3WSksXG4gICAgICAgIGxvY2FsUG9pbnQgPSBnZXRMb2NhbFBvaW50KHRyYW5zZm9ybSwgdHJhbnNmb3JtLm9yaWdpblgsIHRyYW5zZm9ybS5vcmlnaW5ZLCB4LCB5KSxcbiAgICAgICAgLy8gdGhlIG1vdXNlIGlzIGluIHRoZSBjZW50ZXIgb2YgdGhlIG9iamVjdCwgYW5kIHdlIHdhbnQgaXQgdG8gc3RheSB0aGVyZS5cbiAgICAgICAgLy8gc28gdGhlIG9iamVjdCB3aWxsIGdyb3cgdHdpY2UgYXMgbXVjaCBhcyB0aGUgbW91c2UuXG4gICAgICAgIC8vIHRoaXMgbWFrZXMgdGhlIHNrZXcgZ3Jvd3RoIHRvIGxvY2FsUG9pbnQgKiAyIC0gZGltTm9Ta2V3LlxuICAgICAgICB0b3RhbFNrZXdTaXplID0gTWF0aC5hYnMobG9jYWxQb2ludC54ICogMikgLSBkaW1Ob1NrZXcueCxcbiAgICAgICAgY3VycmVudFNrZXcgPSB0YXJnZXQuc2tld1gsIG5ld1NrZXc7XG4gICAgaWYgKHRvdGFsU2tld1NpemUgPCAyKSB7XG4gICAgICAvLyBsZXQncyBtYWtlIGl0IGVhc3kgdG8gZ28gYmFjayB0byBwb3NpdGlvbiAwLlxuICAgICAgbmV3U2tldyA9IDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbmV3U2tldyA9IHJhZGlhbnNUb0RlZ3JlZXMoXG4gICAgICAgIE1hdGguYXRhbjIoKHRvdGFsU2tld1NpemUgLyB0YXJnZXQuc2NhbGVYKSwgKGRpbU5vU2tldy55IC8gdGFyZ2V0LnNjYWxlWSkpXG4gICAgICApO1xuICAgICAgLy8gbm93IHdlIGhhdmUgdG8gZmluZCB0aGUgc2lnbiBvZiB0aGUgc2tldy5cbiAgICAgIC8vIGl0IG1vc3RseSBkZXBlbmQgb24gdGhlIG9yaWdpbiBvZiB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgIGlmICh0cmFuc2Zvcm0ub3JpZ2luWCA9PT0gTEVGVCAmJiB0cmFuc2Zvcm0ub3JpZ2luWSA9PT0gQk9UVE9NKSB7XG4gICAgICAgIG5ld1NrZXcgPSAtbmV3U2tldztcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2Zvcm0ub3JpZ2luWCA9PT0gUklHSFQgJiYgdHJhbnNmb3JtLm9yaWdpblkgPT09IFRPUCkge1xuICAgICAgICBuZXdTa2V3ID0gLW5ld1NrZXc7XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0SGFzT25lRmxpcCh0YXJnZXQpKSB7XG4gICAgICAgIG5ld1NrZXcgPSAtbmV3U2tldztcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGhhc1NrZXdlZCA9IGN1cnJlbnRTa2V3ICE9PSBuZXdTa2V3O1xuICAgIGlmIChoYXNTa2V3ZWQpIHtcbiAgICAgIHZhciBkaW1CZWZvcmVTa2V3aW5nID0gdGFyZ2V0Ll9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKS55O1xuICAgICAgdGFyZ2V0LnNldCgnc2tld1gnLCBuZXdTa2V3KTtcbiAgICAgIGNvbXBlbnNhdGVTY2FsZUZvclNrZXcodGFyZ2V0LCAnc2tld1knLCAnc2NhbGVZJywgJ3knLCBkaW1CZWZvcmVTa2V3aW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc1NrZXdlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3Rpb24gaGFuZGxlciBmb3Igc2tld2luZyBvbiB0aGUgWSBheGlzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBza2V3T2JqZWN0WShldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIHZhciB0YXJnZXQgPSB0cmFuc2Zvcm0udGFyZ2V0LFxuICAgICAgICAvLyBmaW5kIGhvdyBiaWcgdGhlIG9iamVjdCB3b3VsZCBiZSwgaWYgdGhlcmUgd2FzIG5vIHNrZXdYLiB0YWtlcyBpbiBhY2NvdW50IHNjYWxpbmdcbiAgICAgICAgZGltTm9Ta2V3ID0gdGFyZ2V0Ll9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnModGFyZ2V0LnNrZXdYLCAwKSxcbiAgICAgICAgbG9jYWxQb2ludCA9IGdldExvY2FsUG9pbnQodHJhbnNmb3JtLCB0cmFuc2Zvcm0ub3JpZ2luWCwgdHJhbnNmb3JtLm9yaWdpblksIHgsIHkpLFxuICAgICAgICAvLyB0aGUgbW91c2UgaXMgaW4gdGhlIGNlbnRlciBvZiB0aGUgb2JqZWN0LCBhbmQgd2Ugd2FudCBpdCB0byBzdGF5IHRoZXJlLlxuICAgICAgICAvLyBzbyB0aGUgb2JqZWN0IHdpbGwgZ3JvdyB0d2ljZSBhcyBtdWNoIGFzIHRoZSBtb3VzZS5cbiAgICAgICAgLy8gdGhpcyBtYWtlcyB0aGUgc2tldyBncm93dGggdG8gbG9jYWxQb2ludCAqIDIgLSBkaW1Ob1NrZXcuXG4gICAgICAgIHRvdGFsU2tld1NpemUgPSBNYXRoLmFicyhsb2NhbFBvaW50LnkgKiAyKSAtIGRpbU5vU2tldy55LFxuICAgICAgICBjdXJyZW50U2tldyA9IHRhcmdldC5za2V3WSwgbmV3U2tldztcbiAgICBpZiAodG90YWxTa2V3U2l6ZSA8IDIpIHtcbiAgICAgIC8vIGxldCdzIG1ha2UgaXQgZWFzeSB0byBnbyBiYWNrIHRvIHBvc2l0aW9uIDAuXG4gICAgICBuZXdTa2V3ID0gMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBuZXdTa2V3ID0gcmFkaWFuc1RvRGVncmVlcyhcbiAgICAgICAgTWF0aC5hdGFuMigodG90YWxTa2V3U2l6ZSAvIHRhcmdldC5zY2FsZVkpLCAoZGltTm9Ta2V3LnggLyB0YXJnZXQuc2NhbGVYKSlcbiAgICAgICk7XG4gICAgICAvLyBub3cgd2UgaGF2ZSB0byBmaW5kIHRoZSBzaWduIG9mIHRoZSBza2V3LlxuICAgICAgLy8gaXQgbW9zdGx5IGRlcGVuZCBvbiB0aGUgb3JpZ2luIG9mIHRyYW5zZm9ybWF0aW9uLlxuICAgICAgaWYgKHRyYW5zZm9ybS5vcmlnaW5YID09PSBMRUZUICYmIHRyYW5zZm9ybS5vcmlnaW5ZID09PSBCT1RUT00pIHtcbiAgICAgICAgbmV3U2tldyA9IC1uZXdTa2V3O1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zZm9ybS5vcmlnaW5YID09PSBSSUdIVCAmJiB0cmFuc2Zvcm0ub3JpZ2luWSA9PT0gVE9QKSB7XG4gICAgICAgIG5ld1NrZXcgPSAtbmV3U2tldztcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXRIYXNPbmVGbGlwKHRhcmdldCkpIHtcbiAgICAgICAgbmV3U2tldyA9IC1uZXdTa2V3O1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaGFzU2tld2VkID0gY3VycmVudFNrZXcgIT09IG5ld1NrZXc7XG4gICAgaWYgKGhhc1NrZXdlZCkge1xuICAgICAgdmFyIGRpbUJlZm9yZVNrZXdpbmcgPSB0YXJnZXQuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpLng7XG4gICAgICB0YXJnZXQuc2V0KCdza2V3WScsIG5ld1NrZXcpO1xuICAgICAgY29tcGVuc2F0ZVNjYWxlRm9yU2tldyh0YXJnZXQsICdza2V3WCcsICdzY2FsZVgnLCAneCcsIGRpbUJlZm9yZVNrZXdpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gaGFzU2tld2VkO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBwZWQgQWN0aW9uIGhhbmRsZXIgZm9yIHNrZXdpbmcgb24gdGhlIFkgYXhpcywgdGFrZXMgY2FyZSBvZiB0aGVcbiAgICogc2tldyBkaXJlY3Rpb24gYW5kIGRldGVybWluZSB0aGUgY29ycmVjdCB0cmFuc2Zvcm0gb3JpZ2luIGZvciB0aGUgYW5jaG9yIHBvaW50XG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgZG9pbmcgdGhlIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzZXJpZXMgb2YgaW5mb3JtYXRpb24gYXJvdW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge251bWJlcn0geCBjdXJyZW50IG1vdXNlIHggcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGN1cnJlbnQgbW91c2UgeSBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBzb21lIGNoYW5nZSBoYXBwZW5lZFxuICAgKi9cbiAgZnVuY3Rpb24gc2tld0hhbmRsZXJYKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgLy8gc3RlcDEgZmlndXJlIG91dCBhbmQgY2hhbmdlIHRyYW5zZm9ybSBvcmlnaW4uXG4gICAgLy8gaWYgc2tld1ggPiAwIGFuZCBvcmlnaW5ZIGJvdHRvbSB3ZSBhbmNob3Igb24gcmlnaHRcbiAgICAvLyBpZiBza2V3WCA+IDAgYW5kIG9yaWdpblkgdG9wIHdlIGFuY2hvciBvbiBsZWZ0XG4gICAgLy8gaWYgc2tld1ggPCAwIGFuZCBvcmlnaW5ZIGJvdHRvbSB3ZSBhbmNob3Igb24gbGVmdFxuICAgIC8vIGlmIHNrZXdYIDwgMCBhbmQgb3JpZ2luWSB0b3Agd2UgYW5jaG9yIG9uIHJpZ2h0XG4gICAgLy8gaWYgc2tld1ggaXMgMCwgd2UgbG9vayBmb3IgbW91c2UgcG9zaXRpb24gdG8gdW5kZXJzdGFuZCB3aGVyZSBhcmUgd2UgZ29pbmcuXG4gICAgdmFyIHRhcmdldCA9IHRyYW5zZm9ybS50YXJnZXQsIGN1cnJlbnRTa2V3ID0gdGFyZ2V0LnNrZXdYLCBvcmlnaW5YLCBvcmlnaW5ZID0gdHJhbnNmb3JtLm9yaWdpblk7XG4gICAgaWYgKHRhcmdldC5sb2NrU2tld2luZ1gpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRTa2V3ID09PSAwKSB7XG4gICAgICB2YXIgbG9jYWxQb2ludEZyb21DZW50ZXIgPSBnZXRMb2NhbFBvaW50KHRyYW5zZm9ybSwgQ0VOVEVSLCBDRU5URVIsIHgsIHkpO1xuICAgICAgaWYgKGxvY2FsUG9pbnRGcm9tQ2VudGVyLnggPiAwKSB7XG4gICAgICAgIC8vIHdlIGFyZSBwdWxsaW5nIHJpZ2h0LCBhbmNob3IgbGVmdDtcbiAgICAgICAgb3JpZ2luWCA9IExFRlQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gd2UgYXJlIHB1bGxpbmcgcmlnaHQsIGFuY2hvciByaWdodFxuICAgICAgICBvcmlnaW5YID0gUklHSFQ7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGN1cnJlbnRTa2V3ID4gMCkge1xuICAgICAgICBvcmlnaW5YID0gb3JpZ2luWSA9PT0gVE9QID8gTEVGVCA6IFJJR0hUO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRTa2V3IDwgMCkge1xuICAgICAgICBvcmlnaW5YID0gb3JpZ2luWSA9PT0gVE9QID8gUklHSFQgOiBMRUZUO1xuICAgICAgfVxuICAgICAgLy8gaXMgdGhlIG9iamVjdCBmbGlwcGVkIG9uIG9uZSBzaWRlIG9ubHk/IHN3YXAgdGhlIG9yaWdpbi5cbiAgICAgIGlmICh0YXJnZXRIYXNPbmVGbGlwKHRhcmdldCkpIHtcbiAgICAgICAgb3JpZ2luWCA9IG9yaWdpblggPT09IExFRlQgPyBSSUdIVCA6IExFRlQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gb25jZSB3ZSBoYXZlIHRoZSBvcmlnaW4sIHdlIGZpbmQgdGhlIGFuY2hvciBwb2ludFxuICAgIHRyYW5zZm9ybS5vcmlnaW5YID0gb3JpZ2luWDtcbiAgICB2YXIgZmluYWxIYW5kbGVyID0gd3JhcFdpdGhGaXJlRXZlbnQoJ3NrZXdpbmcnLCB3cmFwV2l0aEZpeGVkQW5jaG9yKHNrZXdPYmplY3RYKSk7XG4gICAgcmV0dXJuIGZpbmFsSGFuZGxlcihldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSk7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHBlZCBBY3Rpb24gaGFuZGxlciBmb3Igc2tld2luZyBvbiB0aGUgWSBheGlzLCB0YWtlcyBjYXJlIG9mIHRoZVxuICAgKiBza2V3IGRpcmVjdGlvbiBhbmQgZGV0ZXJtaW5lIHRoZSBjb3JyZWN0IHRyYW5zZm9ybSBvcmlnaW4gZm9yIHRoZSBhbmNob3IgcG9pbnRcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBkb2luZyB0aGUgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm0gamF2YXNjcmlwdCBvYmplY3QgY29udGFpbmluZyBhIHNlcmllcyBvZiBpbmZvcm1hdGlvbiBhcm91bmQgdGhlIGN1cnJlbnQgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IGN1cnJlbnQgbW91c2UgeCBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgY3VycmVudCBtb3VzZSB5IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHNvbWUgY2hhbmdlIGhhcHBlbmVkXG4gICAqL1xuICBmdW5jdGlvbiBza2V3SGFuZGxlclkoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICAvLyBzdGVwMSBmaWd1cmUgb3V0IGFuZCBjaGFuZ2UgdHJhbnNmb3JtIG9yaWdpbi5cbiAgICAvLyBpZiBza2V3WSA+IDAgYW5kIG9yaWdpblggbGVmdCB3ZSBhbmNob3Igb24gdG9wXG4gICAgLy8gaWYgc2tld1kgPiAwIGFuZCBvcmlnaW5YIHJpZ2h0IHdlIGFuY2hvciBvbiBib3R0b21cbiAgICAvLyBpZiBza2V3WSA8IDAgYW5kIG9yaWdpblggbGVmdCB3ZSBhbmNob3Igb24gYm90dG9tXG4gICAgLy8gaWYgc2tld1kgPCAwIGFuZCBvcmlnaW5YIHJpZ2h0IHdlIGFuY2hvciBvbiB0b3BcbiAgICAvLyBpZiBza2V3WSBpcyAwLCB3ZSBsb29rIGZvciBtb3VzZSBwb3NpdGlvbiB0byB1bmRlcnN0YW5kIHdoZXJlIGFyZSB3ZSBnb2luZy5cbiAgICB2YXIgdGFyZ2V0ID0gdHJhbnNmb3JtLnRhcmdldCwgY3VycmVudFNrZXcgPSB0YXJnZXQuc2tld1ksIG9yaWdpblksIG9yaWdpblggPSB0cmFuc2Zvcm0ub3JpZ2luWDtcbiAgICBpZiAodGFyZ2V0LmxvY2tTa2V3aW5nWSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFNrZXcgPT09IDApIHtcbiAgICAgIHZhciBsb2NhbFBvaW50RnJvbUNlbnRlciA9IGdldExvY2FsUG9pbnQodHJhbnNmb3JtLCBDRU5URVIsIENFTlRFUiwgeCwgeSk7XG4gICAgICBpZiAobG9jYWxQb2ludEZyb21DZW50ZXIueSA+IDApIHtcbiAgICAgICAgLy8gd2UgYXJlIHB1bGxpbmcgZG93biwgYW5jaG9yIHVwO1xuICAgICAgICBvcmlnaW5ZID0gVE9QO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHdlIGFyZSBwdWxsaW5nIHVwLCBhbmNob3IgZG93blxuICAgICAgICBvcmlnaW5ZID0gQk9UVE9NO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChjdXJyZW50U2tldyA+IDApIHtcbiAgICAgICAgb3JpZ2luWSA9IG9yaWdpblggPT09IExFRlQgPyBUT1AgOiBCT1RUT007XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFNrZXcgPCAwKSB7XG4gICAgICAgIG9yaWdpblkgPSBvcmlnaW5YID09PSBMRUZUID8gQk9UVE9NIDogVE9QO1xuICAgICAgfVxuICAgICAgLy8gaXMgdGhlIG9iamVjdCBmbGlwcGVkIG9uIG9uZSBzaWRlIG9ubHk/IHN3YXAgdGhlIG9yaWdpbi5cbiAgICAgIGlmICh0YXJnZXRIYXNPbmVGbGlwKHRhcmdldCkpIHtcbiAgICAgICAgb3JpZ2luWSA9IG9yaWdpblkgPT09IFRPUCA/IEJPVFRPTSA6IFRPUDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBvbmNlIHdlIGhhdmUgdGhlIG9yaWdpbiwgd2UgZmluZCB0aGUgYW5jaG9yIHBvaW50XG4gICAgdHJhbnNmb3JtLm9yaWdpblkgPSBvcmlnaW5ZO1xuICAgIHZhciBmaW5hbEhhbmRsZXIgPSB3cmFwV2l0aEZpcmVFdmVudCgnc2tld2luZycsIHdyYXBXaXRoRml4ZWRBbmNob3Ioc2tld09iamVjdFkpKTtcbiAgICByZXR1cm4gZmluYWxIYW5kbGVyKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3Rpb24gaGFuZGxlciBmb3Igcm90YXRpb24gYW5kIHNuYXBwaW5nLCB3aXRob3V0IGFuY2hvciBwb2ludC5cbiAgICogTmVlZHMgdG8gYmUgd3JhcHBlZCB3aXRoIGB3cmFwV2l0aEZpeGVkQW5jaG9yYCB0byBiZSBlZmZlY3RpdmVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBkb2luZyB0aGUgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm0gamF2YXNjcmlwdCBvYmplY3QgY29udGFpbmluZyBhIHNlcmllcyBvZiBpbmZvcm1hdGlvbiBhcm91bmQgdGhlIGN1cnJlbnQgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IGN1cnJlbnQgbW91c2UgeCBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgY3VycmVudCBtb3VzZSB5IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHNvbWUgY2hhbmdlIGhhcHBlbmVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiByb3RhdGlvbldpdGhTbmFwcGluZyhldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIHZhciB0ID0gdHJhbnNmb3JtLFxuICAgICAgICB0YXJnZXQgPSB0LnRhcmdldCxcbiAgICAgICAgcGl2b3RQb2ludCA9IHRhcmdldC50cmFuc2xhdGVUb09yaWdpblBvaW50KHRhcmdldC5nZXRDZW50ZXJQb2ludCgpLCB0Lm9yaWdpblgsIHQub3JpZ2luWSk7XG5cbiAgICBpZiAodGFyZ2V0LmxvY2tSb3RhdGlvbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBsYXN0QW5nbGUgPSBNYXRoLmF0YW4yKHQuZXkgLSBwaXZvdFBvaW50LnksIHQuZXggLSBwaXZvdFBvaW50LngpLFxuICAgICAgICBjdXJBbmdsZSA9IE1hdGguYXRhbjIoeSAtIHBpdm90UG9pbnQueSwgeCAtIHBpdm90UG9pbnQueCksXG4gICAgICAgIGFuZ2xlID0gcmFkaWFuc1RvRGVncmVlcyhjdXJBbmdsZSAtIGxhc3RBbmdsZSArIHQudGhldGEpLFxuICAgICAgICBoYXNSb3RhdGVkID0gdHJ1ZTtcblxuICAgIGlmICh0YXJnZXQuc25hcEFuZ2xlID4gMCkge1xuICAgICAgdmFyIHNuYXBBbmdsZSAgPSB0YXJnZXQuc25hcEFuZ2xlLFxuICAgICAgICAgIHNuYXBUaHJlc2hvbGQgID0gdGFyZ2V0LnNuYXBUaHJlc2hvbGQgfHwgc25hcEFuZ2xlLFxuICAgICAgICAgIHJpZ2h0QW5nbGVMb2NrZWQgPSBNYXRoLmNlaWwoYW5nbGUgLyBzbmFwQW5nbGUpICogc25hcEFuZ2xlLFxuICAgICAgICAgIGxlZnRBbmdsZUxvY2tlZCA9IE1hdGguZmxvb3IoYW5nbGUgLyBzbmFwQW5nbGUpICogc25hcEFuZ2xlO1xuXG4gICAgICBpZiAoTWF0aC5hYnMoYW5nbGUgLSBsZWZ0QW5nbGVMb2NrZWQpIDwgc25hcFRocmVzaG9sZCkge1xuICAgICAgICBhbmdsZSA9IGxlZnRBbmdsZUxvY2tlZDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKE1hdGguYWJzKGFuZ2xlIC0gcmlnaHRBbmdsZUxvY2tlZCkgPCBzbmFwVGhyZXNob2xkKSB7XG4gICAgICAgIGFuZ2xlID0gcmlnaHRBbmdsZUxvY2tlZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBub3JtYWxpemUgYW5nbGUgdG8gcG9zaXRpdmUgdmFsdWVcbiAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICBhbmdsZSA9IDM2MCArIGFuZ2xlO1xuICAgIH1cbiAgICBhbmdsZSAlPSAzNjA7XG5cbiAgICBoYXNSb3RhdGVkID0gdGFyZ2V0LmFuZ2xlICE9PSBhbmdsZTtcbiAgICB0YXJnZXQuYW5nbGUgPSBhbmdsZTtcbiAgICByZXR1cm4gaGFzUm90YXRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBCYXNpYyBzY2FsaW5nIGxvZ2ljLCByZXVzZWQgd2l0aCBkaWZmZXJlbnQgY29uc3RyYWluIGZvciBzY2FsaW5nIFgsWSwgZnJlZWx5IG9yIGVxdWFsbHkuXG4gICAqIE5lZWRzIHRvIGJlIHdyYXBwZWQgd2l0aCBgd3JhcFdpdGhGaXhlZEFuY2hvcmAgdG8gYmUgZWZmZWN0aXZlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgZG9pbmcgdGhlIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzZXJpZXMgb2YgaW5mb3JtYXRpb24gYXJvdW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge251bWJlcn0geCBjdXJyZW50IG1vdXNlIHggcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGN1cnJlbnQgbW91c2UgeSBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBmb3Igc2NhbGluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5ieSAneCcsICd5JywgJ2VxdWFsbHknIG9yICcnIHRvIGluZGljYXRlIHR5cGUgb2Ygc2NhbGluZ1xuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHNvbWUgY2hhbmdlIGhhcHBlbmVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBzY2FsZU9iamVjdChldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciB0YXJnZXQgPSB0cmFuc2Zvcm0udGFyZ2V0LFxuICAgICAgICBsb2NrU2NhbGluZ1ggPSB0YXJnZXQubG9ja1NjYWxpbmdYLCBsb2NrU2NhbGluZ1kgPSB0YXJnZXQubG9ja1NjYWxpbmdZLFxuICAgICAgICBieSA9IG9wdGlvbnMuYnksIG5ld1BvaW50LCBzY2FsZVgsIHNjYWxlWSwgZGltLFxuICAgICAgICBzY2FsZVByb3BvcnRpb25hbGx5ID0gc2NhbGVJc1Byb3BvcnRpb25hbChldmVudERhdGEsIHRhcmdldCksXG4gICAgICAgIGZvcmJpZFNjYWxpbmcgPSBzY2FsaW5nSXNGb3JiaWRkZW4odGFyZ2V0LCBieSwgc2NhbGVQcm9wb3J0aW9uYWxseSksXG4gICAgICAgIHNpZ25YLCBzaWduWSwgZ2VzdHVyZVNjYWxlID0gdHJhbnNmb3JtLmdlc3R1cmVTY2FsZTtcblxuICAgIGlmIChmb3JiaWRTY2FsaW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChnZXN0dXJlU2NhbGUpIHtcbiAgICAgIHNjYWxlWCA9IHRyYW5zZm9ybS5zY2FsZVggKiBnZXN0dXJlU2NhbGU7XG4gICAgICBzY2FsZVkgPSB0cmFuc2Zvcm0uc2NhbGVZICogZ2VzdHVyZVNjYWxlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG5ld1BvaW50ID0gZ2V0TG9jYWxQb2ludCh0cmFuc2Zvcm0sIHRyYW5zZm9ybS5vcmlnaW5YLCB0cmFuc2Zvcm0ub3JpZ2luWSwgeCwgeSk7XG4gICAgICAvLyB1c2Ugb2Ygc2lnbjogV2UgdXNlIHNpZ24gdG8gZGV0ZWN0IGNoYW5nZSBvZiBkaXJlY3Rpb24gb2YgYW4gYWN0aW9uLiBzaWduIHVzdWFsbHkgY2hhbmdlIHdoZW5cbiAgICAgIC8vIHdlIGNyb3NzIHRoZSBvcmlnaW4gcG9pbnQgd2l0aCB0aGUgbW91c2UuIFNvIGEgc2NhbGUgZmxpcCBmb3IgZXhhbXBsZS4gVGhlcmUgaXMgYW4gaXNzdWUgd2hlbiBzY2FsaW5nXG4gICAgICAvLyBieSBjZW50ZXIgYW5kIHNjYWxpbmcgdXNpbmcgb25lIG1pZGRsZSBjb250cm9sICggZGVmYXVsdDogbXIsIG10LCBtbCwgbWIpLCB0aGUgbW91c2UgbW92ZW1lbnQgY2FuIGVhc2lseVxuICAgICAgLy8gY3Jvc3MgbWFueSB0aW1lIHRoZSBvcmlnaW4gcG9pbnQgYW5kIGZsaXAgdGhlIG9iamVjdC4gc28gd2UgbmVlZCBhIHdheSB0byBmaWx0ZXIgb3V0IHRoZSBub2lzZS5cbiAgICAgIC8vIFRoaXMgdGVybmFyeSBoZXJlIHNob3VsZCBiZSBvayB0byBmaWx0ZXIgb3V0IFggc2NhbGluZyB3aGVuIHdlIHdhbnQgWSBvbmx5IGFuZCB2aWNlIHZlcnNhLlxuICAgICAgc2lnblggPSBieSAhPT0gJ3knID8gc2lnbihuZXdQb2ludC54KSA6IDE7XG4gICAgICBzaWduWSA9IGJ5ICE9PSAneCcgPyBzaWduKG5ld1BvaW50LnkpIDogMTtcbiAgICAgIGlmICghdHJhbnNmb3JtLnNpZ25YKSB7XG4gICAgICAgIHRyYW5zZm9ybS5zaWduWCA9IHNpZ25YO1xuICAgICAgfVxuICAgICAgaWYgKCF0cmFuc2Zvcm0uc2lnblkpIHtcbiAgICAgICAgdHJhbnNmb3JtLnNpZ25ZID0gc2lnblk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0YXJnZXQubG9ja1NjYWxpbmdGbGlwICYmXG4gICAgICAgICh0cmFuc2Zvcm0uc2lnblggIT09IHNpZ25YIHx8IHRyYW5zZm9ybS5zaWduWSAhPT0gc2lnblkpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBkaW0gPSB0YXJnZXQuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpO1xuICAgICAgLy8gbWlzc2luZyBkZXRlY3Rpb24gb2YgZmxpcCBhbmQgbG9naWMgdG8gc3dpdGNoIHRoZSBvcmlnaW5cbiAgICAgIGlmIChzY2FsZVByb3BvcnRpb25hbGx5ICYmICFieSkge1xuICAgICAgICAvLyB1bmlmb3JtIHNjYWxpbmdcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5hYnMobmV3UG9pbnQueCkgKyBNYXRoLmFicyhuZXdQb2ludC55KSxcbiAgICAgICAgICAgIG9yaWdpbmFsID0gdHJhbnNmb3JtLm9yaWdpbmFsLFxuICAgICAgICAgICAgb3JpZ2luYWxEaXN0YW5jZSA9IE1hdGguYWJzKGRpbS54ICogb3JpZ2luYWwuc2NhbGVYIC8gdGFyZ2V0LnNjYWxlWCkgK1xuICAgICAgICAgICAgICBNYXRoLmFicyhkaW0ueSAqIG9yaWdpbmFsLnNjYWxlWSAvIHRhcmdldC5zY2FsZVkpLFxuICAgICAgICAgICAgc2NhbGUgPSBkaXN0YW5jZSAvIG9yaWdpbmFsRGlzdGFuY2U7XG4gICAgICAgIHNjYWxlWCA9IG9yaWdpbmFsLnNjYWxlWCAqIHNjYWxlO1xuICAgICAgICBzY2FsZVkgPSBvcmlnaW5hbC5zY2FsZVkgKiBzY2FsZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzY2FsZVggPSBNYXRoLmFicyhuZXdQb2ludC54ICogdGFyZ2V0LnNjYWxlWCAvIGRpbS54KTtcbiAgICAgICAgc2NhbGVZID0gTWF0aC5hYnMobmV3UG9pbnQueSAqIHRhcmdldC5zY2FsZVkgLyBkaW0ueSk7XG4gICAgICB9XG4gICAgICAvLyBpZiB3ZSBhcmUgc2NhbGluZyBieSBjZW50ZXIsIHdlIG5lZWQgdG8gZG91YmxlIHRoZSBzY2FsZVxuICAgICAgaWYgKGlzVHJhbnNmb3JtQ2VudGVyZWQodHJhbnNmb3JtKSkge1xuICAgICAgICBzY2FsZVggKj0gMjtcbiAgICAgICAgc2NhbGVZICo9IDI7XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNmb3JtLnNpZ25YICE9PSBzaWduWCAmJiBieSAhPT0gJ3knKSB7XG4gICAgICAgIHRyYW5zZm9ybS5vcmlnaW5YID0gb3Bwb3NpdGVbdHJhbnNmb3JtLm9yaWdpblhdO1xuICAgICAgICBzY2FsZVggKj0gLTE7XG4gICAgICAgIHRyYW5zZm9ybS5zaWduWCA9IHNpZ25YO1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zZm9ybS5zaWduWSAhPT0gc2lnblkgJiYgYnkgIT09ICd4Jykge1xuICAgICAgICB0cmFuc2Zvcm0ub3JpZ2luWSA9IG9wcG9zaXRlW3RyYW5zZm9ybS5vcmlnaW5ZXTtcbiAgICAgICAgc2NhbGVZICo9IC0xO1xuICAgICAgICB0cmFuc2Zvcm0uc2lnblkgPSBzaWduWTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gbWluU2NhbGUgaXMgdGFrZW4gYXJlIGluIHRoZSBzZXR0ZXIuXG4gICAgdmFyIG9sZFNjYWxlWCA9IHRhcmdldC5zY2FsZVgsIG9sZFNjYWxlWSA9IHRhcmdldC5zY2FsZVk7XG4gICAgaWYgKCFieSkge1xuICAgICAgIWxvY2tTY2FsaW5nWCAmJiB0YXJnZXQuc2V0KCdzY2FsZVgnLCBzY2FsZVgpO1xuICAgICAgIWxvY2tTY2FsaW5nWSAmJiB0YXJnZXQuc2V0KCdzY2FsZVknLCBzY2FsZVkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGZvcmJpZGRlbiBjYXNlcyBhbHJlYWR5IGhhbmRsZWQgb24gdG9wIGhlcmUuXG4gICAgICBieSA9PT0gJ3gnICYmIHRhcmdldC5zZXQoJ3NjYWxlWCcsIHNjYWxlWCk7XG4gICAgICBieSA9PT0gJ3knICYmIHRhcmdldC5zZXQoJ3NjYWxlWScsIHNjYWxlWSk7XG4gICAgfVxuICAgIHJldHVybiBvbGRTY2FsZVggIT09IHRhcmdldC5zY2FsZVggfHwgb2xkU2NhbGVZICE9PSB0YXJnZXQuc2NhbGVZO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyaWMgc2NhbGluZyBsb2dpYywgdG8gc2NhbGUgZnJvbSBjb3JuZXJzIGVpdGhlciBlcXVhbGx5IG9yIGZyZWVseS5cbiAgICogTmVlZHMgdG8gYmUgd3JhcHBlZCB3aXRoIGB3cmFwV2l0aEZpeGVkQW5jaG9yYCB0byBiZSBlZmZlY3RpdmVcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIGphdmFzY3JpcHQgZXZlbnQgdGhhdCBpcyBkb2luZyB0aGUgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm0gamF2YXNjcmlwdCBvYmplY3QgY29udGFpbmluZyBhIHNlcmllcyBvZiBpbmZvcm1hdGlvbiBhcm91bmQgdGhlIGN1cnJlbnQgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IGN1cnJlbnQgbW91c2UgeCBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgY3VycmVudCBtb3VzZSB5IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHNvbWUgY2hhbmdlIGhhcHBlbmVkXG4gICAqL1xuICBmdW5jdGlvbiBzY2FsZU9iamVjdEZyb21Db3JuZXIoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgICByZXR1cm4gc2NhbGVPYmplY3QoZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjYWxpbmcgbG9naWMgZm9yIHRoZSBYIGF4aXMuXG4gICAqIE5lZWRzIHRvIGJlIHdyYXBwZWQgd2l0aCBgd3JhcFdpdGhGaXhlZEFuY2hvcmAgdG8gYmUgZWZmZWN0aXZlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgZG9pbmcgdGhlIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzZXJpZXMgb2YgaW5mb3JtYXRpb24gYXJvdW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge251bWJlcn0geCBjdXJyZW50IG1vdXNlIHggcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGN1cnJlbnQgbW91c2UgeSBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBzb21lIGNoYW5nZSBoYXBwZW5lZFxuICAgKi9cbiAgZnVuY3Rpb24gc2NhbGVPYmplY3RYKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgcmV0dXJuIHNjYWxlT2JqZWN0KGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5ICwgeyBieTogJ3gnIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjYWxpbmcgbG9naWMgZm9yIHRoZSBZIGF4aXMuXG4gICAqIE5lZWRzIHRvIGJlIHdyYXBwZWQgd2l0aCBgd3JhcFdpdGhGaXhlZEFuY2hvcmAgdG8gYmUgZWZmZWN0aXZlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgZG9pbmcgdGhlIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzZXJpZXMgb2YgaW5mb3JtYXRpb24gYXJvdW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge251bWJlcn0geCBjdXJyZW50IG1vdXNlIHggcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGN1cnJlbnQgbW91c2UgeSBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBzb21lIGNoYW5nZSBoYXBwZW5lZFxuICAgKi9cbiAgZnVuY3Rpb24gc2NhbGVPYmplY3RZKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgcmV0dXJuIHNjYWxlT2JqZWN0KGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5ICwgeyBieTogJ3knIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBvc2VkIGFjdGlvbiBoYW5kbGVyIHRvIGVpdGhlciBzY2FsZSBZIG9yIHNrZXcgWFxuICAgKiBOZWVkcyB0byBiZSB3cmFwcGVkIHdpdGggYHdyYXBXaXRoRml4ZWRBbmNob3JgIHRvIGJlIGVmZmVjdGl2ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGRvaW5nIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGEgc2VyaWVzIG9mIGluZm9ybWF0aW9uIGFyb3VuZCB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggY3VycmVudCBtb3VzZSB4IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBjdXJyZW50IG1vdXNlIHkgcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc29tZSBjaGFuZ2UgaGFwcGVuZWRcbiAgICovXG4gIGZ1bmN0aW9uIHNjYWxpbmdZT3JTa2V3aW5nWChldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSkge1xuICAgIC8vIG9rIHNvbWUgc2FmZXR5IG5lZWRlZCBoZXJlLlxuICAgIGlmIChldmVudERhdGFbdHJhbnNmb3JtLnRhcmdldC5jYW52YXMuYWx0QWN0aW9uS2V5XSkge1xuICAgICAgcmV0dXJuIGNvbnRyb2xzLnNrZXdIYW5kbGVyWChldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSk7XG4gICAgfVxuICAgIHJldHVybiBjb250cm9scy5zY2FsaW5nWShldmVudERhdGEsIHRyYW5zZm9ybSwgeCwgeSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcG9zZWQgYWN0aW9uIGhhbmRsZXIgdG8gZWl0aGVyIHNjYWxlIFggb3Igc2tldyBZXG4gICAqIE5lZWRzIHRvIGJlIHdyYXBwZWQgd2l0aCBgd3JhcFdpdGhGaXhlZEFuY2hvcmAgdG8gYmUgZWZmZWN0aXZlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgZG9pbmcgdGhlIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzZXJpZXMgb2YgaW5mb3JtYXRpb24gYXJvdW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge251bWJlcn0geCBjdXJyZW50IG1vdXNlIHggcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGN1cnJlbnQgbW91c2UgeSBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBzb21lIGNoYW5nZSBoYXBwZW5lZFxuICAgKi9cbiAgZnVuY3Rpb24gc2NhbGluZ1hPclNrZXdpbmdZKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgLy8gb2sgc29tZSBzYWZldHkgbmVlZGVkIGhlcmUuXG4gICAgaWYgKGV2ZW50RGF0YVt0cmFuc2Zvcm0udGFyZ2V0LmNhbnZhcy5hbHRBY3Rpb25LZXldKSB7XG4gICAgICByZXR1cm4gY29udHJvbHMuc2tld0hhbmRsZXJZKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRyb2xzLnNjYWxpbmdYKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3Rpb24gaGFuZGxlciB0byBjaGFuZ2UgdGV4dGJveCB3aWR0aFxuICAgKiBOZWVkcyB0byBiZSB3cmFwcGVkIHdpdGggYHdyYXBXaXRoRml4ZWRBbmNob3JgIHRvIGJlIGVmZmVjdGl2ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgamF2YXNjcmlwdCBldmVudCB0aGF0IGlzIGRvaW5nIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nIGEgc2VyaWVzIG9mIGluZm9ybWF0aW9uIGFyb3VuZCB0aGUgY3VycmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggY3VycmVudCBtb3VzZSB4IHBvc2l0aW9uLCBjYW52YXMgbm9ybWFsaXplZFxuICAgKiBAcGFyYW0ge251bWJlcn0geSBjdXJyZW50IG1vdXNlIHkgcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc29tZSBjaGFuZ2UgaGFwcGVuZWRcbiAgICovXG4gIGZ1bmN0aW9uIGNoYW5nZVdpZHRoKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgdmFyIHRhcmdldCA9IHRyYW5zZm9ybS50YXJnZXQsIGxvY2FsUG9pbnQgPSBnZXRMb2NhbFBvaW50KHRyYW5zZm9ybSwgdHJhbnNmb3JtLm9yaWdpblgsIHRyYW5zZm9ybS5vcmlnaW5ZLCB4LCB5KSxcbiAgICAgICAgc3Ryb2tlUGFkZGluZyA9IHRhcmdldC5zdHJva2VXaWR0aCAvICh0YXJnZXQuc3Ryb2tlVW5pZm9ybSA/IHRhcmdldC5zY2FsZVggOiAxKSxcbiAgICAgICAgbXVsdGlwbGllciA9IGlzVHJhbnNmb3JtQ2VudGVyZWQodHJhbnNmb3JtKSA/IDIgOiAxLFxuICAgICAgICBvbGRXaWR0aCA9IHRhcmdldC53aWR0aCxcbiAgICAgICAgbmV3V2lkdGggPSBNYXRoLmFicyhsb2NhbFBvaW50LnggKiBtdWx0aXBsaWVyIC8gdGFyZ2V0LnNjYWxlWCkgLSBzdHJva2VQYWRkaW5nO1xuICAgIHRhcmdldC5zZXQoJ3dpZHRoJywgTWF0aC5tYXgobmV3V2lkdGgsIDApKTtcbiAgICByZXR1cm4gb2xkV2lkdGggIT09IG5ld1dpZHRoO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjdGlvbiBoYW5kbGVyXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSBqYXZhc2NyaXB0IGV2ZW50IHRoYXQgaXMgZG9pbmcgdGhlIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtIGphdmFzY3JpcHQgb2JqZWN0IGNvbnRhaW5pbmcgYSBzZXJpZXMgb2YgaW5mb3JtYXRpb24gYXJvdW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge251bWJlcn0geCBjdXJyZW50IG1vdXNlIHggcG9zaXRpb24sIGNhbnZhcyBub3JtYWxpemVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGN1cnJlbnQgbW91c2UgeSBwb3NpdGlvbiwgY2FudmFzIG5vcm1hbGl6ZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgdHJhbnNsYXRpb24gb2NjdXJyZWRcbiAgICovXG4gIGZ1bmN0aW9uIGRyYWdIYW5kbGVyKGV2ZW50RGF0YSwgdHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgdmFyIHRhcmdldCA9IHRyYW5zZm9ybS50YXJnZXQsXG4gICAgICAgIG5ld0xlZnQgPSB4IC0gdHJhbnNmb3JtLm9mZnNldFgsXG4gICAgICAgIG5ld1RvcCA9IHkgLSB0cmFuc2Zvcm0ub2Zmc2V0WSxcbiAgICAgICAgbW92ZVggPSAhdGFyZ2V0LmdldCgnbG9ja01vdmVtZW50WCcpICYmIHRhcmdldC5sZWZ0ICE9PSBuZXdMZWZ0LFxuICAgICAgICBtb3ZlWSA9ICF0YXJnZXQuZ2V0KCdsb2NrTW92ZW1lbnRZJykgJiYgdGFyZ2V0LnRvcCAhPT0gbmV3VG9wO1xuICAgIG1vdmVYICYmIHRhcmdldC5zZXQoJ2xlZnQnLCBuZXdMZWZ0KTtcbiAgICBtb3ZlWSAmJiB0YXJnZXQuc2V0KCd0b3AnLCBuZXdUb3ApO1xuICAgIGlmIChtb3ZlWCB8fCBtb3ZlWSkge1xuICAgICAgZmlyZUV2ZW50KCdtb3ZpbmcnLCBjb21tb25FdmVudEluZm8oZXZlbnREYXRhLCB0cmFuc2Zvcm0sIHgsIHkpKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vdmVYIHx8IG1vdmVZO1xuICB9XG5cbiAgY29udHJvbHMuc2NhbGVDdXJzb3JTdHlsZUhhbmRsZXIgPSBzY2FsZUN1cnNvclN0eWxlSGFuZGxlcjtcbiAgY29udHJvbHMuc2tld0N1cnNvclN0eWxlSGFuZGxlciA9IHNrZXdDdXJzb3JTdHlsZUhhbmRsZXI7XG4gIGNvbnRyb2xzLnNjYWxlU2tld0N1cnNvclN0eWxlSGFuZGxlciA9IHNjYWxlU2tld0N1cnNvclN0eWxlSGFuZGxlcjtcbiAgY29udHJvbHMucm90YXRpb25XaXRoU25hcHBpbmcgPSB3cmFwV2l0aEZpcmVFdmVudCgncm90YXRpbmcnLCB3cmFwV2l0aEZpeGVkQW5jaG9yKHJvdGF0aW9uV2l0aFNuYXBwaW5nKSk7XG4gIGNvbnRyb2xzLnNjYWxpbmdFcXVhbGx5ID0gd3JhcFdpdGhGaXJlRXZlbnQoJ3NjYWxpbmcnLCB3cmFwV2l0aEZpeGVkQW5jaG9yKCBzY2FsZU9iamVjdEZyb21Db3JuZXIpKTtcbiAgY29udHJvbHMuc2NhbGluZ1ggPSB3cmFwV2l0aEZpcmVFdmVudCgnc2NhbGluZycsIHdyYXBXaXRoRml4ZWRBbmNob3Ioc2NhbGVPYmplY3RYKSk7XG4gIGNvbnRyb2xzLnNjYWxpbmdZID0gd3JhcFdpdGhGaXJlRXZlbnQoJ3NjYWxpbmcnLCB3cmFwV2l0aEZpeGVkQW5jaG9yKHNjYWxlT2JqZWN0WSkpO1xuICBjb250cm9scy5zY2FsaW5nWU9yU2tld2luZ1ggPSBzY2FsaW5nWU9yU2tld2luZ1g7XG4gIGNvbnRyb2xzLnNjYWxpbmdYT3JTa2V3aW5nWSA9IHNjYWxpbmdYT3JTa2V3aW5nWTtcbiAgY29udHJvbHMuY2hhbmdlV2lkdGggPSB3cmFwV2l0aEZpcmVFdmVudCgncmVzaXppbmcnLCB3cmFwV2l0aEZpeGVkQW5jaG9yKGNoYW5nZVdpZHRoKSk7XG4gIGNvbnRyb2xzLnNrZXdIYW5kbGVyWCA9IHNrZXdIYW5kbGVyWDtcbiAgY29udHJvbHMuc2tld0hhbmRsZXJZID0gc2tld0hhbmRsZXJZO1xuICBjb250cm9scy5kcmFnSGFuZGxlciA9IGRyYWdIYW5kbGVyO1xuICBjb250cm9scy5zY2FsZU9yU2tld0FjdGlvbk5hbWUgPSBzY2FsZU9yU2tld0FjdGlvbk5hbWU7XG4gIGNvbnRyb2xzLnJvdGF0aW9uU3R5bGVIYW5kbGVyID0gcm90YXRpb25TdHlsZUhhbmRsZXI7XG4gIGNvbnRyb2xzLmZpcmVFdmVudCA9IGZpcmVFdmVudDtcbiAgY29udHJvbHMud3JhcFdpdGhGaXhlZEFuY2hvciA9IHdyYXBXaXRoRml4ZWRBbmNob3I7XG4gIGNvbnRyb2xzLndyYXBXaXRoRmlyZUV2ZW50ID0gd3JhcFdpdGhGaXJlRXZlbnQ7XG4gIGNvbnRyb2xzLmdldExvY2FsUG9pbnQgPSBnZXRMb2NhbFBvaW50O1xuICBmYWJyaWMuY29udHJvbHNVdGlscyA9IGNvbnRyb2xzO1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBkZWdyZWVzVG9SYWRpYW5zID0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucyxcbiAgICAgIGNvbnRyb2xzID0gZmFicmljLmNvbnRyb2xzVXRpbHM7XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIHJvdW5kIGNvbnRyb2wsIGFzIHBlciBmYWJyaWMgZmVhdHVyZXMuXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgd3JpdHRlbiB0byByZXNwZWN0IG9iamVjdCBwcm9wZXJ0aWVzIGxpa2UgdHJhbnNwYXJlbnRDb3JuZXJzLCBjb3JuZXJTaXplXG4gICAqIGNvcm5lckNvbG9yLCBjb3JuZXJTdHJva2VDb2xvclxuICAgKiBwbHVzIHRoZSBhZGRpdGlvbiBvZiBvZmZzZXRZIGFuZCBvZmZzZXRYLlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0IHggY29vcmRpbmF0ZSB3aGVyZSB0aGUgY29udHJvbCBjZW50ZXIgc2hvdWxkIGJlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0b3AgeSBjb29yZGluYXRlIHdoZXJlIHRoZSBjb250cm9sIGNlbnRlciBzaG91bGQgYmVcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlT3ZlcnJpZGUgb3ZlcnJpZGUgZm9yIGZhYnJpYy5PYmplY3QgY29udHJvbHMgc3R5bGVcbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3QgdGhlIGZhYnJpYyBvYmplY3QgZm9yIHdoaWNoIHdlIGFyZSByZW5kZXJpbmcgY29udHJvbHNcbiAgICovXG4gIGZ1bmN0aW9uIHJlbmRlckNpcmNsZUNvbnRyb2wgKGN0eCwgbGVmdCwgdG9wLCBzdHlsZU92ZXJyaWRlLCBmYWJyaWNPYmplY3QpIHtcbiAgICBzdHlsZU92ZXJyaWRlID0gc3R5bGVPdmVycmlkZSB8fCB7fTtcbiAgICB2YXIgeFNpemUgPSB0aGlzLnNpemVYIHx8IHN0eWxlT3ZlcnJpZGUuY29ybmVyU2l6ZSB8fCBmYWJyaWNPYmplY3QuY29ybmVyU2l6ZSxcbiAgICAgICAgeVNpemUgPSB0aGlzLnNpemVZIHx8IHN0eWxlT3ZlcnJpZGUuY29ybmVyU2l6ZSB8fCBmYWJyaWNPYmplY3QuY29ybmVyU2l6ZSxcbiAgICAgICAgdHJhbnNwYXJlbnRDb3JuZXJzID0gdHlwZW9mIHN0eWxlT3ZlcnJpZGUudHJhbnNwYXJlbnRDb3JuZXJzICE9PSAndW5kZWZpbmVkJyA/XG4gICAgICAgICAgc3R5bGVPdmVycmlkZS50cmFuc3BhcmVudENvcm5lcnMgOiBmYWJyaWNPYmplY3QudHJhbnNwYXJlbnRDb3JuZXJzLFxuICAgICAgICBtZXRob2ROYW1lID0gdHJhbnNwYXJlbnRDb3JuZXJzID8gJ3N0cm9rZScgOiAnZmlsbCcsXG4gICAgICAgIHN0cm9rZSA9ICF0cmFuc3BhcmVudENvcm5lcnMgJiYgKHN0eWxlT3ZlcnJpZGUuY29ybmVyU3Ryb2tlQ29sb3IgfHwgZmFicmljT2JqZWN0LmNvcm5lclN0cm9rZUNvbG9yKSxcbiAgICAgICAgbXlMZWZ0ID0gbGVmdCxcbiAgICAgICAgbXlUb3AgPSB0b3AsIHNpemU7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguZmlsbFN0eWxlID0gc3R5bGVPdmVycmlkZS5jb3JuZXJDb2xvciB8fCBmYWJyaWNPYmplY3QuY29ybmVyQ29sb3I7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGVPdmVycmlkZS5jb3JuZXJTdHJva2VDb2xvciB8fCBmYWJyaWNPYmplY3QuY29ybmVyU3Ryb2tlQ29sb3I7XG4gICAgLy8gYXMgc29vbiBhcyBmYWJyaWMgcmVhY3QgdjUsIHJlbW92ZSBpZTExLCB1c2UgcHJvcGVyIGVsbGlwc2UgY29kZS5cbiAgICBpZiAoeFNpemUgPiB5U2l6ZSkge1xuICAgICAgc2l6ZSA9IHhTaXplO1xuICAgICAgY3R4LnNjYWxlKDEuMCwgeVNpemUgLyB4U2l6ZSk7XG4gICAgICBteVRvcCA9IHRvcCAqIHhTaXplIC8geVNpemU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHlTaXplID4geFNpemUpIHtcbiAgICAgIHNpemUgPSB5U2l6ZTtcbiAgICAgIGN0eC5zY2FsZSh4U2l6ZSAvIHlTaXplLCAxLjApO1xuICAgICAgbXlMZWZ0ID0gbGVmdCAqIHlTaXplIC8geFNpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc2l6ZSA9IHhTaXplO1xuICAgIH1cbiAgICAvLyB0aGlzIGlzIHN0aWxsIHdyb25nXG4gICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMobXlMZWZ0LCBteVRvcCwgc2l6ZSAvIDIsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgY3R4W21ldGhvZE5hbWVdKCk7XG4gICAgaWYgKHN0cm9rZSkge1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIHNxdWFyZSBjb250cm9sLCBhcyBwZXIgZmFicmljIGZlYXR1cmVzLlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHdyaXR0ZW4gdG8gcmVzcGVjdCBvYmplY3QgcHJvcGVydGllcyBsaWtlIHRyYW5zcGFyZW50Q29ybmVycywgY29ybmVyU2l6ZVxuICAgKiBjb3JuZXJDb2xvciwgY29ybmVyU3Ryb2tlQ29sb3JcbiAgICogcGx1cyB0aGUgYWRkaXRpb24gb2Ygb2Zmc2V0WSBhbmQgb2Zmc2V0WC5cbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0IHRvIHJlbmRlciBvblxuICAgKiBAcGFyYW0ge051bWJlcn0gbGVmdCB4IGNvb3JkaW5hdGUgd2hlcmUgdGhlIGNvbnRyb2wgY2VudGVyIHNob3VsZCBiZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdG9wIHkgY29vcmRpbmF0ZSB3aGVyZSB0aGUgY29udHJvbCBjZW50ZXIgc2hvdWxkIGJlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZU92ZXJyaWRlIG92ZXJyaWRlIGZvciBmYWJyaWMuT2JqZWN0IGNvbnRyb2xzIHN0eWxlXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IHRoZSBmYWJyaWMgb2JqZWN0IGZvciB3aGljaCB3ZSBhcmUgcmVuZGVyaW5nIGNvbnRyb2xzXG4gICAqL1xuICBmdW5jdGlvbiByZW5kZXJTcXVhcmVDb250cm9sKGN0eCwgbGVmdCwgdG9wLCBzdHlsZU92ZXJyaWRlLCBmYWJyaWNPYmplY3QpIHtcbiAgICBzdHlsZU92ZXJyaWRlID0gc3R5bGVPdmVycmlkZSB8fCB7fTtcbiAgICB2YXIgeFNpemUgPSB0aGlzLnNpemVYIHx8IHN0eWxlT3ZlcnJpZGUuY29ybmVyU2l6ZSB8fCBmYWJyaWNPYmplY3QuY29ybmVyU2l6ZSxcbiAgICAgICAgeVNpemUgPSB0aGlzLnNpemVZIHx8IHN0eWxlT3ZlcnJpZGUuY29ybmVyU2l6ZSB8fCBmYWJyaWNPYmplY3QuY29ybmVyU2l6ZSxcbiAgICAgICAgdHJhbnNwYXJlbnRDb3JuZXJzID0gdHlwZW9mIHN0eWxlT3ZlcnJpZGUudHJhbnNwYXJlbnRDb3JuZXJzICE9PSAndW5kZWZpbmVkJyA/XG4gICAgICAgICAgc3R5bGVPdmVycmlkZS50cmFuc3BhcmVudENvcm5lcnMgOiBmYWJyaWNPYmplY3QudHJhbnNwYXJlbnRDb3JuZXJzLFxuICAgICAgICBtZXRob2ROYW1lID0gdHJhbnNwYXJlbnRDb3JuZXJzID8gJ3N0cm9rZScgOiAnZmlsbCcsXG4gICAgICAgIHN0cm9rZSA9ICF0cmFuc3BhcmVudENvcm5lcnMgJiYgKFxuICAgICAgICAgIHN0eWxlT3ZlcnJpZGUuY29ybmVyU3Ryb2tlQ29sb3IgfHwgZmFicmljT2JqZWN0LmNvcm5lclN0cm9rZUNvbG9yXG4gICAgICAgICksIHhTaXplQnkyID0geFNpemUgLyAyLCB5U2l6ZUJ5MiA9IHlTaXplIC8gMjtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBzdHlsZU92ZXJyaWRlLmNvcm5lckNvbG9yIHx8IGZhYnJpY09iamVjdC5jb3JuZXJDb2xvcjtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZU92ZXJyaWRlLmNvcm5lclN0cm9rZUNvbG9yIHx8IGZhYnJpY09iamVjdC5jb3JuZXJTdHJva2VDb2xvcjtcbiAgICAvLyB0aGlzIGlzIHN0aWxsIHdyb25nXG4gICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgY3R4LnRyYW5zbGF0ZShsZWZ0LCB0b3ApO1xuICAgIGN0eC5yb3RhdGUoZGVncmVlc1RvUmFkaWFucyhmYWJyaWNPYmplY3QuYW5nbGUpKTtcbiAgICAvLyB0aGlzIGRvZXMgbm90IHdvcmssIGFuZCBmaXhlZCB3aXRoICggJiYgKSBkb2VzIG5vdCBtYWtlIHNlbnNlLlxuICAgIC8vIHRvIGhhdmUgcmVhbCB0cmFuc3BhcmVudCBjb3JuZXJzIHdlIG5lZWQgdGhlIGNvbnRyb2xzIG9uIHVwcGVyQ2FudmFzXG4gICAgLy8gdHJhbnNwYXJlbnRDb3JuZXJzIHx8IGN0eC5jbGVhclJlY3QoLXhTaXplQnkyLCAteVNpemVCeTIsIHhTaXplLCB5U2l6ZSk7XG4gICAgY3R4W21ldGhvZE5hbWUgKyAnUmVjdCddKC14U2l6ZUJ5MiwgLXlTaXplQnkyLCB4U2l6ZSwgeVNpemUpO1xuICAgIGlmIChzdHJva2UpIHtcbiAgICAgIGN0eC5zdHJva2VSZWN0KC14U2l6ZUJ5MiwgLXlTaXplQnkyLCB4U2l6ZSwgeVNpemUpO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG5cbiAgY29udHJvbHMucmVuZGVyQ2lyY2xlQ29udHJvbCA9IHJlbmRlckNpcmNsZUNvbnRyb2w7XG4gIGNvbnRyb2xzLnJlbmRlclNxdWFyZUNvbnRyb2wgPSByZW5kZXJTcXVhcmVDb250cm9sO1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSk7XG5cbiAgZnVuY3Rpb24gQ29udHJvbChvcHRpb25zKSB7XG4gICAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzW2ldID0gb3B0aW9uc1tpXTtcbiAgICB9XG4gIH1cblxuICBmYWJyaWMuQ29udHJvbCA9IENvbnRyb2w7XG5cbiAgZmFicmljLkNvbnRyb2wucHJvdG90eXBlID0gLyoqIEBsZW5kcyBmYWJyaWMuQ29udHJvbC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICoga2VlcCB0cmFjayBvZiBjb250cm9sIHZpc2liaWxpdHkuXG4gICAgICogbWFpbmx5IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgICAqIGlmIHlvdSBkbyBub3Qgd2FudCB0byBzZWUgYSBjb250cm9sLCB5b3UgY2FuIHJlbW92ZSBpdFxuICAgICAqIGZyb20gdGhlIGNvbnRyb2xzZXQuXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIHZpc2libGU6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBOYW1lIG9mIHRoZSBhY3Rpb24gdGhhdCB0aGUgY29udHJvbCB3aWxsIGxpa2VseSBleGVjdXRlLlxuICAgICAqIFRoaXMgaXMgb3B0aW9uYWwuIEZhYnJpY0pTIHVzZXMgdG8gaWRlbnRpZnkgd2hhdCB0aGUgdXNlciBpcyBkb2luZyBmb3Igc29tZVxuICAgICAqIGV4dHJhIG9wdGltaXphdGlvbnMuIElmIHlvdSBhcmUgd3JpdGluZyBhIGN1c3RvbSBjb250cm9sIGFuZCB5b3Ugd2FudCB0byBrbm93XG4gICAgICogc29tZXdoZXJlIGVsc2UgaW4gdGhlIGNvZGUgd2hhdCBpcyBnb2luZyBvbiwgeW91IGNhbiB1c2UgdGhpcyBzdHJpbmcgaGVyZS5cbiAgICAgKiB5b3UgY2FuIGFsc28gcHJvdmlkZSBhIGN1c3RvbSBnZXRBY3Rpb25OYW1lIGlmIHlvdXIgY29udHJvbCBydW4gbXVsdGlwbGUgYWN0aW9uc1xuICAgICAqIGRlcGVuZGluZyBvbiBzb21lIGV4dGVybmFsIHN0YXRlLlxuICAgICAqIGRlZmF1bHQgdG8gc2NhbGUgc2luY2UgaXMgdGhlIG1vc3QgY29tbW9uLCB1c2VkIG9uIDQgY29ybmVycyBieSBkZWZhdWx0XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAnc2NhbGUnXG4gICAgICovXG4gICAgYWN0aW9uTmFtZTogJ3NjYWxlJyxcblxuICAgIC8qKlxuICAgICAqIERyYXdpbmcgYW5nbGUgb2YgdGhlIGNvbnRyb2wuXG4gICAgICogTk9UIHVzZWQgZm9yIG5vdywgYnV0IG5hbWUgbWFya2VkIGFzIG5lZWRlZCBmb3IgaW50ZXJuYWwgbG9naWNcbiAgICAgKiBleGFtcGxlOiB0byByZXVzZSB0aGUgc2FtZSBkcmF3aW5nIGZ1bmN0aW9uIGZvciBkaWZmZXJlbnQgcm90YXRlZCBjb250cm9sc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIGFuZ2xlOiAwLFxuXG4gICAgLyoqXG4gICAgICogUmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wuIFhcbiAgICAgKiAwLDAgaXMgdGhlIGNlbnRlciBvZiB0aGUgT2JqZWN0LCB3aGlsZSAtMC41IChsZWZ0KSBvciAwLjUgKHJpZ2h0KSBhcmUgdGhlIGV4dHJlbWl0aWVzXG4gICAgICogb2YgdGhlIGJvdW5kaW5nIGJveC5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB4OiAwLFxuXG4gICAgLyoqXG4gICAgICogUmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIGNvbnRyb2wuIFlcbiAgICAgKiAwLDAgaXMgdGhlIGNlbnRlciBvZiB0aGUgT2JqZWN0LCB3aGlsZSAtMC41ICh0b3ApIG9yIDAuNSAoYm90dG9tKSBhcmUgdGhlIGV4dHJlbWl0aWVzXG4gICAgICogb2YgdGhlIGJvdW5kaW5nIGJveC5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB5OiAwLFxuXG4gICAgLyoqXG4gICAgICogSG9yaXpvbnRhbCBvZmZzZXQgb2YgdGhlIGNvbnRyb2wgZnJvbSB0aGUgZGVmaW5lZCBwb3NpdGlvbi4gSW4gcGl4ZWxzXG4gICAgICogUG9zaXRpdmUgb2Zmc2V0IG1vdmVzIHRoZSBjb250cm9sIHRvIHRoZSByaWdodCwgbmVnYXRpdmUgdG8gdGhlIGxlZnQuXG4gICAgICogSXQgdXNlZCB3aGVuIHlvdSB3YW50IHRvIGhhdmUgcG9zaXRpb24gb2YgY29udHJvbCB0aGF0IGRvZXMgbm90IHNjYWxlIHdpdGhcbiAgICAgKiB0aGUgYm91bmRpbmcgYm94LiBFeGFtcGxlOiByb3RhdGlvbiBjb250cm9sIGlzIHBsYWNlZCBhdCB4OjAsIHk6IDAuNSBvblxuICAgICAqIHRoZSBib3VuZGluZGJveCwgd2l0aCBhbiBvZmZzZXQgb2YgMzAgcGl4ZWxzIHZlcnRpY2FsbHkuIFRob3NlIDMwIHBpeGVscyB3aWxsXG4gICAgICogc3RheSAzMCBwaXhlbHMgbm8gbWF0dGVyIGhvdyB0aGUgb2JqZWN0IGlzIGJpZy4gQW5vdGhlciBleGFtcGxlIGlzIGhhdmluZyAyXG4gICAgICogY29udHJvbHMgaW4gdGhlIGNvcm5lciwgdGhhdCBzdGF5IGluIHRoZSBzYW1lIHBvc2l0aW9uIHdoZW4gdGhlIG9iamVjdCBzY2FsZS5cbiAgICAgKiBvZiB0aGUgYm91bmRpbmcgYm94LlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIG9mZnNldFg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBWZXJ0aWNhbCBvZmZzZXQgb2YgdGhlIGNvbnRyb2wgZnJvbSB0aGUgZGVmaW5lZCBwb3NpdGlvbi4gSW4gcGl4ZWxzXG4gICAgICogUG9zaXRpdmUgb2Zmc2V0IG1vdmVzIHRoZSBjb250cm9sIHRvIHRoZSBib3R0b20sIG5lZ2F0aXZlIHRvIHRoZSB0b3AuXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgb2Zmc2V0WTogMCxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGxlbmd0aCBvZiB0aGUgY29udHJvbC4gSWYgbnVsbCwgZGVmYXVsdHMgdG8gb2JqZWN0J3MgY29ybmVyU2l6ZS5cbiAgICAgKiBFeHBlY3RzIGJvdGggc2l6ZVggYW5kIHNpemVZIHRvIGJlIHNldCB3aGVuIHNldC5cbiAgICAgKiBAdHlwZSB7P051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgc2l6ZVg6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBoZWlnaHQgb2YgdGhlIGNvbnRyb2wuIElmIG51bGwsIGRlZmF1bHRzIHRvIG9iamVjdCdzIGNvcm5lclNpemUuXG4gICAgICogRXhwZWN0cyBib3RoIHNpemVYIGFuZCBzaXplWSB0byBiZSBzZXQgd2hlbiBzZXQuXG4gICAgICogQHR5cGUgez9OdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIHNpemVZOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGVuZ3RoIG9mIHRoZSB0b3VjaCBhcmVhIG9mIHRoZSBjb250cm9sLiBJZiBudWxsLCBkZWZhdWx0cyB0byBvYmplY3QncyB0b3VjaENvcm5lclNpemUuXG4gICAgICogRXhwZWN0cyBib3RoIHRvdWNoU2l6ZVggYW5kIHRvdWNoU2l6ZVkgdG8gYmUgc2V0IHdoZW4gc2V0LlxuICAgICAqIEB0eXBlIHs/TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICB0b3VjaFNpemVYOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSB0b3VjaCBhcmVhIG9mIHRoZSBjb250cm9sLiBJZiBudWxsLCBkZWZhdWx0cyB0byBvYmplY3QncyB0b3VjaENvcm5lclNpemUuXG4gICAgICogRXhwZWN0cyBib3RoIHRvdWNoU2l6ZVggYW5kIHRvdWNoU2l6ZVkgdG8gYmUgc2V0IHdoZW4gc2V0LlxuICAgICAqIEB0eXBlIHs/TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICB0b3VjaFNpemVZOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQ3NzIGN1cnNvciBzdHlsZSB0byBkaXNwbGF5IHdoZW4gdGhlIGNvbnRyb2wgaXMgaG92ZXJlZC5cbiAgICAgKiBpZiB0aGUgbWV0aG9kIGBjdXJzb3JTdHlsZUhhbmRsZXJgIGlzIHByb3ZpZGVkLCB0aGlzIHByb3BlcnR5IGlzIGlnbm9yZWQuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAnY3Jvc3NoYWlyJ1xuICAgICAqL1xuICAgIGN1cnNvclN0eWxlOiAnY3Jvc3NoYWlyJyxcblxuICAgIC8qKlxuICAgICAqIElmIGNvbnRyb2xzIGhhcyBhbiBvZmZzZXRZIG9yIG9mZnNldFgsIGRyYXcgYSBsaW5lIHRoYXQgY29ubmVjdHNcbiAgICAgKiB0aGUgY29udHJvbCB0byB0aGUgYm91bmRpbmcgYm94XG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICB3aXRoQ29ubmVjdGlvbjogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29udHJvbCBhY3Rpb25IYW5kbGVyLCBwcm92aWRlIG9uZSB0byBoYW5kbGUgYWN0aW9uICggY29udHJvbCBiZWluZyBtb3ZlZCApXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBuYXRpdmUgbW91c2UgZXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtRGF0YSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IHggcG9zaXRpb24gb2YgdGhlIGN1cnNvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHkgcG9zaXRpb24gb2YgdGhlIGN1cnNvclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIGFjdGlvbi9ldmVudCBtb2RpZmllZCB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgYWN0aW9uSGFuZGxlcjogZnVuY3Rpb24oLyogZXZlbnREYXRhLCB0cmFuc2Zvcm1EYXRhLCB4LCB5ICovKSB7IH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29udHJvbCBoYW5kbGVyIGZvciBtb3VzZSBkb3duLCBwcm92aWRlIG9uZSB0byBoYW5kbGUgbW91c2UgZG93biBvbiBjb250cm9sXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnREYXRhIHRoZSBuYXRpdmUgbW91c2UgZXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtRGF0YSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IHggcG9zaXRpb24gb2YgdGhlIGN1cnNvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHkgcG9zaXRpb24gb2YgdGhlIGN1cnNvclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIGFjdGlvbi9ldmVudCBtb2RpZmllZCB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgbW91c2VEb3duSGFuZGxlcjogZnVuY3Rpb24oLyogZXZlbnREYXRhLCB0cmFuc2Zvcm1EYXRhLCB4LCB5ICovKSB7IH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29udHJvbCBtb3VzZVVwSGFuZGxlciwgcHJvdmlkZSBvbmUgdG8gaGFuZGxlIGFuIGVmZmVjdCBvbiBtb3VzZSB1cC5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIG5hdGl2ZSBtb3VzZSBldmVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm1EYXRhIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgdHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggeCBwb3NpdGlvbiBvZiB0aGUgY3Vyc29yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgeSBwb3NpdGlvbiBvZiB0aGUgY3Vyc29yXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgYWN0aW9uL2V2ZW50IG1vZGlmaWVkIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBtb3VzZVVwSGFuZGxlcjogZnVuY3Rpb24oLyogZXZlbnREYXRhLCB0cmFuc2Zvcm1EYXRhLCB4LCB5ICovKSB7IH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnRyb2wgYWN0aW9uSGFuZGxlclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSB0aGUgbmF0aXZlIG1vdXNlIGV2ZW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3Qgb24gd2hpY2ggdGhlIGNvbnRyb2wgaXMgZGlzcGxheWVkXG4gICAgICogQHBhcmFtIHtmYWJyaWMuQ29udHJvbH0gY29udHJvbCBjb250cm9sIGZvciB3aGljaCB0aGUgYWN0aW9uIGhhbmRsZXIgaXMgYmVpbmcgYXNrZWRcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGhlIGFjdGlvbiBoYW5kbGVyXG4gICAgICovXG4gICAgZ2V0QWN0aW9uSGFuZGxlcjogZnVuY3Rpb24oLyogZXZlbnREYXRhLCBmYWJyaWNPYmplY3QsIGNvbnRyb2wgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLmFjdGlvbkhhbmRsZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29udHJvbCBtb3VzZURvd24gaGFuZGxlclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSB0aGUgbmF0aXZlIG1vdXNlIGV2ZW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBmYWJyaWNPYmplY3Qgb24gd2hpY2ggdGhlIGNvbnRyb2wgaXMgZGlzcGxheWVkXG4gICAgICogQHBhcmFtIHtmYWJyaWMuQ29udHJvbH0gY29udHJvbCBjb250cm9sIGZvciB3aGljaCB0aGUgYWN0aW9uIGhhbmRsZXIgaXMgYmVpbmcgYXNrZWRcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGhlIGFjdGlvbiBoYW5kbGVyXG4gICAgICovXG4gICAgZ2V0TW91c2VEb3duSGFuZGxlcjogZnVuY3Rpb24oLyogZXZlbnREYXRhLCBmYWJyaWNPYmplY3QsIGNvbnRyb2wgKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLm1vdXNlRG93bkhhbmRsZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29udHJvbCBtb3VzZVVwIGhhbmRsZXJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIG5hdGl2ZSBtb3VzZSBldmVudFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gZmFicmljT2JqZWN0IG9uIHdoaWNoIHRoZSBjb250cm9sIGlzIGRpc3BsYXllZFxuICAgICAqIEBwYXJhbSB7ZmFicmljLkNvbnRyb2x9IGNvbnRyb2wgY29udHJvbCBmb3Igd2hpY2ggdGhlIGFjdGlvbiBoYW5kbGVyIGlzIGJlaW5nIGFza2VkXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IHRoZSBhY3Rpb24gaGFuZGxlclxuICAgICAqL1xuICAgIGdldE1vdXNlVXBIYW5kbGVyOiBmdW5jdGlvbigvKiBldmVudERhdGEsIGZhYnJpY09iamVjdCwgY29udHJvbCAqLykge1xuICAgICAgcmV0dXJuIHRoaXMubW91c2VVcEhhbmRsZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29udHJvbCBjdXJzb3JTdHlsZSBmb3IgY3NzIHVzaW5nIGN1cnNvclN0eWxlLiBJZiB5b3UgbmVlZCBhIG1vcmUgZWxhYm9yYXRlXG4gICAgICogZnVuY3Rpb24geW91IGNhbiBwYXNzIG9uZSBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAgKiB0aGUgY3Vyc29yU3R5bGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudERhdGEgdGhlIG5hdGl2ZSBtb3VzZSBldmVudFxuICAgICAqIEBwYXJhbSB7ZmFicmljLkNvbnRyb2x9IGNvbnRyb2wgdGhlIGN1cnJlbnQgY29udHJvbCAoIGxpa2VseSB0aGlzKVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IG9uIHdoaWNoIHRoZSBjb250cm9sIGlzIGRpc3BsYXllZFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50RGF0YSwgY29udHJvbCAvKiBmYWJyaWNPYmplY3QgKi8pIHtcbiAgICAgIHJldHVybiBjb250cm9sLmN1cnNvclN0eWxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhY3Rpb24gbmFtZS4gVGhlIGJhc2ljIGltcGxlbWVudGF0aW9uIGp1c3QgcmV0dXJuIHRoZSBhY3Rpb25OYW1lIHByb3BlcnR5LlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50RGF0YSB0aGUgbmF0aXZlIG1vdXNlIGV2ZW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuQ29udHJvbH0gY29udHJvbCB0aGUgY3VycmVudCBjb250cm9sICggbGlrZWx5IHRoaXMpXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3Qgb24gd2hpY2ggdGhlIGNvbnRyb2wgaXMgZGlzcGxheWVkXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldEFjdGlvbk5hbWU6IGZ1bmN0aW9uKGV2ZW50RGF0YSwgY29udHJvbCAvKiBmYWJyaWNPYmplY3QgKi8pIHtcbiAgICAgIHJldHVybiBjb250cm9sLmFjdGlvbk5hbWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29udHJvbHMgdmlzaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IG9uIHdoaWNoIHRoZSBjb250cm9sIGlzIGRpc3BsYXllZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb250cm9sS2V5IGtleSB3aGVyZSB0aGUgY29udHJvbCBpcyBtZW1vcml6ZWQgb24gdGhlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXRWaXNpYmlsaXR5OiBmdW5jdGlvbihmYWJyaWNPYmplY3QsIGNvbnRyb2xLZXkpIHtcbiAgICAgIHZhciBvYmplY3RWaXNpYmlsaXR5ID0gZmFicmljT2JqZWN0Ll9jb250cm9sc1Zpc2liaWxpdHk7XG4gICAgICBpZiAob2JqZWN0VmlzaWJpbGl0eSAmJiB0eXBlb2Ygb2JqZWN0VmlzaWJpbGl0eVtjb250cm9sS2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdFZpc2liaWxpdHlbY29udHJvbEtleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy52aXNpYmxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGNvbnRyb2xzIHZpc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZpc2liaWxpdHkgZm9yIHRoZSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAqL1xuICAgIHNldFZpc2liaWxpdHk6IGZ1bmN0aW9uKHZpc2liaWxpdHkgLyogbmFtZSwgZmFicmljT2JqZWN0ICovKSB7XG4gICAgICB0aGlzLnZpc2libGUgPSB2aXNpYmlsaXR5O1xuICAgIH0sXG5cblxuICAgIHBvc2l0aW9uSGFuZGxlcjogZnVuY3Rpb24oZGltLCBmaW5hbE1hdHJpeCAvKiwgZmFicmljT2JqZWN0LCBjdXJyZW50Q29udHJvbCAqLykge1xuICAgICAgdmFyIHBvaW50ID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQoe1xuICAgICAgICB4OiB0aGlzLnggKiBkaW0ueCArIHRoaXMub2Zmc2V0WCxcbiAgICAgICAgeTogdGhpcy55ICogZGltLnkgKyB0aGlzLm9mZnNldFkgfSwgZmluYWxNYXRyaXgpO1xuICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb29yZHMgZm9yIHRoaXMgY29udHJvbCBiYXNlZCBvbiBvYmplY3QgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvYmplY3RBbmdsZSBhbmdsZSBmcm9tIHRoZSBmYWJyaWMgb2JqZWN0IGhvbGRpbmcgdGhlIGNvbnRyb2xcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2JqZWN0Q29ybmVyU2l6ZSBjb3JuZXJTaXplIGZyb20gdGhlIGZhYnJpYyBvYmplY3QgaG9sZGluZyB0aGUgY29udHJvbCAob3IgdG91Y2hDb3JuZXJTaXplIGlmXG4gICAgICogICBpc1RvdWNoIGlzIHRydWUpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNlbnRlclggeCBjb29yZGluYXRlIHdoZXJlIHRoZSBjb250cm9sIGNlbnRlciBzaG91bGQgYmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2VudGVyWSB5IGNvb3JkaW5hdGUgd2hlcmUgdGhlIGNvbnRyb2wgY2VudGVyIHNob3VsZCBiZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNUb3VjaCB0cnVlIGlmIHRvdWNoIGNvcm5lciwgZmFsc2UgaWYgbm9ybWFsIGNvcm5lclxuICAgICAqL1xuICAgIGNhbGNDb3JuZXJDb29yZHM6IGZ1bmN0aW9uKG9iamVjdEFuZ2xlLCBvYmplY3RDb3JuZXJTaXplLCBjZW50ZXJYLCBjZW50ZXJZLCBpc1RvdWNoKSB7XG4gICAgICB2YXIgY29zSGFsZk9mZnNldCxcbiAgICAgICAgICBzaW5IYWxmT2Zmc2V0LFxuICAgICAgICAgIGNvc0hhbGZPZmZzZXRDb21wLFxuICAgICAgICAgIHNpbkhhbGZPZmZzZXRDb21wLFxuICAgICAgICAgIHhTaXplID0gKGlzVG91Y2gpID8gdGhpcy50b3VjaFNpemVYIDogdGhpcy5zaXplWCxcbiAgICAgICAgICB5U2l6ZSA9IChpc1RvdWNoKSA/IHRoaXMudG91Y2hTaXplWSA6IHRoaXMuc2l6ZVk7XG4gICAgICBpZiAoeFNpemUgJiYgeVNpemUgJiYgeFNpemUgIT09IHlTaXplKSB7XG4gICAgICAgIC8vIGhhbmRsZSByZWN0YW5ndWxhciBjb3JuZXJzXG4gICAgICAgIHZhciBjb250cm9sVHJpYW5nbGVBbmdsZSA9IE1hdGguYXRhbjIoeVNpemUsIHhTaXplKTtcbiAgICAgICAgdmFyIGNvcm5lckh5cG90ZW51c2UgPSBNYXRoLnNxcnQoeFNpemUgKiB4U2l6ZSArIHlTaXplICogeVNpemUpIC8gMjtcbiAgICAgICAgdmFyIG5ld1RoZXRhID0gY29udHJvbFRyaWFuZ2xlQW5nbGUgLSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zKG9iamVjdEFuZ2xlKTtcbiAgICAgICAgdmFyIG5ld1RoZXRhQ29tcCA9IE1hdGguUEkgLyAyIC0gY29udHJvbFRyaWFuZ2xlQW5nbGUgLSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zKG9iamVjdEFuZ2xlKTtcbiAgICAgICAgY29zSGFsZk9mZnNldCA9IGNvcm5lckh5cG90ZW51c2UgKiBmYWJyaWMudXRpbC5jb3MobmV3VGhldGEpO1xuICAgICAgICBzaW5IYWxmT2Zmc2V0ID0gY29ybmVySHlwb3RlbnVzZSAqIGZhYnJpYy51dGlsLnNpbihuZXdUaGV0YSk7XG4gICAgICAgIC8vIHVzZSBjb21wbGVtZW50YXJ5IGFuZ2xlIGZvciB0d28gY29ybmVyc1xuICAgICAgICBjb3NIYWxmT2Zmc2V0Q29tcCA9IGNvcm5lckh5cG90ZW51c2UgKiBmYWJyaWMudXRpbC5jb3MobmV3VGhldGFDb21wKTtcbiAgICAgICAgc2luSGFsZk9mZnNldENvbXAgPSBjb3JuZXJIeXBvdGVudXNlICogZmFicmljLnV0aWwuc2luKG5ld1RoZXRhQ29tcCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gaGFuZGxlIHNxdWFyZSBjb3JuZXJzXG4gICAgICAgIC8vIHVzZSBkZWZhdWx0IG9iamVjdCBjb3JuZXIgc2l6ZSB1bmxlc3Mgc2l6ZSBpcyBkZWZpbmVkXG4gICAgICAgIHZhciBjb3JuZXJTaXplID0gKHhTaXplICYmIHlTaXplKSA/IHhTaXplIDogb2JqZWN0Q29ybmVyU2l6ZTtcbiAgICAgICAgLyogMC43MDcxMDY3ODEyIHN0YW5kcyBmb3Igc3FydCgyKS8yICovXG4gICAgICAgIGNvcm5lckh5cG90ZW51c2UgPSBjb3JuZXJTaXplICogMC43MDcxMDY3ODEyO1xuICAgICAgICAvLyBjb21wbGVtZW50YXJ5IGFuZ2xlcyBhcmUgZXF1YWwgc2luY2UgdGhleSdyZSBib3RoIDQ1IGRlZ3JlZXNcbiAgICAgICAgdmFyIG5ld1RoZXRhID0gZmFicmljLnV0aWwuZGVncmVlc1RvUmFkaWFucyg0NSAtIG9iamVjdEFuZ2xlKTtcbiAgICAgICAgY29zSGFsZk9mZnNldCA9IGNvc0hhbGZPZmZzZXRDb21wID0gY29ybmVySHlwb3RlbnVzZSAqIGZhYnJpYy51dGlsLmNvcyhuZXdUaGV0YSk7XG4gICAgICAgIHNpbkhhbGZPZmZzZXQgPSBzaW5IYWxmT2Zmc2V0Q29tcCA9IGNvcm5lckh5cG90ZW51c2UgKiBmYWJyaWMudXRpbC5zaW4obmV3VGhldGEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0bDoge1xuICAgICAgICAgIHg6IGNlbnRlclggLSBzaW5IYWxmT2Zmc2V0Q29tcCxcbiAgICAgICAgICB5OiBjZW50ZXJZIC0gY29zSGFsZk9mZnNldENvbXAsXG4gICAgICAgIH0sXG4gICAgICAgIHRyOiB7XG4gICAgICAgICAgeDogY2VudGVyWCArIGNvc0hhbGZPZmZzZXQsXG4gICAgICAgICAgeTogY2VudGVyWSAtIHNpbkhhbGZPZmZzZXQsXG4gICAgICAgIH0sXG4gICAgICAgIGJsOiB7XG4gICAgICAgICAgeDogY2VudGVyWCAtIGNvc0hhbGZPZmZzZXQsXG4gICAgICAgICAgeTogY2VudGVyWSArIHNpbkhhbGZPZmZzZXQsXG4gICAgICAgIH0sXG4gICAgICAgIGJyOiB7XG4gICAgICAgICAgeDogY2VudGVyWCArIHNpbkhhbGZPZmZzZXRDb21wLFxuICAgICAgICAgIHk6IGNlbnRlclkgKyBjb3NIYWxmT2Zmc2V0Q29tcCxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogUmVuZGVyIGZ1bmN0aW9uIGZvciB0aGUgY29udHJvbC5cbiAgICAqIFdoZW4gdGhpcyBmdW5jdGlvbiBydW5zIHRoZSBjb250ZXh0IGlzIHVuc2NhbGVkLiB1bnJvdGF0ZS4gSnVzdCByZXRpbmEgc2NhbGVkLlxuICAgICogYWxsIHRoZSBmdW5jdGlvbnMgd2lsbCBoYXZlIHRvIHRyYW5zbGF0ZSB0byB0aGUgcG9pbnQgbGVmdCx0b3AgYmVmb3JlIHN0YXJ0aW5nIERyYXdpbmdcbiAgICAqIGlmIHRoZXkgd2FudCB0byBkcmF3IGEgY29udHJvbCB3aGVyZSB0aGUgcG9zaXRpb24gaXMgZGV0ZWN0ZWQuXG4gICAgKiBsZWZ0IGFuZCB0b3AgYXJlIHRoZSByZXN1bHQgb2YgdGhlIHBvc2l0aW9uSGFuZGxlciBmdW5jdGlvblxuICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCB0aGUgY29udGV4dCB3aGVyZSB0aGUgY29udHJvbCB3aWxsIGJlIGRyYXduXG4gICAgKiBAcGFyYW0ge051bWJlcn0gbGVmdCBwb3NpdGlvbiBvZiB0aGUgY2FudmFzIHdoZXJlIHdlIGFyZSBhYm91dCB0byByZW5kZXIgdGhlIGNvbnRyb2wuXG4gICAgKiBAcGFyYW0ge051bWJlcn0gdG9wIHBvc2l0aW9uIG9mIHRoZSBjYW52YXMgd2hlcmUgd2UgYXJlIGFib3V0IHRvIHJlbmRlciB0aGUgY29udHJvbC5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZU92ZXJyaWRlXG4gICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGZhYnJpY09iamVjdCB0aGUgb2JqZWN0IHdoZXJlIHRoZSBjb250cm9sIGlzIGFib3V0IHRvIGJlIHJlbmRlcmVkXG4gICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGN0eCwgbGVmdCwgdG9wLCBzdHlsZU92ZXJyaWRlLCBmYWJyaWNPYmplY3QpIHtcbiAgICAgIHN0eWxlT3ZlcnJpZGUgPSBzdHlsZU92ZXJyaWRlIHx8IHt9O1xuICAgICAgc3dpdGNoIChzdHlsZU92ZXJyaWRlLmNvcm5lclN0eWxlIHx8IGZhYnJpY09iamVjdC5jb3JuZXJTdHlsZSkge1xuICAgICAgICBjYXNlICdjaXJjbGUnOlxuICAgICAgICAgIGZhYnJpYy5jb250cm9sc1V0aWxzLnJlbmRlckNpcmNsZUNvbnRyb2wuY2FsbCh0aGlzLCBjdHgsIGxlZnQsIHRvcCwgc3R5bGVPdmVycmlkZSwgZmFicmljT2JqZWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBmYWJyaWMuY29udHJvbHNVdGlscy5yZW5kZXJTcXVhcmVDb250cm9sLmNhbGwodGhpcywgY3R4LCBsZWZ0LCB0b3AsIHN0eWxlT3ZlcnJpZGUsIGZhYnJpY09iamVjdCk7XG4gICAgICB9XG4gICAgfSxcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIGZ1bmN0aW9uIGdldENvbG9yU3RvcChlbCwgbXVsdGlwbGllcikge1xuICAgIHZhciBzdHlsZSA9IGVsLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSxcbiAgICAgICAgb2Zmc2V0ID0gZWwuZ2V0QXR0cmlidXRlKCdvZmZzZXQnKSB8fCAwLFxuICAgICAgICBjb2xvciwgY29sb3JBbHBoYSwgb3BhY2l0eSwgaTtcblxuICAgIC8vIGNvbnZlcnQgcGVyY2VudHMgdG8gYWJzb2x1dGUgdmFsdWVzXG4gICAgb2Zmc2V0ID0gcGFyc2VGbG9hdChvZmZzZXQpIC8gKC8lJC8udGVzdChvZmZzZXQpID8gMTAwIDogMSk7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IDwgMCA/IDAgOiBvZmZzZXQgPiAxID8gMSA6IG9mZnNldDtcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIHZhciBrZXlWYWx1ZVBhaXJzID0gc3R5bGUuc3BsaXQoL1xccyo7XFxzKi8pO1xuXG4gICAgICBpZiAoa2V5VmFsdWVQYWlyc1trZXlWYWx1ZVBhaXJzLmxlbmd0aCAtIDFdID09PSAnJykge1xuICAgICAgICBrZXlWYWx1ZVBhaXJzLnBvcCgpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSBrZXlWYWx1ZVBhaXJzLmxlbmd0aDsgaS0tOyApIHtcblxuICAgICAgICB2YXIgc3BsaXQgPSBrZXlWYWx1ZVBhaXJzW2ldLnNwbGl0KC9cXHMqOlxccyovKSxcbiAgICAgICAgICAgIGtleSA9IHNwbGl0WzBdLnRyaW0oKSxcbiAgICAgICAgICAgIHZhbHVlID0gc3BsaXRbMV0udHJpbSgpO1xuXG4gICAgICAgIGlmIChrZXkgPT09ICdzdG9wLWNvbG9yJykge1xuICAgICAgICAgIGNvbG9yID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnc3RvcC1vcGFjaXR5Jykge1xuICAgICAgICAgIG9wYWNpdHkgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY29sb3IpIHtcbiAgICAgIGNvbG9yID0gZWwuZ2V0QXR0cmlidXRlKCdzdG9wLWNvbG9yJykgfHwgJ3JnYigwLDAsMCknO1xuICAgIH1cbiAgICBpZiAoIW9wYWNpdHkpIHtcbiAgICAgIG9wYWNpdHkgPSBlbC5nZXRBdHRyaWJ1dGUoJ3N0b3Atb3BhY2l0eScpO1xuICAgIH1cblxuICAgIGNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcihjb2xvcik7XG4gICAgY29sb3JBbHBoYSA9IGNvbG9yLmdldEFscGhhKCk7XG4gICAgb3BhY2l0eSA9IGlzTmFOKHBhcnNlRmxvYXQob3BhY2l0eSkpID8gMSA6IHBhcnNlRmxvYXQob3BhY2l0eSk7XG4gICAgb3BhY2l0eSAqPSBjb2xvckFscGhhICogbXVsdGlwbGllcjtcblxuICAgIHJldHVybiB7XG4gICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgIGNvbG9yOiBjb2xvci50b1JnYigpLFxuICAgICAgb3BhY2l0eTogb3BhY2l0eVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRMaW5lYXJDb29yZHMoZWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDE6IGVsLmdldEF0dHJpYnV0ZSgneDEnKSB8fCAwLFxuICAgICAgeTE6IGVsLmdldEF0dHJpYnV0ZSgneTEnKSB8fCAwLFxuICAgICAgeDI6IGVsLmdldEF0dHJpYnV0ZSgneDInKSB8fCAnMTAwJScsXG4gICAgICB5MjogZWwuZ2V0QXR0cmlidXRlKCd5MicpIHx8IDBcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UmFkaWFsQ29vcmRzKGVsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHgxOiBlbC5nZXRBdHRyaWJ1dGUoJ2Z4JykgfHwgZWwuZ2V0QXR0cmlidXRlKCdjeCcpIHx8ICc1MCUnLFxuICAgICAgeTE6IGVsLmdldEF0dHJpYnV0ZSgnZnknKSB8fCBlbC5nZXRBdHRyaWJ1dGUoJ2N5JykgfHwgJzUwJScsXG4gICAgICByMTogMCxcbiAgICAgIHgyOiBlbC5nZXRBdHRyaWJ1dGUoJ2N4JykgfHwgJzUwJScsXG4gICAgICB5MjogZWwuZ2V0QXR0cmlidXRlKCdjeScpIHx8ICc1MCUnLFxuICAgICAgcjI6IGVsLmdldEF0dHJpYnV0ZSgncicpIHx8ICc1MCUnXG4gICAgfTtcbiAgfVxuICAvKiBfRlJPTV9TVkdfRU5EXyAqL1xuXG4gIHZhciBjbG9uZSA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZTtcblxuICAvKipcbiAgICogR3JhZGllbnQgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5HcmFkaWVudFxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMiNncmFkaWVudHN9XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5HcmFkaWVudCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLkdyYWRpZW50ID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoLyoqIEBsZW5kcyBmYWJyaWMuR3JhZGllbnQucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEhvcml6b250YWwgb2Zmc2V0IGZvciBhbGlnbmluZyBncmFkaWVudHMgY29taW5nIGZyb20gU1ZHIHdoZW4gb3V0c2lkZSBwYXRoZ3JvdXBzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIG9mZnNldFg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBWZXJ0aWNhbCBvZmZzZXQgZm9yIGFsaWduaW5nIGdyYWRpZW50cyBjb21pbmcgZnJvbSBTVkcgd2hlbiBvdXRzaWRlIHBhdGhncm91cHNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgb2Zmc2V0WTogMCxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhbnNmb3JtIG1hdHJpeCB0byBhcHBseSB0byB0aGUgZ3JhZGllbnQgYmVmb3JlIHBhaW50aW5nLlxuICAgICAqIEltcG9ydGVkIGZyb20gc3ZnIGdyYWRpZW50cywgaXMgbm90IGFwcGxpZWQgd2l0aCB0aGUgY3VycmVudCB0cmFuc2Zvcm0gaW4gdGhlIGNlbnRlci5cbiAgICAgKiBCZWZvcmUgdGhpcyB0cmFuc2Zvcm0gaXMgYXBwbGllZCwgdGhlIG9yaWdpbiBwb2ludCBpcyBhdCB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBvYmplY3RcbiAgICAgKiBwbHVzIHRoZSBhZGRpdGlvbiBvZiBvZmZzZXRZIGFuZCBvZmZzZXRYLlxuICAgICAqIEB0eXBlIE51bWJlcltdXG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIGdyYWRpZW50VHJhbnNmb3JtOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogY29vcmRpbmF0ZXMgdW5pdHMgZm9yIGNvb3Jkcy5cbiAgICAgKiBJZiBgcGl4ZWxzYCwgdGhlIG51bWJlciBvZiBjb29yZHMgYXJlIGluIHRoZSBzYW1lIHVuaXQgb2Ygd2lkdGggLyBoZWlnaHQuXG4gICAgICogSWYgc2V0IGFzIGBwZXJjZW50YWdlYCB0aGUgY29vcmRzIGFyZSBzdGlsbCBhIG51bWJlciwgYnV0IDEgbWVhbnMgMTAwJSBvZiB3aWR0aFxuICAgICAqIGZvciB0aGUgWCBhbmQgMTAwJSBvZiB0aGUgaGVpZ2h0IGZvciB0aGUgeS4gSXQgY2FuIGJlIGJpZ2dlciB0aGFuIDEgYW5kIG5lZ2F0aXZlLlxuICAgICAqIGFsbG93ZWQgdmFsdWVzIHBpeGVscyBvciBwZXJjZW50YWdlLlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0ICdwaXhlbHMnXG4gICAgICovXG4gICAgZ3JhZGllbnRVbml0czogJ3BpeGVscycsXG5cbiAgICAvKipcbiAgICAgKiBHcmFkaWVudCB0eXBlIGxpbmVhciBvciByYWRpYWxcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdCAncGl4ZWxzJ1xuICAgICAqL1xuICAgIHR5cGU6ICdsaW5lYXInLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdCB3aXRoIHR5cGUsIGNvb3JkcywgZ3JhZGllbnRVbml0cyBhbmQgY29sb3JTdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy50eXBlXSBncmFkaWVudCB0eXBlIGxpbmVhciBvciByYWRpYWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZ3JhZGllbnRVbml0c10gZ3JhZGllbnQgdW5pdHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMub2Zmc2V0WF0gU1ZHIGltcG9ydCBjb21wYXRpYmlsaXR5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm9mZnNldFldIFNWRyBpbXBvcnQgY29tcGF0aWJpbGl0eVxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IG9wdGlvbnMuY29sb3JTdG9wcyBjb250YWlucyB0aGUgY29sb3JzdG9wcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5jb29yZHMgY29udGFpbnMgdGhlIGNvb3JkcyBvZiB0aGUgZ3JhZGllbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29vcmRzLngxXSBYIGNvb3JkaWFudGUgb2YgdGhlIGZpcnN0IHBvaW50IGZvciBsaW5lYXIgb3Igb2YgdGhlIGZvY2FsIHBvaW50IGZvciByYWRpYWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29vcmRzLnkxXSBZIGNvb3JkaWFudGUgb2YgdGhlIGZpcnN0IHBvaW50IGZvciBsaW5lYXIgb3Igb2YgdGhlIGZvY2FsIHBvaW50IGZvciByYWRpYWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29vcmRzLngyXSBYIGNvb3JkaWFudGUgb2YgdGhlIHNlY29uZCBwb2ludCBmb3IgbGluZWFyIG9yIG9mIHRoZSBjZW50ZXIgcG9pbnQgZm9yIHJhZGlhbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29yZHMueTJdIFkgY29vcmRpYW50ZSBvZiB0aGUgc2Vjb25kIHBvaW50IGZvciBsaW5lYXIgb3Igb2YgdGhlIGNlbnRlciBwb2ludCBmb3IgcmFkaWFsXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb3Jkcy5yMV0gb25seSBmb3IgcmFkaWFsIGdyYWRpZW50LCByYWRpdXMgb2YgdGhlIGlubmVyIGNpcmNsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29yZHMucjJdIG9ubHkgZm9yIHJhZGlhbCBncmFkaWVudCwgcmFkaXVzIG9mIHRoZSBleHRlcm5hbCBjaXJjbGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JhZGllbnR9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcbiAgICAgIG9wdGlvbnMuY29vcmRzIHx8IChvcHRpb25zLmNvb3JkcyA9IHsgfSk7XG5cbiAgICAgIHZhciBjb29yZHMsIF90aGlzID0gdGhpcztcblxuICAgICAgLy8gc2V0cyBldmVyeXRoaW5nLCB0aGVuIGNvb3JkcyBhbmQgY29sb3JzdG9wcyBnZXQgc2V0cyBhZ2FpblxuICAgICAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbihvcHRpb24pIHtcbiAgICAgICAgX3RoaXNbb3B0aW9uXSA9IG9wdGlvbnNbb3B0aW9uXTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5pZCkge1xuICAgICAgICB0aGlzLmlkICs9ICdfJyArIGZhYnJpYy5PYmplY3QuX191aWQrKztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmlkID0gZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgICAgfVxuXG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHgxOiBvcHRpb25zLmNvb3Jkcy54MSB8fCAwLFxuICAgICAgICB5MTogb3B0aW9ucy5jb29yZHMueTEgfHwgMCxcbiAgICAgICAgeDI6IG9wdGlvbnMuY29vcmRzLngyIHx8IDAsXG4gICAgICAgIHkyOiBvcHRpb25zLmNvb3Jkcy55MiB8fCAwXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy50eXBlID09PSAncmFkaWFsJykge1xuICAgICAgICBjb29yZHMucjEgPSBvcHRpb25zLmNvb3Jkcy5yMSB8fCAwO1xuICAgICAgICBjb29yZHMucjIgPSBvcHRpb25zLmNvb3Jkcy5yMiB8fCAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvb3JkcyA9IGNvb3JkcztcbiAgICAgIHRoaXMuY29sb3JTdG9wcyA9IG9wdGlvbnMuY29sb3JTdG9wcy5zbGljZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFub3RoZXIgY29sb3JTdG9wXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbG9yU3RvcCBPYmplY3Qgd2l0aCBvZmZzZXQgYW5kIGNvbG9yXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyYWRpZW50fSB0aGlzQXJnXG4gICAgICovXG4gICAgYWRkQ29sb3JTdG9wOiBmdW5jdGlvbihjb2xvclN0b3BzKSB7XG4gICAgICBmb3IgKHZhciBwb3NpdGlvbiBpbiBjb2xvclN0b3BzKSB7XG4gICAgICAgIHZhciBjb2xvciA9IG5ldyBmYWJyaWMuQ29sb3IoY29sb3JTdG9wc1twb3NpdGlvbl0pO1xuICAgICAgICB0aGlzLmNvbG9yU3RvcHMucHVzaCh7XG4gICAgICAgICAgb2Zmc2V0OiBwYXJzZUZsb2F0KHBvc2l0aW9uKSxcbiAgICAgICAgICBjb2xvcjogY29sb3IudG9SZ2IoKSxcbiAgICAgICAgICBvcGFjaXR5OiBjb2xvci5nZXRBbHBoYSgpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGEgZ3JhZGllbnRcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgb2JqZWN0ID0ge1xuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGNvb3JkczogdGhpcy5jb29yZHMsXG4gICAgICAgIGNvbG9yU3RvcHM6IHRoaXMuY29sb3JTdG9wcyxcbiAgICAgICAgb2Zmc2V0WDogdGhpcy5vZmZzZXRYLFxuICAgICAgICBvZmZzZXRZOiB0aGlzLm9mZnNldFksXG4gICAgICAgIGdyYWRpZW50VW5pdHM6IHRoaXMuZ3JhZGllbnRVbml0cyxcbiAgICAgICAgZ3JhZGllbnRUcmFuc2Zvcm06IHRoaXMuZ3JhZGllbnRUcmFuc2Zvcm0gPyB0aGlzLmdyYWRpZW50VHJhbnNmb3JtLmNvbmNhdCgpIDogdGhpcy5ncmFkaWVudFRyYW5zZm9ybVxuICAgICAgfTtcbiAgICAgIGZhYnJpYy51dGlsLnBvcHVsYXRlV2l0aFByb3BlcnRpZXModGhpcywgb2JqZWN0LCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBhbiBncmFkaWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhIGdyYWRpZW50IGZvclxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGFuIGdyYWRpZW50IChsaW5lYXIvcmFkaWFsKVxuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihvYmplY3QsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBjb29yZHMgPSBjbG9uZSh0aGlzLmNvb3JkcywgdHJ1ZSksIGksIGxlbiwgb3B0aW9ucyA9IG9wdGlvbnMgfHwge30sXG4gICAgICAgICAgbWFya3VwLCBjb21tb25BdHRyaWJ1dGVzLCBjb2xvclN0b3BzID0gY2xvbmUodGhpcy5jb2xvclN0b3BzLCB0cnVlKSxcbiAgICAgICAgICBuZWVkc1N3YXAgPSBjb29yZHMucjEgPiBjb29yZHMucjIsXG4gICAgICAgICAgdHJhbnNmb3JtID0gdGhpcy5ncmFkaWVudFRyYW5zZm9ybSA/IHRoaXMuZ3JhZGllbnRUcmFuc2Zvcm0uY29uY2F0KCkgOiBmYWJyaWMuaU1hdHJpeC5jb25jYXQoKSxcbiAgICAgICAgICBvZmZzZXRYID0gLXRoaXMub2Zmc2V0WCwgb2Zmc2V0WSA9IC10aGlzLm9mZnNldFksXG4gICAgICAgICAgd2l0aFZpZXdwb3J0ID0gISFvcHRpb25zLmFkZGl0aW9uYWxUcmFuc2Zvcm0sXG4gICAgICAgICAgZ3JhZGllbnRVbml0cyA9IHRoaXMuZ3JhZGllbnRVbml0cyA9PT0gJ3BpeGVscycgPyAndXNlclNwYWNlT25Vc2UnIDogJ29iamVjdEJvdW5kaW5nQm94JztcbiAgICAgIC8vIGNvbG9yU3RvcHMgbXVzdCBiZSBzb3J0ZWQgYXNjZW5kaW5nXG4gICAgICBjb2xvclN0b3BzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gYS5vZmZzZXQgLSBiLm9mZnNldDtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZ3JhZGllbnRVbml0cyA9PT0gJ29iamVjdEJvdW5kaW5nQm94Jykge1xuICAgICAgICBvZmZzZXRYIC89IG9iamVjdC53aWR0aDtcbiAgICAgICAgb2Zmc2V0WSAvPSBvYmplY3QuaGVpZ2h0O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG9mZnNldFggKz0gb2JqZWN0LndpZHRoIC8gMjtcbiAgICAgICAgb2Zmc2V0WSArPSBvYmplY3QuaGVpZ2h0IC8gMjtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QudHlwZSA9PT0gJ3BhdGgnICYmIHRoaXMuZ3JhZGllbnRVbml0cyAhPT0gJ3BlcmNlbnRhZ2UnKSB7XG4gICAgICAgIG9mZnNldFggLT0gb2JqZWN0LnBhdGhPZmZzZXQueDtcbiAgICAgICAgb2Zmc2V0WSAtPSBvYmplY3QucGF0aE9mZnNldC55O1xuICAgICAgfVxuXG5cbiAgICAgIHRyYW5zZm9ybVs0XSAtPSBvZmZzZXRYO1xuICAgICAgdHJhbnNmb3JtWzVdIC09IG9mZnNldFk7XG5cbiAgICAgIGNvbW1vbkF0dHJpYnV0ZXMgPSAnaWQ9XCJTVkdJRF8nICsgdGhpcy5pZCArXG4gICAgICAgICAgICAgICAgICAgICAnXCIgZ3JhZGllbnRVbml0cz1cIicgKyBncmFkaWVudFVuaXRzICsgJ1wiJztcbiAgICAgIGNvbW1vbkF0dHJpYnV0ZXMgKz0gJyBncmFkaWVudFRyYW5zZm9ybT1cIicgKyAod2l0aFZpZXdwb3J0ID9cbiAgICAgICAgb3B0aW9ucy5hZGRpdGlvbmFsVHJhbnNmb3JtICsgJyAnIDogJycpICsgZmFicmljLnV0aWwubWF0cml4VG9TVkcodHJhbnNmb3JtKSArICdcIiAnO1xuXG4gICAgICBpZiAodGhpcy50eXBlID09PSAnbGluZWFyJykge1xuICAgICAgICBtYXJrdXAgPSBbXG4gICAgICAgICAgJzxsaW5lYXJHcmFkaWVudCAnLFxuICAgICAgICAgIGNvbW1vbkF0dHJpYnV0ZXMsXG4gICAgICAgICAgJyB4MT1cIicsIGNvb3Jkcy54MSxcbiAgICAgICAgICAnXCIgeTE9XCInLCBjb29yZHMueTEsXG4gICAgICAgICAgJ1wiIHgyPVwiJywgY29vcmRzLngyLFxuICAgICAgICAgICdcIiB5Mj1cIicsIGNvb3Jkcy55MixcbiAgICAgICAgICAnXCI+XFxuJ1xuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy50eXBlID09PSAncmFkaWFsJykge1xuICAgICAgICAvLyBzdmcgcmFkaWFsIGdyYWRpZW50IGhhcyBqdXN0IDEgcmFkaXVzLiB0aGUgYmlnZ2VzdC5cbiAgICAgICAgbWFya3VwID0gW1xuICAgICAgICAgICc8cmFkaWFsR3JhZGllbnQgJyxcbiAgICAgICAgICBjb21tb25BdHRyaWJ1dGVzLFxuICAgICAgICAgICcgY3g9XCInLCBuZWVkc1N3YXAgPyBjb29yZHMueDEgOiBjb29yZHMueDIsXG4gICAgICAgICAgJ1wiIGN5PVwiJywgbmVlZHNTd2FwID8gY29vcmRzLnkxIDogY29vcmRzLnkyLFxuICAgICAgICAgICdcIiByPVwiJywgbmVlZHNTd2FwID8gY29vcmRzLnIxIDogY29vcmRzLnIyLFxuICAgICAgICAgICdcIiBmeD1cIicsIG5lZWRzU3dhcCA/IGNvb3Jkcy54MiA6IGNvb3Jkcy54MSxcbiAgICAgICAgICAnXCIgZnk9XCInLCBuZWVkc1N3YXAgPyBjb29yZHMueTIgOiBjb29yZHMueTEsXG4gICAgICAgICAgJ1wiPlxcbidcbiAgICAgICAgXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3JhZGlhbCcpIHtcbiAgICAgICAgaWYgKG5lZWRzU3dhcCkge1xuICAgICAgICAgIC8vIHN2ZyBnb2VzIGZyb20gaW50ZXJuYWwgdG8gZXh0ZXJuYWwgcmFkaXVzLiBpZiByYWRpdXMgYXJlIGludmVydGVkLCBzd2FwIGNvbG9yIHN0b3BzLlxuICAgICAgICAgIGNvbG9yU3RvcHMgPSBjb2xvclN0b3BzLmNvbmNhdCgpO1xuICAgICAgICAgIGNvbG9yU3RvcHMucmV2ZXJzZSgpO1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNvbG9yU3RvcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbG9yU3RvcHNbaV0ub2Zmc2V0ID0gMSAtIGNvbG9yU3RvcHNbaV0ub2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbWluUmFkaXVzID0gTWF0aC5taW4oY29vcmRzLnIxLCBjb29yZHMucjIpO1xuICAgICAgICBpZiAobWluUmFkaXVzID4gMCkge1xuICAgICAgICAgIC8vIGkgaGF2ZSB0byBzaGlmdCBhbGwgY29sb3JTdG9wcyBhbmQgYWRkIG5ldyBvbmUgaW4gMC5cbiAgICAgICAgICB2YXIgbWF4UmFkaXVzID0gTWF0aC5tYXgoY29vcmRzLnIxLCBjb29yZHMucjIpLFxuICAgICAgICAgICAgICBwZXJjZW50YWdlU2hpZnQgPSBtaW5SYWRpdXMgLyBtYXhSYWRpdXM7XG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY29sb3JTdG9wcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29sb3JTdG9wc1tpXS5vZmZzZXQgKz0gcGVyY2VudGFnZVNoaWZ0ICogKDEgLSBjb2xvclN0b3BzW2ldLm9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNvbG9yU3RvcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbG9yU3RvcCA9IGNvbG9yU3RvcHNbaV07XG4gICAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAgICc8c3RvcCAnLFxuICAgICAgICAgICdvZmZzZXQ9XCInLCAoY29sb3JTdG9wLm9mZnNldCAqIDEwMCkgKyAnJScsXG4gICAgICAgICAgJ1wiIHN0eWxlPVwic3RvcC1jb2xvcjonLCBjb2xvclN0b3AuY29sb3IsXG4gICAgICAgICAgKHR5cGVvZiBjb2xvclN0b3Aub3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCcgPyAnO3N0b3Atb3BhY2l0eTogJyArIGNvbG9yU3RvcC5vcGFjaXR5IDogJzsnKSxcbiAgICAgICAgICAnXCIvPlxcbidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgbWFya3VwLnB1c2goKHRoaXMudHlwZSA9PT0gJ2xpbmVhcicgPyAnPC9saW5lYXJHcmFkaWVudD5cXG4nIDogJzwvcmFkaWFsR3JhZGllbnQ+XFxuJykpO1xuXG4gICAgICByZXR1cm4gbWFya3VwLmpvaW4oJycpO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIENhbnZhc0dyYWRpZW50XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEByZXR1cm4ge0NhbnZhc0dyYWRpZW50fVxuICAgICAqL1xuICAgIHRvTGl2ZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgZ3JhZGllbnQsIGNvb3JkcyA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZSh0aGlzLmNvb3JkcyksIGksIGxlbjtcblxuICAgICAgaWYgKCF0aGlzLnR5cGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50eXBlID09PSAnbGluZWFyJykge1xuICAgICAgICBncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudChcbiAgICAgICAgICBjb29yZHMueDEsIGNvb3Jkcy55MSwgY29vcmRzLngyLCBjb29yZHMueTIpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy50eXBlID09PSAncmFkaWFsJykge1xuICAgICAgICBncmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChcbiAgICAgICAgICBjb29yZHMueDEsIGNvb3Jkcy55MSwgY29vcmRzLnIxLCBjb29yZHMueDIsIGNvb3Jkcy55MiwgY29vcmRzLnIyKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5jb2xvclN0b3BzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjb2xvciA9IHRoaXMuY29sb3JTdG9wc1tpXS5jb2xvcixcbiAgICAgICAgICAgIG9wYWNpdHkgPSB0aGlzLmNvbG9yU3RvcHNbaV0ub3BhY2l0eSxcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuY29sb3JTdG9wc1tpXS5vZmZzZXQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcGFjaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcihjb2xvcikuc2V0QWxwaGEob3BhY2l0eSkudG9SZ2JhKCk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKG9mZnNldCwgY29sb3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ3JhZGllbnQ7XG4gICAgfVxuICB9KTtcblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5HcmFkaWVudCwge1xuXG4gICAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5HcmFkaWVudH0gaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkdyYWRpZW50XG4gICAgICogQHBhcmFtIHtTVkdHcmFkaWVudEVsZW1lbnR9IGVsIFNWRyBncmFkaWVudCBlbGVtZW50XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcGFjaXR5QXR0ciBBIGZpbGwtb3BhY2l0eSBvciBzdHJva2Utb3BhY2l0eSBhdHRyaWJ1dGUgdG8gbXVsdGlwbHkgdG8gZWFjaCBzdG9wJ3Mgb3BhY2l0eS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3ZnT3B0aW9ucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgc2l6ZSBvZiB0aGUgU1ZHIGluIG9yZGVyIHRvIHBhcnNlIGNvcnJlY3RseSBncmFkaWVudHNcbiAgICAgKiB0aGF0IHVzZXMgZ3JhZGllbnRVbml0cyBhcyAndXNlclNwYWNlT25Vc2UnIGFuZCBwZXJjZW50YWdlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdC5udW1iZXJ9IHZpZXdCb3hXaWR0aCB3aWR0aCBwYXJ0IG9mIHRoZSB2aWV3Qm94IGF0dHJpYnV0ZSBvbiBzdmdcbiAgICAgKiBAcGFyYW0ge09iamVjdC5udW1iZXJ9IHZpZXdCb3hIZWlnaHQgaGVpZ2h0IHBhcnQgb2YgdGhlIHZpZXdCb3ggYXR0cmlidXRlIG9uIHN2Z1xuICAgICAqIEBwYXJhbSB7T2JqZWN0Lm51bWJlcn0gd2lkdGggd2lkdGggcGFydCBvZiB0aGUgc3ZnIHRhZyBpZiB2aWV3Qm94IGlzIG5vdCBzcGVjaWZpZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdC5udW1iZXJ9IGhlaWdodCBoZWlnaHQgcGFydCBvZiB0aGUgc3ZnIHRhZyBpZiB2aWV3Qm94IGlzIG5vdCBzcGVjaWZpZWRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JhZGllbnR9IEdyYWRpZW50IGluc3RhbmNlXG4gICAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvcHNlcnZlcnMuaHRtbCNMaW5lYXJHcmFkaWVudEVsZW1lbnRcbiAgICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wc2VydmVycy5odG1sI1JhZGlhbEdyYWRpZW50RWxlbWVudFxuICAgICAqL1xuICAgIGZyb21FbGVtZW50OiBmdW5jdGlvbihlbCwgaW5zdGFuY2UsIG9wYWNpdHlBdHRyLCBzdmdPcHRpb25zKSB7XG4gICAgICAvKipcbiAgICAgICAqICBAZXhhbXBsZTpcbiAgICAgICAqXG4gICAgICAgKiAgPGxpbmVhckdyYWRpZW50IGlkPVwibGluZWFyR3JhZDFcIj5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjAlXCIgc3RvcC1jb2xvcj1cIndoaXRlXCIvPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMTAwJVwiIHN0b3AtY29sb3I9XCJibGFja1wiLz5cbiAgICAgICAqICA8L2xpbmVhckdyYWRpZW50PlxuICAgICAgICpcbiAgICAgICAqICBPUlxuICAgICAgICpcbiAgICAgICAqICA8bGluZWFyR3JhZGllbnQgaWQ9XCJsaW5lYXJHcmFkMlwiPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMFwiIHN0eWxlPVwic3RvcC1jb2xvcjpyZ2IoMjU1LDI1NSwyNTUpXCIvPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMVwiIHN0eWxlPVwic3RvcC1jb2xvcjpyZ2IoMCwwLDApXCIvPlxuICAgICAgICogIDwvbGluZWFyR3JhZGllbnQ+XG4gICAgICAgKlxuICAgICAgICogIE9SXG4gICAgICAgKlxuICAgICAgICogIDxyYWRpYWxHcmFkaWVudCBpZD1cInJhZGlhbEdyYWQxXCI+XG4gICAgICAgKiAgICA8c3RvcCBvZmZzZXQ9XCIwJVwiIHN0b3AtY29sb3I9XCJ3aGl0ZVwiIHN0b3Atb3BhY2l0eT1cIjFcIiAvPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiNTAlXCIgc3RvcC1jb2xvcj1cImJsYWNrXCIgc3RvcC1vcGFjaXR5PVwiMC41XCIgLz5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjEwMCVcIiBzdG9wLWNvbG9yPVwid2hpdGVcIiBzdG9wLW9wYWNpdHk9XCIxXCIgLz5cbiAgICAgICAqICA8L3JhZGlhbEdyYWRpZW50PlxuICAgICAgICpcbiAgICAgICAqICBPUlxuICAgICAgICpcbiAgICAgICAqICA8cmFkaWFsR3JhZGllbnQgaWQ9XCJyYWRpYWxHcmFkMlwiPlxuICAgICAgICogICAgPHN0b3Agb2Zmc2V0PVwiMFwiIHN0b3AtY29sb3I9XCJyZ2IoMjU1LDI1NSwyNTUpXCIgLz5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjAuNVwiIHN0b3AtY29sb3I9XCJyZ2IoMCwwLDApXCIgLz5cbiAgICAgICAqICAgIDxzdG9wIG9mZnNldD1cIjFcIiBzdG9wLWNvbG9yPVwicmdiKDI1NSwyNTUsMjU1KVwiIC8+XG4gICAgICAgKiAgPC9yYWRpYWxHcmFkaWVudD5cbiAgICAgICAqXG4gICAgICAgKi9cblxuICAgICAgdmFyIG11bHRpcGxpZXIgPSBwYXJzZUZsb2F0KG9wYWNpdHlBdHRyKSAvICgvJSQvLnRlc3Qob3BhY2l0eUF0dHIpID8gMTAwIDogMSk7XG4gICAgICBtdWx0aXBsaWVyID0gbXVsdGlwbGllciA8IDAgPyAwIDogbXVsdGlwbGllciA+IDEgPyAxIDogbXVsdGlwbGllcjtcbiAgICAgIGlmIChpc05hTihtdWx0aXBsaWVyKSkge1xuICAgICAgICBtdWx0aXBsaWVyID0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbG9yU3RvcEVscyA9IGVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzdG9wJyksXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBncmFkaWVudFVuaXRzID0gZWwuZ2V0QXR0cmlidXRlKCdncmFkaWVudFVuaXRzJykgPT09ICd1c2VyU3BhY2VPblVzZScgP1xuICAgICAgICAgICAgJ3BpeGVscycgOiAncGVyY2VudGFnZScsXG4gICAgICAgICAgZ3JhZGllbnRUcmFuc2Zvcm0gPSBlbC5nZXRBdHRyaWJ1dGUoJ2dyYWRpZW50VHJhbnNmb3JtJykgfHwgJycsXG4gICAgICAgICAgY29sb3JTdG9wcyA9IFtdLFxuICAgICAgICAgIGNvb3JkcywgaSwgb2Zmc2V0WCA9IDAsIG9mZnNldFkgPSAwLFxuICAgICAgICAgIHRyYW5zZm9ybU1hdHJpeDtcbiAgICAgIGlmIChlbC5ub2RlTmFtZSA9PT0gJ2xpbmVhckdyYWRpZW50JyB8fCBlbC5ub2RlTmFtZSA9PT0gJ0xJTkVBUkdSQURJRU5UJykge1xuICAgICAgICB0eXBlID0gJ2xpbmVhcic7XG4gICAgICAgIGNvb3JkcyA9IGdldExpbmVhckNvb3JkcyhlbCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdHlwZSA9ICdyYWRpYWwnO1xuICAgICAgICBjb29yZHMgPSBnZXRSYWRpYWxDb29yZHMoZWwpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSBjb2xvclN0b3BFbHMubGVuZ3RoOyBpLS07ICkge1xuICAgICAgICBjb2xvclN0b3BzLnB1c2goZ2V0Q29sb3JTdG9wKGNvbG9yU3RvcEVsc1tpXSwgbXVsdGlwbGllcikpO1xuICAgICAgfVxuXG4gICAgICB0cmFuc2Zvcm1NYXRyaXggPSBmYWJyaWMucGFyc2VUcmFuc2Zvcm1BdHRyaWJ1dGUoZ3JhZGllbnRUcmFuc2Zvcm0pO1xuXG4gICAgICBfX2NvbnZlcnRQZXJjZW50VW5pdHNUb1ZhbHVlcyhpbnN0YW5jZSwgY29vcmRzLCBzdmdPcHRpb25zLCBncmFkaWVudFVuaXRzKTtcblxuICAgICAgaWYgKGdyYWRpZW50VW5pdHMgPT09ICdwaXhlbHMnKSB7XG4gICAgICAgIG9mZnNldFggPSAtaW5zdGFuY2UubGVmdDtcbiAgICAgICAgb2Zmc2V0WSA9IC1pbnN0YW5jZS50b3A7XG4gICAgICB9XG5cbiAgICAgIHZhciBncmFkaWVudCA9IG5ldyBmYWJyaWMuR3JhZGllbnQoe1xuICAgICAgICBpZDogZWwuZ2V0QXR0cmlidXRlKCdpZCcpLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBjb29yZHM6IGNvb3JkcyxcbiAgICAgICAgY29sb3JTdG9wczogY29sb3JTdG9wcyxcbiAgICAgICAgZ3JhZGllbnRVbml0czogZ3JhZGllbnRVbml0cyxcbiAgICAgICAgZ3JhZGllbnRUcmFuc2Zvcm06IHRyYW5zZm9ybU1hdHJpeCxcbiAgICAgICAgb2Zmc2V0WDogb2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WTogb2Zmc2V0WSxcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gZ3JhZGllbnQ7XG4gICAgfVxuICAgIC8qIF9GUk9NX1NWR19FTkRfICovXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX19jb252ZXJ0UGVyY2VudFVuaXRzVG9WYWx1ZXMoaW5zdGFuY2UsIG9wdGlvbnMsIHN2Z09wdGlvbnMsIGdyYWRpZW50VW5pdHMpIHtcbiAgICB2YXIgcHJvcFZhbHVlLCBmaW5hbFZhbHVlO1xuICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgcHJvcFZhbHVlID0gb3B0aW9uc1twcm9wXTtcbiAgICAgIGlmIChwcm9wVmFsdWUgPT09ICdJbmZpbml0eScpIHtcbiAgICAgICAgZmluYWxWYWx1ZSA9IDE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChwcm9wVmFsdWUgPT09ICctSW5maW5pdHknKSB7XG4gICAgICAgIGZpbmFsVmFsdWUgPSAwO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZpbmFsVmFsdWUgPSBwYXJzZUZsb2F0KG9wdGlvbnNbcHJvcF0sIDEwKTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICdzdHJpbmcnICYmIC9eKFxcZCtcXC5cXGQrKSV8KFxcZCspJSQvLnRlc3QocHJvcFZhbHVlKSkge1xuICAgICAgICAgIGZpbmFsVmFsdWUgKj0gMC4wMTtcbiAgICAgICAgICBpZiAoZ3JhZGllbnRVbml0cyA9PT0gJ3BpeGVscycpIHtcbiAgICAgICAgICAgIC8vIHRoZW4gd2UgbmVlZCB0byBmaXggdGhvc2UgcGVyY2VudGFnZXMgaGVyZSBpbiBzdmcgcGFyc2luZ1xuICAgICAgICAgICAgaWYgKHByb3AgPT09ICd4MScgfHwgcHJvcCA9PT0gJ3gyJyB8fCBwcm9wID09PSAncjInKSB7XG4gICAgICAgICAgICAgIGZpbmFsVmFsdWUgKj0gc3ZnT3B0aW9ucy52aWV3Qm94V2lkdGggfHwgc3ZnT3B0aW9ucy53aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wID09PSAneTEnIHx8IHByb3AgPT09ICd5MicpIHtcbiAgICAgICAgICAgICAgZmluYWxWYWx1ZSAqPSBzdmdPcHRpb25zLnZpZXdCb3hIZWlnaHQgfHwgc3ZnT3B0aW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvcHRpb25zW3Byb3BdID0gZmluYWxWYWx1ZTtcbiAgICB9KTtcbiAgfVxufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZDtcblxuICAvKipcbiAgICogUGF0dGVybiBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlBhdHRlcm5cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9wYXR0ZXJuc3xQYXR0ZXJuIGRlbW99XG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZHluYW1pYy1wYXR0ZXJuc3xEeW5hbWljUGF0dGVybiBkZW1vfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuUGF0dGVybiNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cblxuXG4gIGZhYnJpYy5QYXR0ZXJuID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoLyoqIEBsZW5kcyBmYWJyaWMuUGF0dGVybi5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogUmVwZWF0IHByb3BlcnR5IG9mIGEgcGF0dGVybiAob25lIG9mIHJlcGVhdCwgcmVwZWF0LXgsIHJlcGVhdC15IG9yIG5vLXJlcGVhdClcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJlcGVhdDogJ3JlcGVhdCcsXG5cbiAgICAvKipcbiAgICAgKiBQYXR0ZXJuIGhvcml6b250YWwgb2Zmc2V0IGZyb20gb2JqZWN0J3MgbGVmdC90b3AgY29ybmVyXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvZmZzZXRYOiAwLFxuXG4gICAgLyoqXG4gICAgICogUGF0dGVybiB2ZXJ0aWNhbCBvZmZzZXQgZnJvbSBvYmplY3QncyBsZWZ0L3RvcCBjb3JuZXJcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG9mZnNldFk6IDAsXG5cbiAgICAvKipcbiAgICAgKiBjcm9zc09yaWdpbiB2YWx1ZSAob25lIG9mIFwiXCIsIFwiYW5vbnltb3VzXCIsIFwidXNlLWNyZWRlbnRpYWxzXCIpXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0hUTUwvQ09SU19zZXR0aW5nc19hdHRyaWJ1dGVzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjcm9zc09yaWdpbjogJycsXG5cbiAgICAvKipcbiAgICAgKiB0cmFuc2Zvcm0gbWF0cml4IHRvIGNoYW5nZSB0aGUgcGF0dGVybiwgaW1wb3J0ZWQgZnJvbSBzdmdzLlxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwYXR0ZXJuVHJhbnNmb3JtOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBmdW5jdGlvbiB0byBpbnZva2UgYWZ0ZXIgY2FsbGJhY2sgaW5pdC5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUGF0dGVybn0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgdGhpcy5pZCA9IGZhYnJpYy5PYmplY3QuX191aWQrKztcbiAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIGlmICghb3B0aW9ucy5zb3VyY2UgfHwgKG9wdGlvbnMuc291cmNlICYmIHR5cGVvZiBvcHRpb25zLnNvdXJjZSAhPT0gJ3N0cmluZycpKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHRoaXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gaW1nIHNyYyBzdHJpbmdcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBmYWJyaWMudXRpbC5jcmVhdGVJbWFnZSgpO1xuICAgICAgICBmYWJyaWMudXRpbC5sb2FkSW1hZ2Uob3B0aW9ucy5zb3VyY2UsIGZ1bmN0aW9uKGltZywgaXNFcnJvcikge1xuICAgICAgICAgIF90aGlzLnNvdXJjZSA9IGltZztcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhfdGhpcywgaXNFcnJvcik7XG4gICAgICAgIH0sIG51bGwsIHRoaXMuY3Jvc3NPcmlnaW4pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhIHBhdHRlcm5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYSBwYXR0ZXJuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTLFxuICAgICAgICAgIHNvdXJjZSwgb2JqZWN0O1xuXG4gICAgICAvLyA8aW1nPiBlbGVtZW50XG4gICAgICBpZiAodHlwZW9mIHRoaXMuc291cmNlLnNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc291cmNlID0gdGhpcy5zb3VyY2Uuc3JjO1xuICAgICAgfVxuICAgICAgLy8gPGNhbnZhcz4gZWxlbWVudFxuICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXMuc291cmNlID09PSAnb2JqZWN0JyAmJiB0aGlzLnNvdXJjZS50b0RhdGFVUkwpIHtcbiAgICAgICAgc291cmNlID0gdGhpcy5zb3VyY2UudG9EYXRhVVJMKCk7XG4gICAgICB9XG5cbiAgICAgIG9iamVjdCA9IHtcbiAgICAgICAgdHlwZTogJ3BhdHRlcm4nLFxuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgcmVwZWF0OiB0aGlzLnJlcGVhdCxcbiAgICAgICAgY3Jvc3NPcmlnaW46IHRoaXMuY3Jvc3NPcmlnaW4sXG4gICAgICAgIG9mZnNldFg6IHRvRml4ZWQodGhpcy5vZmZzZXRYLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgb2Zmc2V0WTogdG9GaXhlZCh0aGlzLm9mZnNldFksIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICBwYXR0ZXJuVHJhbnNmb3JtOiB0aGlzLnBhdHRlcm5UcmFuc2Zvcm0gPyB0aGlzLnBhdHRlcm5UcmFuc2Zvcm0uY29uY2F0KCkgOiBudWxsXG4gICAgICB9O1xuICAgICAgZmFicmljLnV0aWwucG9wdWxhdGVXaXRoUHJvcGVydGllcyh0aGlzLCBvYmplY3QsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGEgcGF0dGVyblxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTVkcgcmVwcmVzZW50YXRpb24gb2YgYSBwYXR0ZXJuXG4gICAgICovXG4gICAgdG9TVkc6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIHBhdHRlcm5Tb3VyY2UgPSB0eXBlb2YgdGhpcy5zb3VyY2UgPT09ICdmdW5jdGlvbicgPyB0aGlzLnNvdXJjZSgpIDogdGhpcy5zb3VyY2UsXG4gICAgICAgICAgcGF0dGVybldpZHRoID0gcGF0dGVyblNvdXJjZS53aWR0aCAvIG9iamVjdC53aWR0aCxcbiAgICAgICAgICBwYXR0ZXJuSGVpZ2h0ID0gcGF0dGVyblNvdXJjZS5oZWlnaHQgLyBvYmplY3QuaGVpZ2h0LFxuICAgICAgICAgIHBhdHRlcm5PZmZzZXRYID0gdGhpcy5vZmZzZXRYIC8gb2JqZWN0LndpZHRoLFxuICAgICAgICAgIHBhdHRlcm5PZmZzZXRZID0gdGhpcy5vZmZzZXRZIC8gb2JqZWN0LmhlaWdodCxcbiAgICAgICAgICBwYXR0ZXJuSW1nU3JjID0gJyc7XG4gICAgICBpZiAodGhpcy5yZXBlYXQgPT09ICdyZXBlYXQteCcgfHwgdGhpcy5yZXBlYXQgPT09ICduby1yZXBlYXQnKSB7XG4gICAgICAgIHBhdHRlcm5IZWlnaHQgPSAxO1xuICAgICAgICBpZiAocGF0dGVybk9mZnNldFkpIHtcbiAgICAgICAgICBwYXR0ZXJuSGVpZ2h0ICs9IE1hdGguYWJzKHBhdHRlcm5PZmZzZXRZKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMucmVwZWF0ID09PSAncmVwZWF0LXknIHx8IHRoaXMucmVwZWF0ID09PSAnbm8tcmVwZWF0Jykge1xuICAgICAgICBwYXR0ZXJuV2lkdGggPSAxO1xuICAgICAgICBpZiAocGF0dGVybk9mZnNldFgpIHtcbiAgICAgICAgICBwYXR0ZXJuV2lkdGggKz0gTWF0aC5hYnMocGF0dGVybk9mZnNldFgpO1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICAgIGlmIChwYXR0ZXJuU291cmNlLnNyYykge1xuICAgICAgICBwYXR0ZXJuSW1nU3JjID0gcGF0dGVyblNvdXJjZS5zcmM7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChwYXR0ZXJuU291cmNlLnRvRGF0YVVSTCkge1xuICAgICAgICBwYXR0ZXJuSW1nU3JjID0gcGF0dGVyblNvdXJjZS50b0RhdGFVUkwoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICc8cGF0dGVybiBpZD1cIlNWR0lEXycgKyB0aGlzLmlkICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiIHg9XCInICsgcGF0dGVybk9mZnNldFggK1xuICAgICAgICAgICAgICAgICAgICAnXCIgeT1cIicgKyBwYXR0ZXJuT2Zmc2V0WSArXG4gICAgICAgICAgICAgICAgICAgICdcIiB3aWR0aD1cIicgKyBwYXR0ZXJuV2lkdGggK1xuICAgICAgICAgICAgICAgICAgICAnXCIgaGVpZ2h0PVwiJyArIHBhdHRlcm5IZWlnaHQgKyAnXCI+XFxuJyArXG4gICAgICAgICAgICAgICAnPGltYWdlIHg9XCIwXCIgeT1cIjBcIicgK1xuICAgICAgICAgICAgICAgICAgICAgICcgd2lkdGg9XCInICsgcGF0dGVyblNvdXJjZS53aWR0aCArXG4gICAgICAgICAgICAgICAgICAgICAgJ1wiIGhlaWdodD1cIicgKyBwYXR0ZXJuU291cmNlLmhlaWdodCArXG4gICAgICAgICAgICAgICAgICAgICAgJ1wiIHhsaW5rOmhyZWY9XCInICsgcGF0dGVybkltZ1NyYyArXG4gICAgICAgICAgICAgICAnXCI+PC9pbWFnZT5cXG4nICtcbiAgICAgICAgICAgICAnPC9wYXR0ZXJuPlxcbic7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gb3B0aW9ucykge1xuICAgICAgICB0aGlzW3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBpbnN0YW5jZSBvZiBDYW52YXNQYXR0ZXJuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIGNyZWF0ZSBwYXR0ZXJuXG4gICAgICogQHJldHVybiB7Q2FudmFzUGF0dGVybn1cbiAgICAgKi9cbiAgICB0b0xpdmU6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgICAgLy8gaWYgdGhlIGltYWdlIGZhaWxlZCB0byBsb2FkLCByZXR1cm4sIGFuZCBhbGxvdyByZXN0IHRvIGNvbnRpbnVlIGxvYWRpbmdcbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgLy8gaWYgYW4gaW1hZ2VcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlLnNyYyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKCFzb3VyY2UuY29tcGxldGUpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZS5uYXR1cmFsV2lkdGggPT09IDAgfHwgc291cmNlLm5hdHVyYWxIZWlnaHQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjdHguY3JlYXRlUGF0dGVybihzb3VyY2UsIHRoaXMucmVwZWF0KTtcbiAgICB9XG4gIH0pO1xufSkoKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkO1xuXG4gIGlmIChmYWJyaWMuU2hhZG93KSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5TaGFkb3cgaXMgYWxyZWFkeSBkZWZpbmVkLicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaGFkb3cgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5TaGFkb3dcbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9zaGFkb3dzfFNoYWRvdyBkZW1vfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuU2hhZG93I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuU2hhZG93ID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoLyoqIEBsZW5kcyBmYWJyaWMuU2hhZG93LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBTaGFkb3cgY29sb3JcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNvbG9yOiAncmdiKDAsMCwwKScsXG5cbiAgICAvKipcbiAgICAgKiBTaGFkb3cgYmx1clxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIGJsdXI6IDAsXG5cbiAgICAvKipcbiAgICAgKiBTaGFkb3cgaG9yaXpvbnRhbCBvZmZzZXRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG9mZnNldFg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBTaGFkb3cgdmVydGljYWwgb2Zmc2V0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvZmZzZXRZOiAwLFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgc2hhZG93IHNob3VsZCBhZmZlY3Qgc3Ryb2tlIG9wZXJhdGlvbnNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBhZmZlY3RTdHJva2U6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdG9PYmplY3Qgc2hvdWxkIGluY2x1ZGUgZGVmYXVsdCB2YWx1ZXNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbmNsdWRlRGVmYXVsdFZhbHVlczogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYGZhbHNlYCwgdGhlIHNoYWRvdyB3aWxsIHNjYWxlIHdpdGggdGhlIG9iamVjdC5cbiAgICAgKiBXaGVuIGB0cnVlYCwgdGhlIHNoYWRvdydzIG9mZnNldFgsIG9mZnNldFksIGFuZCBibHVyIHdpbGwgbm90IGJlIGFmZmVjdGVkIGJ5IHRoZSBvYmplY3QncyBzY2FsZS5cbiAgICAgKiBkZWZhdWx0IHRvIGZhbHNlXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbm9uU2NhbGluZzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0IHdpdGggYW55IG9mIGNvbG9yLCBibHVyLCBvZmZzZXRYLCBvZmZzZXRZIHByb3BlcnRpZXMgb3Igc3RyaW5nIChlLmcuIFwicmdiYSgwLDAsMCwwLjIpIDJweCAycHggMTBweFwiKVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5TaGFkb3d9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMuX3BhcnNlU2hhZG93KG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpc1twcm9wXSA9IG9wdGlvbnNbcHJvcF07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaWQgPSBmYWJyaWMuT2JqZWN0Ll9fdWlkKys7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNoYWRvdyBTaGFkb3cgdmFsdWUgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFNoYWRvdyBvYmplY3Qgd2l0aCBjb2xvciwgb2Zmc2V0WCwgb2Zmc2V0WSBhbmQgYmx1clxuICAgICAqL1xuICAgIF9wYXJzZVNoYWRvdzogZnVuY3Rpb24oc2hhZG93KSB7XG4gICAgICB2YXIgc2hhZG93U3RyID0gc2hhZG93LnRyaW0oKSxcbiAgICAgICAgICBvZmZzZXRzQW5kQmx1ciA9IGZhYnJpYy5TaGFkb3cucmVPZmZzZXRzQW5kQmx1ci5leGVjKHNoYWRvd1N0cikgfHwgW10sXG4gICAgICAgICAgY29sb3IgPSBzaGFkb3dTdHIucmVwbGFjZShmYWJyaWMuU2hhZG93LnJlT2Zmc2V0c0FuZEJsdXIsICcnKSB8fCAncmdiKDAsMCwwKSc7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbG9yOiBjb2xvci50cmltKCksXG4gICAgICAgIG9mZnNldFg6IHBhcnNlRmxvYXQob2Zmc2V0c0FuZEJsdXJbMV0sIDEwKSB8fCAwLFxuICAgICAgICBvZmZzZXRZOiBwYXJzZUZsb2F0KG9mZnNldHNBbmRCbHVyWzJdLCAxMCkgfHwgMCxcbiAgICAgICAgYmx1cjogcGFyc2VGbG9hdChvZmZzZXRzQW5kQmx1clszXSwgMTApIHx8IDBcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2Nzcy10ZXh0LWRlY29yLTMvI3RleHQtc2hhZG93XG4gICAgICogQHJldHVybiB7U3RyaW5nfSBSZXR1cm5zIENTUzMgdGV4dC1zaGFkb3cgZGVjbGFyYXRpb25cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gW3RoaXMub2Zmc2V0WCwgdGhpcy5vZmZzZXRZLCB0aGlzLmJsdXIsIHRoaXMuY29sb3JdLmpvaW4oJ3B4ICcpO1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGEgc2hhZG93XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFNWRyByZXByZXNlbnRhdGlvbiBvZiBhIHNoYWRvd1xuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciBmQm94WCA9IDQwLCBmQm94WSA9IDQwLCBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTLFxuICAgICAgICAgIG9mZnNldCA9IGZhYnJpYy51dGlsLnJvdGF0ZVZlY3RvcihcbiAgICAgICAgICAgIHsgeDogdGhpcy5vZmZzZXRYLCB5OiB0aGlzLm9mZnNldFkgfSxcbiAgICAgICAgICAgIGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMoLW9iamVjdC5hbmdsZSkpLFxuICAgICAgICAgIEJMVVJfQk9YID0gMjAsIGNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcih0aGlzLmNvbG9yKTtcblxuICAgICAgaWYgKG9iamVjdC53aWR0aCAmJiBvYmplY3QuaGVpZ2h0KSB7XG4gICAgICAgIC8vaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2ZpbHRlcnMuaHRtbCNGaWx0ZXJFZmZlY3RzUmVnaW9uXG4gICAgICAgIC8vIHdlIGFkZCBzb21lIGV4dHJhIHNwYWNlIHRvIGZpbHRlciBib3ggdG8gY29udGFpbiB0aGUgYmx1ciAoIDIwIClcbiAgICAgICAgZkJveFggPSB0b0ZpeGVkKChNYXRoLmFicyhvZmZzZXQueCkgKyB0aGlzLmJsdXIpIC8gb2JqZWN0LndpZHRoLCBOVU1fRlJBQ1RJT05fRElHSVRTKSAqIDEwMCArIEJMVVJfQk9YO1xuICAgICAgICBmQm94WSA9IHRvRml4ZWQoKE1hdGguYWJzKG9mZnNldC55KSArIHRoaXMuYmx1cikgLyBvYmplY3QuaGVpZ2h0LCBOVU1fRlJBQ1RJT05fRElHSVRTKSAqIDEwMCArIEJMVVJfQk9YO1xuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5mbGlwWCkge1xuICAgICAgICBvZmZzZXQueCAqPSAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmplY3QuZmxpcFkpIHtcbiAgICAgICAgb2Zmc2V0LnkgKj0gLTE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgICc8ZmlsdGVyIGlkPVwiU1ZHSURfJyArIHRoaXMuaWQgKyAnXCIgeT1cIi0nICsgZkJveFkgKyAnJVwiIGhlaWdodD1cIicgKyAoMTAwICsgMiAqIGZCb3hZKSArICclXCIgJyArXG4gICAgICAgICAgJ3g9XCItJyArIGZCb3hYICsgJyVcIiB3aWR0aD1cIicgKyAoMTAwICsgMiAqIGZCb3hYKSArICclXCIgJyArICc+XFxuJyArXG4gICAgICAgICAgJ1xcdDxmZUdhdXNzaWFuQmx1ciBpbj1cIlNvdXJjZUFscGhhXCIgc3RkRGV2aWF0aW9uPVwiJyArXG4gICAgICAgICAgICB0b0ZpeGVkKHRoaXMuYmx1ciA/IHRoaXMuYmx1ciAvIDIgOiAwLCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICdcIj48L2ZlR2F1c3NpYW5CbHVyPlxcbicgK1xuICAgICAgICAgICdcXHQ8ZmVPZmZzZXQgZHg9XCInICsgdG9GaXhlZChvZmZzZXQueCwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgK1xuICAgICAgICAgICdcIiBkeT1cIicgKyB0b0ZpeGVkKG9mZnNldC55LCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICdcIiByZXN1bHQ9XCJvQmx1clwiID48L2ZlT2Zmc2V0PlxcbicgK1xuICAgICAgICAgICdcXHQ8ZmVGbG9vZCBmbG9vZC1jb2xvcj1cIicgKyBjb2xvci50b1JnYigpICsgJ1wiIGZsb29kLW9wYWNpdHk9XCInICsgY29sb3IuZ2V0QWxwaGEoKSArICdcIi8+XFxuJyArXG4gICAgICAgICAgJ1xcdDxmZUNvbXBvc2l0ZSBpbjI9XCJvQmx1clwiIG9wZXJhdG9yPVwiaW5cIiAvPlxcbicgK1xuICAgICAgICAgICdcXHQ8ZmVNZXJnZT5cXG4nICtcbiAgICAgICAgICAgICdcXHRcXHQ8ZmVNZXJnZU5vZGU+PC9mZU1lcmdlTm9kZT5cXG4nICtcbiAgICAgICAgICAgICdcXHRcXHQ8ZmVNZXJnZU5vZGUgaW49XCJTb3VyY2VHcmFwaGljXCI+PC9mZU1lcmdlTm9kZT5cXG4nICtcbiAgICAgICAgICAnXFx0PC9mZU1lcmdlPlxcbicgK1xuICAgICAgICAnPC9maWx0ZXI+XFxuJyk7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGEgc2hhZG93XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYSBzaGFkb3cgaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pbmNsdWRlRGVmYXVsdFZhbHVlcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICAgIGJsdXI6IHRoaXMuYmx1cixcbiAgICAgICAgICBvZmZzZXRYOiB0aGlzLm9mZnNldFgsXG4gICAgICAgICAgb2Zmc2V0WTogdGhpcy5vZmZzZXRZLFxuICAgICAgICAgIGFmZmVjdFN0cm9rZTogdGhpcy5hZmZlY3RTdHJva2UsXG4gICAgICAgICAgbm9uU2NhbGluZzogdGhpcy5ub25TY2FsaW5nXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0geyB9LCBwcm90byA9IGZhYnJpYy5TaGFkb3cucHJvdG90eXBlO1xuXG4gICAgICBbJ2NvbG9yJywgJ2JsdXInLCAnb2Zmc2V0WCcsICdvZmZzZXRZJywgJ2FmZmVjdFN0cm9rZScsICdub25TY2FsaW5nJ10uZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIGlmICh0aGlzW3Byb3BdICE9PSBwcm90b1twcm9wXSkge1xuICAgICAgICAgIG9ialtwcm9wXSA9IHRoaXNbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJlZ2V4IG1hdGNoaW5nIHNoYWRvdyBvZmZzZXRYLCBvZmZzZXRZIGFuZCBibHVyIChleDogXCIycHggMnB4IDEwcHggcmdiYSgwLDAsMCwwLjIpXCIsIFwicmdiKDAsMjU1LDApIDJweCAycHhcIilcbiAgICogQHN0YXRpY1xuICAgKiBAZmllbGRcbiAgICogQG1lbWJlck9mIGZhYnJpYy5TaGFkb3dcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gIGZhYnJpYy5TaGFkb3cucmVPZmZzZXRzQW5kQmx1ciA9IC8oPzpcXHN8XikoLT9cXGQrKD86XFwuXFxkKik/KD86cHgpPyg/Olxccz98JCkpPygtP1xcZCsoPzpcXC5cXGQqKT8oPzpweCk/KD86XFxzP3wkKSk/KFxcZCsoPzpcXC5cXGQqKT8oPzpweCk/KT8oPzpcXHM/fCQpKD86JHxcXHMpLztcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbiAoKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmIChmYWJyaWMuU3RhdGljQ2FudmFzKSB7XG4gICAgZmFicmljLndhcm4oJ2ZhYnJpYy5TdGF0aWNDYW52YXMgaXMgYWxyZWFkeSBkZWZpbmVkLicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGFsaWFzZXMgZm9yIGZhc3RlciByZXNvbHV0aW9uXG4gIHZhciBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgZ2V0RWxlbWVudE9mZnNldCA9IGZhYnJpYy51dGlsLmdldEVsZW1lbnRPZmZzZXQsXG4gICAgICByZW1vdmVGcm9tQXJyYXkgPSBmYWJyaWMudXRpbC5yZW1vdmVGcm9tQXJyYXksXG4gICAgICB0b0ZpeGVkID0gZmFicmljLnV0aWwudG9GaXhlZCxcbiAgICAgIHRyYW5zZm9ybVBvaW50ID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQsXG4gICAgICBpbnZlcnRUcmFuc2Zvcm0gPSBmYWJyaWMudXRpbC5pbnZlcnRUcmFuc2Zvcm0sXG4gICAgICBnZXROb2RlQ2FudmFzID0gZmFicmljLnV0aWwuZ2V0Tm9kZUNhbnZhcyxcbiAgICAgIGNyZWF0ZUNhbnZhc0VsZW1lbnQgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50LFxuXG4gICAgICBDQU5WQVNfSU5JVF9FUlJPUiA9IG5ldyBFcnJvcignQ291bGQgbm90IGluaXRpYWxpemUgYGNhbnZhc2AgZWxlbWVudCcpO1xuXG4gIC8qKlxuICAgKiBTdGF0aWMgY2FudmFzIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuU3RhdGljQ2FudmFzXG4gICAqIEBtaXhlcyBmYWJyaWMuQ29sbGVjdGlvblxuICAgKiBAbWl4ZXMgZmFicmljLk9ic2VydmFibGVcbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9zdGF0aWNfY2FudmFzfFN0YXRpY0NhbnZhcyBkZW1vfVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBmaXJlcyBiZWZvcmU6cmVuZGVyXG4gICAqIEBmaXJlcyBhZnRlcjpyZW5kZXJcbiAgICogQGZpcmVzIGNhbnZhczpjbGVhcmVkXG4gICAqIEBmaXJlcyBvYmplY3Q6YWRkZWRcbiAgICogQGZpcmVzIG9iamVjdDpyZW1vdmVkXG4gICAqL1xuICBmYWJyaWMuU3RhdGljQ2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLkNvbW1vbk1ldGhvZHMsIC8qKiBAbGVuZHMgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgU3RyaW5nfSBlbCAmbHQ7Y2FudmFzPiBlbGVtZW50IHRvIGluaXRpYWxpemUgaW5zdGFuY2Ugb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZWwsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuICAgICAgdGhpcy5yZW5kZXJBbmRSZXNldEJvdW5kID0gdGhpcy5yZW5kZXJBbmRSZXNldC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsQm91bmQgPSB0aGlzLnJlcXVlc3RSZW5kZXJBbGwuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX2luaXRTdGF0aWMoZWwsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCYWNrZ3JvdW5kIGNvbG9yIG9mIGNhbnZhcyBpbnN0YW5jZS5cbiAgICAgKiBTaG91bGQgYmUgc2V0IHZpYSB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNzZXRCYWNrZ3JvdW5kQ29sb3J9LlxuICAgICAqIEB0eXBlIHsoU3RyaW5nfGZhYnJpYy5QYXR0ZXJuKX1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJhY2tncm91bmRDb2xvcjogJycsXG5cbiAgICAvKipcbiAgICAgKiBCYWNrZ3JvdW5kIGltYWdlIG9mIGNhbnZhcyBpbnN0YW5jZS5cbiAgICAgKiBzaW5jZSAyLjQuMCBpbWFnZSBjYWNoaW5nIGlzIGFjdGl2ZSwgcGxlYXNlIHdoZW4gcHV0dGluZyBhbiBpbWFnZSBhcyBiYWNrZ3JvdW5kLCBhZGQgdG8gdGhlXG4gICAgICogY2FudmFzIHByb3BlcnR5IGEgcmVmZXJlbmNlIHRvIHRoZSBjYW52YXMgaXQgaXMgb24uIE90aGVyd2lzZSB0aGUgaW1hZ2UgY2Fubm90IGRldGVjdCB0aGUgem9vbVxuICAgICAqIHZhbGUuIEFzIGFuIGFsdGVybmF0aXZlIHlvdSBjYW4gZGlzYWJsZSBpbWFnZSBvYmplY3RDYWNoaW5nXG4gICAgICogQHR5cGUgZmFicmljLkltYWdlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBPdmVybGF5IGNvbG9yIG9mIGNhbnZhcyBpbnN0YW5jZS5cbiAgICAgKiBTaG91bGQgYmUgc2V0IHZpYSB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNzZXRPdmVybGF5Q29sb3J9XG4gICAgICogQHNpbmNlIDEuMy45XG4gICAgICogQHR5cGUgeyhTdHJpbmd8ZmFicmljLlBhdHRlcm4pfVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb3ZlcmxheUNvbG9yOiAnJyxcblxuICAgIC8qKlxuICAgICAqIE92ZXJsYXkgaW1hZ2Ugb2YgY2FudmFzIGluc3RhbmNlLlxuICAgICAqIHNpbmNlIDIuNC4wIGltYWdlIGNhY2hpbmcgaXMgYWN0aXZlLCBwbGVhc2Ugd2hlbiBwdXR0aW5nIGFuIGltYWdlIGFzIG92ZXJsYXksIGFkZCB0byB0aGVcbiAgICAgKiBjYW52YXMgcHJvcGVydHkgYSByZWZlcmVuY2UgdG8gdGhlIGNhbnZhcyBpdCBpcyBvbi4gT3RoZXJ3aXNlIHRoZSBpbWFnZSBjYW5ub3QgZGV0ZWN0IHRoZSB6b29tXG4gICAgICogdmFsZS4gQXMgYW4gYWx0ZXJuYXRpdmUgeW91IGNhbiBkaXNhYmxlIGltYWdlIG9iamVjdENhY2hpbmdcbiAgICAgKiBAdHlwZSBmYWJyaWMuSW1hZ2VcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG92ZXJsYXlJbWFnZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRvT2JqZWN0L3RvRGF0YWxlc3NPYmplY3Qgc2hvdWxkIGluY2x1ZGUgZGVmYXVsdCB2YWx1ZXNcbiAgICAgKiBpZiBzZXQgdG8gZmFsc2UsIHRha2VzIHByZWNlZGVuY2Ugb3ZlciB0aGUgb2JqZWN0IHZhbHVlLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGluY2x1ZGVEZWZhdWx0VmFsdWVzOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgb2JqZWN0cycgc3RhdGUgc2hvdWxkIGJlIHNhdmVkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3RhdGVmdWw6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIge0BsaW5rIGZhYnJpYy5Db2xsZWN0aW9uLmFkZH0sIHtAbGluayBmYWJyaWMuQ29sbGVjdGlvbi5pbnNlcnRBdH0gYW5kIHtAbGluayBmYWJyaWMuQ29sbGVjdGlvbi5yZW1vdmV9LFxuICAgICAqIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzLm1vdmVUb30sIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzLmNsZWFyfSBhbmQgbWFueSBtb3JlLCBzaG91bGQgYWxzbyByZS1yZW5kZXIgY2FudmFzLlxuICAgICAqIERpc2FibGluZyB0aGlzIG9wdGlvbiB3aWxsIG5vdCBnaXZlIGEgcGVyZm9ybWFuY2UgYm9vc3Qgd2hlbiBhZGRpbmcvcmVtb3ZpbmcgYSBsb3Qgb2Ygb2JqZWN0cyB0by9mcm9tIGNhbnZhcyBhdCBvbmNlXG4gICAgICogc2luY2UgdGhlIHJlbmRlcnMgYXJlIHF1ZXF1ZWQgYW5kIGV4ZWN1dGVkIG9uZSBwZXIgZnJhbWUuXG4gICAgICogRGlzYWJsaW5nIGlzIHN1Z2dlc3RlZCBhbnl3YXkgYW5kIG1hbmFnaW5nIHRoZSByZW5kZXJzIG9mIHRoZSBhcHAgbWFudWFsbHkgaXMgbm90IGEgYmlnIGVmZm9ydCAoIGNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCkgKVxuICAgICAqIExlZnQgZGVmYXVsdCB0byB0cnVlIHRvIGRvIG5vdCBicmVhayBkb2N1bWVudGF0aW9uIGFuZCBvbGQgYXBwLCBmaWRkbGVzLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJlbmRlck9uQWRkUmVtb3ZlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgb2JqZWN0IGNvbnRyb2xzIChib3JkZXJzL2NvbnRyb2xzKSBhcmUgcmVuZGVyZWQgYWJvdmUgb3ZlcmxheSBpbWFnZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNvbnRyb2xzQWJvdmVPdmVybGF5OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBicm93c2VyIGNhbiBiZSBzY3JvbGxlZCB3aGVuIHVzaW5nIGEgdG91Y2hzY3JlZW4gYW5kIGRyYWdnaW5nIG9uIHRoZSBjYW52YXNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBhbGxvd1RvdWNoU2Nyb2xsaW5nOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgY2FudmFzIHdpbGwgdXNlIGltYWdlIHNtb290aGluZywgdGhpcyBpcyBvbiBieSBkZWZhdWx0IGluIGJyb3dzZXJzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaW1hZ2VTbW9vdGhpbmdFbmFibGVkOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHRyYW5zZm9ybWF0aW9uIChhIENhbnZhcyAyRCBBUEkgdHJhbnNmb3JtIG1hdHJpeCkgd2hpY2ggZm9jdXNlcyB0aGUgdmlld3BvcnRcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkRlZmF1bHQgdHJhbnNmb3JtPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybSA9IFsxLCAwLCAwLCAxLCAwLCAwXTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TY2FsZSBieSA3MCUgYW5kIHRyYW5zbGF0ZSB0b3dhcmQgYm90dG9tLXJpZ2h0IGJ5IDUwLCB3aXRob3V0IHNrZXdpbmc8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtID0gWzAuNywgMCwgMCwgMC43LCA1MCwgNTBdO1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdmlld3BvcnRUcmFuc2Zvcm06IGZhYnJpYy5pTWF0cml4LmNvbmNhdCgpLFxuXG4gICAgLyoqXG4gICAgICogaWYgc2V0IHRvIGZhbHNlIGJhY2tncm91bmQgaW1hZ2UgaXMgbm90IGFmZmVjdGVkIGJ5IHZpZXdwb3J0IHRyYW5zZm9ybVxuICAgICAqIEBzaW5jZSAxLjYuM1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJhY2tncm91bmRWcHQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBpZiBzZXQgdG8gZmFsc2Ugb3Zlcmx5YSBpbWFnZSBpcyBub3QgYWZmZWN0ZWQgYnkgdmlld3BvcnQgdHJhbnNmb3JtXG4gICAgICogQHNpbmNlIDEuNi4zXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb3ZlcmxheVZwdDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgY2FudmFzIGlzIHNjYWxlZCBieSBkZXZpY2VQaXhlbFJhdGlvIGZvciBiZXR0ZXIgcmVuZGVyaW5nIG9uIHJldGluYSBzY3JlZW5zXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZW5hYmxlUmV0aW5hU2NhbGluZzogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIGNhbnZhcyBlbGVtZW50IGV4dGVuc2lvbiBvdmVyIGRlc2lnblxuICAgICAqIHByb3BlcnRpZXMgYXJlIHRsLHRyLGJsLGJyLlxuICAgICAqIGlmIGNhbnZhcyBpcyBub3Qgem9vbWVkL3Bhbm5lZCB0aG9zZSBwb2ludHMgYXJlIHRoZSBmb3VyIGNvcm5lciBvZiBjYW52YXNcbiAgICAgKiBpZiBjYW52YXMgaXMgdmlld3BvcnRUcmFuc2Zvcm1lZCB5b3UgdGhvc2UgcG9pbnRzIGluZGljYXRlIHRoZSBleHRlbnNpb25cbiAgICAgKiBvZiBjYW52YXMgZWxlbWVudCBpbiBwbGFpbiB1bnRyYXNmb3JtZWQgY29vcmRpbmF0ZXNcbiAgICAgKiBUaGUgY29vcmRpbmF0ZXMgZ2V0IHVwZGF0ZWQgd2l0aCBAbWV0aG9kIGNhbGNWaWV3cG9ydEJvdW5kYXJpZXMuXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlXG4gICAgICovXG4gICAgdnB0Q29vcmRzOiB7IH0sXG5cbiAgICAvKipcbiAgICAgKiBCYXNlZCBvbiB2cHRDb29yZHMgYW5kIG9iamVjdC5hQ29vcmRzLCBza2lwIHJlbmRlcmluZyBvZiBvYmplY3RzIHRoYXRcbiAgICAgKiBhcmUgbm90IGluY2x1ZGVkIGluIGN1cnJlbnQgdmlld3BvcnQuXG4gICAgICogTWF5IGdyZWF0bHkgaGVscCBpbiBhcHBsaWNhdGlvbnMgd2l0aCBjcm93ZGVkIGNhbnZhcyBhbmQgdXNlIG9mIHpvb20vcGFuXG4gICAgICogSWYgT25lIG9mIHRoZSBjb3JuZXIgb2YgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgb2JqZWN0IGlzIG9uIHRoZSBjYW52YXNcbiAgICAgKiB0aGUgb2JqZWN0cyBnZXQgcmVuZGVyZWQuXG4gICAgICogQG1lbWJlck9mIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2tpcE9mZnNjcmVlbjogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIGEgZmFicmljT2JqZWN0IHRoYXQsIHdpdGhvdXQgc3Ryb2tlIGRlZmluZSBhIGNsaXBwaW5nIGFyZWEgd2l0aCB0aGVpciBzaGFwZS4gZmlsbGVkIGluIGJsYWNrXG4gICAgICogdGhlIGNsaXBQYXRoIG9iamVjdCBnZXRzIHVzZWQgd2hlbiB0aGUgY2FudmFzIGhhcyByZW5kZXJlZCwgYW5kIHRoZSBjb250ZXh0IGlzIHBsYWNlZCBpbiB0aGVcbiAgICAgKiB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhcy5cbiAgICAgKiBjbGlwUGF0aCB3aWxsIGNsaXAgYXdheSBjb250cm9scywgaWYgeW91IGRvIG5vdCB3YW50IHRoaXMgdG8gaGFwcGVuIHVzZSBjb250cm9sc0Fib3ZlT3ZlcmxheSA9IHRydWVcbiAgICAgKiBAdHlwZSBmYWJyaWMuT2JqZWN0XG4gICAgICovXG4gICAgY2xpcFBhdGg6IHVuZGVmaW5lZCxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IFN0cmluZ30gZWwgJmx0O2NhbnZhcz4gZWxlbWVudCB0byBpbml0aWFsaXplIGluc3RhbmNlIG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIF9pbml0U3RhdGljOiBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xuICAgICAgdmFyIGNiID0gdGhpcy5yZXF1ZXN0UmVuZGVyQWxsQm91bmQ7XG4gICAgICB0aGlzLl9vYmplY3RzID0gW107XG4gICAgICB0aGlzLl9jcmVhdGVMb3dlckNhbnZhcyhlbCk7XG4gICAgICB0aGlzLl9pbml0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIC8vIG9ubHkgaW5pdGlhbGl6ZSByZXRpbmEgc2NhbGluZyBvbmNlXG4gICAgICBpZiAoIXRoaXMuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgdGhpcy5faW5pdFJldGluYVNjYWxpbmcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMub3ZlcmxheUltYWdlKSB7XG4gICAgICAgIHRoaXMuc2V0T3ZlcmxheUltYWdlKG9wdGlvbnMub3ZlcmxheUltYWdlLCBjYik7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5iYWNrZ3JvdW5kSW1hZ2UpIHtcbiAgICAgICAgdGhpcy5zZXRCYWNrZ3JvdW5kSW1hZ2Uob3B0aW9ucy5iYWNrZ3JvdW5kSW1hZ2UsIGNiKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICB0aGlzLnNldEJhY2tncm91bmRDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvciwgY2IpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMub3ZlcmxheUNvbG9yKSB7XG4gICAgICAgIHRoaXMuc2V0T3ZlcmxheUNvbG9yKG9wdGlvbnMub3ZlcmxheUNvbG9yLCBjYik7XG4gICAgICB9XG4gICAgICB0aGlzLmNhbGNPZmZzZXQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNSZXRpbmFTY2FsaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAoZmFicmljLmRldmljZVBpeGVsUmF0aW8gPiAxICYmIHRoaXMuZW5hYmxlUmV0aW5hU2NhbGluZyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSByZXRpbmFTY2FsaW5nIGlmIGFwcGxpZWQsIG90aGVyd2lzZSAxO1xuICAgICAqL1xuICAgIGdldFJldGluYVNjYWxpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzUmV0aW5hU2NhbGluZygpID8gTWF0aC5tYXgoMSwgZmFicmljLmRldmljZVBpeGVsUmF0aW8pIDogMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdFJldGluYVNjYWxpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9pc1JldGluYVNjYWxpbmcoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgc2NhbGVSYXRpbyA9IGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgdGhpcy5fX2luaXRSZXRpbmFTY2FsaW5nKHNjYWxlUmF0aW8sIHRoaXMubG93ZXJDYW52YXNFbCwgdGhpcy5jb250ZXh0Q29udGFpbmVyKTtcbiAgICAgIGlmICh0aGlzLnVwcGVyQ2FudmFzRWwpIHtcbiAgICAgICAgdGhpcy5fX2luaXRSZXRpbmFTY2FsaW5nKHNjYWxlUmF0aW8sIHRoaXMudXBwZXJDYW52YXNFbCwgdGhpcy5jb250ZXh0VG9wKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX19pbml0UmV0aW5hU2NhbGluZzogZnVuY3Rpb24oc2NhbGVSYXRpbywgY2FudmFzLCBjb250ZXh0KSB7XG4gICAgICBjYW52YXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMud2lkdGggKiBzY2FsZVJhdGlvKTtcbiAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuaGVpZ2h0ICogc2NhbGVSYXRpbyk7XG4gICAgICBjb250ZXh0LnNjYWxlKHNjYWxlUmF0aW8sIHNjYWxlUmF0aW8pO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgY2FudmFzIGVsZW1lbnQgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudFxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGFsc28gYXR0YWNoZWQgYXMgXCJyZXNpemVcIiBldmVudCBoYW5kbGVyIG9mIHdpbmRvd1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNhbGNPZmZzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuX29mZnNldCA9IGdldEVsZW1lbnRPZmZzZXQodGhpcy5sb3dlckNhbnZhc0VsKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI292ZXJsYXlJbWFnZXxvdmVybGF5IGltYWdlfSBmb3IgdGhpcyBjYW52YXNcbiAgICAgKiBAcGFyYW0geyhmYWJyaWMuSW1hZ2V8U3RyaW5nKX0gaW1hZ2UgZmFicmljLkltYWdlIGluc3RhbmNlIG9yIFVSTCBvZiBhbiBpbWFnZSB0byBzZXQgb3ZlcmxheSB0b1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIHRvIGludm9rZSB3aGVuIGltYWdlIGlzIGxvYWRlZCBhbmQgc2V0IGFzIGFuIG92ZXJsYXlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbmFsIG9wdGlvbnMgdG8gc2V0IGZvciB0aGUge0BsaW5rIGZhYnJpYy5JbWFnZXxvdmVybGF5IGltYWdlfS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvTW56SFQvfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+Tm9ybWFsIG92ZXJsYXlJbWFnZSB3aXRoIGxlZnQvdG9wID0gMDwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0T3ZlcmxheUltYWdlKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9qYWlsX2NlbGxfYmFycy5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgLy8gTmVlZGVkIHRvIHBvc2l0aW9uIG92ZXJsYXlJbWFnZSBhdCAwLzBcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+b3ZlcmxheUltYWdlIHdpdGggZGlmZmVyZW50IHByb3BlcnRpZXM8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvamFpbF9jZWxsX2JhcnMucG5nJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIHtcbiAgICAgKiAgIG9wYWNpdHk6IDAuNSxcbiAgICAgKiAgIGFuZ2xlOiA0NSxcbiAgICAgKiAgIGxlZnQ6IDQwMCxcbiAgICAgKiAgIHRvcDogNDAwLFxuICAgICAqICAgb3JpZ2luWDogJ2xlZnQnLFxuICAgICAqICAgb3JpZ2luWTogJ3RvcCdcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TdHJldGNoZWQgb3ZlcmxheUltYWdlICMxIC0gd2lkdGgvaGVpZ2h0IGNvcnJlc3BvbmQgdG8gY2FudmFzIHdpZHRoL2hlaWdodDwvY2FwdGlvbj5cbiAgICAgKiBmYWJyaWMuSW1hZ2UuZnJvbVVSTCgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvamFpbF9jZWxsX2JhcnMucG5nJywgZnVuY3Rpb24oaW1nLCBpc0Vycm9yKSB7XG4gICAgICogICAgaW1nLnNldCh7d2lkdGg6IGNhbnZhcy53aWR0aCwgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0LCBvcmlnaW5YOiAnbGVmdCcsIG9yaWdpblk6ICd0b3AnfSk7XG4gICAgICogICAgY2FudmFzLnNldE92ZXJsYXlJbWFnZShpbWcsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TdHJldGNoZWQgb3ZlcmxheUltYWdlICMyIC0gd2lkdGgvaGVpZ2h0IGNvcnJlc3BvbmQgdG8gY2FudmFzIHdpZHRoL2hlaWdodDwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0T3ZlcmxheUltYWdlKCdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9qYWlsX2NlbGxfYmFycy5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgKiAgIGhlaWdodDogY2FudmFzLmhlaWdodCxcbiAgICAgKiAgIC8vIE5lZWRlZCB0byBwb3NpdGlvbiBvdmVybGF5SW1hZ2UgYXQgMC8wXG4gICAgICogICBvcmlnaW5YOiAnbGVmdCcsXG4gICAgICogICBvcmlnaW5ZOiAndG9wJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPm92ZXJsYXlJbWFnZSBsb2FkZWQgZnJvbSBjcm9zcy1vcmlnaW48L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvamFpbF9jZWxsX2JhcnMucG5nJywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcyksIHtcbiAgICAgKiAgIG9wYWNpdHk6IDAuNSxcbiAgICAgKiAgIGFuZ2xlOiA0NSxcbiAgICAgKiAgIGxlZnQ6IDQwMCxcbiAgICAgKiAgIHRvcDogNDAwLFxuICAgICAqICAgb3JpZ2luWDogJ2xlZnQnLFxuICAgICAqICAgb3JpZ2luWTogJ3RvcCcsXG4gICAgICogICBjcm9zc09yaWdpbjogJ2Fub255bW91cydcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBzZXRPdmVybGF5SW1hZ2U6IGZ1bmN0aW9uIChpbWFnZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc2V0QmdPdmVybGF5SW1hZ2UoJ292ZXJsYXlJbWFnZScsIGltYWdlLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMge0BsaW5rIGZhYnJpYy5TdGF0aWNDYW52YXMjYmFja2dyb3VuZEltYWdlfGJhY2tncm91bmQgaW1hZ2V9IGZvciB0aGlzIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7KGZhYnJpYy5JbWFnZXxTdHJpbmcpfSBpbWFnZSBmYWJyaWMuSW1hZ2UgaW5zdGFuY2Ugb3IgVVJMIG9mIGFuIGltYWdlIHRvIHNldCBiYWNrZ3JvdW5kIHRvXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gaW1hZ2UgaXMgbG9hZGVkIGFuZCBzZXQgYXMgYmFja2dyb3VuZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uYWwgb3B0aW9ucyB0byBzZXQgZm9yIHRoZSB7QGxpbmsgZmFicmljLkltYWdlfGJhY2tncm91bmQgaW1hZ2V9LlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9kam5yOG83YS8yOC98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Ob3JtYWwgYmFja2dyb3VuZEltYWdlIHdpdGggbGVmdC90b3AgPSAwPC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kSW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2hvbmV5X2ltX3N1YnRsZS5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgLy8gTmVlZGVkIHRvIHBvc2l0aW9uIGJhY2tncm91bmRJbWFnZSBhdCAwLzBcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+YmFja2dyb3VuZEltYWdlIHdpdGggZGlmZmVyZW50IHByb3BlcnRpZXM8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldEJhY2tncm91bmRJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvaG9uZXlfaW1fc3VidGxlLnBuZycsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCB7XG4gICAgICogICBvcGFjaXR5OiAwLjUsXG4gICAgICogICBhbmdsZTogNDUsXG4gICAgICogICBsZWZ0OiA0MDAsXG4gICAgICogICB0b3A6IDQwMCxcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnXG4gICAgICogfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U3RyZXRjaGVkIGJhY2tncm91bmRJbWFnZSAjMSAtIHdpZHRoL2hlaWdodCBjb3JyZXNwb25kIHRvIGNhbnZhcyB3aWR0aC9oZWlnaHQ8L2NhcHRpb24+XG4gICAgICogZmFicmljLkltYWdlLmZyb21VUkwoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2hvbmV5X2ltX3N1YnRsZS5wbmcnLCBmdW5jdGlvbihpbWcsIGlzRXJyb3IpIHtcbiAgICAgKiAgICBpbWcuc2V0KHt3aWR0aDogY2FudmFzLndpZHRoLCBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsIG9yaWdpblg6ICdsZWZ0Jywgb3JpZ2luWTogJ3RvcCd9KTtcbiAgICAgKiAgICBjYW52YXMuc2V0QmFja2dyb3VuZEltYWdlKGltZywgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlN0cmV0Y2hlZCBiYWNrZ3JvdW5kSW1hZ2UgIzIgLSB3aWR0aC9oZWlnaHQgY29ycmVzcG9uZCB0byBjYW52YXMgd2lkdGgvaGVpZ2h0PC9jYXB0aW9uPlxuICAgICAqIGNhbnZhcy5zZXRCYWNrZ3JvdW5kSW1hZ2UoJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2hvbmV5X2ltX3N1YnRsZS5wbmcnLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwge1xuICAgICAqICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgKiAgIGhlaWdodDogY2FudmFzLmhlaWdodCxcbiAgICAgKiAgIC8vIE5lZWRlZCB0byBwb3NpdGlvbiBiYWNrZ3JvdW5kSW1hZ2UgYXQgMC8wXG4gICAgICogICBvcmlnaW5YOiAnbGVmdCcsXG4gICAgICogICBvcmlnaW5ZOiAndG9wJ1xuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmJhY2tncm91bmRJbWFnZSBsb2FkZWQgZnJvbSBjcm9zcy1vcmlnaW48L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldEJhY2tncm91bmRJbWFnZSgnaHR0cDovL2ZhYnJpY2pzLmNvbS9hc3NldHMvaG9uZXlfaW1fc3VidGxlLnBuZycsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpLCB7XG4gICAgICogICBvcGFjaXR5OiAwLjUsXG4gICAgICogICBhbmdsZTogNDUsXG4gICAgICogICBsZWZ0OiA0MDAsXG4gICAgICogICB0b3A6IDQwMCxcbiAgICAgKiAgIG9yaWdpblg6ICdsZWZ0JyxcbiAgICAgKiAgIG9yaWdpblk6ICd0b3AnLFxuICAgICAqICAgY3Jvc3NPcmlnaW46ICdhbm9ueW1vdXMnXG4gICAgICogfSk7XG4gICAgICovXG4gICAgLy8gVE9ETzogZml4IHN0cmV0Y2hlZCBleGFtcGxlc1xuICAgIHNldEJhY2tncm91bmRJbWFnZTogZnVuY3Rpb24gKGltYWdlLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuX19zZXRCZ092ZXJsYXlJbWFnZSgnYmFja2dyb3VuZEltYWdlJywgaW1hZ2UsIGNhbGxiYWNrLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNvdmVybGF5Q29sb3J8Zm9yZWdyb3VuZCBjb2xvcn0gZm9yIHRoaXMgY2FudmFzXG4gICAgICogQHBhcmFtIHsoU3RyaW5nfGZhYnJpYy5QYXR0ZXJuKX0gb3ZlcmxheUNvbG9yIENvbG9yIG9yIHBhdHRlcm4gdG8gc2V0IGZvcmVncm91bmQgY29sb3IgdG9cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBmb3JlZ3JvdW5kIGNvbG9yIGlzIHNldFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9wQjU1aC98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Ob3JtYWwgb3ZlcmxheUNvbG9yIC0gY29sb3IgdmFsdWU8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlDb2xvcigncmdiYSgyNTUsIDczLCA2NCwgMC42KScsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5mYWJyaWMuUGF0dGVybiB1c2VkIGFzIG92ZXJsYXlDb2xvcjwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0T3ZlcmxheUNvbG9yKHtcbiAgICAgKiAgIHNvdXJjZTogJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2VzY2hlcmVzcXVlX3N0ZS5wbmcnXG4gICAgICogfSwgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmZhYnJpYy5QYXR0ZXJuIHVzZWQgYXMgb3ZlcmxheUNvbG9yIHdpdGggcmVwZWF0IGFuZCBvZmZzZXQ8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldE92ZXJsYXlDb2xvcih7XG4gICAgICogICBzb3VyY2U6ICdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9lc2NoZXJlc3F1ZV9zdGUucG5nJyxcbiAgICAgKiAgIHJlcGVhdDogJ3JlcGVhdCcsXG4gICAgICogICBvZmZzZXRYOiAyMDAsXG4gICAgICogICBvZmZzZXRZOiAxMDBcbiAgICAgKiB9LCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAgICovXG4gICAgc2V0T3ZlcmxheUNvbG9yOiBmdW5jdGlvbihvdmVybGF5Q29sb3IsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3NldEJnT3ZlcmxheUNvbG9yKCdvdmVybGF5Q29sb3InLCBvdmVybGF5Q29sb3IsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNiYWNrZ3JvdW5kQ29sb3J8YmFja2dyb3VuZCBjb2xvcn0gZm9yIHRoaXMgY2FudmFzXG4gICAgICogQHBhcmFtIHsoU3RyaW5nfGZhYnJpYy5QYXR0ZXJuKX0gYmFja2dyb3VuZENvbG9yIENvbG9yIG9yIHBhdHRlcm4gdG8gc2V0IGJhY2tncm91bmQgY29sb3IgdG9cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBiYWNrZ3JvdW5kIGNvbG9yIGlzIHNldFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9oWHp2ay98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Ob3JtYWwgYmFja2dyb3VuZENvbG9yIC0gY29sb3IgdmFsdWU8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldEJhY2tncm91bmRDb2xvcigncmdiYSgyNTUsIDczLCA2NCwgMC42KScsIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5mYWJyaWMuUGF0dGVybiB1c2VkIGFzIGJhY2tncm91bmRDb2xvcjwvY2FwdGlvbj5cbiAgICAgKiBjYW52YXMuc2V0QmFja2dyb3VuZENvbG9yKHtcbiAgICAgKiAgIHNvdXJjZTogJ2h0dHA6Ly9mYWJyaWNqcy5jb20vYXNzZXRzL2VzY2hlcmVzcXVlX3N0ZS5wbmcnXG4gICAgICogfSwgY2FudmFzLnJlbmRlckFsbC5iaW5kKGNhbnZhcykpO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPmZhYnJpYy5QYXR0ZXJuIHVzZWQgYXMgYmFja2dyb3VuZENvbG9yIHdpdGggcmVwZWF0IGFuZCBvZmZzZXQ8L2NhcHRpb24+XG4gICAgICogY2FudmFzLnNldEJhY2tncm91bmRDb2xvcih7XG4gICAgICogICBzb3VyY2U6ICdodHRwOi8vZmFicmljanMuY29tL2Fzc2V0cy9lc2NoZXJlc3F1ZV9zdGUucG5nJyxcbiAgICAgKiAgIHJlcGVhdDogJ3JlcGVhdCcsXG4gICAgICogICBvZmZzZXRYOiAyMDAsXG4gICAgICogICBvZmZzZXRZOiAxMDBcbiAgICAgKiB9LCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAgICovXG4gICAgc2V0QmFja2dyb3VuZENvbG9yOiBmdW5jdGlvbihiYWNrZ3JvdW5kQ29sb3IsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3NldEJnT3ZlcmxheUNvbG9yKCdiYWNrZ3JvdW5kQ29sb3InLCBiYWNrZ3JvdW5kQ29sb3IsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdG8gc2V0ICh7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNiYWNrZ3JvdW5kSW1hZ2V8YmFja2dyb3VuZEltYWdlfVxuICAgICAqIG9yIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI292ZXJsYXlJbWFnZXxvdmVybGF5SW1hZ2V9KVxuICAgICAqIEBwYXJhbSB7KGZhYnJpYy5JbWFnZXxTdHJpbmd8bnVsbCl9IGltYWdlIGZhYnJpYy5JbWFnZSBpbnN0YW5jZSwgVVJMIG9mIGFuIGltYWdlIG9yIG51bGwgdG8gc2V0IGJhY2tncm91bmQgb3Igb3ZlcmxheSB0b1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGltYWdlIGlzIGxvYWRlZCBhbmQgc2V0IGFzIGJhY2tncm91bmQgb3Igb3ZlcmxheS4gVGhlIGZpcnN0IGFyZ3VtZW50IGlzIHRoZSBjcmVhdGVkIGltYWdlLCB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIGEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgYW4gZXJyb3Igb2NjdXJyZWQgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uYWwgb3B0aW9ucyB0byBzZXQgZm9yIHRoZSB7QGxpbmsgZmFicmljLkltYWdlfGltYWdlfS5cbiAgICAgKi9cbiAgICBfX3NldEJnT3ZlcmxheUltYWdlOiBmdW5jdGlvbihwcm9wZXJ0eSwgaW1hZ2UsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIGltYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICBmYWJyaWMudXRpbC5sb2FkSW1hZ2UoaW1hZ2UsIGZ1bmN0aW9uKGltZywgaXNFcnJvcikge1xuICAgICAgICAgIGlmIChpbWcpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBmYWJyaWMuSW1hZ2UoaW1nLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXNbcHJvcGVydHldID0gaW5zdGFuY2U7XG4gICAgICAgICAgICBpbnN0YW5jZS5jYW52YXMgPSB0aGlzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhpbWcsIGlzRXJyb3IpO1xuICAgICAgICB9LCB0aGlzLCBvcHRpb25zICYmIG9wdGlvbnMuY3Jvc3NPcmlnaW4pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgJiYgaW1hZ2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSBpbWFnZTtcbiAgICAgICAgaW1hZ2UgJiYgKGltYWdlLmNhbnZhcyA9IHRoaXMpO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhpbWFnZSwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdG8gc2V0ICh7QGxpbmsgZmFicmljLlN0YXRpY0NhbnZhcyNiYWNrZ3JvdW5kQ29sb3J8YmFja2dyb3VuZENvbG9yfVxuICAgICAqIG9yIHtAbGluayBmYWJyaWMuU3RhdGljQ2FudmFzI292ZXJsYXlDb2xvcnxvdmVybGF5Q29sb3J9KVxuICAgICAqIEBwYXJhbSB7KE9iamVjdHxTdHJpbmd8bnVsbCl9IGNvbG9yIE9iamVjdCB3aXRoIHBhdHRlcm4gaW5mb3JtYXRpb24sIGNvbG9yIHZhbHVlIG9yIG51bGxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIGlzIGludm9rZWQgd2hlbiBjb2xvciBpcyBzZXRcbiAgICAgKi9cbiAgICBfX3NldEJnT3ZlcmxheUNvbG9yOiBmdW5jdGlvbihwcm9wZXJ0eSwgY29sb3IsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzW3Byb3BlcnR5XSA9IGNvbG9yO1xuICAgICAgdGhpcy5faW5pdEdyYWRpZW50KGNvbG9yLCBwcm9wZXJ0eSk7XG4gICAgICB0aGlzLl9pbml0UGF0dGVybihjb2xvciwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVDYW52YXNFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHRocm93IENBTlZBU19JTklUX0VSUk9SO1xuICAgICAgfVxuICAgICAgaWYgKCFlbGVtZW50LnN0eWxlKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUgPSB7IH07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnQuZ2V0Q29udGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgQ0FOVkFTX0lOSVRfRVJST1I7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgX2luaXRPcHRpb25zOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgdmFyIGxvd2VyQ2FudmFzRWwgPSB0aGlzLmxvd2VyQ2FudmFzRWw7XG4gICAgICB0aGlzLl9zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgICB0aGlzLndpZHRoID0gdGhpcy53aWR0aCB8fCBwYXJzZUludChsb3dlckNhbnZhc0VsLndpZHRoLCAxMCkgfHwgMDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgfHwgcGFyc2VJbnQobG93ZXJDYW52YXNFbC5oZWlnaHQsIDEwKSB8fCAwO1xuXG4gICAgICBpZiAoIXRoaXMubG93ZXJDYW52YXNFbC5zdHlsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxvd2VyQ2FudmFzRWwud2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgbG93ZXJDYW52YXNFbC5oZWlnaHQgPSB0aGlzLmhlaWdodDtcblxuICAgICAgbG93ZXJDYW52YXNFbC5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyAncHgnO1xuICAgICAgbG93ZXJDYW52YXNFbC5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArICdweCc7XG5cbiAgICAgIHRoaXMudmlld3BvcnRUcmFuc2Zvcm0gPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtLnNsaWNlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBib3R0b20gY2FudmFzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbY2FudmFzRWxdXG4gICAgICovXG4gICAgX2NyZWF0ZUxvd2VyQ2FudmFzOiBmdW5jdGlvbiAoY2FudmFzRWwpIHtcbiAgICAgIC8vIGNhbnZhc0VsID09PSAnSFRNTENhbnZhc0VsZW1lbnQnIGRvZXMgbm90IHdvcmsgb24ganNkb20vbm9kZVxuICAgICAgaWYgKGNhbnZhc0VsICYmIGNhbnZhc0VsLmdldENvbnRleHQpIHtcbiAgICAgICAgdGhpcy5sb3dlckNhbnZhc0VsID0gY2FudmFzRWw7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5sb3dlckNhbnZhc0VsID0gZmFicmljLnV0aWwuZ2V0QnlJZChjYW52YXNFbCkgfHwgdGhpcy5fY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgfVxuXG4gICAgICBmYWJyaWMudXRpbC5hZGRDbGFzcyh0aGlzLmxvd2VyQ2FudmFzRWwsICdsb3dlci1jYW52YXMnKTtcbiAgICAgIHRoaXMuX29yaWdpbmFsQ2FudmFzU3R5bGUgPSB0aGlzLmxvd2VyQ2FudmFzRWwuc3R5bGU7XG4gICAgICBpZiAodGhpcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICB0aGlzLl9hcHBseUNhbnZhc1N0eWxlKHRoaXMubG93ZXJDYW52YXNFbCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udGV4dENvbnRhaW5lciA9IHRoaXMubG93ZXJDYW52YXNFbC5nZXRDb250ZXh0KCcyZCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNhbnZhcyB3aWR0aCAoaW4gcHgpXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjYW52YXMgaGVpZ2h0IChpbiBweClcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgd2lkdGggb2YgdGhpcyBjYW52YXMgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHZhbHVlICAgICAgICAgICAgICAgICAgICAgICAgIFZhbHVlIHRvIHNldCB3aWR0aCB0b1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgW29wdGlvbnNdICAgICAgICAgICAgICAgICAgICAgT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgIFtvcHRpb25zLmJhY2tzdG9yZU9ubHk9ZmFsc2VdIFNldCB0aGUgZ2l2ZW4gZGltZW5zaW9ucyBvbmx5IGFzIGNhbnZhcyBiYWNrc3RvcmUgZGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgW29wdGlvbnMuY3NzT25seT1mYWxzZV0gICAgICAgU2V0IHRoZSBnaXZlbiBkaW1lbnNpb25zIG9ubHkgYXMgY3NzIGRpbWVuc2lvbnNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIHNldFdpZHRoOiBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldERpbWVuc2lvbnMoeyB3aWR0aDogdmFsdWUgfSwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgaGVpZ2h0IG9mIHRoaXMgY2FudmFzIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSB2YWx1ZSAgICAgICAgICAgICAgICAgICAgICAgICBWYWx1ZSB0byBzZXQgaGVpZ2h0IHRvXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICBbb3B0aW9uc10gICAgICAgICAgICAgICAgICAgICBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgW29wdGlvbnMuYmFja3N0b3JlT25seT1mYWxzZV0gU2V0IHRoZSBnaXZlbiBkaW1lbnNpb25zIG9ubHkgYXMgY2FudmFzIGJhY2tzdG9yZSBkaW1lbnNpb25zXG4gICAgICogQHBhcmFtIHtCb29sZWFufSAgICAgICBbb3B0aW9ucy5jc3NPbmx5PWZhbHNlXSAgICAgICBTZXQgdGhlIGdpdmVuIGRpbWVuc2lvbnMgb25seSBhcyBjc3MgZGltZW5zaW9uc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgc2V0SGVpZ2h0OiBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldERpbWVuc2lvbnMoeyBoZWlnaHQ6IHZhbHVlIH0sIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGRpbWVuc2lvbnMgKHdpZHRoLCBoZWlnaHQpIG9mIHRoaXMgY2FudmFzIGluc3RhbmNlLiB3aGVuIG9wdGlvbnMuY3NzT25seSBmbGFnIGFjdGl2ZSB5b3Ugc2hvdWxkIGFsc28gc3VwcGx5IHRoZSB1bml0IG9mIG1lYXN1cmUgKHB4LyUvZW0pXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgICAgICBkaW1lbnNpb25zICAgICAgICAgICAgICAgICAgICBPYmplY3Qgd2l0aCB3aWR0aC9oZWlnaHQgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW2RpbWVuc2lvbnMud2lkdGhdICAgICAgICAgICAgV2lkdGggb2YgY2FudmFzIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IFtkaW1lbnNpb25zLmhlaWdodF0gICAgICAgICAgIEhlaWdodCBvZiBjYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgW29wdGlvbnNdICAgICAgICAgICAgICAgICAgICAgT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59ICAgICAgIFtvcHRpb25zLmJhY2tzdG9yZU9ubHk9ZmFsc2VdIFNldCB0aGUgZ2l2ZW4gZGltZW5zaW9ucyBvbmx5IGFzIGNhbnZhcyBiYWNrc3RvcmUgZGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgICAgW29wdGlvbnMuY3NzT25seT1mYWxzZV0gICAgICAgU2V0IHRoZSBnaXZlbiBkaW1lbnNpb25zIG9ubHkgYXMgY3NzIGRpbWVuc2lvbnNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uIChkaW1lbnNpb25zLCBvcHRpb25zKSB7XG4gICAgICB2YXIgY3NzVmFsdWU7XG5cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIGRpbWVuc2lvbnMpIHtcbiAgICAgICAgY3NzVmFsdWUgPSBkaW1lbnNpb25zW3Byb3BdO1xuXG4gICAgICAgIGlmICghb3B0aW9ucy5jc3NPbmx5KSB7XG4gICAgICAgICAgdGhpcy5fc2V0QmFja3N0b3JlRGltZW5zaW9uKHByb3AsIGRpbWVuc2lvbnNbcHJvcF0pO1xuICAgICAgICAgIGNzc1ZhbHVlICs9ICdweCc7XG4gICAgICAgICAgdGhpcy5oYXNMb3N0Q29udGV4dCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9wdGlvbnMuYmFja3N0b3JlT25seSkge1xuICAgICAgICAgIHRoaXMuX3NldENzc0RpbWVuc2lvbihwcm9wLCBjc3NWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9pc0N1cnJlbnRseURyYXdpbmcpIHtcbiAgICAgICAgdGhpcy5mcmVlRHJhd2luZ0JydXNoICYmIHRoaXMuZnJlZURyYXdpbmdCcnVzaC5fc2V0QnJ1c2hTdHlsZXModGhpcy5jb250ZXh0VG9wKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2luaXRSZXRpbmFTY2FsaW5nKCk7XG4gICAgICB0aGlzLmNhbGNPZmZzZXQoKTtcblxuICAgICAgaWYgKCFvcHRpb25zLmNzc09ubHkpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZm9yIHNldHRpbmcgd2lkdGgvaGVpZ2h0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBwcm9wZXJ0eSAod2lkdGh8aGVpZ2h0KVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSB2YWx1ZSB0byBzZXQgcHJvcGVydHkgdG9cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIF9zZXRCYWNrc3RvcmVEaW1lbnNpb246IGZ1bmN0aW9uIChwcm9wLCB2YWx1ZSkge1xuICAgICAgdGhpcy5sb3dlckNhbnZhc0VsW3Byb3BdID0gdmFsdWU7XG5cbiAgICAgIGlmICh0aGlzLnVwcGVyQ2FudmFzRWwpIHtcbiAgICAgICAgdGhpcy51cHBlckNhbnZhc0VsW3Byb3BdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNhY2hlQ2FudmFzRWwpIHtcbiAgICAgICAgdGhpcy5jYWNoZUNhbnZhc0VsW3Byb3BdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXNbcHJvcF0gPSB2YWx1ZTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmb3Igc2V0dGluZyBjc3Mgd2lkdGgvaGVpZ2h0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBwcm9wZXJ0eSAod2lkdGh8aGVpZ2h0KVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSB2YWx1ZSB0byBzZXQgcHJvcGVydHkgdG9cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIF9zZXRDc3NEaW1lbnNpb246IGZ1bmN0aW9uIChwcm9wLCB2YWx1ZSkge1xuICAgICAgdGhpcy5sb3dlckNhbnZhc0VsLnN0eWxlW3Byb3BdID0gdmFsdWU7XG5cbiAgICAgIGlmICh0aGlzLnVwcGVyQ2FudmFzRWwpIHtcbiAgICAgICAgdGhpcy51cHBlckNhbnZhc0VsLnN0eWxlW3Byb3BdID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLndyYXBwZXJFbCkge1xuICAgICAgICB0aGlzLndyYXBwZXJFbC5zdHlsZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjYW52YXMgem9vbSBsZXZlbFxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRab29tOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy52aWV3cG9ydFRyYW5zZm9ybVswXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB2aWV3cG9ydCB0cmFuc2Zvcm1hdGlvbiBvZiB0aGlzIGNhbnZhcyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZwdCBhIENhbnZhcyAyRCBBUEkgdHJhbnNmb3JtIG1hdHJpeFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgc2V0Vmlld3BvcnRUcmFuc2Zvcm06IGZ1bmN0aW9uICh2cHQpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3QgPSB0aGlzLl9hY3RpdmVPYmplY3QsXG4gICAgICAgICAgYmFja2dyb3VuZE9iamVjdCA9IHRoaXMuYmFja2dyb3VuZEltYWdlLFxuICAgICAgICAgIG92ZXJsYXlPYmplY3QgPSB0aGlzLm92ZXJsYXlJbWFnZSxcbiAgICAgICAgICBvYmplY3QsIGksIGxlbjtcbiAgICAgIHRoaXMudmlld3BvcnRUcmFuc2Zvcm0gPSB2cHQ7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG9iamVjdCA9IHRoaXMuX29iamVjdHNbaV07XG4gICAgICAgIG9iamVjdC5ncm91cCB8fCBvYmplY3Quc2V0Q29vcmRzKHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKGFjdGl2ZU9iamVjdCkge1xuICAgICAgICBhY3RpdmVPYmplY3Quc2V0Q29vcmRzKCk7XG4gICAgICB9XG4gICAgICBpZiAoYmFja2dyb3VuZE9iamVjdCkge1xuICAgICAgICBiYWNrZ3JvdW5kT2JqZWN0LnNldENvb3Jkcyh0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvdmVybGF5T2JqZWN0KSB7XG4gICAgICAgIG92ZXJsYXlPYmplY3Quc2V0Q29vcmRzKHRydWUpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWxjVmlld3BvcnRCb3VuZGFyaWVzKCk7XG4gICAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgem9vbSBsZXZlbCBvZiB0aGlzIGNhbnZhcyBpbnN0YW5jZSwgdGhlIHpvb20gY2VudGVyZWQgYXJvdW5kIHBvaW50XG4gICAgICogbWVhbmluZyB0aGF0IGZvbGxvd2luZyB6b29tIHRvIHBvaW50IHdpdGggdGhlIHNhbWUgcG9pbnQgd2lsbCBoYXZlIHRoZSB2aXN1YWxcbiAgICAgKiBlZmZlY3Qgb2YgdGhlIHpvb20gb3JpZ2luYXRpbmcgZnJvbSB0aGF0IHBvaW50LiBUaGUgcG9pbnQgd29uJ3QgbW92ZS5cbiAgICAgKiBJdCBoYXMgbm90aGluZyB0byBkbyB3aXRoIGNhbnZhcyBjZW50ZXIgb3IgdmlzdWFsIGNlbnRlciBvZiB0aGUgdmlld3BvcnQuXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IHRvIHpvb20gd2l0aCByZXNwZWN0IHRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIHRvIHNldCB6b29tIHRvLCBsZXNzIHRoYW4gMSB6b29tcyBvdXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIHpvb21Ub1BvaW50OiBmdW5jdGlvbiAocG9pbnQsIHZhbHVlKSB7XG4gICAgICAvLyBUT0RPOiBqdXN0IGNoYW5nZSB0aGUgc2NhbGUsIHByZXNlcnZlIG90aGVyIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgdmFyIGJlZm9yZSA9IHBvaW50LCB2cHQgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtLnNsaWNlKDApO1xuICAgICAgcG9pbnQgPSB0cmFuc2Zvcm1Qb2ludChwb2ludCwgaW52ZXJ0VHJhbnNmb3JtKHRoaXMudmlld3BvcnRUcmFuc2Zvcm0pKTtcbiAgICAgIHZwdFswXSA9IHZhbHVlO1xuICAgICAgdnB0WzNdID0gdmFsdWU7XG4gICAgICB2YXIgYWZ0ZXIgPSB0cmFuc2Zvcm1Qb2ludChwb2ludCwgdnB0KTtcbiAgICAgIHZwdFs0XSArPSBiZWZvcmUueCAtIGFmdGVyLng7XG4gICAgICB2cHRbNV0gKz0gYmVmb3JlLnkgLSBhZnRlci55O1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Vmlld3BvcnRUcmFuc2Zvcm0odnB0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB6b29tIGxldmVsIG9mIHRoaXMgY2FudmFzIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIHRvIHNldCB6b29tIHRvLCBsZXNzIHRoYW4gMSB6b29tcyBvdXRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGUgdHJ1ZVxuICAgICAqL1xuICAgIHNldFpvb206IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdGhpcy56b29tVG9Qb2ludChuZXcgZmFicmljLlBvaW50KDAsIDApLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFuIHZpZXdwb3J0IHNvIGFzIHRvIHBsYWNlIHBvaW50IGF0IHRvcCBsZWZ0IGNvcm5lciBvZiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgdG8gbW92ZSB0b1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZSB0cnVlXG4gICAgICovXG4gICAgYWJzb2x1dGVQYW46IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgdmFyIHZwdCA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm0uc2xpY2UoMCk7XG4gICAgICB2cHRbNF0gPSAtcG9pbnQueDtcbiAgICAgIHZwdFs1XSA9IC1wb2ludC55O1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Vmlld3BvcnRUcmFuc2Zvcm0odnB0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFucyB2aWV3cG9pbnQgcmVsYXRpdmVseVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCAocG9zaXRpb24gdmVjdG9yKSB0byBtb3ZlIGJ5XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gaW5zdGFuY2VcbiAgICAgKiBAY2hhaW5hYmxlIHRydWVcbiAgICAgKi9cbiAgICByZWxhdGl2ZVBhbjogZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5hYnNvbHV0ZVBhbihuZXcgZmFicmljLlBvaW50KFxuICAgICAgICAtcG9pbnQueCAtIHRoaXMudmlld3BvcnRUcmFuc2Zvcm1bNF0sXG4gICAgICAgIC1wb2ludC55IC0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybVs1XVxuICAgICAgKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgJmx0O2NhbnZhcz4gZWxlbWVudCBjb3JyZXNwb25kaW5nIHRvIHRoaXMgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cbiAgICBnZXRFbGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb3dlckNhbnZhc0VsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqIE9iamVjdCB0aGF0IHdhcyBhZGRlZFxuICAgICAqL1xuICAgIF9vbk9iamVjdEFkZGVkOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHRoaXMuc3RhdGVmdWwgJiYgb2JqLnNldHVwU3RhdGUoKTtcbiAgICAgIG9iai5fc2V0KCdjYW52YXMnLCB0aGlzKTtcbiAgICAgIG9iai5zZXRDb29yZHMoKTtcbiAgICAgIHRoaXMuZmlyZSgnb2JqZWN0OmFkZGVkJywgeyB0YXJnZXQ6IG9iaiB9KTtcbiAgICAgIG9iai5maXJlKCdhZGRlZCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqIE9iamVjdCB0aGF0IHdhcyByZW1vdmVkXG4gICAgICovXG4gICAgX29uT2JqZWN0UmVtb3ZlZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICB0aGlzLmZpcmUoJ29iamVjdDpyZW1vdmVkJywgeyB0YXJnZXQ6IG9iaiB9KTtcbiAgICAgIG9iai5maXJlKCdyZW1vdmVkJyk7XG4gICAgICBkZWxldGUgb2JqLmNhbnZhcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHNwZWNpZmllZCBjb250ZXh0IG9mIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIGNsZWFyXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjbGVhckNvbnRleHQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb250ZXh0IG9mIGNhbnZhcyB3aGVyZSBvYmplY3RzIGFyZSBkcmF3blxuICAgICAqIEByZXR1cm4ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKi9cbiAgICBnZXRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZXh0Q29udGFpbmVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIGNvbnRleHRzIChiYWNrZ3JvdW5kLCBtYWluLCB0b3ApIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5yZW1vdmUuYXBwbHkodGhpcywgdGhpcy5nZXRPYmplY3RzKCkpO1xuICAgICAgdGhpcy5iYWNrZ3JvdW5kSW1hZ2UgPSBudWxsO1xuICAgICAgdGhpcy5vdmVybGF5SW1hZ2UgPSBudWxsO1xuICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSAnJztcbiAgICAgIHRoaXMub3ZlcmxheUNvbG9yID0gJyc7XG4gICAgICBpZiAodGhpcy5faGFzSVRleHRIYW5kbGVycykge1xuICAgICAgICB0aGlzLm9mZignbW91c2U6dXAnLCB0aGlzLl9tb3VzZVVwSVRleHRIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5faVRleHRJbnN0YW5jZXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9oYXNJVGV4dEhhbmRsZXJzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLmNsZWFyQ29udGV4dCh0aGlzLmNvbnRleHRDb250YWluZXIpO1xuICAgICAgdGhpcy5maXJlKCdjYW52YXM6Y2xlYXJlZCcpO1xuICAgICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByZW5kZXJBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjYW52YXNUb0RyYXdPbiA9IHRoaXMuY29udGV4dENvbnRhaW5lcjtcbiAgICAgIHRoaXMucmVuZGVyQ2FudmFzKGNhbnZhc1RvRHJhd09uLCB0aGlzLl9vYmplY3RzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiBjcmVhdGVkIHRvIGJlIGluc3RhbmNlIGJvdW5kIGF0IGluaXRpYWxpemF0aW9uXG4gICAgICogdXNlZCBpbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgcmVuZGVyaW5nXG4gICAgICogTGV0IHRoZSBmYWJyaWNKUyBjYWxsIGl0LiBJZiB5b3UgY2FsbCBpdCBtYW51YWxseSB5b3UgY291bGQgaGF2ZSBtb3JlXG4gICAgICogYW5pbWF0aW9uRnJhbWUgc3RhY2tpbmcgb24gdG8gb2YgZWFjaCBvdGhlclxuICAgICAqIGZvciBhbiBpbXBlcmF0aXZlIHJlbmRlcmluZywgdXNlIGNhbnZhcy5yZW5kZXJBbGxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlbmRlckFuZFJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaXNSZW5kZXJpbmcgPSAwO1xuICAgICAgdGhpcy5yZW5kZXJBbGwoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwZW5kIGEgcmVuZGVyQWxsIHJlcXVlc3QgdG8gbmV4dCBhbmltYXRpb24gZnJhbWUuXG4gICAgICogdW5sZXNzIG9uZSBpcyBhbHJlYWR5IGluIHByb2dyZXNzLCBpbiB0aGF0IGNhc2Ugbm90aGluZyBpcyBkb25lXG4gICAgICogYSBib29sZWFuIGZsYWcgd2lsbCBhdm9pZCBhcHBlbmRpbmcgbW9yZS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByZXF1ZXN0UmVuZGVyQWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgdGhpcy5pc1JlbmRlcmluZyA9IGZhYnJpYy51dGlsLnJlcXVlc3RBbmltRnJhbWUodGhpcy5yZW5kZXJBbmRSZXNldEJvdW5kKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSA0IGNvcm5lciBvZiBjYW52YXMgd2l0aCBjdXJyZW50IHZpZXdwb3J0VHJhbnNmb3JtLlxuICAgICAqIGhlbHBzIHRvIGRldGVybWluYXRlIHdoZW4gYW4gb2JqZWN0IGlzIGluIHRoZSBjdXJyZW50IHJlbmRlcmluZyB2aWV3cG9ydCB1c2luZ1xuICAgICAqIG9iamVjdCBhYnNvbHV0ZSBjb29yZGluYXRlcyAoIGFDb29yZHMgKVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gcG9pbnRzLnRsXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNhbGNWaWV3cG9ydEJvdW5kYXJpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvaW50cyA9IHsgfSwgd2lkdGggPSB0aGlzLndpZHRoLCBoZWlnaHQgPSB0aGlzLmhlaWdodCxcbiAgICAgICAgICBpVnB0ID0gaW52ZXJ0VHJhbnNmb3JtKHRoaXMudmlld3BvcnRUcmFuc2Zvcm0pO1xuICAgICAgcG9pbnRzLnRsID0gdHJhbnNmb3JtUG9pbnQoeyB4OiAwLCB5OiAwIH0sIGlWcHQpO1xuICAgICAgcG9pbnRzLmJyID0gdHJhbnNmb3JtUG9pbnQoeyB4OiB3aWR0aCwgeTogaGVpZ2h0IH0sIGlWcHQpO1xuICAgICAgcG9pbnRzLnRyID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludHMuYnIueCwgcG9pbnRzLnRsLnkpO1xuICAgICAgcG9pbnRzLmJsID0gbmV3IGZhYnJpYy5Qb2ludChwb2ludHMudGwueCwgcG9pbnRzLmJyLnkpO1xuICAgICAgdGhpcy52cHRDb29yZHMgPSBwb2ludHM7XG4gICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH0sXG5cbiAgICBjYW5jZWxSZXF1ZXN0ZWRSZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgZmFicmljLnV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuaXNSZW5kZXJpbmcpO1xuICAgICAgICB0aGlzLmlzUmVuZGVyaW5nID0gMDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBiYWNrZ3JvdW5kLCBvYmplY3RzLCBvdmVybGF5IGFuZCBjb250cm9scy5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqZWN0cyB0byByZW5kZXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICByZW5kZXJDYW52YXM6IGZ1bmN0aW9uKGN0eCwgb2JqZWN0cykge1xuICAgICAgdmFyIHYgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtLCBwYXRoID0gdGhpcy5jbGlwUGF0aDtcbiAgICAgIHRoaXMuY2FuY2VsUmVxdWVzdGVkUmVuZGVyKCk7XG4gICAgICB0aGlzLmNhbGNWaWV3cG9ydEJvdW5kYXJpZXMoKTtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0KGN0eCk7XG4gICAgICBmYWJyaWMudXRpbC5zZXRJbWFnZVNtb290aGluZyhjdHgsIHRoaXMuaW1hZ2VTbW9vdGhpbmdFbmFibGVkKTtcbiAgICAgIHRoaXMuZmlyZSgnYmVmb3JlOnJlbmRlcicsIHsgY3R4OiBjdHgsIH0pO1xuICAgICAgdGhpcy5fcmVuZGVyQmFja2dyb3VuZChjdHgpO1xuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgLy9hcHBseSB2aWV3cG9ydCB0cmFuc2Zvcm0gb25jZSBmb3IgYWxsIHJlbmRlcmluZyBwcm9jZXNzXG4gICAgICBjdHgudHJhbnNmb3JtKHZbMF0sIHZbMV0sIHZbMl0sIHZbM10sIHZbNF0sIHZbNV0pO1xuICAgICAgdGhpcy5fcmVuZGVyT2JqZWN0cyhjdHgsIG9iamVjdHMpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIGlmICghdGhpcy5jb250cm9sc0Fib3ZlT3ZlcmxheSAmJiB0aGlzLmludGVyYWN0aXZlKSB7XG4gICAgICAgIHRoaXMuZHJhd0NvbnRyb2xzKGN0eCk7XG4gICAgICB9XG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICBwYXRoLmNhbnZhcyA9IHRoaXM7XG4gICAgICAgIC8vIG5lZWRlZCB0byBzZXR1cCBhIGNvdXBsZSBvZiB2YXJpYWJsZXNcbiAgICAgICAgcGF0aC5zaG91bGRDYWNoZSgpO1xuICAgICAgICBwYXRoLl90cmFuc2Zvcm1Eb25lID0gdHJ1ZTtcbiAgICAgICAgcGF0aC5yZW5kZXJDYWNoZSh7IGZvckNsaXBwaW5nOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLmRyYXdDbGlwUGF0aE9uQ2FudmFzKGN0eCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZW5kZXJPdmVybGF5KGN0eCk7XG4gICAgICBpZiAodGhpcy5jb250cm9sc0Fib3ZlT3ZlcmxheSAmJiB0aGlzLmludGVyYWN0aXZlKSB7XG4gICAgICAgIHRoaXMuZHJhd0NvbnRyb2xzKGN0eCk7XG4gICAgICB9XG4gICAgICB0aGlzLmZpcmUoJ2FmdGVyOnJlbmRlcicsIHsgY3R4OiBjdHgsIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYWludCB0aGUgY2FjaGVkIGNsaXBQYXRoIG9uIHRoZSBsb3dlckNhbnZhc0VsXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIGRyYXdDbGlwUGF0aE9uQ2FudmFzOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciB2ID0gdGhpcy52aWV3cG9ydFRyYW5zZm9ybSwgcGF0aCA9IHRoaXMuY2xpcFBhdGg7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zZm9ybSh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKTtcbiAgICAgIC8vIERFQlVHOiB1bmNvbW1lbnQgdGhpcyBsaW5lLCBjb21tZW50IHRoZSBmb2xsb3dpbmdcbiAgICAgIC8vIGN0eC5nbG9iYWxBbHBoYSA9IDAuNDtcbiAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24taW4nO1xuICAgICAgcGF0aC50cmFuc2Zvcm0oY3R4KTtcbiAgICAgIGN0eC5zY2FsZSgxIC8gcGF0aC56b29tWCwgMSAvIHBhdGguem9vbVkpO1xuICAgICAgY3R4LmRyYXdJbWFnZShwYXRoLl9jYWNoZUNhbnZhcywgLXBhdGguY2FjaGVUcmFuc2xhdGlvblgsIC1wYXRoLmNhY2hlVHJhbnNsYXRpb25ZKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9iamVjdHMgdG8gcmVuZGVyXG4gICAgICovXG4gICAgX3JlbmRlck9iamVjdHM6IGZ1bmN0aW9uKGN0eCwgb2JqZWN0cykge1xuICAgICAgdmFyIGksIGxlbjtcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgb2JqZWN0c1tpXSAmJiBvYmplY3RzW2ldLnJlbmRlcihjdHgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgJ2JhY2tncm91bmQnIG9yICdvdmVybGF5J1xuICAgICAqL1xuICAgIF9yZW5kZXJCYWNrZ3JvdW5kT3JPdmVybGF5OiBmdW5jdGlvbihjdHgsIHByb3BlcnR5KSB7XG4gICAgICB2YXIgZmlsbCA9IHRoaXNbcHJvcGVydHkgKyAnQ29sb3InXSwgb2JqZWN0ID0gdGhpc1twcm9wZXJ0eSArICdJbWFnZSddLFxuICAgICAgICAgIHYgPSB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtLCBuZWVkc1ZwdCA9IHRoaXNbcHJvcGVydHkgKyAnVnB0J107XG4gICAgICBpZiAoIWZpbGwgJiYgIW9iamVjdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZmlsbCkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oMCwgMCk7XG4gICAgICAgIGN0eC5saW5lVG8odGhpcy53aWR0aCwgMCk7XG4gICAgICAgIGN0eC5saW5lVG8odGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICBjdHgubGluZVRvKDAsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbC50b0xpdmVcbiAgICAgICAgICA/IGZpbGwudG9MaXZlKGN0eCwgdGhpcylcbiAgICAgICAgICA6IGZpbGw7XG4gICAgICAgIGlmIChuZWVkc1ZwdCkge1xuICAgICAgICAgIGN0eC50cmFuc2Zvcm0odlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnRyYW5zZm9ybSgxLCAwLCAwLCAxLCBmaWxsLm9mZnNldFggfHwgMCwgZmlsbC5vZmZzZXRZIHx8IDApO1xuICAgICAgICB2YXIgbSA9IGZpbGwuZ3JhZGllbnRUcmFuc2Zvcm0gfHwgZmlsbC5wYXR0ZXJuVHJhbnNmb3JtO1xuICAgICAgICBtICYmIGN0eC50cmFuc2Zvcm0obVswXSwgbVsxXSwgbVsyXSwgbVszXSwgbVs0XSwgbVs1XSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIHZhciBza2lwT2Zmc2NyZWVuID0gdGhpcy5za2lwT2Zmc2NyZWVuO1xuICAgICAgICAvLyBpZiB0aGUgb2JqZWN0IGRvZXNuJ3QgbW92ZSB3aXRoIHRoZSB2aWV3cG9ydCxcbiAgICAgICAgLy8gdGhlIG9mZnNjcmVlbiBjb25jZXB0IGRvZXMgbm90IGFwcGx5O1xuICAgICAgICB0aGlzLnNraXBPZmZzY3JlZW4gPSBuZWVkc1ZwdDtcbiAgICAgICAgaWYgKG5lZWRzVnB0KSB7XG4gICAgICAgICAgY3R4LnRyYW5zZm9ybSh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QucmVuZGVyKGN0eCk7XG4gICAgICAgIHRoaXMuc2tpcE9mZnNjcmVlbiA9IHNraXBPZmZzY3JlZW47XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJCYWNrZ3JvdW5kOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuX3JlbmRlckJhY2tncm91bmRPck92ZXJsYXkoY3R4LCAnYmFja2dyb3VuZCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyT3ZlcmxheTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLl9yZW5kZXJCYWNrZ3JvdW5kT3JPdmVybGF5KGN0eCwgJ292ZXJsYXknKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb29yZGluYXRlcyBvZiBhIGNlbnRlciBvZiBjYW52YXMuXG4gICAgICogUmV0dXJuZWQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggdG9wIGFuZCBsZWZ0IHByb3BlcnRpZXNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCB3aXRoIFwidG9wXCIgYW5kIFwibGVmdFwiIG51bWJlciB2YWx1ZXNcbiAgICAgKiBAZGVwcmVjYXRlZCBtaWdyYXRlIHRvIGBnZXRDZW50ZXJQb2ludGBcbiAgICAgKi9cbiAgICBnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogdGhpcy5oZWlnaHQgLyAyLFxuICAgICAgICBsZWZ0OiB0aGlzLndpZHRoIC8gMlxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb29yZGluYXRlcyBvZiBhIGNlbnRlciBvZiBjYW52YXMuXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSBcbiAgICAgKi9cbiAgICBnZXRDZW50ZXJQb2ludDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuUG9pbnQodGhpcy53aWR0aCAvIDIsIHRoaXMuaGVpZ2h0IC8gMik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IGhvcml6b250YWxseSBpbiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlciBob3Jpem9udGFsbHlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICovXG4gICAgY2VudGVyT2JqZWN0SDogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlck9iamVjdChvYmplY3QsIG5ldyBmYWJyaWMuUG9pbnQodGhpcy5nZXRDZW50ZXJQb2ludCgpLngsIG9iamVjdC5nZXRDZW50ZXJQb2ludCgpLnkpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgdmVydGljYWxseSBpbiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlciB2ZXJ0aWNhbGx5XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjZW50ZXJPYmplY3RWOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2VudGVyT2JqZWN0KG9iamVjdCwgbmV3IGZhYnJpYy5Qb2ludChvYmplY3QuZ2V0Q2VudGVyUG9pbnQoKS54LCB0aGlzLmdldENlbnRlclBvaW50KCkueSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHkgaW4gdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXIgdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5XG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjZW50ZXJPYmplY3Q6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICAgIHJldHVybiB0aGlzLl9jZW50ZXJPYmplY3Qob2JqZWN0LCBjZW50ZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHkgaW4gdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlciB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHZpZXdwb3J0Q2VudGVyT2JqZWN0OiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciB2cENlbnRlciA9IHRoaXMuZ2V0VnBDZW50ZXIoKTtcbiAgICAgIHJldHVybiB0aGlzLl9jZW50ZXJPYmplY3Qob2JqZWN0LCB2cENlbnRlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IGhvcml6b250YWxseSBpbiB0aGUgdmlld3BvcnQsIG9iamVjdC50b3AgaXMgdW5jaGFuZ2VkXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlciB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHlcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHZpZXdwb3J0Q2VudGVyT2JqZWN0SDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgdnBDZW50ZXIgPSB0aGlzLmdldFZwQ2VudGVyKCk7XG4gICAgICB0aGlzLl9jZW50ZXJPYmplY3Qob2JqZWN0LCBuZXcgZmFicmljLlBvaW50KHZwQ2VudGVyLngsIG9iamVjdC5nZXRDZW50ZXJQb2ludCgpLnkpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCBWZXJ0aWNhbGx5IGluIHRoZSB2aWV3cG9ydCwgb2JqZWN0LnRvcCBpcyB1bmNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY2VudGVyIHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgdmlld3BvcnRDZW50ZXJPYmplY3RWOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciB2cENlbnRlciA9IHRoaXMuZ2V0VnBDZW50ZXIoKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX2NlbnRlck9iamVjdChvYmplY3QsIG5ldyBmYWJyaWMuUG9pbnQob2JqZWN0LmdldENlbnRlclBvaW50KCkueCwgdnBDZW50ZXIueSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHBvaW50IGluIGNhbnZhcyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlIGNlbnRlciBvZiBhY3R1YWwgdmlld3BvcnQuXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fSB2cENlbnRlciwgdmlld3BvcnQgY2VudGVyXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGdldFZwQ2VudGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlclBvaW50KCksXG4gICAgICAgICAgaVZwdCA9IGludmVydFRyYW5zZm9ybSh0aGlzLnZpZXdwb3J0VHJhbnNmb3JtKTtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1Qb2ludChjZW50ZXIsIGlWcHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXJcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gY2VudGVyIENlbnRlciBwb2ludFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgX2NlbnRlck9iamVjdDogZnVuY3Rpb24ob2JqZWN0LCBjZW50ZXIpIHtcbiAgICAgIG9iamVjdC5zZXRQb3NpdGlvbkJ5T3JpZ2luKGNlbnRlciwgJ2NlbnRlcicsICdjZW50ZXInKTtcbiAgICAgIG9iamVjdC5zZXRDb29yZHMoKTtcbiAgICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgJiYgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBkYXRhbGVzcyBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGpzb24gc3RyaW5nXG4gICAgICovXG4gICAgdG9EYXRhbGVzc0pTT046IGZ1bmN0aW9uIChwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0RhdGFsZXNzT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24gKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl90b09iamVjdE1ldGhvZCgndG9PYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBkYXRhbGVzcyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgY2FudmFzXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9EYXRhbGVzc09iamVjdDogZnVuY3Rpb24gKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl90b09iamVjdE1ldGhvZCgndG9EYXRhbGVzc09iamVjdCcsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF90b09iamVjdE1ldGhvZDogZnVuY3Rpb24gKG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcblxuICAgICAgdmFyIGNsaXBQYXRoID0gdGhpcy5jbGlwUGF0aCwgZGF0YSA9IHtcbiAgICAgICAgdmVyc2lvbjogZmFicmljLnZlcnNpb24sXG4gICAgICAgIG9iamVjdHM6IHRoaXMuX3RvT2JqZWN0cyhtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSxcbiAgICAgIH07XG4gICAgICBpZiAoY2xpcFBhdGggJiYgIWNsaXBQYXRoLmV4Y2x1ZGVGcm9tRXhwb3J0KSB7XG4gICAgICAgIGRhdGEuY2xpcFBhdGggPSB0aGlzLl90b09iamVjdCh0aGlzLmNsaXBQYXRoLCBtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIH1cbiAgICAgIGV4dGVuZChkYXRhLCB0aGlzLl9fc2VyaWFsaXplQmdPdmVybGF5KG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpKTtcblxuICAgICAgZmFicmljLnV0aWwucG9wdWxhdGVXaXRoUHJvcGVydGllcyh0aGlzLCBkYXRhLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RvT2JqZWN0czogZnVuY3Rpb24obWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX29iamVjdHMuZmlsdGVyKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gIW9iamVjdC5leGNsdWRlRnJvbUV4cG9ydDtcbiAgICAgIH0pLm1hcChmdW5jdGlvbihpbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9PYmplY3QoaW5zdGFuY2UsIG1ldGhvZE5hbWUsIHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RvT2JqZWN0OiBmdW5jdGlvbihpbnN0YW5jZSwgbWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG9yaWdpbmFsVmFsdWU7XG5cbiAgICAgIGlmICghdGhpcy5pbmNsdWRlRGVmYXVsdFZhbHVlcykge1xuICAgICAgICBvcmlnaW5hbFZhbHVlID0gaW5zdGFuY2UuaW5jbHVkZURlZmF1bHRWYWx1ZXM7XG4gICAgICAgIGluc3RhbmNlLmluY2x1ZGVEZWZhdWx0VmFsdWVzID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBvYmplY3QgPSBpbnN0YW5jZVttZXRob2ROYW1lXShwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIGlmICghdGhpcy5pbmNsdWRlRGVmYXVsdFZhbHVlcykge1xuICAgICAgICBpbnN0YW5jZS5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IG9yaWdpbmFsVmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9fc2VyaWFsaXplQmdPdmVybGF5OiBmdW5jdGlvbihtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgZGF0YSA9IHt9LCBiZ0ltYWdlID0gdGhpcy5iYWNrZ3JvdW5kSW1hZ2UsIG92ZXJsYXlJbWFnZSA9IHRoaXMub3ZlcmxheUltYWdlLFxuICAgICAgICAgIGJnQ29sb3IgPSB0aGlzLmJhY2tncm91bmRDb2xvciwgb3ZlcmxheUNvbG9yID0gdGhpcy5vdmVybGF5Q29sb3I7XG5cbiAgICAgIGlmIChiZ0NvbG9yICYmIGJnQ29sb3IudG9PYmplY3QpIHtcbiAgICAgICAgaWYgKCFiZ0NvbG9yLmV4Y2x1ZGVGcm9tRXhwb3J0KSB7XG4gICAgICAgICAgZGF0YS5iYWNrZ3JvdW5kID0gYmdDb2xvci50b09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYmdDb2xvcikge1xuICAgICAgICBkYXRhLmJhY2tncm91bmQgPSBiZ0NvbG9yO1xuICAgICAgfVxuXG4gICAgICBpZiAob3ZlcmxheUNvbG9yICYmIG92ZXJsYXlDb2xvci50b09iamVjdCkge1xuICAgICAgICBpZiAoIW92ZXJsYXlDb2xvci5leGNsdWRlRnJvbUV4cG9ydCkge1xuICAgICAgICAgIGRhdGEub3ZlcmxheSA9IG92ZXJsYXlDb2xvci50b09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3ZlcmxheUNvbG9yKSB7XG4gICAgICAgIGRhdGEub3ZlcmxheSA9IG92ZXJsYXlDb2xvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGJnSW1hZ2UgJiYgIWJnSW1hZ2UuZXhjbHVkZUZyb21FeHBvcnQpIHtcbiAgICAgICAgZGF0YS5iYWNrZ3JvdW5kSW1hZ2UgPSB0aGlzLl90b09iamVjdChiZ0ltYWdlLCBtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvdmVybGF5SW1hZ2UgJiYgIW92ZXJsYXlJbWFnZS5leGNsdWRlRnJvbUV4cG9ydCkge1xuICAgICAgICBkYXRhLm92ZXJsYXlJbWFnZSA9IHRoaXMuX3RvT2JqZWN0KG92ZXJsYXlJbWFnZSwgbWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgZ2V0U3ZnVHJhbnNmb3JtKCkgd2lsbCBhcHBseSB0aGUgU3RhdGljQ2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtIHRvIHRoZSBTVkcgdHJhbnNmb3JtYXRpb24uIFdoZW4gdHJ1ZSxcbiAgICAgKiBhIHpvb21lZCBjYW52YXMgd2lsbCB0aGVuIHByb2R1Y2Ugem9vbWVkIFNWRyBvdXRwdXQuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3ZnVmlld3BvcnRUcmFuc2Zvcm1hdGlvbjogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgU1ZHIHJlcHJlc2VudGF0aW9uIG9mIGNhbnZhc1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3QgZm9yIFNWRyBvdXRwdXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN1cHByZXNzUHJlYW1ibGU9ZmFsc2VdIElmIHRydWUgeG1sIHRhZyBpcyBub3QgaW5jbHVkZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMudmlld0JveF0gU1ZHIHZpZXdib3ggb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnZpZXdCb3gueF0geC1jb29yZGluYXRlIG9mIHZpZXdib3hcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudmlld0JveC55XSB5LWNvb3JkaW5hdGUgb2Ygdmlld2JveFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy52aWV3Qm94LndpZHRoXSBXaWR0aCBvZiB2aWV3Ym94XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnZpZXdCb3guaGVpZ2h0XSBIZWlnaHQgb2Ygdmlld2JveFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz1VVEYtOF0gRW5jb2Rpbmcgb2YgU1ZHIG91dHB1dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy53aWR0aF0gZGVzaXJlZCB3aWR0aCBvZiBzdmcgd2l0aCBvciB3aXRob3V0IHVuaXRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmhlaWdodF0gZGVzaXJlZCBoZWlnaHQgb2Ygc3ZnIHdpdGggb3Igd2l0aG91dCB1bml0c1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgZWxlbWVudHMsIGNhbGxlZCBhZnRlciBlYWNoIGZhYnJpYyBvYmplY3QgY29udmVydGVkIGludG8gc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gU1ZHIHN0cmluZ1xuICAgICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0zI3NlcmlhbGl6YXRpb259XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9qUTNaWi98anNGaWRkbGUgZGVtb31cbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Ob3JtYWwgU1ZHIG91dHB1dDwvY2FwdGlvbj5cbiAgICAgKiB2YXIgc3ZnID0gY2FudmFzLnRvU1ZHKCk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+U1ZHIG91dHB1dCB3aXRob3V0IHByZWFtYmxlICh3aXRob3V0ICZsdDs/eG1sIC4uLz4pPC9jYXB0aW9uPlxuICAgICAqIHZhciBzdmcgPSBjYW52YXMudG9TVkcoe3N1cHByZXNzUHJlYW1ibGU6IHRydWV9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TVkcgb3V0cHV0IHdpdGggdmlld0JveCBhdHRyaWJ1dGU8L2NhcHRpb24+XG4gICAgICogdmFyIHN2ZyA9IGNhbnZhcy50b1NWRyh7XG4gICAgICogICB2aWV3Qm94OiB7XG4gICAgICogICAgIHg6IDEwMCxcbiAgICAgKiAgICAgeTogMTAwLFxuICAgICAqICAgICB3aWR0aDogMjAwLFxuICAgICAqICAgICBoZWlnaHQ6IDMwMFxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlNWRyBvdXRwdXQgd2l0aCBkaWZmZXJlbnQgZW5jb2RpbmcgKGRlZmF1bHQ6IFVURi04KTwvY2FwdGlvbj5cbiAgICAgKiB2YXIgc3ZnID0gY2FudmFzLnRvU1ZHKHtlbmNvZGluZzogJ0lTTy04ODU5LTEnfSk7XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+TW9kaWZ5IFNWRyBvdXRwdXQgd2l0aCByZXZpdmVyIGZ1bmN0aW9uPC9jYXB0aW9uPlxuICAgICAqIHZhciBzdmcgPSBjYW52YXMudG9TVkcobnVsbCwgZnVuY3Rpb24oc3ZnKSB7XG4gICAgICogICByZXR1cm4gc3ZnLnJlcGxhY2UoJ3N0cm9rZS1kYXNoYXJyYXk6IDsgc3Ryb2tlLWxpbmVjYXA6IGJ1dHQ7IHN0cm9rZS1saW5lam9pbjogbWl0ZXI7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDsgJywgJycpO1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHRvU1ZHOiBmdW5jdGlvbihvcHRpb25zLCByZXZpdmVyKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcbiAgICAgIG9wdGlvbnMucmV2aXZlciA9IHJldml2ZXI7XG4gICAgICB2YXIgbWFya3VwID0gW107XG5cbiAgICAgIHRoaXMuX3NldFNWR1ByZWFtYmxlKG1hcmt1cCwgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9zZXRTVkdIZWFkZXIobWFya3VwLCBvcHRpb25zKTtcbiAgICAgIGlmICh0aGlzLmNsaXBQYXRoKSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKCc8ZyBjbGlwLXBhdGg9XCJ1cmwoIycgKyB0aGlzLmNsaXBQYXRoLmNsaXBQYXRoSWQgKyAnKVwiID5cXG4nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldFNWR0JnT3ZlcmxheUNvbG9yKG1hcmt1cCwgJ2JhY2tncm91bmQnKTtcbiAgICAgIHRoaXMuX3NldFNWR0JnT3ZlcmxheUltYWdlKG1hcmt1cCwgJ2JhY2tncm91bmRJbWFnZScsIHJldml2ZXIpO1xuICAgICAgdGhpcy5fc2V0U1ZHT2JqZWN0cyhtYXJrdXAsIHJldml2ZXIpO1xuICAgICAgaWYgKHRoaXMuY2xpcFBhdGgpIHtcbiAgICAgICAgbWFya3VwLnB1c2goJzwvZz5cXG4nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldFNWR0JnT3ZlcmxheUNvbG9yKG1hcmt1cCwgJ292ZXJsYXknKTtcbiAgICAgIHRoaXMuX3NldFNWR0JnT3ZlcmxheUltYWdlKG1hcmt1cCwgJ292ZXJsYXlJbWFnZScsIHJldml2ZXIpO1xuXG4gICAgICBtYXJrdXAucHVzaCgnPC9zdmc+Jyk7XG5cbiAgICAgIHJldHVybiBtYXJrdXAuam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR1ByZWFtYmxlOiBmdW5jdGlvbihtYXJrdXAsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLnN1cHByZXNzUHJlYW1ibGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbWFya3VwLnB1c2goXG4gICAgICAgICc8P3htbCB2ZXJzaW9uPVwiMS4wXCIgZW5jb2Rpbmc9XCInLCAob3B0aW9ucy5lbmNvZGluZyB8fCAnVVRGLTgnKSwgJ1wiIHN0YW5kYWxvbmU9XCJub1wiID8+XFxuJyxcbiAgICAgICAgJzwhRE9DVFlQRSBzdmcgUFVCTElDIFwiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU5cIiAnLFxuICAgICAgICAnXCJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGRcIj5cXG4nXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTVkdIZWFkZXI6IGZ1bmN0aW9uKG1hcmt1cCwgb3B0aW9ucykge1xuICAgICAgdmFyIHdpZHRoID0gb3B0aW9ucy53aWR0aCB8fCB0aGlzLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0IHx8IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgIHZwdCwgdmlld0JveCA9ICd2aWV3Qm94PVwiMCAwICcgKyB0aGlzLndpZHRoICsgJyAnICsgdGhpcy5oZWlnaHQgKyAnXCIgJyxcbiAgICAgICAgICBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTO1xuXG4gICAgICBpZiAob3B0aW9ucy52aWV3Qm94KSB7XG4gICAgICAgIHZpZXdCb3ggPSAndmlld0JveD1cIicgK1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudmlld0JveC54ICsgJyAnICtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnZpZXdCb3gueSArICcgJyArXG4gICAgICAgICAgICAgICAgb3B0aW9ucy52aWV3Qm94LndpZHRoICsgJyAnICtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnZpZXdCb3guaGVpZ2h0ICsgJ1wiICc7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuc3ZnVmlld3BvcnRUcmFuc2Zvcm1hdGlvbikge1xuICAgICAgICAgIHZwdCA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm07XG4gICAgICAgICAgdmlld0JveCA9ICd2aWV3Qm94PVwiJyArXG4gICAgICAgICAgICAgICAgICB0b0ZpeGVkKC12cHRbNF0gLyB2cHRbMF0sIE5VTV9GUkFDVElPTl9ESUdJVFMpICsgJyAnICtcbiAgICAgICAgICAgICAgICAgIHRvRml4ZWQoLXZwdFs1XSAvIHZwdFszXSwgTlVNX0ZSQUNUSU9OX0RJR0lUUykgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLndpZHRoIC8gdnB0WzBdLCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICcgJyArXG4gICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuaGVpZ2h0IC8gdnB0WzNdLCBOVU1fRlJBQ1RJT05fRElHSVRTKSArICdcIiAnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAnPHN2ZyAnLFxuICAgICAgICAneG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiICcsXG4gICAgICAgICd4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiAnLFxuICAgICAgICAndmVyc2lvbj1cIjEuMVwiICcsXG4gICAgICAgICd3aWR0aD1cIicsIHdpZHRoLCAnXCIgJyxcbiAgICAgICAgJ2hlaWdodD1cIicsIGhlaWdodCwgJ1wiICcsXG4gICAgICAgIHZpZXdCb3gsXG4gICAgICAgICd4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiPlxcbicsXG4gICAgICAgICc8ZGVzYz5DcmVhdGVkIHdpdGggRmFicmljLmpzICcsIGZhYnJpYy52ZXJzaW9uLCAnPC9kZXNjPlxcbicsXG4gICAgICAgICc8ZGVmcz5cXG4nLFxuICAgICAgICB0aGlzLmNyZWF0ZVNWR0ZvbnRGYWNlc01hcmt1cCgpLFxuICAgICAgICB0aGlzLmNyZWF0ZVNWR1JlZkVsZW1lbnRzTWFya3VwKCksXG4gICAgICAgIHRoaXMuY3JlYXRlU1ZHQ2xpcFBhdGhNYXJrdXAob3B0aW9ucyksXG4gICAgICAgICc8L2RlZnM+XFxuJ1xuICAgICAgKTtcbiAgICB9LFxuXG4gICAgY3JlYXRlU1ZHQ2xpcFBhdGhNYXJrdXA6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjbGlwUGF0aCA9IHRoaXMuY2xpcFBhdGg7XG4gICAgICBpZiAoY2xpcFBhdGgpIHtcbiAgICAgICAgY2xpcFBhdGguY2xpcFBhdGhJZCA9ICdDTElQUEFUSF8nICsgZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgICAgICByZXR1cm4gICc8Y2xpcFBhdGggaWQ9XCInICsgY2xpcFBhdGguY2xpcFBhdGhJZCArICdcIiA+XFxuJyArXG4gICAgICAgICAgdGhpcy5jbGlwUGF0aC50b0NsaXBQYXRoU1ZHKG9wdGlvbnMucmV2aXZlcikgK1xuICAgICAgICAgICc8L2NsaXBQYXRoPlxcbic7XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbWFya3VwIGNvbnRhaW5pbmcgU1ZHIHJlZmVyZW5jZWQgZWxlbWVudHMgbGlrZSBwYXR0ZXJucywgZ3JhZGllbnRzIGV0Yy5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgY3JlYXRlU1ZHUmVmRWxlbWVudHNNYXJrdXA6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgICBtYXJrdXAgPSBbJ2JhY2tncm91bmQnLCAnb3ZlcmxheSddLm1hcChmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgICAgICB2YXIgZmlsbCA9IF90aGlzW3Byb3AgKyAnQ29sb3InXTtcbiAgICAgICAgICAgIGlmIChmaWxsICYmIGZpbGwudG9MaXZlKSB7XG4gICAgICAgICAgICAgIHZhciBzaG91bGRUcmFuc2Zvcm0gPSBfdGhpc1twcm9wICsgJ1ZwdCddLCB2cHQgPSBfdGhpcy52aWV3cG9ydFRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICAgIG9iamVjdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IF90aGlzLndpZHRoIC8gKHNob3VsZFRyYW5zZm9ybSA/IHZwdFswXSA6IDEpLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IF90aGlzLmhlaWdodCAvIChzaG91bGRUcmFuc2Zvcm0gPyB2cHRbM10gOiAxKVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbGwudG9TVkcoXG4gICAgICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgICAgIHsgYWRkaXRpb25hbFRyYW5zZm9ybTogc2hvdWxkVHJhbnNmb3JtID8gZmFicmljLnV0aWwubWF0cml4VG9TVkcodnB0KSA6ICcnIH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIHJldHVybiBtYXJrdXAuam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbWFya3VwIGNvbnRhaW5pbmcgU1ZHIGZvbnQgZmFjZXMsXG4gICAgICogZm9udCBVUkxzIGZvciBmb250IGZhY2VzIG11c3QgYmUgY29sbGVjdGVkIGJ5IGRldmVsb3BlcnNcbiAgICAgKiBhbmQgYXJlIG5vdCBleHRyYWN0ZWQgZnJvbSB0aGUgRE9NIGJ5IGZhYnJpY2pzXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqZWN0cyBBcnJheSBvZiBmYWJyaWMgb2JqZWN0c1xuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBjcmVhdGVTVkdGb250RmFjZXNNYXJrdXA6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG1hcmt1cCA9ICcnLCBmb250TGlzdCA9IHsgfSwgb2JqLCBmb250RmFtaWx5LFxuICAgICAgICAgIHN0eWxlLCByb3csIHJvd0luZGV4LCBfY2hhciwgY2hhckluZGV4LCBpLCBsZW4sXG4gICAgICAgICAgZm9udFBhdGhzID0gZmFicmljLmZvbnRQYXRocywgb2JqZWN0cyA9IFtdO1xuXG4gICAgICB0aGlzLl9vYmplY3RzLmZvckVhY2goZnVuY3Rpb24gYWRkKG9iamVjdCkge1xuICAgICAgICBvYmplY3RzLnB1c2gob2JqZWN0KTtcbiAgICAgICAgaWYgKG9iamVjdC5fb2JqZWN0cykge1xuICAgICAgICAgIG9iamVjdC5fb2JqZWN0cy5mb3JFYWNoKGFkZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBvYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG9iaiA9IG9iamVjdHNbaV07XG4gICAgICAgIGZvbnRGYW1pbHkgPSBvYmouZm9udEZhbWlseTtcbiAgICAgICAgaWYgKG9iai50eXBlLmluZGV4T2YoJ3RleHQnKSA9PT0gLTEgfHwgZm9udExpc3RbZm9udEZhbWlseV0gfHwgIWZvbnRQYXRoc1tmb250RmFtaWx5XSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvbnRMaXN0W2ZvbnRGYW1pbHldID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFvYmouc3R5bGVzKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGUgPSBvYmouc3R5bGVzO1xuICAgICAgICBmb3IgKHJvd0luZGV4IGluIHN0eWxlKSB7XG4gICAgICAgICAgcm93ID0gc3R5bGVbcm93SW5kZXhdO1xuICAgICAgICAgIGZvciAoY2hhckluZGV4IGluIHJvdykge1xuICAgICAgICAgICAgX2NoYXIgPSByb3dbY2hhckluZGV4XTtcbiAgICAgICAgICAgIGZvbnRGYW1pbHkgPSBfY2hhci5mb250RmFtaWx5O1xuICAgICAgICAgICAgaWYgKCFmb250TGlzdFtmb250RmFtaWx5XSAmJiBmb250UGF0aHNbZm9udEZhbWlseV0pIHtcbiAgICAgICAgICAgICAgZm9udExpc3RbZm9udEZhbWlseV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqIGluIGZvbnRMaXN0KSB7XG4gICAgICAgIG1hcmt1cCArPSBbXG4gICAgICAgICAgJ1xcdFxcdEBmb250LWZhY2Uge1xcbicsXG4gICAgICAgICAgJ1xcdFxcdFxcdGZvbnQtZmFtaWx5OiBcXCcnLCBqLCAnXFwnO1xcbicsXG4gICAgICAgICAgJ1xcdFxcdFxcdHNyYzogdXJsKFxcJycsIGZvbnRQYXRoc1tqXSwgJ1xcJyk7XFxuJyxcbiAgICAgICAgICAnXFx0XFx0fVxcbidcbiAgICAgICAgXS5qb2luKCcnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hcmt1cCkge1xuICAgICAgICBtYXJrdXAgPSBbXG4gICAgICAgICAgJ1xcdDxzdHlsZSB0eXBlPVwidGV4dC9jc3NcIj4nLFxuICAgICAgICAgICc8IVtDREFUQVtcXG4nLFxuICAgICAgICAgIG1hcmt1cCxcbiAgICAgICAgICAnXV0+JyxcbiAgICAgICAgICAnPC9zdHlsZT5cXG4nXG4gICAgICAgIF0uam9pbignJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXJrdXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR09iamVjdHM6IGZ1bmN0aW9uKG1hcmt1cCwgcmV2aXZlcikge1xuICAgICAgdmFyIGluc3RhbmNlLCBpLCBsZW4sIG9iamVjdHMgPSB0aGlzLl9vYmplY3RzO1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpbnN0YW5jZSA9IG9iamVjdHNbaV07XG4gICAgICAgIGlmIChpbnN0YW5jZS5leGNsdWRlRnJvbUV4cG9ydCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldFNWR09iamVjdChtYXJrdXAsIGluc3RhbmNlLCByZXZpdmVyKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U1ZHT2JqZWN0OiBmdW5jdGlvbihtYXJrdXAsIGluc3RhbmNlLCByZXZpdmVyKSB7XG4gICAgICBtYXJrdXAucHVzaChpbnN0YW5jZS50b1NWRyhyZXZpdmVyKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR0JnT3ZlcmxheUltYWdlOiBmdW5jdGlvbihtYXJrdXAsIHByb3BlcnR5LCByZXZpdmVyKSB7XG4gICAgICBpZiAodGhpc1twcm9wZXJ0eV0gJiYgIXRoaXNbcHJvcGVydHldLmV4Y2x1ZGVGcm9tRXhwb3J0ICYmIHRoaXNbcHJvcGVydHldLnRvU1ZHKSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKHRoaXNbcHJvcGVydHldLnRvU1ZHKHJldml2ZXIpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U1ZHQmdPdmVybGF5Q29sb3I6IGZ1bmN0aW9uKG1hcmt1cCwgcHJvcGVydHkpIHtcbiAgICAgIHZhciBmaWxsZXIgPSB0aGlzW3Byb3BlcnR5ICsgJ0NvbG9yJ10sIHZwdCA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm0sIGZpbmFsV2lkdGggPSB0aGlzLndpZHRoLFxuICAgICAgICAgIGZpbmFsSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICBpZiAoIWZpbGxlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZmlsbGVyLnRvTGl2ZSkge1xuICAgICAgICB2YXIgcmVwZWF0ID0gZmlsbGVyLnJlcGVhdCwgaVZwdCA9IGZhYnJpYy51dGlsLmludmVydFRyYW5zZm9ybSh2cHQpLCBzaG91bGRJbnZlcnQgPSB0aGlzW3Byb3BlcnR5ICsgJ1ZwdCddLFxuICAgICAgICAgICAgYWRkaXRpb25hbFRyYW5zZm9ybSA9IHNob3VsZEludmVydCA/IGZhYnJpYy51dGlsLm1hdHJpeFRvU1ZHKGlWcHQpIDogJyc7XG4gICAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAgICc8cmVjdCB0cmFuc2Zvcm09XCInICsgYWRkaXRpb25hbFRyYW5zZm9ybSArICcgdHJhbnNsYXRlKCcsIGZpbmFsV2lkdGggLyAyLCAnLCcsIGZpbmFsSGVpZ2h0IC8gMiwgJylcIicsXG4gICAgICAgICAgJyB4PVwiJywgZmlsbGVyLm9mZnNldFggLSBmaW5hbFdpZHRoIC8gMixcbiAgICAgICAgICAnXCIgeT1cIicsIGZpbGxlci5vZmZzZXRZIC0gZmluYWxIZWlnaHQgLyAyLCAnXCIgJyxcbiAgICAgICAgICAnd2lkdGg9XCInLFxuICAgICAgICAgIChyZXBlYXQgPT09ICdyZXBlYXQteScgfHwgcmVwZWF0ID09PSAnbm8tcmVwZWF0J1xuICAgICAgICAgICAgPyBmaWxsZXIuc291cmNlLndpZHRoXG4gICAgICAgICAgICA6IGZpbmFsV2lkdGggKSxcbiAgICAgICAgICAnXCIgaGVpZ2h0PVwiJyxcbiAgICAgICAgICAocmVwZWF0ID09PSAncmVwZWF0LXgnIHx8IHJlcGVhdCA9PT0gJ25vLXJlcGVhdCdcbiAgICAgICAgICAgID8gZmlsbGVyLnNvdXJjZS5oZWlnaHRcbiAgICAgICAgICAgIDogZmluYWxIZWlnaHQpLFxuICAgICAgICAgICdcIiBmaWxsPVwidXJsKCNTVkdJRF8nICsgZmlsbGVyLmlkICsgJylcIicsXG4gICAgICAgICAgJz48L3JlY3Q+XFxuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAgICc8cmVjdCB4PVwiMFwiIHk9XCIwXCIgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiICcsXG4gICAgICAgICAgJ2ZpbGw9XCInLCBmaWxsZXIsICdcIicsXG4gICAgICAgICAgJz48L3JlY3Q+XFxuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBvYmplY3Qgb3IgdGhlIG9iamVjdHMgb2YgYSBtdWx0aXBsZSBzZWxlY3Rpb25cbiAgICAgKiB0byB0aGUgYm90dG9tIG9mIHRoZSBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHNlbmQgdG8gYmFja1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2VuZFRvQmFjazogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgYWN0aXZlU2VsZWN0aW9uID0gdGhpcy5fYWN0aXZlT2JqZWN0LFxuICAgICAgICAgIGksIG9iaiwgb2JqcztcbiAgICAgIGlmIChvYmplY3QgPT09IGFjdGl2ZVNlbGVjdGlvbiAmJiBvYmplY3QudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicpIHtcbiAgICAgICAgb2JqcyA9IGFjdGl2ZVNlbGVjdGlvbi5fb2JqZWN0cztcbiAgICAgICAgZm9yIChpID0gb2Jqcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICBvYmogPSBvYmpzW2ldO1xuICAgICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmopO1xuICAgICAgICAgIHRoaXMuX29iamVjdHMudW5zaGlmdChvYmopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuX29iamVjdHMsIG9iamVjdCk7XG4gICAgICAgIHRoaXMuX29iamVjdHMudW5zaGlmdChvYmplY3QpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBvYmplY3Qgb3IgdGhlIG9iamVjdHMgb2YgYSBtdWx0aXBsZSBzZWxlY3Rpb25cbiAgICAgKiB0byB0aGUgdG9wIG9mIHRoZSBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHNlbmRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgYWN0aXZlU2VsZWN0aW9uID0gdGhpcy5fYWN0aXZlT2JqZWN0LFxuICAgICAgICAgIGksIG9iaiwgb2JqcztcbiAgICAgIGlmIChvYmplY3QgPT09IGFjdGl2ZVNlbGVjdGlvbiAmJiBvYmplY3QudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicpIHtcbiAgICAgICAgb2JqcyA9IGFjdGl2ZVNlbGVjdGlvbi5fb2JqZWN0cztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9ianMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBvYmogPSBvYmpzW2ldO1xuICAgICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmopO1xuICAgICAgICAgIHRoaXMuX29iamVjdHMucHVzaChvYmopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuX29iamVjdHMsIG9iamVjdCk7XG4gICAgICAgIHRoaXMuX29iamVjdHMucHVzaChvYmplY3QpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBvYmplY3Qgb3IgYSBzZWxlY3Rpb24gZG93biBpbiBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAgICogQW4gb3B0aW9uYWwgcGFyYW1ldGVyLCBpbnRlcnNlY3RpbmcgYWxsb3dzIHRvIG1vdmUgdGhlIG9iamVjdCBpbiBiZWhpbmRcbiAgICAgKiB0aGUgZmlyc3QgaW50ZXJzZWN0aW5nIG9iamVjdC4gV2hlcmUgaW50ZXJzZWN0aW9uIGlzIGNhbGN1bGF0ZWQgd2l0aFxuICAgICAqIGJvdW5kaW5nIGJveC4gSWYgbm8gaW50ZXJzZWN0aW9uIGlzIGZvdW5kLCB0aGVyZSB3aWxsIG5vdCBiZSBjaGFuZ2UgaW4gdGhlXG4gICAgICogc3RhY2suXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIHNlbmRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbnRlcnNlY3RpbmddIElmIGB0cnVlYCwgc2VuZCBvYmplY3QgYmVoaW5kIG5leHQgbG93ZXIgaW50ZXJzZWN0aW5nIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2VuZEJhY2t3YXJkczogZnVuY3Rpb24gKG9iamVjdCwgaW50ZXJzZWN0aW5nKSB7XG4gICAgICBpZiAoIW9iamVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBhY3RpdmVTZWxlY3Rpb24gPSB0aGlzLl9hY3RpdmVPYmplY3QsXG4gICAgICAgICAgaSwgb2JqLCBpZHgsIG5ld0lkeCwgb2Jqcywgb2Jqc01vdmVkID0gMDtcblxuICAgICAgaWYgKG9iamVjdCA9PT0gYWN0aXZlU2VsZWN0aW9uICYmIG9iamVjdC50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJykge1xuICAgICAgICBvYmpzID0gYWN0aXZlU2VsZWN0aW9uLl9vYmplY3RzO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2Jqcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG9iaiA9IG9ianNbaV07XG4gICAgICAgICAgaWR4ID0gdGhpcy5fb2JqZWN0cy5pbmRleE9mKG9iaik7XG4gICAgICAgICAgaWYgKGlkeCA+IDAgKyBvYmpzTW92ZWQpIHtcbiAgICAgICAgICAgIG5ld0lkeCA9IGlkeCAtIDE7XG4gICAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5fb2JqZWN0cywgb2JqKTtcbiAgICAgICAgICAgIHRoaXMuX29iamVjdHMuc3BsaWNlKG5ld0lkeCwgMCwgb2JqKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2Jqc01vdmVkKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZHggPSB0aGlzLl9vYmplY3RzLmluZGV4T2Yob2JqZWN0KTtcbiAgICAgICAgaWYgKGlkeCAhPT0gMCkge1xuICAgICAgICAgIC8vIGlmIG9iamVjdCBpcyBub3Qgb24gdGhlIGJvdHRvbSBvZiBzdGFja1xuICAgICAgICAgIG5ld0lkeCA9IHRoaXMuX2ZpbmROZXdMb3dlckluZGV4KG9iamVjdCwgaWR4LCBpbnRlcnNlY3RpbmcpO1xuICAgICAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmplY3QpO1xuICAgICAgICAgIHRoaXMuX29iamVjdHMuc3BsaWNlKG5ld0lkeCwgMCwgb2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maW5kTmV3TG93ZXJJbmRleDogZnVuY3Rpb24ob2JqZWN0LCBpZHgsIGludGVyc2VjdGluZykge1xuICAgICAgdmFyIG5ld0lkeCwgaTtcblxuICAgICAgaWYgKGludGVyc2VjdGluZykge1xuICAgICAgICBuZXdJZHggPSBpZHg7XG5cbiAgICAgICAgLy8gdHJhdmVyc2UgZG93biB0aGUgc3RhY2sgbG9va2luZyBmb3IgdGhlIG5lYXJlc3QgaW50ZXJzZWN0aW5nIG9iamVjdFxuICAgICAgICBmb3IgKGkgPSBpZHggLSAxOyBpID49IDA7IC0taSkge1xuXG4gICAgICAgICAgdmFyIGlzSW50ZXJzZWN0aW5nID0gb2JqZWN0LmludGVyc2VjdHNXaXRoT2JqZWN0KHRoaXMuX29iamVjdHNbaV0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmlzQ29udGFpbmVkV2l0aGluT2JqZWN0KHRoaXMuX29iamVjdHNbaV0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5pc0NvbnRhaW5lZFdpdGhpbk9iamVjdChvYmplY3QpO1xuXG4gICAgICAgICAgaWYgKGlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgICBuZXdJZHggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3SWR4ID0gaWR4IC0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld0lkeDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgYW4gb2JqZWN0IG9yIGEgc2VsZWN0aW9uIHVwIGluIHN0YWNrIG9mIGRyYXduIG9iamVjdHNcbiAgICAgKiBBbiBvcHRpb25hbCBwYXJhbWV0ZXIsIGludGVyc2VjdGluZyBhbGxvd3MgdG8gbW92ZSB0aGUgb2JqZWN0IGluIGZyb250XG4gICAgICogb2YgdGhlIGZpcnN0IGludGVyc2VjdGluZyBvYmplY3QuIFdoZXJlIGludGVyc2VjdGlvbiBpcyBjYWxjdWxhdGVkIHdpdGhcbiAgICAgKiBib3VuZGluZyBib3guIElmIG5vIGludGVyc2VjdGlvbiBpcyBmb3VuZCwgdGhlcmUgd2lsbCBub3QgYmUgY2hhbmdlIGluIHRoZVxuICAgICAqIHN0YWNrLlxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzZW5kXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaW50ZXJzZWN0aW5nXSBJZiBgdHJ1ZWAsIHNlbmQgb2JqZWN0IGluIGZyb250IG9mIG5leHQgdXBwZXIgaW50ZXJzZWN0aW5nIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgYnJpbmdGb3J3YXJkOiBmdW5jdGlvbiAob2JqZWN0LCBpbnRlcnNlY3RpbmcpIHtcbiAgICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIGFjdGl2ZVNlbGVjdGlvbiA9IHRoaXMuX2FjdGl2ZU9iamVjdCxcbiAgICAgICAgICBpLCBvYmosIGlkeCwgbmV3SWR4LCBvYmpzLCBvYmpzTW92ZWQgPSAwO1xuXG4gICAgICBpZiAob2JqZWN0ID09PSBhY3RpdmVTZWxlY3Rpb24gJiYgb2JqZWN0LnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nKSB7XG4gICAgICAgIG9ianMgPSBhY3RpdmVTZWxlY3Rpb24uX29iamVjdHM7XG4gICAgICAgIGZvciAoaSA9IG9ianMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgb2JqID0gb2Jqc1tpXTtcbiAgICAgICAgICBpZHggPSB0aGlzLl9vYmplY3RzLmluZGV4T2Yob2JqKTtcbiAgICAgICAgICBpZiAoaWR4IDwgdGhpcy5fb2JqZWN0cy5sZW5ndGggLSAxIC0gb2Jqc01vdmVkKSB7XG4gICAgICAgICAgICBuZXdJZHggPSBpZHggKyAxO1xuICAgICAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuX29iamVjdHMsIG9iaik7XG4gICAgICAgICAgICB0aGlzLl9vYmplY3RzLnNwbGljZShuZXdJZHgsIDAsIG9iaik7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9ianNNb3ZlZCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWR4ID0gdGhpcy5fb2JqZWN0cy5pbmRleE9mKG9iamVjdCk7XG4gICAgICAgIGlmIChpZHggIT09IHRoaXMuX29iamVjdHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIC8vIGlmIG9iamVjdCBpcyBub3Qgb24gdG9wIG9mIHN0YWNrIChsYXN0IGl0ZW0gaW4gYW4gYXJyYXkpXG4gICAgICAgICAgbmV3SWR4ID0gdGhpcy5fZmluZE5ld1VwcGVySW5kZXgob2JqZWN0LCBpZHgsIGludGVyc2VjdGluZyk7XG4gICAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHRoaXMuX29iamVjdHMsIG9iamVjdCk7XG4gICAgICAgICAgdGhpcy5fb2JqZWN0cy5zcGxpY2UobmV3SWR4LCAwLCBvYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpbmROZXdVcHBlckluZGV4OiBmdW5jdGlvbihvYmplY3QsIGlkeCwgaW50ZXJzZWN0aW5nKSB7XG4gICAgICB2YXIgbmV3SWR4LCBpLCBsZW47XG5cbiAgICAgIGlmIChpbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgbmV3SWR4ID0gaWR4O1xuXG4gICAgICAgIC8vIHRyYXZlcnNlIHVwIHRoZSBzdGFjayBsb29raW5nIGZvciB0aGUgbmVhcmVzdCBpbnRlcnNlY3Rpbmcgb2JqZWN0XG4gICAgICAgIGZvciAoaSA9IGlkeCArIDEsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblxuICAgICAgICAgIHZhciBpc0ludGVyc2VjdGluZyA9IG9iamVjdC5pbnRlcnNlY3RzV2l0aE9iamVjdCh0aGlzLl9vYmplY3RzW2ldKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5pc0NvbnRhaW5lZFdpdGhpbk9iamVjdCh0aGlzLl9vYmplY3RzW2ldKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29iamVjdHNbaV0uaXNDb250YWluZWRXaXRoaW5PYmplY3Qob2JqZWN0KTtcblxuICAgICAgICAgIGlmIChpc0ludGVyc2VjdGluZykge1xuICAgICAgICAgICAgbmV3SWR4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5ld0lkeCA9IGlkeCArIDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdJZHg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFuIG9iamVjdCB0byBzcGVjaWZpZWQgbGV2ZWwgaW4gc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzZW5kXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFBvc2l0aW9uIHRvIG1vdmUgdG9cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIG1vdmVUbzogZnVuY3Rpb24gKG9iamVjdCwgaW5kZXgpIHtcbiAgICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLl9vYmplY3RzLCBvYmplY3QpO1xuICAgICAgdGhpcy5fb2JqZWN0cy5zcGxpY2UoaW5kZXgsIDAsIG9iamVjdCk7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGEgY2FudmFzIGVsZW1lbnQgYW5kIGRpc3Bvc2Ugb2JqZWN0c1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gY2FuY2VsIGV2ZW50dWFsbHkgb25nb2luZyByZW5kZXJzXG4gICAgICBpZiAodGhpcy5pc1JlbmRlcmluZykge1xuICAgICAgICBmYWJyaWMudXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5pc1JlbmRlcmluZyk7XG4gICAgICAgIHRoaXMuaXNSZW5kZXJpbmcgPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5mb3JFYWNoT2JqZWN0KGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBvYmplY3QuZGlzcG9zZSAmJiBvYmplY3QuZGlzcG9zZSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9vYmplY3RzID0gW107XG4gICAgICBpZiAodGhpcy5iYWNrZ3JvdW5kSW1hZ2UgJiYgdGhpcy5iYWNrZ3JvdW5kSW1hZ2UuZGlzcG9zZSkge1xuICAgICAgICB0aGlzLmJhY2tncm91bmRJbWFnZS5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmJhY2tncm91bmRJbWFnZSA9IG51bGw7XG4gICAgICBpZiAodGhpcy5vdmVybGF5SW1hZ2UgJiYgdGhpcy5vdmVybGF5SW1hZ2UuZGlzcG9zZSkge1xuICAgICAgICB0aGlzLm92ZXJsYXlJbWFnZS5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLm92ZXJsYXlJbWFnZSA9IG51bGw7XG4gICAgICB0aGlzLl9pVGV4dEluc3RhbmNlcyA9IG51bGw7XG4gICAgICB0aGlzLmNvbnRleHRDb250YWluZXIgPSBudWxsO1xuICAgICAgLy8gcmVzdG9yZSBjYW52YXMgc3R5bGVcbiAgICAgIHRoaXMubG93ZXJDYW52YXNFbC5jbGFzc0xpc3QucmVtb3ZlKCdsb3dlci1jYW52YXMnKTtcbiAgICAgIGZhYnJpYy51dGlsLnNldFN0eWxlKHRoaXMubG93ZXJDYW52YXNFbCwgdGhpcy5fb3JpZ2luYWxDYW52YXNTdHlsZSk7XG4gICAgICBkZWxldGUgdGhpcy5fb3JpZ2luYWxDYW52YXNTdHlsZTtcbiAgICAgIC8vIHJlc3RvcmUgY2FudmFzIHNpemUgdG8gb3JpZ2luYWwgc2l6ZSBpbiBjYXNlIHJldGluYSBzY2FsaW5nIHdhcyBhcHBsaWVkXG4gICAgICB0aGlzLmxvd2VyQ2FudmFzRWwuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMud2lkdGgpO1xuICAgICAgdGhpcy5sb3dlckNhbnZhc0VsLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5oZWlnaHQpO1xuICAgICAgZmFicmljLnV0aWwuY2xlYW5VcEpzZG9tTm9kZSh0aGlzLmxvd2VyQ2FudmFzRWwpO1xuICAgICAgdGhpcy5sb3dlckNhbnZhc0VsID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gJyM8ZmFicmljLkNhbnZhcyAoJyArIHRoaXMuY29tcGxleGl0eSgpICsgJyk6ICcgK1xuICAgICAgICAgICAgICAgJ3sgb2JqZWN0czogJyArIHRoaXMuX29iamVjdHMubGVuZ3RoICsgJyB9Pic7XG4gICAgfVxuICB9KTtcblxuICBleHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIGZhYnJpYy5PYnNlcnZhYmxlKTtcbiAgZXh0ZW5kKGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLCBmYWJyaWMuQ29sbGVjdGlvbik7XG4gIGV4dGVuZChmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZSwgZmFicmljLkRhdGFVUkxFeHBvcnRlcik7XG5cbiAgZXh0ZW5kKGZhYnJpYy5TdGF0aWNDYW52YXMsIC8qKiBAbGVuZHMgZmFicmljLlN0YXRpY0NhbnZhcyAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBFTVBUWV9KU09OOiAne1wib2JqZWN0c1wiOiBbXSwgXCJiYWNrZ3JvdW5kXCI6IFwid2hpdGVcIn0nLFxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSB3YXkgdG8gY2hlY2sgc3VwcG9ydCBvZiBzb21lIG9mIHRoZSBjYW52YXMgbWV0aG9kc1xuICAgICAqIChlaXRoZXIgdGhvc2Ugb2YgSFRNTENhbnZhc0VsZW1lbnQgaXRzZWxmLCBvciByZW5kZXJpbmcgY29udGV4dClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2ROYW1lIE1ldGhvZCB0byBjaGVjayBzdXBwb3J0IGZvcjtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb3VsZCBiZSBvbmUgb2YgXCJzZXRMaW5lRGFzaFwiXG4gICAgICogQHJldHVybiB7Qm9vbGVhbiB8IG51bGx9IGB0cnVlYCBpZiBtZXRob2QgaXMgc3VwcG9ydGVkIChvciBhdCBsZWFzdCBleGlzdHMpLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBgbnVsbGAgaWYgY2FudmFzIGVsZW1lbnQgb3IgY29udGV4dCBjYW4gbm90IGJlIGluaXRpYWxpemVkXG4gICAgICovXG4gICAgc3VwcG9ydHM6IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZWwgPSBjcmVhdGVDYW52YXNFbGVtZW50KCk7XG5cbiAgICAgIGlmICghZWwgfHwgIWVsLmdldENvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdHggPSBlbC5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAobWV0aG9kTmFtZSkge1xuXG4gICAgICAgIGNhc2UgJ3NldExpbmVEYXNoJzpcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIGN0eC5zZXRMaW5lRGFzaCAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBjYW52YXNcbiAgICogdGhpcyBhbGlhcyBpcyBwcm92aWRlZCBiZWNhdXNlIGlmIHlvdSBjYWxsIEpTT04uc3RyaW5naWZ5IG9uIGFuIGluc3RhbmNlLFxuICAgKiB0aGUgdG9KU09OIG9iamVjdCB3aWxsIGJlIGludm9rZWQgaWYgaXQgZXhpc3RzLlxuICAgKiBIYXZpbmcgYSB0b0pTT04gbWV0aG9kIG1lYW5zIHlvdSBjYW4gZG8gSlNPTi5zdHJpbmdpZnkobXlDYW52YXMpXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAqIEByZXR1cm4ge09iamVjdH0gSlNPTiBjb21wYXRpYmxlIG9iamVjdFxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMyNzZXJpYWxpemF0aW9ufVxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vanNmaWRkbGUubmV0L2ZhYnJpY2pzL3BlYzg2L3xqc0ZpZGRsZSBkZW1vfVxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5KU09OIHdpdGhvdXQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzPC9jYXB0aW9uPlxuICAgKiB2YXIganNvbiA9IGNhbnZhcy50b0pTT04oKTtcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+SlNPTiB3aXRoIGFkZGl0aW9uYWwgcHJvcGVydGllcyBpbmNsdWRlZDwvY2FwdGlvbj5cbiAgICogdmFyIGpzb24gPSBjYW52YXMudG9KU09OKFsnbG9ja01vdmVtZW50WCcsICdsb2NrTW92ZW1lbnRZJywgJ2xvY2tSb3RhdGlvbicsICdsb2NrU2NhbGluZ1gnLCAnbG9ja1NjYWxpbmdZJ10pO1xuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5KU09OIHdpdGhvdXQgZGVmYXVsdCB2YWx1ZXM8L2NhcHRpb24+XG4gICAqIGNhbnZhcy5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IGZhbHNlO1xuICAgKiB2YXIganNvbiA9IGNhbnZhcy50b0pTT04oKTtcbiAgICovXG4gIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLnRvSlNPTiA9IGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLnRvT2JqZWN0O1xuXG4gIGlmIChmYWJyaWMuaXNMaWtlbHlOb2RlKSB7XG4gICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuY3JlYXRlUE5HU3RyZWFtID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaW1wbCA9IGdldE5vZGVDYW52YXModGhpcy5sb3dlckNhbnZhc0VsKTtcbiAgICAgIHJldHVybiBpbXBsICYmIGltcGwuY3JlYXRlUE5HU3RyZWFtKCk7XG4gICAgfTtcbiAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5jcmVhdGVKUEVHU3RyZWFtID0gZnVuY3Rpb24ob3B0cykge1xuICAgICAgdmFyIGltcGwgPSBnZXROb2RlQ2FudmFzKHRoaXMubG93ZXJDYW52YXNFbCk7XG4gICAgICByZXR1cm4gaW1wbCAmJiBpbXBsLmNyZWF0ZUpQRUdTdHJlYW0ob3B0cyk7XG4gICAgfTtcbiAgfVxufSkoKTtcblxuXG4vKipcbiAqIEJhc2VCcnVzaCBjbGFzc1xuICogQGNsYXNzIGZhYnJpYy5CYXNlQnJ1c2hcbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZnJlZWRyYXdpbmd8RnJlZWRyYXdpbmcgZGVtb31cbiAqL1xuZmFicmljLkJhc2VCcnVzaCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKC8qKiBAbGVuZHMgZmFicmljLkJhc2VCcnVzaC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBDb2xvciBvZiBhIGJydXNoXG4gICAqIEB0eXBlIFN0cmluZ1xuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgY29sb3I6ICdyZ2IoMCwgMCwgMCknLFxuXG4gIC8qKlxuICAgKiBXaWR0aCBvZiBhIGJydXNoLCBoYXMgdG8gYmUgYSBOdW1iZXIsIG5vIHN0cmluZyBsaXRlcmFsc1xuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHdpZHRoOiAxLFxuXG4gIC8qKlxuICAgKiBTaGFkb3cgb2JqZWN0IHJlcHJlc2VudGluZyBzaGFkb3cgb2YgdGhpcyBzaGFwZS5cbiAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSByZXBsYWNlcyBcInNoYWRvd0NvbG9yXCIgKFN0cmluZyksIFwic2hhZG93T2Zmc2V0WFwiIChOdW1iZXIpLFxuICAgKiBcInNoYWRvd09mZnNldFlcIiAoTnVtYmVyKSBhbmQgXCJzaGFkb3dCbHVyXCIgKE51bWJlcikgc2luY2UgdjEuMi4xMlxuICAgKiBAdHlwZSBmYWJyaWMuU2hhZG93XG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBzaGFkb3c6IG51bGwsXG5cbiAgLyoqXG4gICAqIExpbmUgZW5kaW5ncyBzdHlsZSBvZiBhIGJydXNoIChvbmUgb2YgXCJidXR0XCIsIFwicm91bmRcIiwgXCJzcXVhcmVcIilcbiAgICogQHR5cGUgU3RyaW5nXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBzdHJva2VMaW5lQ2FwOiAncm91bmQnLFxuXG4gIC8qKlxuICAgKiBDb3JuZXIgc3R5bGUgb2YgYSBicnVzaCAob25lIG9mIFwiYmV2ZWxcIiwgXCJyb3VuZFwiLCBcIm1pdGVyXCIpXG4gICAqIEB0eXBlIFN0cmluZ1xuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgc3Ryb2tlTGluZUpvaW46ICdyb3VuZCcsXG5cbiAgLyoqXG4gICAqIE1heGltdW0gbWl0ZXIgbGVuZ3RoICh1c2VkIGZvciBzdHJva2VMaW5lSm9pbiA9IFwibWl0ZXJcIikgb2YgYSBicnVzaCdzXG4gICAqIEB0eXBlIE51bWJlclxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgc3Ryb2tlTWl0ZXJMaW1pdDogICAgICAgICAxMCxcblxuICAvKipcbiAgICogU3Ryb2tlIERhc2ggQXJyYXkuXG4gICAqIEB0eXBlIEFycmF5XG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBzdHJva2VEYXNoQXJyYXk6IG51bGwsXG5cbiAgLyoqXG4gICAqIFdoZW4gYHRydWVgLCB0aGUgZnJlZSBkcmF3aW5nIGlzIGxpbWl0ZWQgdG8gdGhlIHdoaXRlYm9hcmQgc2l6ZS4gRGVmYXVsdCB0byBmYWxzZS5cbiAgICogQHR5cGUgQm9vbGVhblxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAqL1xuXG4gIGxpbWl0ZWRUb0NhbnZhc1NpemU6IGZhbHNlLFxuXG5cbiAgLyoqXG4gICAqIFNldHMgYnJ1c2ggc3R5bGVzXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICovXG4gIF9zZXRCcnVzaFN0eWxlczogZnVuY3Rpb24gKGN0eCkge1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgY3R4LmxpbmVDYXAgPSB0aGlzLnN0cm9rZUxpbmVDYXA7XG4gICAgY3R4Lm1pdGVyTGltaXQgPSB0aGlzLnN0cm9rZU1pdGVyTGltaXQ7XG4gICAgY3R4LmxpbmVKb2luID0gdGhpcy5zdHJva2VMaW5lSm9pbjtcbiAgICBjdHguc2V0TGluZURhc2godGhpcy5zdHJva2VEYXNoQXJyYXkgfHwgW10pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0cmFuc2Zvcm1hdGlvbiBvbiBnaXZlbiBjb250ZXh0XG4gICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dDJkfSBjdHggY29udGV4dCB0byByZW5kZXIgb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zYXZlQW5kVHJhbnNmb3JtOiBmdW5jdGlvbihjdHgpIHtcbiAgICB2YXIgdiA9IHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zZm9ybSh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBicnVzaCBzaGFkb3cgc3R5bGVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0U2hhZG93OiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuc2hhZG93KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzLFxuICAgICAgICBzaGFkb3cgPSB0aGlzLnNoYWRvdyxcbiAgICAgICAgY3R4ID0gY2FudmFzLmNvbnRleHRUb3AsXG4gICAgICAgIHpvb20gPSBjYW52YXMuZ2V0Wm9vbSgpO1xuICAgIGlmIChjYW52YXMgJiYgY2FudmFzLl9pc1JldGluYVNjYWxpbmcoKSkge1xuICAgICAgem9vbSAqPSBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICB9XG5cbiAgICBjdHguc2hhZG93Q29sb3IgPSBzaGFkb3cuY29sb3I7XG4gICAgY3R4LnNoYWRvd0JsdXIgPSBzaGFkb3cuYmx1ciAqIHpvb207XG4gICAgY3R4LnNoYWRvd09mZnNldFggPSBzaGFkb3cub2Zmc2V0WCAqIHpvb207XG4gICAgY3R4LnNoYWRvd09mZnNldFkgPSBzaGFkb3cub2Zmc2V0WSAqIHpvb207XG4gIH0sXG5cbiAgbmVlZHNGdWxsUmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29sb3IgPSBuZXcgZmFicmljLkNvbG9yKHRoaXMuY29sb3IpO1xuICAgIHJldHVybiBjb2xvci5nZXRBbHBoYSgpIDwgMSB8fCAhIXRoaXMuc2hhZG93O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGJydXNoIHNoYWRvdyBzdHlsZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZXNldFNoYWRvdzogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG5cbiAgICBjdHguc2hhZG93Q29sb3IgPSAnJztcbiAgICBjdHguc2hhZG93Qmx1ciA9IGN0eC5zaGFkb3dPZmZzZXRYID0gY3R4LnNoYWRvd09mZnNldFkgPSAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpcyBwb2ludGVyIGlzIG91dHNpZGUgY2FudmFzIGJvdW5kYXJpZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICogQHByaXZhdGVcbiAgKi9cbiAgX2lzT3V0U2lkZUNhbnZhczogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIHJldHVybiBwb2ludGVyLnggPCAwIHx8IHBvaW50ZXIueCA+IHRoaXMuY2FudmFzLmdldFdpZHRoKCkgfHwgcG9pbnRlci55IDwgMCB8fCBwb2ludGVyLnkgPiB0aGlzLmNhbnZhcy5nZXRIZWlnaHQoKTtcbiAgfVxufSk7XG5cblxuKGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICogUGVuY2lsQnJ1c2ggY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5QZW5jaWxCcnVzaFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuQmFzZUJydXNoXG4gICAqL1xuICBmYWJyaWMuUGVuY2lsQnJ1c2ggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuQmFzZUJydXNoLCAvKiogQGxlbmRzIGZhYnJpYy5QZW5jaWxCcnVzaC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRGlzY2FyZCBwb2ludHMgdGhhdCBhcmUgbGVzcyB0aGFuIGBkZWNpbWF0ZWAgcGl4ZWwgZGlzdGFudCBmcm9tIGVhY2ggb3RoZXJcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdCAwLjRcbiAgICAgKi9cbiAgICBkZWNpbWF0ZTogMC40LFxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYSBzdHJhaWdodCBsaW5lIGJldHdlZW4gbGFzdCByZWNvcmRlZCBwb2ludCB0byBjdXJyZW50IHBvaW50ZXJcbiAgICAgKiBVc2VkIGZvciBgc2hpZnRgIGZ1bmN0aW9uYWxpdHlcbiAgICAgKlxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGRyYXdTdHJhaWdodExpbmU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50IG1vZGlmaWVyIGtleSB0aGF0IG1ha2VzIHRoZSBicnVzaCBkcmF3IGEgc3RyYWlnaHQgbGluZS5cbiAgICAgKiBJZiBgbnVsbGAgb3IgJ25vbmUnIG9yIGFueSBvdGhlciBzdHJpbmcgdGhhdCBpcyBub3QgYSBtb2RpZmllciBrZXkgdGhlIGZlYXR1cmUgaXMgZGlzYWJsZWQuXG4gICAgICogQHR5cGUgeydhbHRLZXknIHwgJ3NoaWZ0S2V5JyB8ICdjdHJsS2V5JyB8ICdub25lJyB8IHVuZGVmaW5lZCB8IG51bGx9XG4gICAgICovXG4gICAgc3RyYWlnaHRMaW5lS2V5OiAnc2hpZnRLZXknLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5DYW52YXN9IGNhbnZhc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5QZW5jaWxCcnVzaH0gSW5zdGFuY2Ugb2YgYSBwZW5jaWwgYnJ1c2hcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgdGhpcy5fcG9pbnRzID0gW107XG4gICAgfSxcblxuICAgIG5lZWRzRnVsbFJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCduZWVkc0Z1bGxSZW5kZXInKSB8fCB0aGlzLl9oYXNTdHJhaWdodExpbmU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgaW5zaWRlIG9uIG1vdXNlIGRvd24gYW5kIG1vdXNlIG1vdmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgICAqL1xuICAgIF9kcmF3U2VnbWVudDogZnVuY3Rpb24gKGN0eCwgcDEsIHAyKSB7XG4gICAgICB2YXIgbWlkUG9pbnQgPSBwMS5taWRQb2ludEZyb20ocDIpO1xuICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8ocDEueCwgcDEueSwgbWlkUG9pbnQueCwgbWlkUG9pbnQueSk7XG4gICAgICByZXR1cm4gbWlkUG9pbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgb24gbW91c2UgZG93blxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAgICovXG4gICAgb25Nb3VzZURvd246IGZ1bmN0aW9uKHBvaW50ZXIsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMuX2lzTWFpbkV2ZW50KG9wdGlvbnMuZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5kcmF3U3RyYWlnaHRMaW5lID0gb3B0aW9ucy5lW3RoaXMuc3RyYWlnaHRMaW5lS2V5XTtcbiAgICAgIHRoaXMuX3ByZXBhcmVGb3JEcmF3aW5nKHBvaW50ZXIpO1xuICAgICAgLy8gY2FwdHVyZSBjb29yZGluYXRlcyBpbW1lZGlhdGVseVxuICAgICAgLy8gdGhpcyBhbGxvd3MgdG8gZHJhdyBkb3RzICh3aGVuIG1vdmVtZW50IG5ldmVyIG9jY3VycylcbiAgICAgIHRoaXMuX2NhcHR1cmVEcmF3aW5nUGF0aChwb2ludGVyKTtcbiAgICAgIHRoaXMuX3JlbmRlcigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIG9uIG1vdXNlIG1vdmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlclxuICAgICAqL1xuICAgIG9uTW91c2VNb3ZlOiBmdW5jdGlvbihwb2ludGVyLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzLl9pc01haW5FdmVudChvcHRpb25zLmUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZHJhd1N0cmFpZ2h0TGluZSA9IG9wdGlvbnMuZVt0aGlzLnN0cmFpZ2h0TGluZUtleV07XG4gICAgICBpZiAodGhpcy5saW1pdGVkVG9DYW52YXNTaXplID09PSB0cnVlICYmIHRoaXMuX2lzT3V0U2lkZUNhbnZhcyhwb2ludGVyKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fY2FwdHVyZURyYXdpbmdQYXRoKHBvaW50ZXIpICYmIHRoaXMuX3BvaW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGlmICh0aGlzLm5lZWRzRnVsbFJlbmRlcigpKSB7XG4gICAgICAgICAgLy8gcmVkcmF3IGN1cnZlXG4gICAgICAgICAgLy8gY2xlYXIgdG9wIGNhbnZhc1xuICAgICAgICAgIHRoaXMuY2FudmFzLmNsZWFyQ29udGV4dCh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICAgICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5fcG9pbnRzLCBsZW5ndGggPSBwb2ludHMubGVuZ3RoLCBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wO1xuICAgICAgICAgIC8vIGRyYXcgdGhlIGN1cnZlIHVwZGF0ZVxuICAgICAgICAgIHRoaXMuX3NhdmVBbmRUcmFuc2Zvcm0oY3R4KTtcbiAgICAgICAgICBpZiAodGhpcy5vbGRFbmQpIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8odGhpcy5vbGRFbmQueCwgdGhpcy5vbGRFbmQueSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMub2xkRW5kID0gdGhpcy5fZHJhd1NlZ21lbnQoY3R4LCBwb2ludHNbbGVuZ3RoIC0gMl0sIHBvaW50c1tsZW5ndGggLSAxXSwgdHJ1ZSk7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCBvbiBtb3VzZSB1cFxuICAgICAqL1xuICAgIG9uTW91c2VVcDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcy5faXNNYWluRXZlbnQob3B0aW9ucy5lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZHJhd1N0cmFpZ2h0TGluZSA9IGZhbHNlO1xuICAgICAgdGhpcy5vbGRFbmQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9maW5hbGl6ZUFuZEFkZFBhdGgoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlciBBY3R1YWwgbW91c2UgcG9zaXRpb24gcmVsYXRlZCB0byB0aGUgY2FudmFzLlxuICAgICAqL1xuICAgIF9wcmVwYXJlRm9yRHJhd2luZzogZnVuY3Rpb24ocG9pbnRlcikge1xuXG4gICAgICB2YXIgcCA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRlci54LCBwb2ludGVyLnkpO1xuXG4gICAgICB0aGlzLl9yZXNldCgpO1xuICAgICAgdGhpcy5fYWRkUG9pbnQocCk7XG4gICAgICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLm1vdmVUbyhwLngsIHAueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFBvaW50IHRvIGJlIGFkZGVkIHRvIHBvaW50cyBhcnJheVxuICAgICAqL1xuICAgIF9hZGRQb2ludDogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgIGlmICh0aGlzLl9wb2ludHMubGVuZ3RoID4gMSAmJiBwb2ludC5lcSh0aGlzLl9wb2ludHNbdGhpcy5fcG9pbnRzLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5kcmF3U3RyYWlnaHRMaW5lICYmIHRoaXMuX3BvaW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMuX2hhc1N0cmFpZ2h0TGluZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3BvaW50cy5wb3AoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBwb2ludHMgYXJyYXkgYW5kIHNldCBjb250ZXh0VG9wIGNhbnZhcyBzdHlsZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9wb2ludHMgPSBbXTtcbiAgICAgIHRoaXMuX3NldEJydXNoU3R5bGVzKHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xuICAgICAgdGhpcy5fc2V0U2hhZG93KCk7XG4gICAgICB0aGlzLl9oYXNTdHJhaWdodExpbmUgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlciBBY3R1YWwgbW91c2UgcG9zaXRpb24gcmVsYXRlZCB0byB0aGUgY2FudmFzLlxuICAgICAqL1xuICAgIF9jYXB0dXJlRHJhd2luZ1BhdGg6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICAgIHZhciBwb2ludGVyUG9pbnQgPSBuZXcgZmFicmljLlBvaW50KHBvaW50ZXIueCwgcG9pbnRlci55KTtcbiAgICAgIHJldHVybiB0aGlzLl9hZGRQb2ludChwb2ludGVyUG9pbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgc21vb3RoIHBhdGggb24gdGhlIHRvcENhbnZhcyB1c2luZyBxdWFkcmF0aWNDdXJ2ZVRvXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gW2N0eF1cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciBpLCBsZW4sXG4gICAgICAgICAgcDEgPSB0aGlzLl9wb2ludHNbMF0sXG4gICAgICAgICAgcDIgPSB0aGlzLl9wb2ludHNbMV07XG4gICAgICBjdHggPSBjdHggfHwgdGhpcy5jYW52YXMuY29udGV4dFRvcDtcbiAgICAgIHRoaXMuX3NhdmVBbmRUcmFuc2Zvcm0oY3R4KTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIC8vaWYgd2Ugb25seSBoYXZlIDIgcG9pbnRzIGluIHRoZSBwYXRoIGFuZCB0aGV5IGFyZSB0aGUgc2FtZVxuICAgICAgLy9pdCBtZWFucyB0aGF0IHRoZSB1c2VyIG9ubHkgY2xpY2tlZCB0aGUgY2FudmFzIHdpdGhvdXQgbW92aW5nIHRoZSBtb3VzZVxuICAgICAgLy90aGVuIHdlIHNob3VsZCBiZSBkcmF3aW5nIGEgZG90LiBBIHBhdGggaXNuJ3QgZHJhd24gYmV0d2VlbiB0d28gaWRlbnRpY2FsIGRvdHNcbiAgICAgIC8vdGhhdCdzIHdoeSB3ZSBzZXQgdGhlbSBhcGFydCBhIGJpdFxuICAgICAgaWYgKHRoaXMuX3BvaW50cy5sZW5ndGggPT09IDIgJiYgcDEueCA9PT0gcDIueCAmJiBwMS55ID09PSBwMi55KSB7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGggLyAxMDAwO1xuICAgICAgICBwMSA9IG5ldyBmYWJyaWMuUG9pbnQocDEueCwgcDEueSk7XG4gICAgICAgIHAyID0gbmV3IGZhYnJpYy5Qb2ludChwMi54LCBwMi55KTtcbiAgICAgICAgcDEueCAtPSB3aWR0aDtcbiAgICAgICAgcDIueCArPSB3aWR0aDtcbiAgICAgIH1cbiAgICAgIGN0eC5tb3ZlVG8ocDEueCwgcDEueSk7XG5cbiAgICAgIGZvciAoaSA9IDEsIGxlbiA9IHRoaXMuX3BvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAvLyB3ZSBwaWNrIHRoZSBwb2ludCBiZXR3ZWVuIHBpICsgMSAmIHBpICsgMiBhcyB0aGVcbiAgICAgICAgLy8gZW5kIHBvaW50IGFuZCBwMSBhcyBvdXIgY29udHJvbCBwb2ludC5cbiAgICAgICAgdGhpcy5fZHJhd1NlZ21lbnQoY3R4LCBwMSwgcDIpO1xuICAgICAgICBwMSA9IHRoaXMuX3BvaW50c1tpXTtcbiAgICAgICAgcDIgPSB0aGlzLl9wb2ludHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gRHJhdyBsYXN0IGxpbmUgYXMgYSBzdHJhaWdodCBsaW5lIHdoaWxlXG4gICAgICAvLyB3ZSB3YWl0IGZvciB0aGUgbmV4dCBwb2ludCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZVxuICAgICAgLy8gdGhlIGJlemllciBjb250cm9sIHBvaW50XG4gICAgICBjdHgubGluZVRvKHAxLngsIHAxLnkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgcG9pbnRzIHRvIFNWRyBwYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIEFycmF5IG9mIHBvaW50c1xuICAgICAqIEByZXR1cm4geyhzdHJpbmd8bnVtYmVyKVtdW119IFNWRyBwYXRoIGNvbW1hbmRzXG4gICAgICovXG4gICAgY29udmVydFBvaW50c1RvU1ZHUGF0aDogZnVuY3Rpb24gKHBvaW50cykge1xuICAgICAgdmFyIGNvcnJlY3Rpb24gPSB0aGlzLndpZHRoIC8gMTAwMDtcbiAgICAgIHJldHVybiBmYWJyaWMudXRpbC5nZXRTbW9vdGhQYXRoRnJvbVBvaW50cyhwb2ludHMsIGNvcnJlY3Rpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3xudW1iZXIpW11bXX0gcGF0aERhdGEgU1ZHIHBhdGggY29tbWFuZHNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBfaXNFbXB0eVNWR1BhdGg6IGZ1bmN0aW9uIChwYXRoRGF0YSkge1xuICAgICAgdmFyIHBhdGhTdHJpbmcgPSBmYWJyaWMudXRpbC5qb2luUGF0aChwYXRoRGF0YSk7XG4gICAgICByZXR1cm4gcGF0aFN0cmluZyA9PT0gJ00gMCAwIFEgMCAwIDAgMCBMIDAgMCc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgZmFicmljLlBhdGggb2JqZWN0IHRvIGFkZCBvbiBjYW52YXNcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyKVtdW119IHBhdGhEYXRhIFBhdGggZGF0YVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5QYXRofSBQYXRoIHRvIGFkZCBvbiBjYW52YXNcbiAgICAgKi9cbiAgICBjcmVhdGVQYXRoOiBmdW5jdGlvbihwYXRoRGF0YSkge1xuICAgICAgdmFyIHBhdGggPSBuZXcgZmFicmljLlBhdGgocGF0aERhdGEsIHtcbiAgICAgICAgZmlsbDogbnVsbCxcbiAgICAgICAgc3Ryb2tlOiB0aGlzLmNvbG9yLFxuICAgICAgICBzdHJva2VXaWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgc3Ryb2tlTGluZUNhcDogdGhpcy5zdHJva2VMaW5lQ2FwLFxuICAgICAgICBzdHJva2VNaXRlckxpbWl0OiB0aGlzLnN0cm9rZU1pdGVyTGltaXQsXG4gICAgICAgIHN0cm9rZUxpbmVKb2luOiB0aGlzLnN0cm9rZUxpbmVKb2luLFxuICAgICAgICBzdHJva2VEYXNoQXJyYXk6IHRoaXMuc3Ryb2tlRGFzaEFycmF5LFxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5zaGFkb3cpIHtcbiAgICAgICAgdGhpcy5zaGFkb3cuYWZmZWN0U3Ryb2tlID0gdHJ1ZTtcbiAgICAgICAgcGF0aC5zaGFkb3cgPSBuZXcgZmFicmljLlNoYWRvdyh0aGlzLnNoYWRvdyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWNpbWF0ZSBwb2ludHMgYXJyYXkgd2l0aCB0aGUgZGVjaW1hdGUgdmFsdWVcbiAgICAgKi9cbiAgICBkZWNpbWF0ZVBvaW50czogZnVuY3Rpb24ocG9pbnRzLCBkaXN0YW5jZSkge1xuICAgICAgaWYgKHBvaW50cy5sZW5ndGggPD0gMikge1xuICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgfVxuICAgICAgdmFyIHpvb20gPSB0aGlzLmNhbnZhcy5nZXRab29tKCksIGFkanVzdGVkRGlzdGFuY2UgPSBNYXRoLnBvdyhkaXN0YW5jZSAvIHpvb20sIDIpLFxuICAgICAgICAgIGksIGwgPSBwb2ludHMubGVuZ3RoIC0gMSwgbGFzdFBvaW50ID0gcG9pbnRzWzBdLCBuZXdQb2ludHMgPSBbbGFzdFBvaW50XSxcbiAgICAgICAgICBjRGlzdGFuY2U7XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbCAtIDE7IGkrKykge1xuICAgICAgICBjRGlzdGFuY2UgPSBNYXRoLnBvdyhsYXN0UG9pbnQueCAtIHBvaW50c1tpXS54LCAyKSArIE1hdGgucG93KGxhc3RQb2ludC55IC0gcG9pbnRzW2ldLnksIDIpO1xuICAgICAgICBpZiAoY0Rpc3RhbmNlID49IGFkanVzdGVkRGlzdGFuY2UpIHtcbiAgICAgICAgICBsYXN0UG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgICAgbmV3UG9pbnRzLnB1c2gobGFzdFBvaW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBBZGQgdGhlIGxhc3QgcG9pbnQgZnJvbSB0aGUgb3JpZ2luYWwgbGluZSB0byB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICAgICAqIFRoaXMgZW5zdXJlcyBkZWNpbWF0ZSBkb2Vzbid0IGRlbGV0ZSB0aGUgbGFzdCBwb2ludCBvbiB0aGUgbGluZSwgYW5kIGVuc3VyZXMgdGhlIGxpbmUgaXMgPiAxIHBvaW50LlxuICAgICAgICovXG4gICAgICBuZXdQb2ludHMucHVzaChwb2ludHNbbF0pO1xuICAgICAgcmV0dXJuIG5ld1BvaW50cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT24gbW91c2V1cCBhZnRlciBkcmF3aW5nIHRoZSBwYXRoIG9uIGNvbnRleHRUb3AgY2FudmFzXG4gICAgICogd2UgdXNlIHRoZSBwb2ludHMgY2FwdHVyZWQgdG8gY3JlYXRlIGFuIG5ldyBmYWJyaWMgcGF0aCBvYmplY3RcbiAgICAgKiBhbmQgYWRkIGl0IHRvIHRoZSBmYWJyaWMgY2FudmFzLlxuICAgICAqL1xuICAgIF9maW5hbGl6ZUFuZEFkZFBhdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBpZiAodGhpcy5kZWNpbWF0ZSkge1xuICAgICAgICB0aGlzLl9wb2ludHMgPSB0aGlzLmRlY2ltYXRlUG9pbnRzKHRoaXMuX3BvaW50cywgdGhpcy5kZWNpbWF0ZSk7XG4gICAgICB9XG4gICAgICB2YXIgcGF0aERhdGEgPSB0aGlzLmNvbnZlcnRQb2ludHNUb1NWR1BhdGgodGhpcy5fcG9pbnRzKTtcbiAgICAgIGlmICh0aGlzLl9pc0VtcHR5U1ZHUGF0aChwYXRoRGF0YSkpIHtcbiAgICAgICAgLy8gZG8gbm90IGNyZWF0ZSAwIHdpZHRoL2hlaWdodCBwYXRocywgYXMgdGhleSBhcmVcbiAgICAgICAgLy8gcmVuZGVyZWQgaW5jb25zaXN0ZW50bHkgYWNyb3NzIGJyb3dzZXJzXG4gICAgICAgIC8vIEZpcmVmb3ggNCwgZm9yIGV4YW1wbGUsIHJlbmRlcnMgYSBkb3QsXG4gICAgICAgIC8vIHdoZXJlYXMgQ2hyb21lIDEwIHJlbmRlcnMgbm90aGluZ1xuICAgICAgICB0aGlzLmNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhdGggPSB0aGlzLmNyZWF0ZVBhdGgocGF0aERhdGEpO1xuICAgICAgdGhpcy5jYW52YXMuY2xlYXJDb250ZXh0KHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xuICAgICAgdGhpcy5jYW52YXMuZmlyZSgnYmVmb3JlOnBhdGg6Y3JlYXRlZCcsIHsgcGF0aDogcGF0aCB9KTtcbiAgICAgIHRoaXMuY2FudmFzLmFkZChwYXRoKTtcbiAgICAgIHRoaXMuY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICAgIHBhdGguc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLl9yZXNldFNoYWRvdygpO1xuXG5cbiAgICAgIC8vIGZpcmUgZXZlbnQgJ3BhdGgnIGNyZWF0ZWRcbiAgICAgIHRoaXMuY2FudmFzLmZpcmUoJ3BhdGg6Y3JlYXRlZCcsIHsgcGF0aDogcGF0aCB9KTtcbiAgICB9XG4gIH0pO1xufSkoKTtcblxuXG4vKipcbiAqIENpcmNsZUJydXNoIGNsYXNzXG4gKiBAY2xhc3MgZmFicmljLkNpcmNsZUJydXNoXG4gKi9cbmZhYnJpYy5DaXJjbGVCcnVzaCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5CYXNlQnJ1c2gsIC8qKiBAbGVuZHMgZmFicmljLkNpcmNsZUJydXNoLnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIFdpZHRoIG9mIGEgYnJ1c2hcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICB3aWR0aDogMTAsXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7ZmFicmljLkNhbnZhc30gY2FudmFzXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5DaXJjbGVCcnVzaH0gSW5zdGFuY2Ugb2YgYSBjaXJjbGUgYnJ1c2hcbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMucG9pbnRzID0gW107XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZWQgaW5zaWRlIG9uIG1vdXNlIGRvd24gYW5kIG1vdXNlIG1vdmVcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICovXG4gIGRyYXdEb3Q6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICB2YXIgcG9pbnQgPSB0aGlzLmFkZFBvaW50KHBvaW50ZXIpLFxuICAgICAgICBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wO1xuICAgIHRoaXMuX3NhdmVBbmRUcmFuc2Zvcm0oY3R4KTtcbiAgICB0aGlzLmRvdChjdHgsIHBvaW50KTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9LFxuXG4gIGRvdDogZnVuY3Rpb24oY3R4LCBwb2ludCkge1xuICAgIGN0eC5maWxsU3R5bGUgPSBwb2ludC5maWxsO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKHBvaW50LngsIHBvaW50LnksIHBvaW50LnJhZGl1cywgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmZpbGwoKTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlZCBvbiBtb3VzZSBkb3duXG4gICAqL1xuICBvbk1vdXNlRG93bjogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIHRoaXMucG9pbnRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5jYW52YXMuY2xlYXJDb250ZXh0KHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xuICAgIHRoaXMuX3NldFNoYWRvdygpO1xuICAgIHRoaXMuZHJhd0RvdChwb2ludGVyKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBmdWxsIHN0YXRlIG9mIHRoZSBicnVzaFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN0eCAgPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLCBpLCBsZW4sXG4gICAgICAgIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIHRoaXMuX3NhdmVBbmRUcmFuc2Zvcm0oY3R4KTtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRoaXMuZG90KGN0eCwgcG9pbnRzW2ldKTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlZCBvbiBtb3VzZSBtb3ZlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAqL1xuICBvbk1vdXNlTW92ZTogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIGlmICh0aGlzLmxpbWl0ZWRUb0NhbnZhc1NpemUgPT09IHRydWUgJiYgdGhpcy5faXNPdXRTaWRlQ2FudmFzKHBvaW50ZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm5lZWRzRnVsbFJlbmRlcigpKSB7XG4gICAgICB0aGlzLmNhbnZhcy5jbGVhckNvbnRleHQodGhpcy5jYW52YXMuY29udGV4dFRvcCk7XG4gICAgICB0aGlzLmFkZFBvaW50KHBvaW50ZXIpO1xuICAgICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5kcmF3RG90KHBvaW50ZXIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlZCBvbiBtb3VzZSB1cFxuICAgKi9cbiAgb25Nb3VzZVVwOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3JpZ2luYWxSZW5kZXJPbkFkZFJlbW92ZSA9IHRoaXMuY2FudmFzLnJlbmRlck9uQWRkUmVtb3ZlLCBpLCBsZW47XG4gICAgdGhpcy5jYW52YXMucmVuZGVyT25BZGRSZW1vdmUgPSBmYWxzZTtcblxuICAgIHZhciBjaXJjbGVzID0gW107XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLnBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHBvaW50ID0gdGhpcy5wb2ludHNbaV0sXG4gICAgICAgICAgY2lyY2xlID0gbmV3IGZhYnJpYy5DaXJjbGUoe1xuICAgICAgICAgICAgcmFkaXVzOiBwb2ludC5yYWRpdXMsXG4gICAgICAgICAgICBsZWZ0OiBwb2ludC54LFxuICAgICAgICAgICAgdG9wOiBwb2ludC55LFxuICAgICAgICAgICAgb3JpZ2luWDogJ2NlbnRlcicsXG4gICAgICAgICAgICBvcmlnaW5ZOiAnY2VudGVyJyxcbiAgICAgICAgICAgIGZpbGw6IHBvaW50LmZpbGxcbiAgICAgICAgICB9KTtcblxuICAgICAgdGhpcy5zaGFkb3cgJiYgKGNpcmNsZS5zaGFkb3cgPSBuZXcgZmFicmljLlNoYWRvdyh0aGlzLnNoYWRvdykpO1xuXG4gICAgICBjaXJjbGVzLnB1c2goY2lyY2xlKTtcbiAgICB9XG4gICAgdmFyIGdyb3VwID0gbmV3IGZhYnJpYy5Hcm91cChjaXJjbGVzKTtcbiAgICBncm91cC5jYW52YXMgPSB0aGlzLmNhbnZhcztcblxuICAgIHRoaXMuY2FudmFzLmZpcmUoJ2JlZm9yZTpwYXRoOmNyZWF0ZWQnLCB7IHBhdGg6IGdyb3VwIH0pO1xuICAgIHRoaXMuY2FudmFzLmFkZChncm91cCk7XG4gICAgdGhpcy5jYW52YXMuZmlyZSgncGF0aDpjcmVhdGVkJywgeyBwYXRoOiBncm91cCB9KTtcblxuICAgIHRoaXMuY2FudmFzLmNsZWFyQ29udGV4dCh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICB0aGlzLl9yZXNldFNoYWRvdygpO1xuICAgIHRoaXMuY2FudmFzLnJlbmRlck9uQWRkUmVtb3ZlID0gb3JpZ2luYWxSZW5kZXJPbkFkZFJlbW92ZTtcbiAgICB0aGlzLmNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludGVyXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH0gSnVzdCBhZGRlZCBwb2ludGVyIHBvaW50XG4gICAqL1xuICBhZGRQb2ludDogZnVuY3Rpb24ocG9pbnRlcikge1xuICAgIHZhciBwb2ludGVyUG9pbnQgPSBuZXcgZmFicmljLlBvaW50KHBvaW50ZXIueCwgcG9pbnRlci55KSxcblxuICAgICAgICBjaXJjbGVSYWRpdXMgPSBmYWJyaWMudXRpbC5nZXRSYW5kb21JbnQoXG4gICAgICAgICAgTWF0aC5tYXgoMCwgdGhpcy53aWR0aCAtIDIwKSwgdGhpcy53aWR0aCArIDIwKSAvIDIsXG5cbiAgICAgICAgY2lyY2xlQ29sb3IgPSBuZXcgZmFicmljLkNvbG9yKHRoaXMuY29sb3IpXG4gICAgICAgICAgLnNldEFscGhhKGZhYnJpYy51dGlsLmdldFJhbmRvbUludCgwLCAxMDApIC8gMTAwKVxuICAgICAgICAgIC50b1JnYmEoKTtcblxuICAgIHBvaW50ZXJQb2ludC5yYWRpdXMgPSBjaXJjbGVSYWRpdXM7XG4gICAgcG9pbnRlclBvaW50LmZpbGwgPSBjaXJjbGVDb2xvcjtcblxuICAgIHRoaXMucG9pbnRzLnB1c2gocG9pbnRlclBvaW50KTtcblxuICAgIHJldHVybiBwb2ludGVyUG9pbnQ7XG4gIH1cbn0pO1xuXG5cbi8qKlxuICogU3ByYXlCcnVzaCBjbGFzc1xuICogQGNsYXNzIGZhYnJpYy5TcHJheUJydXNoXG4gKi9cbmZhYnJpYy5TcHJheUJydXNoID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoIGZhYnJpYy5CYXNlQnJ1c2gsIC8qKiBAbGVuZHMgZmFicmljLlNwcmF5QnJ1c2gucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogV2lkdGggb2YgYSBzcHJheVxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHdpZHRoOiAgICAgICAgICAgICAgMTAsXG5cbiAgLyoqXG4gICAqIERlbnNpdHkgb2YgYSBzcHJheSAobnVtYmVyIG9mIGRvdHMgcGVyIGNodW5rKVxuICAgKiBAdHlwZSBOdW1iZXJcbiAgICogQGRlZmF1bHRcbiAgICovXG4gIGRlbnNpdHk6ICAgICAgICAgICAgMjAsXG5cbiAgLyoqXG4gICAqIFdpZHRoIG9mIHNwcmF5IGRvdHNcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBkb3RXaWR0aDogICAgICAgICAgIDEsXG5cbiAgLyoqXG4gICAqIFdpZHRoIHZhcmlhbmNlIG9mIHNwcmF5IGRvdHNcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBkb3RXaWR0aFZhcmlhbmNlOiAgIDEsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3BhY2l0eSBvZiBhIGRvdCBzaG91bGQgYmUgcmFuZG9tXG4gICAqIEB0eXBlIEJvb2xlYW5cbiAgICogQGRlZmF1bHRcbiAgICovXG4gIHJhbmRvbU9wYWNpdHk6ICAgICAgICBmYWxzZSxcblxuICAvKipcbiAgICogV2hldGhlciBvdmVybGFwcGluZyBkb3RzIChyZWN0YW5nbGVzKSBzaG91bGQgYmUgcmVtb3ZlZCAoZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMpXG4gICAqIEB0eXBlIEJvb2xlYW5cbiAgICogQGRlZmF1bHRcbiAgICovXG4gIG9wdGltaXplT3ZlcmxhcHBpbmc6ICB0cnVlLFxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge2ZhYnJpYy5DYW52YXN9IGNhbnZhc1xuICAgKiBAcmV0dXJuIHtmYWJyaWMuU3ByYXlCcnVzaH0gSW5zdGFuY2Ugb2YgYSBzcHJheSBicnVzaFxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5zcHJheUNodW5rcyA9IFtdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIG1vdXNlIGRvd25cbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICovXG4gIG9uTW91c2VEb3duOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgdGhpcy5zcHJheUNodW5rcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuY2FudmFzLmNsZWFyQ29udGV4dCh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICB0aGlzLl9zZXRTaGFkb3coKTtcblxuICAgIHRoaXMuYWRkU3ByYXlDaHVuayhwb2ludGVyKTtcbiAgICB0aGlzLnJlbmRlcih0aGlzLnNwcmF5Q2h1bmtQb2ludHMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uIG1vdXNlIG1vdmVcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICovXG4gIG9uTW91c2VNb3ZlOiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgaWYgKHRoaXMubGltaXRlZFRvQ2FudmFzU2l6ZSA9PT0gdHJ1ZSAmJiB0aGlzLl9pc091dFNpZGVDYW52YXMocG9pbnRlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hZGRTcHJheUNodW5rKHBvaW50ZXIpO1xuICAgIHRoaXMucmVuZGVyKHRoaXMuc3ByYXlDaHVua1BvaW50cyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb24gbW91c2UgdXBcbiAgICovXG4gIG9uTW91c2VVcDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9yaWdpbmFsUmVuZGVyT25BZGRSZW1vdmUgPSB0aGlzLmNhbnZhcy5yZW5kZXJPbkFkZFJlbW92ZTtcbiAgICB0aGlzLmNhbnZhcy5yZW5kZXJPbkFkZFJlbW92ZSA9IGZhbHNlO1xuXG4gICAgdmFyIHJlY3RzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWxlbiA9IHRoaXMuc3ByYXlDaHVua3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICB2YXIgc3ByYXlDaHVuayA9IHRoaXMuc3ByYXlDaHVua3NbaV07XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gc3ByYXlDaHVuay5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcblxuICAgICAgICB2YXIgcmVjdCA9IG5ldyBmYWJyaWMuUmVjdCh7XG4gICAgICAgICAgd2lkdGg6IHNwcmF5Q2h1bmtbal0ud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBzcHJheUNodW5rW2pdLndpZHRoLFxuICAgICAgICAgIGxlZnQ6IHNwcmF5Q2h1bmtbal0ueCArIDEsXG4gICAgICAgICAgdG9wOiBzcHJheUNodW5rW2pdLnkgKyAxLFxuICAgICAgICAgIG9yaWdpblg6ICdjZW50ZXInLFxuICAgICAgICAgIG9yaWdpblk6ICdjZW50ZXInLFxuICAgICAgICAgIGZpbGw6IHRoaXMuY29sb3JcbiAgICAgICAgfSk7XG4gICAgICAgIHJlY3RzLnB1c2gocmVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW1pemVPdmVybGFwcGluZykge1xuICAgICAgcmVjdHMgPSB0aGlzLl9nZXRPcHRpbWl6ZWRSZWN0cyhyZWN0cyk7XG4gICAgfVxuXG4gICAgdmFyIGdyb3VwID0gbmV3IGZhYnJpYy5Hcm91cChyZWN0cyk7XG4gICAgdGhpcy5zaGFkb3cgJiYgZ3JvdXAuc2V0KCdzaGFkb3cnLCBuZXcgZmFicmljLlNoYWRvdyh0aGlzLnNoYWRvdykpO1xuICAgIHRoaXMuY2FudmFzLmZpcmUoJ2JlZm9yZTpwYXRoOmNyZWF0ZWQnLCB7IHBhdGg6IGdyb3VwIH0pO1xuICAgIHRoaXMuY2FudmFzLmFkZChncm91cCk7XG4gICAgdGhpcy5jYW52YXMuZmlyZSgncGF0aDpjcmVhdGVkJywgeyBwYXRoOiBncm91cCB9KTtcblxuICAgIHRoaXMuY2FudmFzLmNsZWFyQ29udGV4dCh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKTtcbiAgICB0aGlzLl9yZXNldFNoYWRvdygpO1xuICAgIHRoaXMuY2FudmFzLnJlbmRlck9uQWRkUmVtb3ZlID0gb3JpZ2luYWxSZW5kZXJPbkFkZFJlbW92ZTtcbiAgICB0aGlzLmNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJlY3RzXG4gICAqL1xuICBfZ2V0T3B0aW1pemVkUmVjdHM6IGZ1bmN0aW9uKHJlY3RzKSB7XG5cbiAgICAvLyBhdm9pZCBjcmVhdGluZyBkdXBsaWNhdGUgcmVjdHMgYXQgdGhlIHNhbWUgY29vcmRpbmF0ZXNcbiAgICB2YXIgdW5pcXVlUmVjdHMgPSB7IH0sIGtleSwgaSwgbGVuO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gcmVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGtleSA9IHJlY3RzW2ldLmxlZnQgKyAnJyArIHJlY3RzW2ldLnRvcDtcbiAgICAgIGlmICghdW5pcXVlUmVjdHNba2V5XSkge1xuICAgICAgICB1bmlxdWVSZWN0c1trZXldID0gcmVjdHNbaV07XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB1bmlxdWVSZWN0c0FycmF5ID0gW107XG4gICAgZm9yIChrZXkgaW4gdW5pcXVlUmVjdHMpIHtcbiAgICAgIHVuaXF1ZVJlY3RzQXJyYXkucHVzaCh1bmlxdWVSZWN0c1trZXldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5pcXVlUmVjdHNBcnJheTtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVyIG5ldyBjaHVuayBvZiBzcHJheSBicnVzaFxuICAgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbihzcHJheUNodW5rKSB7XG4gICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3AsIGksIGxlbjtcbiAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5jb2xvcjtcblxuICAgIHRoaXMuX3NhdmVBbmRUcmFuc2Zvcm0oY3R4KTtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IHNwcmF5Q2h1bmsubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBwb2ludCA9IHNwcmF5Q2h1bmtbaV07XG4gICAgICBpZiAodHlwZW9mIHBvaW50Lm9wYWNpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHBvaW50Lm9wYWNpdHk7XG4gICAgICB9XG4gICAgICBjdHguZmlsbFJlY3QocG9pbnQueCwgcG9pbnQueSwgcG9pbnQud2lkdGgsIHBvaW50LndpZHRoKTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVyIGFsbCBzcHJheSBjaHVua3NcbiAgICovXG4gIF9yZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLCBpLCBpbGVuO1xuICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yO1xuXG4gICAgdGhpcy5fc2F2ZUFuZFRyYW5zZm9ybShjdHgpO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRoaXMuc3ByYXlDaHVua3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICB0aGlzLnJlbmRlcih0aGlzLnNwcmF5Q2h1bmtzW2ldKTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJcbiAgICovXG4gIGFkZFNwcmF5Q2h1bms6IGZ1bmN0aW9uKHBvaW50ZXIpIHtcbiAgICB0aGlzLnNwcmF5Q2h1bmtQb2ludHMgPSBbXTtcblxuICAgIHZhciB4LCB5LCB3aWR0aCwgcmFkaXVzID0gdGhpcy53aWR0aCAvIDIsIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5kZW5zaXR5OyBpKyspIHtcblxuICAgICAgeCA9IGZhYnJpYy51dGlsLmdldFJhbmRvbUludChwb2ludGVyLnggLSByYWRpdXMsIHBvaW50ZXIueCArIHJhZGl1cyk7XG4gICAgICB5ID0gZmFicmljLnV0aWwuZ2V0UmFuZG9tSW50KHBvaW50ZXIueSAtIHJhZGl1cywgcG9pbnRlci55ICsgcmFkaXVzKTtcblxuICAgICAgaWYgKHRoaXMuZG90V2lkdGhWYXJpYW5jZSkge1xuICAgICAgICB3aWR0aCA9IGZhYnJpYy51dGlsLmdldFJhbmRvbUludChcbiAgICAgICAgICAvLyBib3R0b20gY2xhbXAgd2lkdGggdG8gMVxuICAgICAgICAgIE1hdGgubWF4KDEsIHRoaXMuZG90V2lkdGggLSB0aGlzLmRvdFdpZHRoVmFyaWFuY2UpLFxuICAgICAgICAgIHRoaXMuZG90V2lkdGggKyB0aGlzLmRvdFdpZHRoVmFyaWFuY2UpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHdpZHRoID0gdGhpcy5kb3RXaWR0aDtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvaW50ID0gbmV3IGZhYnJpYy5Qb2ludCh4LCB5KTtcbiAgICAgIHBvaW50LndpZHRoID0gd2lkdGg7XG5cbiAgICAgIGlmICh0aGlzLnJhbmRvbU9wYWNpdHkpIHtcbiAgICAgICAgcG9pbnQub3BhY2l0eSA9IGZhYnJpYy51dGlsLmdldFJhbmRvbUludCgwLCAxMDApIC8gMTAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNwcmF5Q2h1bmtQb2ludHMucHVzaChwb2ludCk7XG4gICAgfVxuXG4gICAgdGhpcy5zcHJheUNodW5rcy5wdXNoKHRoaXMuc3ByYXlDaHVua1BvaW50cyk7XG4gIH1cbn0pO1xuXG5cbi8qKlxuICogUGF0dGVybkJydXNoIGNsYXNzXG4gKiBAY2xhc3MgZmFicmljLlBhdHRlcm5CcnVzaFxuICogQGV4dGVuZHMgZmFicmljLkJhc2VCcnVzaFxuICovXG5mYWJyaWMuUGF0dGVybkJydXNoID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLlBlbmNpbEJydXNoLCAvKiogQGxlbmRzIGZhYnJpYy5QYXR0ZXJuQnJ1c2gucHJvdG90eXBlICovIHtcblxuICBnZXRQYXR0ZXJuU3JjOiBmdW5jdGlvbigpIHtcblxuICAgIHZhciBkb3RXaWR0aCA9IDIwLFxuICAgICAgICBkb3REaXN0YW5jZSA9IDUsXG4gICAgICAgIHBhdHRlcm5DYW52YXMgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCksXG4gICAgICAgIHBhdHRlcm5DdHggPSBwYXR0ZXJuQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICBwYXR0ZXJuQ2FudmFzLndpZHRoID0gcGF0dGVybkNhbnZhcy5oZWlnaHQgPSBkb3RXaWR0aCArIGRvdERpc3RhbmNlO1xuXG4gICAgcGF0dGVybkN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgIHBhdHRlcm5DdHguYmVnaW5QYXRoKCk7XG4gICAgcGF0dGVybkN0eC5hcmMoZG90V2lkdGggLyAyLCBkb3RXaWR0aCAvIDIsIGRvdFdpZHRoIC8gMiwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcbiAgICBwYXR0ZXJuQ3R4LmNsb3NlUGF0aCgpO1xuICAgIHBhdHRlcm5DdHguZmlsbCgpO1xuXG4gICAgcmV0dXJuIHBhdHRlcm5DYW52YXM7XG4gIH0sXG5cbiAgZ2V0UGF0dGVyblNyY0Z1bmN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gU3RyaW5nKHRoaXMuZ2V0UGF0dGVyblNyYykucmVwbGFjZSgndGhpcy5jb2xvcicsICdcIicgKyB0aGlzLmNvbG9yICsgJ1wiJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgXCJwYXR0ZXJuXCIgaW5zdGFuY2UgcHJvcGVydHlcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKi9cbiAgZ2V0UGF0dGVybjogZnVuY3Rpb24oY3R4KSB7XG4gICAgcmV0dXJuIGN0eC5jcmVhdGVQYXR0ZXJuKHRoaXMuc291cmNlIHx8IHRoaXMuZ2V0UGF0dGVyblNyYygpLCAncmVwZWF0Jyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYnJ1c2ggc3R5bGVzXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICovXG4gIF9zZXRCcnVzaFN0eWxlczogZnVuY3Rpb24oY3R4KSB7XG4gICAgdGhpcy5jYWxsU3VwZXIoJ19zZXRCcnVzaFN0eWxlcycsIGN0eCk7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5nZXRQYXR0ZXJuKGN0eCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgcGF0aFxuICAgKi9cbiAgY3JlYXRlUGF0aDogZnVuY3Rpb24ocGF0aERhdGEpIHtcbiAgICB2YXIgcGF0aCA9IHRoaXMuY2FsbFN1cGVyKCdjcmVhdGVQYXRoJywgcGF0aERhdGEpLFxuICAgICAgICB0b3BMZWZ0ID0gcGF0aC5fZ2V0TGVmdFRvcENvb3JkcygpLnNjYWxhckFkZChwYXRoLnN0cm9rZVdpZHRoIC8gMik7XG5cbiAgICBwYXRoLnN0cm9rZSA9IG5ldyBmYWJyaWMuUGF0dGVybih7XG4gICAgICBzb3VyY2U6IHRoaXMuc291cmNlIHx8IHRoaXMuZ2V0UGF0dGVyblNyY0Z1bmN0aW9uKCksXG4gICAgICBvZmZzZXRYOiAtdG9wTGVmdC54LFxuICAgICAgb2Zmc2V0WTogLXRvcExlZnQueVxuICAgIH0pO1xuICAgIHJldHVybiBwYXRoO1xuICB9XG59KTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGdldFBvaW50ZXIgPSBmYWJyaWMudXRpbC5nZXRQb2ludGVyLFxuICAgICAgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMsXG4gICAgICBpc1RvdWNoRXZlbnQgPSBmYWJyaWMudXRpbC5pc1RvdWNoRXZlbnQ7XG5cbiAgLyoqXG4gICAqIENhbnZhcyBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkNhbnZhc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuU3RhdGljQ2FudmFzXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0xI2NhbnZhc31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkNhbnZhcyNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKlxuICAgKiBAZmlyZXMgb2JqZWN0Om1vZGlmaWVkIGF0IHRoZSBlbmQgb2YgYSB0cmFuc2Zvcm0gb3IgYW55IGNoYW5nZSB3aGVuIHN0YXRlZnVsbCBpcyB0cnVlXG4gICAqIEBmaXJlcyBvYmplY3Q6cm90YXRpbmcgd2hpbGUgYW4gb2JqZWN0IGlzIGJlaW5nIHJvdGF0ZWQgZnJvbSB0aGUgY29udHJvbFxuICAgKiBAZmlyZXMgb2JqZWN0OnNjYWxpbmcgd2hpbGUgYW4gb2JqZWN0IGlzIGJlaW5nIHNjYWxlZCBieSBjb250cm9sc1xuICAgKiBAZmlyZXMgb2JqZWN0Om1vdmluZyB3aGlsZSBhbiBvYmplY3QgaXMgYmVpbmcgZHJhZ2dlZFxuICAgKiBAZmlyZXMgb2JqZWN0OnNrZXdpbmcgd2hpbGUgYW4gb2JqZWN0IGlzIGJlaW5nIHNrZXdlZCBmcm9tIHRoZSBjb250cm9sc1xuICAgKlxuICAgKiBAZmlyZXMgYmVmb3JlOnRyYW5zZm9ybSBiZWZvcmUgYSB0cmFuc2Zvcm0gaXMgaXMgc3RhcnRlZFxuICAgKiBAZmlyZXMgYmVmb3JlOnNlbGVjdGlvbjpjbGVhcmVkXG4gICAqIEBmaXJlcyBzZWxlY3Rpb246Y2xlYXJlZFxuICAgKiBAZmlyZXMgc2VsZWN0aW9uOnVwZGF0ZWRcbiAgICogQGZpcmVzIHNlbGVjdGlvbjpjcmVhdGVkXG4gICAqXG4gICAqIEBmaXJlcyBwYXRoOmNyZWF0ZWQgYWZ0ZXIgYSBkcmF3aW5nIG9wZXJhdGlvbiBlbmRzIGFuZCB0aGUgcGF0aCBpcyBhZGRlZFxuICAgKiBAZmlyZXMgbW91c2U6ZG93blxuICAgKiBAZmlyZXMgbW91c2U6bW92ZVxuICAgKiBAZmlyZXMgbW91c2U6dXBcbiAgICogQGZpcmVzIG1vdXNlOmRvd246YmVmb3JlICBvbiBtb3VzZSBkb3duLCBiZWZvcmUgdGhlIGlubmVyIGZhYnJpYyBsb2dpYyBydW5zXG4gICAqIEBmaXJlcyBtb3VzZTptb3ZlOmJlZm9yZSBvbiBtb3VzZSBtb3ZlLCBiZWZvcmUgdGhlIGlubmVyIGZhYnJpYyBsb2dpYyBydW5zXG4gICAqIEBmaXJlcyBtb3VzZTp1cDpiZWZvcmUgb24gbW91c2UgdXAsIGJlZm9yZSB0aGUgaW5uZXIgZmFicmljIGxvZ2ljIHJ1bnNcbiAgICogQGZpcmVzIG1vdXNlOm92ZXJcbiAgICogQGZpcmVzIG1vdXNlOm91dFxuICAgKiBAZmlyZXMgbW91c2U6ZGJsY2xpY2sgd2hlbmV2ZXIgYSBuYXRpdmUgZGJsIGNsaWNrIGV2ZW50IGZpcmVzIG9uIHRoZSBjYW52YXMuXG4gICAqXG4gICAqIEBmaXJlcyBkcmFnb3ZlclxuICAgKiBAZmlyZXMgZHJhZ2VudGVyXG4gICAqIEBmaXJlcyBkcmFnbGVhdmVcbiAgICogQGZpcmVzIGRyb3A6YmVmb3JlIGJlZm9yZSBkcm9wIGV2ZW50LiBzYW1lIG5hdGl2ZSBldmVudC4gVGhpcyBpcyBhZGRlZCB0byBoYW5kbGUgZWRnZSBjYXNlc1xuICAgKiBAZmlyZXMgZHJvcFxuICAgKiBAZmlyZXMgYWZ0ZXI6cmVuZGVyIGF0IHRoZSBlbmQgb2YgdGhlIHJlbmRlciBwcm9jZXNzLCByZWNlaXZlcyB0aGUgY29udGV4dCBpbiB0aGUgY2FsbGJhY2tcbiAgICogQGZpcmVzIGJlZm9yZTpyZW5kZXIgYXQgc3RhcnQgdGhlIHJlbmRlciBwcm9jZXNzLCByZWNlaXZlcyB0aGUgY29udGV4dCBpbiB0aGUgY2FsbGJhY2tcbiAgICpcbiAgICovXG4gIGZhYnJpYy5DYW52YXMgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuU3RhdGljQ2FudmFzLCAvKiogQGxlbmRzIGZhYnJpYy5DYW52YXMucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IFN0cmluZ30gZWwgJmx0O2NhbnZhcz4gZWxlbWVudCB0byBpbml0aWFsaXplIGluc3RhbmNlIG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGVsLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcbiAgICAgIHRoaXMucmVuZGVyQW5kUmVzZXRCb3VuZCA9IHRoaXMucmVuZGVyQW5kUmVzZXQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMucmVxdWVzdFJlbmRlckFsbEJvdW5kID0gdGhpcy5yZXF1ZXN0UmVuZGVyQWxsLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9pbml0U3RhdGljKGVsLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX2luaXRJbnRlcmFjdGl2ZSgpO1xuICAgICAgdGhpcy5fY3JlYXRlQ2FjaGVDYW52YXMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBvYmplY3RzIGNhbiBiZSB0cmFuc2Zvcm1lZCBieSBvbmUgc2lkZSAodW5wcm9wb3J0aW9uYWxseSlcbiAgICAgKiB3aGVuIGRyYWdnZWQgb24gdGhlIGNvcm5lcnMgdGhhdCBub3JtYWxseSB3b3VsZCBub3QgZG8gdGhhdC5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAc2luY2UgZmFicmljIDQuMCAvLyBjaGFuZ2VkIG5hbWUgYW5kIGRlZmF1bHQgdmFsdWVcbiAgICAgKi9cbiAgICB1bmlmb3JtU2NhbGluZzogICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoaWNoIGtleSBzd2l0Y2hlcyB1bmlmb3JtIHNjYWxpbmcuXG4gICAgICogdmFsdWVzOiAnYWx0S2V5JywgJ3NoaWZ0S2V5JywgJ2N0cmxLZXknLlxuICAgICAqIElmIGBudWxsYCBvciAnbm9uZScgb3IgYW55IG90aGVyIHN0cmluZyB0aGF0IGlzIG5vdCBhIG1vZGlmaWVyIGtleVxuICAgICAqIGZlYXR1cmUgaXMgZGlzYWJsZWQuXG4gICAgICogdG90YWxseSB3cm9uZyBuYW1lZC4gdGhpcyBzb3VuZHMgbGlrZSBgdW5pZm9ybSBzY2FsaW5nYFxuICAgICAqIGlmIENhbnZhcy51bmlmb3JtU2NhbGluZyBpcyB0cnVlLCBwcmVzc2luZyB0aGlzIHdpbGwgc2V0IGl0IHRvIGZhbHNlXG4gICAgICogYW5kIHZpY2V2ZXJzYS5cbiAgICAgKiBAc2luY2UgMS42LjJcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHVuaVNjYWxlS2V5OiAgICAgICAgICAgJ3NoaWZ0S2V5JyxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgb2JqZWN0cyB1c2UgY2VudGVyIHBvaW50IGFzIHRoZSBvcmlnaW4gb2Ygc2NhbGUgdHJhbnNmb3JtYXRpb24uXG4gICAgICogPGI+QmFja3dhcmRzIGluY29tcGF0aWJpbGl0eSBub3RlOjwvYj4gVGhpcyBwcm9wZXJ0eSByZXBsYWNlcyBcImNlbnRlclRyYW5zZm9ybVwiIChCb29sZWFuKS5cbiAgICAgKiBAc2luY2UgMS4zLjRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjZW50ZXJlZFNjYWxpbmc6ICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgb2JqZWN0cyB1c2UgY2VudGVyIHBvaW50IGFzIHRoZSBvcmlnaW4gb2Ygcm90YXRlIHRyYW5zZm9ybWF0aW9uLlxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgcmVwbGFjZXMgXCJjZW50ZXJUcmFuc2Zvcm1cIiAoQm9vbGVhbikuXG4gICAgICogQHNpbmNlIDEuMy40XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2VudGVyZWRSb3RhdGlvbjogICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hpY2gga2V5IGVuYWJsZSBjZW50ZXJlZCBUcmFuc2Zvcm1cbiAgICAgKiB2YWx1ZXM6ICdhbHRLZXknLCAnc2hpZnRLZXknLCAnY3RybEtleScuXG4gICAgICogSWYgYG51bGxgIG9yICdub25lJyBvciBhbnkgb3RoZXIgc3RyaW5nIHRoYXQgaXMgbm90IGEgbW9kaWZpZXIga2V5XG4gICAgICogZmVhdHVyZSBpcyBkaXNhYmxlZCBmZWF0dXJlIGRpc2FibGVkLlxuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2VudGVyZWRLZXk6ICAgICAgICAgICAnYWx0S2V5JyxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGljaCBrZXkgZW5hYmxlIGFsdGVybmF0ZSBhY3Rpb24gb24gY29ybmVyXG4gICAgICogdmFsdWVzOiAnYWx0S2V5JywgJ3NoaWZ0S2V5JywgJ2N0cmxLZXknLlxuICAgICAqIElmIGBudWxsYCBvciAnbm9uZScgb3IgYW55IG90aGVyIHN0cmluZyB0aGF0IGlzIG5vdCBhIG1vZGlmaWVyIGtleVxuICAgICAqIGZlYXR1cmUgaXMgZGlzYWJsZWQgZmVhdHVyZSBkaXNhYmxlZC5cbiAgICAgKiBAc2luY2UgMS42LjJcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGFsdEFjdGlvbktleTogICAgICAgICAgICdzaGlmdEtleScsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCBjYW52YXMgaXMgaW50ZXJhY3RpdmUuIFRoaXMgcHJvcGVydHkgc2hvdWxkIG5vdCBiZSBjaGFuZ2VkLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGludGVyYWN0aXZlOiAgICAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBncm91cCBzZWxlY3Rpb24gc2hvdWxkIGJlIGVuYWJsZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb246ICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoaWNoIGtleSBvciBrZXlzIGVuYWJsZSBtdWx0aXBsZSBjbGljayBzZWxlY3Rpb25cbiAgICAgKiBQYXNzIHZhbHVlIGFzIGEgc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3NcbiAgICAgKiB2YWx1ZXM6ICdhbHRLZXknLCAnc2hpZnRLZXknLCAnY3RybEtleScuXG4gICAgICogSWYgYG51bGxgIG9yIGVtcHR5IG9yIGNvbnRhaW5pbmcgYW55IG90aGVyIHN0cmluZyB0aGF0IGlzIG5vdCBhIG1vZGlmaWVyIGtleVxuICAgICAqIGZlYXR1cmUgaXMgZGlzYWJsZWQuXG4gICAgICogQHNpbmNlIDEuNi4yXG4gICAgICogQHR5cGUgU3RyaW5nfEFycmF5XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25LZXk6ICAgICAgICAgICAnc2hpZnRLZXknLFxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoaWNoIGtleSBlbmFibGUgYWx0ZXJuYXRpdmUgc2VsZWN0aW9uXG4gICAgICogaW4gY2FzZSBvZiB0YXJnZXQgb3ZlcmxhcHBpbmcgd2l0aCBhY3RpdmUgb2JqZWN0XG4gICAgICogdmFsdWVzOiAnYWx0S2V5JywgJ3NoaWZ0S2V5JywgJ2N0cmxLZXknLlxuICAgICAqIEZvciBhIHNlcmllcyBvZiByZWFzb24gdGhhdCBjb21lIGZyb20gdGhlIGdlbmVyYWwgZXhwZWN0YXRpb25zIG9uIGhvd1xuICAgICAqIHRoaW5ncyBzaG91bGQgd29yaywgdGhpcyBmZWF0dXJlIHdvcmtzIG9ubHkgZm9yIHByZXNlcnZlT2JqZWN0U3RhY2tpbmcgdHJ1ZS5cbiAgICAgKiBJZiBgbnVsbGAgb3IgJ25vbmUnIG9yIGFueSBvdGhlciBzdHJpbmcgdGhhdCBpcyBub3QgYSBtb2RpZmllciBrZXlcbiAgICAgKiBmZWF0dXJlIGlzIGRpc2FibGVkLlxuICAgICAqIEBzaW5jZSAxLjYuNVxuICAgICAqIEB0eXBlIG51bGx8U3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBhbHRTZWxlY3Rpb25LZXk6ICAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3Igb2Ygc2VsZWN0aW9uXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25Db2xvcjogICAgICAgICAncmdiYSgxMDAsIDEwMCwgMjU1LCAwLjMpJywgLy8gYmx1ZVxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBkYXNoIGFycmF5IHBhdHRlcm5cbiAgICAgKiBJZiBub3QgZW1wdHkgdGhlIHNlbGVjdGlvbiBib3JkZXIgaXMgZGFzaGVkXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25EYXNoQXJyYXk6ICAgICBbXSxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIHRoZSBib3JkZXIgb2Ygc2VsZWN0aW9uICh1c3VhbGx5IHNsaWdodGx5IGRhcmtlciB0aGFuIGNvbG9yIG9mIHNlbGVjdGlvbiBpdHNlbGYpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25Cb3JkZXJDb2xvcjogICAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjMpJyxcblxuICAgIC8qKlxuICAgICAqIFdpZHRoIG9mIGEgbGluZSB1c2VkIGluIG9iamVjdC9ncm91cCBzZWxlY3Rpb25cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvbkxpbmVXaWR0aDogICAgIDEsXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3Qgb25seSBzaGFwZXMgdGhhdCBhcmUgZnVsbHkgY29udGFpbmVkIGluIHRoZSBkcmFnZ2VkIHNlbGVjdGlvbiByZWN0YW5nbGUuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uRnVsbHlDb250YWluZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBjdXJzb3IgdmFsdWUgdXNlZCB3aGVuIGhvdmVyaW5nIG92ZXIgYW4gb2JqZWN0IG9uIGNhbnZhc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaG92ZXJDdXJzb3I6ICAgICAgICAgICAgJ21vdmUnLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBjdXJzb3IgdmFsdWUgdXNlZCB3aGVuIG1vdmluZyBhbiBvYmplY3Qgb24gY2FudmFzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtb3ZlQ3Vyc29yOiAgICAgICAgICAgICAnbW92ZScsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGN1cnNvciB2YWx1ZSB1c2VkIGZvciB0aGUgZW50aXJlIGNhbnZhc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZGVmYXVsdEN1cnNvcjogICAgICAgICAgJ2RlZmF1bHQnLFxuXG4gICAgLyoqXG4gICAgICogQ3Vyc29yIHZhbHVlIHVzZWQgZHVyaW5nIGZyZWUgZHJhd2luZ1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZnJlZURyYXdpbmdDdXJzb3I6ICAgICAgJ2Nyb3NzaGFpcicsXG5cbiAgICAvKipcbiAgICAgKiBDdXJzb3IgdmFsdWUgdXNlZCBmb3IgZGlzYWJsZWQgZWxlbWVudHMgKCBjb3JuZXJzIHdpdGggZGlzYWJsZWQgYWN0aW9uIClcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG5vdEFsbG93ZWRDdXJzb3I6ICAgICAgICAgJ25vdC1hbGxvd2VkJyxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgZWxlbWVudCBjbGFzcyB0aGF0J3MgZ2l2ZW4gdG8gd3JhcHBlciAoZGl2KSBlbGVtZW50IG9mIGNhbnZhc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29udGFpbmVyQ2xhc3M6ICAgICAgICAgJ2NhbnZhcy1jb250YWluZXInLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBvYmplY3QgZGV0ZWN0aW9uIGhhcHBlbnMgb24gcGVyLXBpeGVsIGJhc2lzIHJhdGhlciB0aGFuIG9uIHBlci1ib3VuZGluZy1ib3hcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwZXJQaXhlbFRhcmdldEZpbmQ6ICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiBwaXhlbHMgYXJvdW5kIHRhcmdldCBwaXhlbCB0byB0b2xlcmF0ZSAoY29uc2lkZXIgYWN0aXZlKSBkdXJpbmcgb2JqZWN0IGRldGVjdGlvblxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdGFyZ2V0RmluZFRvbGVyYW5jZTogICAgMCxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgdGFyZ2V0IGRldGVjdGlvbiBpcyBza2lwcGVkLiBUYXJnZXQgZGV0ZWN0aW9uIHdpbGwgcmV0dXJuIGFsd2F5cyB1bmRlZmluZWQuXG4gICAgICogY2xpY2sgc2VsZWN0aW9uIHdvbid0IHdvcmsgYW55bW9yZSwgZXZlbnRzIHdpbGwgZmlyZSB3aXRoIG5vIHRhcmdldHMuXG4gICAgICogaWYgc29tZXRoaW5nIGlzIHNlbGVjdGVkIGJlZm9yZSBzZXR0aW5nIGl0IHRvIHRydWUsIGl0IHdpbGwgYmUgZGVzZWxlY3RlZCBhdCB0aGUgZmlyc3QgY2xpY2suXG4gICAgICogYXJlYSBzZWxlY3Rpb24gd2lsbCBzdGlsbCB3b3JrLiBjaGVjayB0aGUgYHNlbGVjdGlvbmAgcHJvcGVydHkgdG9vLlxuICAgICAqIGlmIHlvdSBkZWFjdGl2YXRlIGJvdGgsIHlvdSBzaG91bGQgbG9vayBpbnRvIHN0YXRpY0NhbnZhcy5cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBza2lwVGFyZ2V0RmluZDogICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgbW91c2UgZXZlbnRzIG9uIGNhbnZhcyAobW91c2Vkb3duL21vdXNlbW92ZS9tb3VzZXVwKSByZXN1bHQgaW4gZnJlZSBkcmF3aW5nLlxuICAgICAqIEFmdGVyIG1vdXNlZG93biwgbW91c2Vtb3ZlIGNyZWF0ZXMgYSBzaGFwZSxcbiAgICAgKiBhbmQgdGhlbiBtb3VzZXVwIGZpbmFsaXplcyBpdCBhbmQgYWRkcyBhbiBpbnN0YW5jZSBvZiBgZmFicmljLlBhdGhgIG9udG8gY2FudmFzLlxuICAgICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC00I2ZyZWVfZHJhd2luZ31cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpc0RyYXdpbmdNb2RlOiAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIG9iamVjdHMgc2hvdWxkIHJlbWFpbiBpbiBjdXJyZW50IHN0YWNrIHBvc2l0aW9uIHdoZW4gc2VsZWN0ZWQuXG4gICAgICogV2hlbiBmYWxzZSBvYmplY3RzIGFyZSBicm91Z2h0IHRvIHRvcCBhbmQgcmVuZGVyZWQgYXMgcGFydCBvZiB0aGUgc2VsZWN0aW9uIGdyb3VwXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcHJlc2VydmVPYmplY3RTdGFja2luZzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIGFuZ2xlIHRoYXQgYW4gb2JqZWN0IHdpbGwgbG9jayB0byB3aGlsZSByb3RhdGluZy5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAc2luY2UgMS42LjdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNuYXBBbmdsZTogMCxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgc25hcEFuZ2xlIHRoZSByb3RhdGlvbiB3aWxsIGxvY2sgdG8gdGhlIHNuYXBBbmdsZS5cbiAgICAgKiBXaGVuIGBudWxsYCwgdGhlIHNuYXBUaHJlc2hvbGQgd2lsbCBkZWZhdWx0IHRvIHRoZSBzbmFwQW5nbGUuXG4gICAgICogQHR5cGUgbnVsbHxOdW1iZXJcbiAgICAgKiBAc2luY2UgMS42LjdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNuYXBUaHJlc2hvbGQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIHJpZ2h0IGNsaWNrIG9uIGNhbnZhcyBjYW4gb3V0cHV0IHRoZSBjb250ZXh0IG1lbnUgb3Igbm90XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBzaW5jZSAxLjYuNVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3RvcENvbnRleHRNZW51OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB0aGUgY2FudmFzIGNhbiBmaXJlIHJpZ2h0IGNsaWNrIGV2ZW50c1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAc2luY2UgMS42LjVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZpcmVSaWdodENsaWNrOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB0aGUgY2FudmFzIGNhbiBmaXJlIG1pZGRsZSBjbGljayBldmVudHNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQHNpbmNlIDEuNy44XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmaXJlTWlkZGxlQ2xpY2s6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogS2VlcCB0cmFjayBvZiB0aGUgc3ViVGFyZ2V0cyBmb3IgTW91c2UgRXZlbnRzXG4gICAgICogQHR5cGUgZmFicmljLk9iamVjdFtdXG4gICAgICovXG4gICAgdGFyZ2V0czogW10sXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBvcHRpb24gaXMgZW5hYmxlZCwgUG9pbnRlckV2ZW50IGlzIHVzZWQgaW5zdGVhZCBvZiBNb3VzZUV2ZW50LlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGVuYWJsZVBvaW50ZXJFdmVudHM6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogS2VlcCB0cmFjayBvZiB0aGUgaG92ZXJlZCB0YXJnZXRcbiAgICAgKiBAdHlwZSBmYWJyaWMuT2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaG92ZXJlZFRhcmdldDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGhvbGQgdGhlIGxpc3Qgb2YgbmVzdGVkIHRhcmdldHMgaG92ZXJlZFxuICAgICAqIEB0eXBlIGZhYnJpYy5PYmplY3RbXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2hvdmVyZWRUYXJnZXRzOiBbXSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRJbnRlcmFjdGl2ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9jdXJyZW50VHJhbnNmb3JtID0gbnVsbDtcbiAgICAgIHRoaXMuX2dyb3VwU2VsZWN0b3IgPSBudWxsO1xuICAgICAgdGhpcy5faW5pdFdyYXBwZXJFbGVtZW50KCk7XG4gICAgICB0aGlzLl9jcmVhdGVVcHBlckNhbnZhcygpO1xuICAgICAgdGhpcy5faW5pdEV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgICAgIHRoaXMuX2luaXRSZXRpbmFTY2FsaW5nKCk7XG5cbiAgICAgIHRoaXMuZnJlZURyYXdpbmdCcnVzaCA9IGZhYnJpYy5QZW5jaWxCcnVzaCAmJiBuZXcgZmFicmljLlBlbmNpbEJydXNoKHRoaXMpO1xuXG4gICAgICB0aGlzLmNhbGNPZmZzZXQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGl2aWRlcyBvYmplY3RzIGluIHR3byBncm91cHMsIG9uZSB0byByZW5kZXIgaW1tZWRpYXRlbHlcbiAgICAgKiBhbmQgb25lIHRvIHJlbmRlciBhcyBhY3RpdmVHcm91cC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gb2JqZWN0cyB0byByZW5kZXIgaW1tZWRpYXRlbHkgYW5kIHB1c2hlcyB0aGUgb3RoZXIgaW4gdGhlIGFjdGl2ZUdyb3VwLlxuICAgICAqL1xuICAgIF9jaG9vc2VPYmplY3RzVG9SZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFjdGl2ZU9iamVjdHMgPSB0aGlzLmdldEFjdGl2ZU9iamVjdHMoKSxcbiAgICAgICAgICBvYmplY3QsIG9ianNUb1JlbmRlciwgYWN0aXZlR3JvdXBPYmplY3RzO1xuXG4gICAgICBpZiAoYWN0aXZlT2JqZWN0cy5sZW5ndGggPiAwICYmICF0aGlzLnByZXNlcnZlT2JqZWN0U3RhY2tpbmcpIHtcbiAgICAgICAgb2Jqc1RvUmVuZGVyID0gW107XG4gICAgICAgIGFjdGl2ZUdyb3VwT2JqZWN0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIG9iamVjdCA9IHRoaXMuX29iamVjdHNbaV07XG4gICAgICAgICAgaWYgKGFjdGl2ZU9iamVjdHMuaW5kZXhPZihvYmplY3QpID09PSAtMSApIHtcbiAgICAgICAgICAgIG9ianNUb1JlbmRlci5wdXNoKG9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWN0aXZlR3JvdXBPYmplY3RzLnB1c2gob2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGl2ZU9iamVjdHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdC5fb2JqZWN0cyA9IGFjdGl2ZUdyb3VwT2JqZWN0cztcbiAgICAgICAgfVxuICAgICAgICBvYmpzVG9SZW5kZXIucHVzaC5hcHBseShvYmpzVG9SZW5kZXIsIGFjdGl2ZUdyb3VwT2JqZWN0cyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgb2Jqc1RvUmVuZGVyID0gdGhpcy5fb2JqZWN0cztcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmpzVG9SZW5kZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYm90aCB0aGUgdG9wIGNhbnZhcyBhbmQgdGhlIHNlY29uZGFyeSBjb250YWluZXIgY2FudmFzLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IGluc3RhbmNlXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlbmRlckFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuY29udGV4dFRvcERpcnR5ICYmICF0aGlzLl9ncm91cFNlbGVjdG9yICYmICF0aGlzLmlzRHJhd2luZ01vZGUpIHtcbiAgICAgICAgdGhpcy5jbGVhckNvbnRleHQodGhpcy5jb250ZXh0VG9wKTtcbiAgICAgICAgdGhpcy5jb250ZXh0VG9wRGlydHkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhhc0xvc3RDb250ZXh0KSB7XG4gICAgICAgIHRoaXMucmVuZGVyVG9wTGF5ZXIodGhpcy5jb250ZXh0VG9wKTtcbiAgICAgICAgdGhpcy5oYXNMb3N0Q29udGV4dCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGNhbnZhc1RvRHJhd09uID0gdGhpcy5jb250ZXh0Q29udGFpbmVyO1xuICAgICAgdGhpcy5yZW5kZXJDYW52YXMoY2FudmFzVG9EcmF3T24sIHRoaXMuX2Nob29zZU9iamVjdHNUb1JlbmRlcigpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZW5kZXJUb3BMYXllcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgaWYgKHRoaXMuaXNEcmF3aW5nTW9kZSAmJiB0aGlzLl9pc0N1cnJlbnRseURyYXdpbmcpIHtcbiAgICAgICAgdGhpcy5mcmVlRHJhd2luZ0JydXNoICYmIHRoaXMuZnJlZURyYXdpbmdCcnVzaC5fcmVuZGVyKCk7XG4gICAgICAgIHRoaXMuY29udGV4dFRvcERpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIHdlIHJlbmRlciB0aGUgdG9wIGNvbnRleHQgLSBsYXN0IG9iamVjdFxuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uICYmIHRoaXMuX2dyb3VwU2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5fZHJhd1NlbGVjdGlvbihjdHgpO1xuICAgICAgICB0aGlzLmNvbnRleHRUb3BEaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gcmVuZGVyIG9ubHkgdGhlIHRvcCBjYW52YXMuXG4gICAgICogQWxzbyB1c2VkIHRvIHJlbmRlciB0aGUgZ3JvdXAgc2VsZWN0aW9uIGJveC5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHJlbmRlclRvcDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dFRvcDtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0KGN0eCk7XG4gICAgICB0aGlzLnJlbmRlclRvcExheWVyKGN0eCk7XG4gICAgICB0aGlzLmZpcmUoJ2FmdGVyOnJlbmRlcicpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX25vcm1hbGl6ZVBvaW50ZXI6IGZ1bmN0aW9uIChvYmplY3QsIHBvaW50ZXIpIHtcbiAgICAgIHZhciBtID0gb2JqZWN0LmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSxcbiAgICAgICAgICBpbnZlcnRlZE0gPSBmYWJyaWMudXRpbC5pbnZlcnRUcmFuc2Zvcm0obSksXG4gICAgICAgICAgdnB0UG9pbnRlciA9IHRoaXMucmVzdG9yZVBvaW50ZXJWcHQocG9pbnRlcik7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQodnB0UG9pbnRlciwgaW52ZXJ0ZWRNKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBpcyB0cmFuc3BhcmVudCBhdCBhIGNlcnRhaW4gbG9jYXRpb25cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHRhcmdldCBPYmplY3QgdG8gY2hlY2tcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBMZWZ0IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSBUb3AgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNUYXJnZXRUcmFuc3BhcmVudDogZnVuY3Rpb24gKHRhcmdldCwgeCwgeSkge1xuICAgICAgLy8gaW4gY2FzZSB0aGUgdGFyZ2V0IGlzIHRoZSBhY3RpdmVPYmplY3QsIHdlIGNhbm5vdCBleGVjdXRlIHRoaXMgb3B0aW1pemF0aW9uXG4gICAgICAvLyBiZWNhdXNlIHdlIG5lZWQgdG8gZHJhdyBjb250cm9scyB0b28uXG4gICAgICBpZiAodGFyZ2V0LnNob3VsZENhY2hlKCkgJiYgdGFyZ2V0Ll9jYWNoZUNhbnZhcyAmJiB0YXJnZXQgIT09IHRoaXMuX2FjdGl2ZU9iamVjdCkge1xuICAgICAgICB2YXIgbm9ybWFsaXplZFBvaW50ZXIgPSB0aGlzLl9ub3JtYWxpemVQb2ludGVyKHRhcmdldCwge3g6IHgsIHk6IHl9KSxcbiAgICAgICAgICAgIHRhcmdldFJlbGF0aXZlWCA9IE1hdGgubWF4KHRhcmdldC5jYWNoZVRyYW5zbGF0aW9uWCArIChub3JtYWxpemVkUG9pbnRlci54ICogdGFyZ2V0Lnpvb21YKSwgMCksXG4gICAgICAgICAgICB0YXJnZXRSZWxhdGl2ZVkgPSBNYXRoLm1heCh0YXJnZXQuY2FjaGVUcmFuc2xhdGlvblkgKyAobm9ybWFsaXplZFBvaW50ZXIueSAqIHRhcmdldC56b29tWSksIDApO1xuXG4gICAgICAgIHZhciBpc1RyYW5zcGFyZW50ID0gZmFicmljLnV0aWwuaXNUcmFuc3BhcmVudChcbiAgICAgICAgICB0YXJnZXQuX2NhY2hlQ29udGV4dCwgTWF0aC5yb3VuZCh0YXJnZXRSZWxhdGl2ZVgpLCBNYXRoLnJvdW5kKHRhcmdldFJlbGF0aXZlWSksIHRoaXMudGFyZ2V0RmluZFRvbGVyYW5jZSk7XG5cbiAgICAgICAgcmV0dXJuIGlzVHJhbnNwYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHRDYWNoZSxcbiAgICAgICAgICBvcmlnaW5hbENvbG9yID0gdGFyZ2V0LnNlbGVjdGlvbkJhY2tncm91bmRDb2xvciwgdiA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm07XG5cbiAgICAgIHRhcmdldC5zZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3IgPSAnJztcblxuICAgICAgdGhpcy5jbGVhckNvbnRleHQoY3R4KTtcblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0odlswXSwgdlsxXSwgdlsyXSwgdlszXSwgdls0XSwgdls1XSk7XG4gICAgICB0YXJnZXQucmVuZGVyKGN0eCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICB0YXJnZXQuc2VsZWN0aW9uQmFja2dyb3VuZENvbG9yID0gb3JpZ2luYWxDb2xvcjtcblxuICAgICAgdmFyIGlzVHJhbnNwYXJlbnQgPSBmYWJyaWMudXRpbC5pc1RyYW5zcGFyZW50KFxuICAgICAgICBjdHgsIHgsIHksIHRoaXMudGFyZ2V0RmluZFRvbGVyYW5jZSk7XG5cbiAgICAgIHJldHVybiBpc1RyYW5zcGFyZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB0YWtlcyBhbiBldmVudCBhbmQgZGV0ZXJtaW5lcyBpZiBzZWxlY3Rpb24ga2V5IGhhcyBiZWVuIHByZXNzZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgX2lzU2VsZWN0aW9uS2V5UHJlc3NlZDogZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHNlbGVjdGlvbktleVByZXNzZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5zZWxlY3Rpb25LZXkpKSB7XG4gICAgICAgIHNlbGVjdGlvbktleVByZXNzZWQgPSAhIXRoaXMuc2VsZWN0aW9uS2V5LmZpbmQoZnVuY3Rpb24oa2V5KSB7IHJldHVybiBlW2tleV0gPT09IHRydWU7IH0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlbGVjdGlvbktleVByZXNzZWQgPSBlW3RoaXMuc2VsZWN0aW9uS2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGVjdGlvbktleVByZXNzZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHRhcmdldFxuICAgICAqL1xuICAgIF9zaG91bGRDbGVhclNlbGVjdGlvbjogZnVuY3Rpb24gKGUsIHRhcmdldCkge1xuICAgICAgdmFyIGFjdGl2ZU9iamVjdHMgPSB0aGlzLmdldEFjdGl2ZU9iamVjdHMoKSxcbiAgICAgICAgICBhY3RpdmVPYmplY3QgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgICF0YXJnZXRcbiAgICAgICAgfHxcbiAgICAgICAgKHRhcmdldCAmJlxuICAgICAgICAgIGFjdGl2ZU9iamVjdCAmJlxuICAgICAgICAgIGFjdGl2ZU9iamVjdHMubGVuZ3RoID4gMSAmJlxuICAgICAgICAgIGFjdGl2ZU9iamVjdHMuaW5kZXhPZih0YXJnZXQpID09PSAtMSAmJlxuICAgICAgICAgIGFjdGl2ZU9iamVjdCAhPT0gdGFyZ2V0ICYmXG4gICAgICAgICAgIXRoaXMuX2lzU2VsZWN0aW9uS2V5UHJlc3NlZChlKSlcbiAgICAgICAgfHxcbiAgICAgICAgKHRhcmdldCAmJiAhdGFyZ2V0LmV2ZW50ZWQpXG4gICAgICAgIHx8XG4gICAgICAgICh0YXJnZXQgJiZcbiAgICAgICAgICAhdGFyZ2V0LnNlbGVjdGFibGUgJiZcbiAgICAgICAgICBhY3RpdmVPYmplY3QgJiZcbiAgICAgICAgICBhY3RpdmVPYmplY3QgIT09IHRhcmdldClcbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNlbnRlcmVkU2NhbGluZyBmcm9tIG9iamVjdCBjYW4ndCBvdmVycmlkZSBjZW50ZXJlZFNjYWxpbmcgZnJvbSBjYW52YXMuXG4gICAgICogdGhpcyBzaG91bGQgYmUgZml4ZWQsIHNpbmNlIG9iamVjdCBzZXR0aW5nIHNob3VsZCB0YWtlIHByZWNlZGVuY2Ugb3ZlciBjYW52YXMuXG4gICAgICogYWxzbyB0aGlzIHNob3VsZCBiZSBzb21ldGhpbmcgdGhhdCB3aWxsIGJlIG1pZ3JhdGVkIGluIHRoZSBjb250cm9sIHByb3BlcnRpZXMuXG4gICAgICogYXMgYWJpbGl0eSB0byBkZWZpbmUgdGhlIG9yaWdpbiBvZiB0aGUgdHJhbnNmb3JtYXRpb24gdGhhdCB0aGUgY29udHJvbCBwcm92aWRlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhbHRLZXlcbiAgICAgKi9cbiAgICBfc2hvdWxkQ2VudGVyVHJhbnNmb3JtOiBmdW5jdGlvbiAodGFyZ2V0LCBhY3Rpb24sIGFsdEtleSkge1xuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2VudGVyVHJhbnNmb3JtO1xuXG4gICAgICBpZiAoYWN0aW9uID09PSAnc2NhbGUnIHx8IGFjdGlvbiA9PT0gJ3NjYWxlWCcgfHwgYWN0aW9uID09PSAnc2NhbGVZJyB8fCBhY3Rpb24gPT09ICdyZXNpemluZycpIHtcbiAgICAgICAgY2VudGVyVHJhbnNmb3JtID0gdGhpcy5jZW50ZXJlZFNjYWxpbmcgfHwgdGFyZ2V0LmNlbnRlcmVkU2NhbGluZztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gJ3JvdGF0ZScpIHtcbiAgICAgICAgY2VudGVyVHJhbnNmb3JtID0gdGhpcy5jZW50ZXJlZFJvdGF0aW9uIHx8IHRhcmdldC5jZW50ZXJlZFJvdGF0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2VudGVyVHJhbnNmb3JtID8gIWFsdEtleSA6IGFsdEtleTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2hvdWxkIGRpc2FwcGVhciBiZWZvcmUgcmVsZWFzZSA0LjBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRPcmlnaW5Gcm9tQ29ybmVyOiBmdW5jdGlvbih0YXJnZXQsIGNvcm5lcikge1xuICAgICAgdmFyIG9yaWdpbiA9IHtcbiAgICAgICAgeDogdGFyZ2V0Lm9yaWdpblgsXG4gICAgICAgIHk6IHRhcmdldC5vcmlnaW5ZXG4gICAgICB9O1xuXG4gICAgICBpZiAoY29ybmVyID09PSAnbWwnIHx8IGNvcm5lciA9PT0gJ3RsJyB8fCBjb3JuZXIgPT09ICdibCcpIHtcbiAgICAgICAgb3JpZ2luLnggPSAncmlnaHQnO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY29ybmVyID09PSAnbXInIHx8IGNvcm5lciA9PT0gJ3RyJyB8fCBjb3JuZXIgPT09ICdicicpIHtcbiAgICAgICAgb3JpZ2luLnggPSAnbGVmdCc7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb3JuZXIgPT09ICd0bCcgfHwgY29ybmVyID09PSAnbXQnIHx8IGNvcm5lciA9PT0gJ3RyJykge1xuICAgICAgICBvcmlnaW4ueSA9ICdib3R0b20nO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY29ybmVyID09PSAnYmwnIHx8IGNvcm5lciA9PT0gJ21iJyB8fCBjb3JuZXIgPT09ICdicicpIHtcbiAgICAgICAgb3JpZ2luLnkgPSAndG9wJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnaW47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhbHJlYWR5U2VsZWN0ZWQgdHJ1ZSBpZiB0YXJnZXQgaXMgYWxyZWFkeSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb3JuZXIgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjb3JuZXIgbWwsIG1yLCB0bCAuLi5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gW3RhcmdldF0gaW5zZXJ0ZWQgYmFjayB0byBoZWxwIG92ZXJyaWRpbmcuIFVudXNlZFxuICAgICAqL1xuICAgIF9nZXRBY3Rpb25Gcm9tQ29ybmVyOiBmdW5jdGlvbihhbHJlYWR5U2VsZWN0ZWQsIGNvcm5lciwgZSwgdGFyZ2V0KSB7XG4gICAgICBpZiAoIWNvcm5lciB8fCAhYWxyZWFkeVNlbGVjdGVkKSB7XG4gICAgICAgIHJldHVybiAnZHJhZyc7XG4gICAgICB9XG4gICAgICB2YXIgY29udHJvbCA9IHRhcmdldC5jb250cm9sc1tjb3JuZXJdO1xuICAgICAgcmV0dXJuIGNvbnRyb2wuZ2V0QWN0aW9uTmFtZShlLCBjb250cm9sLCB0YXJnZXQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBfc2V0dXBDdXJyZW50VHJhbnNmb3JtOiBmdW5jdGlvbiAoZSwgdGFyZ2V0LCBhbHJlYWR5U2VsZWN0ZWQpIHtcbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSksIGNvcm5lciA9IHRhcmdldC5fX2Nvcm5lcixcbiAgICAgICAgICBjb250cm9sID0gdGFyZ2V0LmNvbnRyb2xzW2Nvcm5lcl0sXG4gICAgICAgICAgYWN0aW9uSGFuZGxlciA9IChhbHJlYWR5U2VsZWN0ZWQgJiYgY29ybmVyKSA/XG4gICAgICAgICAgICBjb250cm9sLmdldEFjdGlvbkhhbmRsZXIoZSwgdGFyZ2V0LCBjb250cm9sKSA6IGZhYnJpYy5jb250cm9sc1V0aWxzLmRyYWdIYW5kbGVyLFxuICAgICAgICAgIGFjdGlvbiA9IHRoaXMuX2dldEFjdGlvbkZyb21Db3JuZXIoYWxyZWFkeVNlbGVjdGVkLCBjb3JuZXIsIGUsIHRhcmdldCksXG4gICAgICAgICAgb3JpZ2luID0gdGhpcy5fZ2V0T3JpZ2luRnJvbUNvcm5lcih0YXJnZXQsIGNvcm5lciksXG4gICAgICAgICAgYWx0S2V5ID0gZVt0aGlzLmNlbnRlcmVkS2V5XSxcbiAgICAgICAgICB0cmFuc2Zvcm0gPSB7XG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgICAgYWN0aW9uSGFuZGxlcjogYWN0aW9uSGFuZGxlcixcbiAgICAgICAgICAgIGNvcm5lcjogY29ybmVyLFxuICAgICAgICAgICAgc2NhbGVYOiB0YXJnZXQuc2NhbGVYLFxuICAgICAgICAgICAgc2NhbGVZOiB0YXJnZXQuc2NhbGVZLFxuICAgICAgICAgICAgc2tld1g6IHRhcmdldC5za2V3WCxcbiAgICAgICAgICAgIHNrZXdZOiB0YXJnZXQuc2tld1ksXG4gICAgICAgICAgICAvLyB1c2VkIGJ5IHRyYW5zYXRpb25cbiAgICAgICAgICAgIG9mZnNldFg6IHBvaW50ZXIueCAtIHRhcmdldC5sZWZ0LFxuICAgICAgICAgICAgb2Zmc2V0WTogcG9pbnRlci55IC0gdGFyZ2V0LnRvcCxcbiAgICAgICAgICAgIG9yaWdpblg6IG9yaWdpbi54LFxuICAgICAgICAgICAgb3JpZ2luWTogb3JpZ2luLnksXG4gICAgICAgICAgICBleDogcG9pbnRlci54LFxuICAgICAgICAgICAgZXk6IHBvaW50ZXIueSxcbiAgICAgICAgICAgIGxhc3RYOiBwb2ludGVyLngsXG4gICAgICAgICAgICBsYXN0WTogcG9pbnRlci55LFxuICAgICAgICAgICAgLy8gdW5zdXJlIHRoZXkgYXJlIHVzZWZ1bCBhbnltb3JlLlxuICAgICAgICAgICAgLy8gbGVmdDogdGFyZ2V0LmxlZnQsXG4gICAgICAgICAgICAvLyB0b3A6IHRhcmdldC50b3AsXG4gICAgICAgICAgICB0aGV0YTogZGVncmVlc1RvUmFkaWFucyh0YXJnZXQuYW5nbGUpLFxuICAgICAgICAgICAgLy8gZW5kIG9mIHVuc3VyZVxuICAgICAgICAgICAgd2lkdGg6IHRhcmdldC53aWR0aCAqIHRhcmdldC5zY2FsZVgsXG4gICAgICAgICAgICBzaGlmdEtleTogZS5zaGlmdEtleSxcbiAgICAgICAgICAgIGFsdEtleTogYWx0S2V5LFxuICAgICAgICAgICAgb3JpZ2luYWw6IGZhYnJpYy51dGlsLnNhdmVPYmplY3RUcmFuc2Zvcm0odGFyZ2V0KSxcbiAgICAgICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5fc2hvdWxkQ2VudGVyVHJhbnNmb3JtKHRhcmdldCwgYWN0aW9uLCBhbHRLZXkpKSB7XG4gICAgICAgIHRyYW5zZm9ybS5vcmlnaW5YID0gJ2NlbnRlcic7XG4gICAgICAgIHRyYW5zZm9ybS5vcmlnaW5ZID0gJ2NlbnRlcic7XG4gICAgICB9XG4gICAgICB0cmFuc2Zvcm0ub3JpZ2luYWwub3JpZ2luWCA9IG9yaWdpbi54O1xuICAgICAgdHJhbnNmb3JtLm9yaWdpbmFsLm9yaWdpblkgPSBvcmlnaW4ueTtcbiAgICAgIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICB0aGlzLl9iZWZvcmVUcmFuc2Zvcm0oZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY3Vyc29yIHR5cGUgb2YgdGhlIGNhbnZhcyBlbGVtZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIEN1cnNvciB0eXBlIG9mIHRoZSBjYW52YXMgZWxlbWVudC5cbiAgICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtdWkvI2N1cnNvclxuICAgICAqL1xuICAgIHNldEN1cnNvcjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB0aGlzLnVwcGVyQ2FudmFzRWwuc3R5bGUuY3Vyc29yID0gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCB0byBkcmF3IHRoZSBzZWxlY3Rpb24gb25cbiAgICAgKi9cbiAgICBfZHJhd1NlbGVjdGlvbjogZnVuY3Rpb24gKGN0eCkge1xuICAgICAgdmFyIHNlbGVjdG9yID0gdGhpcy5fZ3JvdXBTZWxlY3RvcixcbiAgICAgICAgICB2aWV3cG9ydFN0YXJ0ID0gbmV3IGZhYnJpYy5Qb2ludChzZWxlY3Rvci5leCwgc2VsZWN0b3IuZXkpLFxuICAgICAgICAgIHN0YXJ0ID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQodmlld3BvcnRTdGFydCwgdGhpcy52aWV3cG9ydFRyYW5zZm9ybSksXG4gICAgICAgICAgdmlld3BvcnRFeHRlbnQgPSBuZXcgZmFicmljLlBvaW50KHNlbGVjdG9yLmV4ICsgc2VsZWN0b3IubGVmdCwgc2VsZWN0b3IuZXkgKyBzZWxlY3Rvci50b3ApLFxuICAgICAgICAgIGV4dGVudCA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KHZpZXdwb3J0RXh0ZW50LCB0aGlzLnZpZXdwb3J0VHJhbnNmb3JtKSxcbiAgICAgICAgICBtaW5YID0gTWF0aC5taW4oc3RhcnQueCwgZXh0ZW50LngpLFxuICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihzdGFydC55LCBleHRlbnQueSksXG4gICAgICAgICAgbWF4WCA9IE1hdGgubWF4KHN0YXJ0LngsIGV4dGVudC54KSxcbiAgICAgICAgICBtYXhZID0gTWF0aC5tYXgoc3RhcnQueSwgZXh0ZW50LnkpLFxuICAgICAgICAgIHN0cm9rZU9mZnNldCA9IHRoaXMuc2VsZWN0aW9uTGluZVdpZHRoIC8gMjtcblxuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uQ29sb3IpIHtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuc2VsZWN0aW9uQ29sb3I7XG4gICAgICAgIGN0eC5maWxsUmVjdChtaW5YLCBtaW5ZLCBtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uTGluZVdpZHRoIHx8ICF0aGlzLnNlbGVjdGlvbkJvcmRlckNvbG9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLnNlbGVjdGlvbkxpbmVXaWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc2VsZWN0aW9uQm9yZGVyQ29sb3I7XG5cbiAgICAgIG1pblggKz0gc3Ryb2tlT2Zmc2V0O1xuICAgICAgbWluWSArPSBzdHJva2VPZmZzZXQ7XG4gICAgICBtYXhYIC09IHN0cm9rZU9mZnNldDtcbiAgICAgIG1heFkgLT0gc3Ryb2tlT2Zmc2V0O1xuICAgICAgLy8gc2VsZWN0aW9uIGJvcmRlclxuICAgICAgZmFicmljLk9iamVjdC5wcm90b3R5cGUuX3NldExpbmVEYXNoLmNhbGwodGhpcywgY3R4LCB0aGlzLnNlbGVjdGlvbkRhc2hBcnJheSk7XG4gICAgICBjdHguc3Ryb2tlUmVjdChtaW5YLCBtaW5ZLCBtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCBkZXRlcm1pbmVzIHdoYXQgb2JqZWN0IHdlIGFyZSBjbGlja2luZyBvblxuICAgICAqIHRoZSBza2lwR3JvdXAgcGFyYW1ldGVyIGlzIGZvciBpbnRlcm5hbCB1c2UsIGlzIG5lZWRlZCBmb3Igc2hpZnQrY2xpY2sgYWN0aW9uXG4gICAgICogMTEvMDkvMjAxOCBUT0RPOiB3b3VsZCBiZSBjb29sIGlmIGZpbmRUYXJnZXQgY291bGQgZGlzY2VybiBiZXR3ZWVuIGJlaW5nIGEgZnVsbCB0YXJnZXRcbiAgICAgKiBvciB0aGUgb3V0c2lkZSBwYXJ0IG9mIHRoZSBjb3JuZXIuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBtb3VzZSBldmVudFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcEdyb3VwIHdoZW4gdHJ1ZSwgYWN0aXZlR3JvdXAgaXMgc2tpcHBlZCBhbmQgb25seSBvYmplY3RzIGFyZSB0cmF2ZXJzZWQgdGhyb3VnaFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoZSB0YXJnZXQgZm91bmRcbiAgICAgKi9cbiAgICBmaW5kVGFyZ2V0OiBmdW5jdGlvbiAoZSwgc2tpcEdyb3VwKSB7XG4gICAgICBpZiAodGhpcy5za2lwVGFyZ2V0RmluZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpZ25vcmVab29tID0gdHJ1ZSxcbiAgICAgICAgICBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUsIGlnbm9yZVpvb20pLFxuICAgICAgICAgIGFjdGl2ZU9iamVjdCA9IHRoaXMuX2FjdGl2ZU9iamVjdCxcbiAgICAgICAgICBhT2JqZWN0cyA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0cygpLFxuICAgICAgICAgIGFjdGl2ZVRhcmdldCwgYWN0aXZlVGFyZ2V0U3VicyxcbiAgICAgICAgICBpc1RvdWNoID0gaXNUb3VjaEV2ZW50KGUpLFxuICAgICAgICAgIHNob3VsZExvb2tGb3JBY3RpdmUgPSAoYU9iamVjdHMubGVuZ3RoID4gMSAmJiAhc2tpcEdyb3VwKSB8fCBhT2JqZWN0cy5sZW5ndGggPT09IDE7XG5cbiAgICAgIC8vIGZpcnN0IGNoZWNrIGN1cnJlbnQgZ3JvdXAgKGlmIG9uZSBleGlzdHMpXG4gICAgICAvLyBhY3RpdmUgZ3JvdXAgZG9lcyBub3QgY2hlY2sgc3ViIHRhcmdldHMgbGlrZSBub3JtYWwgZ3JvdXBzLlxuICAgICAgLy8gaWYgYWN0aXZlIGdyb3VwIGp1c3QgZXhpdHMuXG4gICAgICB0aGlzLnRhcmdldHMgPSBbXTtcblxuICAgICAgLy8gaWYgd2UgaGl0IHRoZSBjb3JuZXIgb2YgYW4gYWN0aXZlT2JqZWN0LCBsZXQncyByZXR1cm4gdGhhdC5cbiAgICAgIGlmIChzaG91bGRMb29rRm9yQWN0aXZlICYmIGFjdGl2ZU9iamVjdC5fZmluZFRhcmdldENvcm5lcihwb2ludGVyLCBpc1RvdWNoKSkge1xuICAgICAgICByZXR1cm4gYWN0aXZlT2JqZWN0O1xuICAgICAgfVxuICAgICAgaWYgKGFPYmplY3RzLmxlbmd0aCA+IDEgJiYgIXNraXBHcm91cCAmJiBhY3RpdmVPYmplY3QgPT09IHRoaXMuX3NlYXJjaFBvc3NpYmxlVGFyZ2V0cyhbYWN0aXZlT2JqZWN0XSwgcG9pbnRlcikpIHtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZU9iamVjdDtcbiAgICAgIH1cbiAgICAgIGlmIChhT2JqZWN0cy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgYWN0aXZlT2JqZWN0ID09PSB0aGlzLl9zZWFyY2hQb3NzaWJsZVRhcmdldHMoW2FjdGl2ZU9iamVjdF0sIHBvaW50ZXIpKSB7XG4gICAgICAgIGlmICghdGhpcy5wcmVzZXJ2ZU9iamVjdFN0YWNraW5nKSB7XG4gICAgICAgICAgcmV0dXJuIGFjdGl2ZU9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBhY3RpdmVUYXJnZXQgPSBhY3RpdmVPYmplY3Q7XG4gICAgICAgICAgYWN0aXZlVGFyZ2V0U3VicyA9IHRoaXMudGFyZ2V0cztcbiAgICAgICAgICB0aGlzLnRhcmdldHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX3NlYXJjaFBvc3NpYmxlVGFyZ2V0cyh0aGlzLl9vYmplY3RzLCBwb2ludGVyKTtcbiAgICAgIGlmIChlW3RoaXMuYWx0U2VsZWN0aW9uS2V5XSAmJiB0YXJnZXQgJiYgYWN0aXZlVGFyZ2V0ICYmIHRhcmdldCAhPT0gYWN0aXZlVGFyZ2V0KSB7XG4gICAgICAgIHRhcmdldCA9IGFjdGl2ZVRhcmdldDtcbiAgICAgICAgdGhpcy50YXJnZXRzID0gYWN0aXZlVGFyZ2V0U3VicztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBwb2ludCBpcyBpbnNpZGUgdGhlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BvaW50ZXJdIHgseSBvYmplY3Qgb2YgcG9pbnQgY29vcmRpbmF0ZXMgd2Ugd2FudCB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iaiBPYmplY3QgdG8gdGVzdCBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtnbG9iYWxQb2ludGVyXSB4LHkgb2JqZWN0IG9mIHBvaW50IGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIGNhbnZhcyB1c2VkIHRvIHNlYXJjaCBwZXIgcGl4ZWwgdGFyZ2V0LlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgcG9pbnQgaXMgY29udGFpbmVkIHdpdGhpbiBhbiBhcmVhIG9mIGdpdmVuIG9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NoZWNrVGFyZ2V0OiBmdW5jdGlvbihwb2ludGVyLCBvYmosIGdsb2JhbFBvaW50ZXIpIHtcbiAgICAgIGlmIChvYmogJiZcbiAgICAgICAgICBvYmoudmlzaWJsZSAmJlxuICAgICAgICAgIG9iai5ldmVudGVkICYmXG4gICAgICAgICAgLy8gaHR0cDovL3d3dy5nZW9nLnViYy5jYS9jb3Vyc2VzL2tsaW5rL2dpcy5ub3Rlcy9uY2dpYS91MzIuaHRtbFxuICAgICAgICAgIC8vIGh0dHA6Ly9pZGF2LnVjZGF2aXMuZWR1L35va3JleWxvcy9UQXNoaXAvU3ByaW5nMjAwMC9Qb2ludEluUG9seWdvbi5odG1sXG4gICAgICAgICAgb2JqLmNvbnRhaW5zUG9pbnQocG9pbnRlcilcbiAgICAgICkge1xuICAgICAgICBpZiAoKHRoaXMucGVyUGl4ZWxUYXJnZXRGaW5kIHx8IG9iai5wZXJQaXhlbFRhcmdldEZpbmQpICYmICFvYmouaXNFZGl0aW5nKSB7XG4gICAgICAgICAgdmFyIGlzVHJhbnNwYXJlbnQgPSB0aGlzLmlzVGFyZ2V0VHJhbnNwYXJlbnQob2JqLCBnbG9iYWxQb2ludGVyLngsIGdsb2JhbFBvaW50ZXIueSk7XG4gICAgICAgICAgaWYgKCFpc1RyYW5zcGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdXNlZCB0byBzZWFyY2ggaW5zaWRlIG9iamVjdHMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgcG9pbnRlciBpbiBib3VuZGluZyBib3ggb3IgdGhhdCBjb250YWlucyBwb2ludGVyT25DYW52YXMgd2hlbiBwYWludGVkXG4gICAgICogQHBhcmFtIHtBcnJheX0gW29iamVjdHNdIG9iamVjdHMgYXJyYXkgdG8gbG9vayBpbnRvXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwb2ludGVyXSB4LHkgb2JqZWN0IG9mIHBvaW50IGNvb3JkaW5hdGVzIHdlIHdhbnQgdG8gY2hlY2suXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gb2JqZWN0IHRoYXQgY29udGFpbnMgcG9pbnRlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NlYXJjaFBvc3NpYmxlVGFyZ2V0czogZnVuY3Rpb24ob2JqZWN0cywgcG9pbnRlcikge1xuICAgICAgLy8gQ2FjaGUgYWxsIHRhcmdldHMgd2hlcmUgdGhlaXIgYm91bmRpbmcgYm94IGNvbnRhaW5zIHBvaW50LlxuICAgICAgdmFyIHRhcmdldCwgaSA9IG9iamVjdHMubGVuZ3RoLCBzdWJUYXJnZXQ7XG4gICAgICAvLyBEbyBub3QgY2hlY2sgZm9yIGN1cnJlbnRseSBncm91cGVkIG9iamVjdHMsIHNpbmNlIHdlIGNoZWNrIHRoZSBwYXJlbnQgZ3JvdXAgaXRzZWxmLlxuICAgICAgLy8gdW50aWwgd2UgY2FsbCB0aGlzIGZ1bmN0aW9uIHNwZWNpZmljYWxseSB0byBzZWFyY2ggaW5zaWRlIHRoZSBhY3RpdmVHcm91cFxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2YXIgb2JqVG9DaGVjayA9IG9iamVjdHNbaV07XG4gICAgICAgIHZhciBwb2ludGVyVG9Vc2UgPSBvYmpUb0NoZWNrLmdyb3VwID9cbiAgICAgICAgICB0aGlzLl9ub3JtYWxpemVQb2ludGVyKG9ialRvQ2hlY2suZ3JvdXAsIHBvaW50ZXIpIDogcG9pbnRlcjtcbiAgICAgICAgaWYgKHRoaXMuX2NoZWNrVGFyZ2V0KHBvaW50ZXJUb1VzZSwgb2JqVG9DaGVjaywgcG9pbnRlcikpIHtcbiAgICAgICAgICB0YXJnZXQgPSBvYmplY3RzW2ldO1xuICAgICAgICAgIGlmICh0YXJnZXQuc3ViVGFyZ2V0Q2hlY2sgJiYgdGFyZ2V0IGluc3RhbmNlb2YgZmFicmljLkdyb3VwKSB7XG4gICAgICAgICAgICBzdWJUYXJnZXQgPSB0aGlzLl9zZWFyY2hQb3NzaWJsZVRhcmdldHModGFyZ2V0Ll9vYmplY3RzLCBwb2ludGVyKTtcbiAgICAgICAgICAgIHN1YlRhcmdldCAmJiB0aGlzLnRhcmdldHMucHVzaChzdWJUYXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBwb2ludGVyIGNvb3JkaW5hdGVzIHdpdGhvdXQgdGhlIGVmZmVjdCBvZiB0aGUgdmlld3BvcnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlciB3aXRoIFwieFwiIGFuZCBcInlcIiBudW1iZXIgdmFsdWVzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qgd2l0aCBcInhcIiBhbmQgXCJ5XCIgbnVtYmVyIHZhbHVlc1xuICAgICAqL1xuICAgIHJlc3RvcmVQb2ludGVyVnB0OiBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQoXG4gICAgICAgIHBvaW50ZXIsXG4gICAgICAgIGZhYnJpYy51dGlsLmludmVydFRyYW5zZm9ybSh0aGlzLnZpZXdwb3J0VHJhbnNmb3JtKVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBwb2ludGVyIGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIGNhbnZhcy5cbiAgICAgKiBDYW4gcmV0dXJuIGNvb3JkaW5hdGVzIHdpdGggb3Igd2l0aG91dCB2aWV3cG9ydFRyYW5zZm9ybS5cbiAgICAgKiBpZ25vcmVab29tIGZhbHNlIGdpdmVzIGJhY2sgY29vcmRpbmF0ZXMgdGhhdCByZXByZXNlbnRcbiAgICAgKiB0aGUgcG9pbnQgY2xpY2tlZCBvbiBjYW52YXMgZWxlbWVudC5cbiAgICAgKiBpZ25vcmVab29tIHRydWUgZ2l2ZXMgYmFjayBjb29yZGluYXRlcyBhZnRlciBiZWluZyBwcm9jZXNzZWRcbiAgICAgKiBieSB0aGUgdmlld3BvcnRUcmFuc2Zvcm0gKCBzb3J0IG9mIGNvb3JkaW5hdGVzIG9mIHdoYXQgaXMgZGlzcGxheWVkXG4gICAgICogb24gdGhlIGNhbnZhcyB3aGVyZSB5b3UgYXJlIGNsaWNraW5nLlxuICAgICAqIGlnbm9yZVpvb20gdHJ1ZSA9IEhUTUxFbGVtZW50IGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIHRvcCxsZWZ0XG4gICAgICogaWdub3JlWm9vbSBmYWxzZSwgZGVmYXVsdCA9IGZhYnJpYyBzcGFjZSBjb29yZGluYXRlcywgdGhlIHNhbWUgdXNlZCBmb3Igc2hhcGUgcG9zaXRpb25cbiAgICAgKiBUbyBpbnRlcmFjdCB3aXRoIHlvdXIgc2hhcGVzIHRvcCBhbmQgbGVmdCB5b3Ugd2FudCB0byB1c2UgaWdub3JlWm9vbSB0cnVlXG4gICAgICogbW9zdCBvZiB0aGUgdGltZSwgd2hpbGUgaWdub3JlWm9vbSBmYWxzZSB3aWxsIGdpdmUgeW91IGNvb3JkaW5hdGVzXG4gICAgICogY29tcGF0aWJsZSB3aXRoIHRoZSBvYmplY3Qub0Nvb3JkcyBzeXN0ZW0uXG4gICAgICogb2YgdGhlIHRpbWUuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlWm9vbVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHdpdGggXCJ4XCIgYW5kIFwieVwiIG51bWJlciB2YWx1ZXNcbiAgICAgKi9cbiAgICBnZXRQb2ludGVyOiBmdW5jdGlvbiAoZSwgaWdub3JlWm9vbSkge1xuICAgICAgLy8gcmV0dXJuIGNhY2hlZCB2YWx1ZXMgaWYgd2UgYXJlIGluIHRoZSBldmVudCBwcm9jZXNzaW5nIGNoYWluXG4gICAgICBpZiAodGhpcy5fYWJzb2x1dGVQb2ludGVyICYmICFpZ25vcmVab29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hYnNvbHV0ZVBvaW50ZXI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fcG9pbnRlciAmJiBpZ25vcmVab29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb2ludGVyO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9pbnRlciA9IGdldFBvaW50ZXIoZSksXG4gICAgICAgICAgdXBwZXJDYW52YXNFbCA9IHRoaXMudXBwZXJDYW52YXNFbCxcbiAgICAgICAgICBib3VuZHMgPSB1cHBlckNhbnZhc0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgIGJvdW5kc1dpZHRoID0gYm91bmRzLndpZHRoIHx8IDAsXG4gICAgICAgICAgYm91bmRzSGVpZ2h0ID0gYm91bmRzLmhlaWdodCB8fCAwLFxuICAgICAgICAgIGNzc1NjYWxlO1xuXG4gICAgICBpZiAoIWJvdW5kc1dpZHRoIHx8ICFib3VuZHNIZWlnaHQgKSB7XG4gICAgICAgIGlmICgndG9wJyBpbiBib3VuZHMgJiYgJ2JvdHRvbScgaW4gYm91bmRzKSB7XG4gICAgICAgICAgYm91bmRzSGVpZ2h0ID0gTWF0aC5hYnMoIGJvdW5kcy50b3AgLSBib3VuZHMuYm90dG9tICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdyaWdodCcgaW4gYm91bmRzICYmICdsZWZ0JyBpbiBib3VuZHMpIHtcbiAgICAgICAgICBib3VuZHNXaWR0aCA9IE1hdGguYWJzKCBib3VuZHMucmlnaHQgLSBib3VuZHMubGVmdCApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FsY09mZnNldCgpO1xuICAgICAgcG9pbnRlci54ID0gcG9pbnRlci54IC0gdGhpcy5fb2Zmc2V0LmxlZnQ7XG4gICAgICBwb2ludGVyLnkgPSBwb2ludGVyLnkgLSB0aGlzLl9vZmZzZXQudG9wO1xuICAgICAgaWYgKCFpZ25vcmVab29tKSB7XG4gICAgICAgIHBvaW50ZXIgPSB0aGlzLnJlc3RvcmVQb2ludGVyVnB0KHBvaW50ZXIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmV0aW5hU2NhbGluZyA9IHRoaXMuZ2V0UmV0aW5hU2NhbGluZygpO1xuICAgICAgaWYgKHJldGluYVNjYWxpbmcgIT09IDEpIHtcbiAgICAgICAgcG9pbnRlci54IC89IHJldGluYVNjYWxpbmc7XG4gICAgICAgIHBvaW50ZXIueSAvPSByZXRpbmFTY2FsaW5nO1xuICAgICAgfVxuXG4gICAgICBpZiAoYm91bmRzV2lkdGggPT09IDAgfHwgYm91bmRzSGVpZ2h0ID09PSAwKSB7XG4gICAgICAgIC8vIElmIGJvdW5kcyBhcmUgbm90IGF2YWlsYWJsZSAoaS5lLiBub3QgdmlzaWJsZSksIGRvIG5vdCBhcHBseSBzY2FsZS5cbiAgICAgICAgY3NzU2NhbGUgPSB7IHdpZHRoOiAxLCBoZWlnaHQ6IDEgfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjc3NTY2FsZSA9IHtcbiAgICAgICAgICB3aWR0aDogdXBwZXJDYW52YXNFbC53aWR0aCAvIGJvdW5kc1dpZHRoLFxuICAgICAgICAgIGhlaWdodDogdXBwZXJDYW52YXNFbC5oZWlnaHQgLyBib3VuZHNIZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcG9pbnRlci54ICogY3NzU2NhbGUud2lkdGgsXG4gICAgICAgIHk6IHBvaW50ZXIueSAqIGNzc1NjYWxlLmhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdGhyb3dzIHtDQU5WQVNfSU5JVF9FUlJPUn0gSWYgY2FudmFzIGNhbiBub3QgYmUgaW5pdGlhbGl6ZWRcbiAgICAgKi9cbiAgICBfY3JlYXRlVXBwZXJDYW52YXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBsb3dlckNhbnZhc0NsYXNzID0gdGhpcy5sb3dlckNhbnZhc0VsLmNsYXNzTmFtZS5yZXBsYWNlKC9cXHMqbG93ZXItY2FudmFzXFxzKi8sICcnKSxcbiAgICAgICAgICBsb3dlckNhbnZhc0VsID0gdGhpcy5sb3dlckNhbnZhc0VsLCB1cHBlckNhbnZhc0VsID0gdGhpcy51cHBlckNhbnZhc0VsO1xuXG4gICAgICAvLyB0aGVyZSBpcyBubyBuZWVkIHRvIGNyZWF0ZSBhIG5ldyB1cHBlckNhbnZhcyBlbGVtZW50IGlmIHdlIGhhdmUgYWxyZWFkeSBvbmUuXG4gICAgICBpZiAodXBwZXJDYW52YXNFbCkge1xuICAgICAgICB1cHBlckNhbnZhc0VsLmNsYXNzTmFtZSA9ICcnO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHVwcGVyQ2FudmFzRWwgPSB0aGlzLl9jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICAgIHRoaXMudXBwZXJDYW52YXNFbCA9IHVwcGVyQ2FudmFzRWw7XG4gICAgICB9XG4gICAgICBmYWJyaWMudXRpbC5hZGRDbGFzcyh1cHBlckNhbnZhc0VsLCAndXBwZXItY2FudmFzICcgKyBsb3dlckNhbnZhc0NsYXNzKTtcblxuICAgICAgdGhpcy53cmFwcGVyRWwuYXBwZW5kQ2hpbGQodXBwZXJDYW52YXNFbCk7XG5cbiAgICAgIHRoaXMuX2NvcHlDYW52YXNTdHlsZShsb3dlckNhbnZhc0VsLCB1cHBlckNhbnZhc0VsKTtcbiAgICAgIHRoaXMuX2FwcGx5Q2FudmFzU3R5bGUodXBwZXJDYW52YXNFbCk7XG4gICAgICB0aGlzLmNvbnRleHRUb3AgPSB1cHBlckNhbnZhc0VsLmdldENvbnRleHQoJzJkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29udGV4dCBvZiB0b3AgY2FudmFzIHdoZXJlIGludGVyYWN0aW9ucyBhcmUgZHJhd25cbiAgICAgKiBAcmV0dXJucyB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuICAgIGdldFRvcENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRleHRUb3A7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZUNhY2hlQ2FudmFzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhY2hlQ2FudmFzRWwgPSB0aGlzLl9jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICB0aGlzLmNhY2hlQ2FudmFzRWwuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMud2lkdGgpO1xuICAgICAgdGhpcy5jYWNoZUNhbnZhc0VsLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5oZWlnaHQpO1xuICAgICAgdGhpcy5jb250ZXh0Q2FjaGUgPSB0aGlzLmNhY2hlQ2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdFdyYXBwZXJFbGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLndyYXBwZXJFbCA9IGZhYnJpYy51dGlsLndyYXBFbGVtZW50KHRoaXMubG93ZXJDYW52YXNFbCwgJ2RpdicsIHtcbiAgICAgICAgJ2NsYXNzJzogdGhpcy5jb250YWluZXJDbGFzc1xuICAgICAgfSk7XG4gICAgICBmYWJyaWMudXRpbC5zZXRTdHlsZSh0aGlzLndyYXBwZXJFbCwge1xuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCArICdweCcsXG4gICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQgKyAncHgnLFxuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgICAgfSk7XG4gICAgICBmYWJyaWMudXRpbC5tYWtlRWxlbWVudFVuc2VsZWN0YWJsZSh0aGlzLndyYXBwZXJFbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBjYW52YXMgZWxlbWVudCB0byBhcHBseSBzdHlsZXMgb25cbiAgICAgKi9cbiAgICBfYXBwbHlDYW52YXNTdHlsZTogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGggfHwgZWxlbWVudC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSB0aGlzLmhlaWdodCB8fCBlbGVtZW50LmhlaWdodDtcblxuICAgICAgZmFicmljLnV0aWwuc2V0U3R5bGUoZWxlbWVudCwge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgd2lkdGg6IHdpZHRoICsgJ3B4JyxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKyAncHgnLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgICd0b3VjaC1hY3Rpb24nOiB0aGlzLmFsbG93VG91Y2hTY3JvbGxpbmcgPyAnbWFuaXB1bGF0aW9uJyA6ICdub25lJyxcbiAgICAgICAgJy1tcy10b3VjaC1hY3Rpb24nOiB0aGlzLmFsbG93VG91Y2hTY3JvbGxpbmcgPyAnbWFuaXB1bGF0aW9uJyA6ICdub25lJ1xuICAgICAgfSk7XG4gICAgICBlbGVtZW50LndpZHRoID0gd2lkdGg7XG4gICAgICBlbGVtZW50LmhlaWdodCA9IGhlaWdodDtcbiAgICAgIGZhYnJpYy51dGlsLm1ha2VFbGVtZW50VW5zZWxlY3RhYmxlKGVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb3B5IHRoZSBlbnRpcmUgaW5saW5lIHN0eWxlIGZyb20gb25lIGVsZW1lbnQgKGZyb21FbCkgdG8gYW5vdGhlciAodG9FbClcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZnJvbUVsIEVsZW1lbnQgc3R5bGUgaXMgY29waWVkIGZyb21cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRvRWwgRWxlbWVudCBjb3BpZWQgc3R5bGUgaXMgYXBwbGllZCB0b1xuICAgICAqL1xuICAgIF9jb3B5Q2FudmFzU3R5bGU6IGZ1bmN0aW9uIChmcm9tRWwsIHRvRWwpIHtcbiAgICAgIHRvRWwuc3R5bGUuY3NzVGV4dCA9IGZyb21FbC5zdHlsZS5jc3NUZXh0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnRleHQgb2YgY2FudmFzIHdoZXJlIG9iamVjdCBzZWxlY3Rpb24gaXMgZHJhd25cbiAgICAgKiBAcmV0dXJuIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICovXG4gICAgZ2V0U2VsZWN0aW9uQ29udGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZXh0VG9wO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zICZsdDtjYW52YXM+IGVsZW1lbnQgb24gd2hpY2ggb2JqZWN0IHNlbGVjdGlvbiBpcyBkcmF3blxuICAgICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIGdldFNlbGVjdGlvbkVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnVwcGVyQ2FudmFzRWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY3VycmVudGx5IGFjdGl2ZSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSBhY3RpdmUgb2JqZWN0XG4gICAgICovXG4gICAgZ2V0QWN0aXZlT2JqZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IHdpdGggdGhlIGN1cnJlbnQgc2VsZWN0ZWQgb2JqZWN0c1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IGFjdGl2ZSBvYmplY3RcbiAgICAgKi9cbiAgICBnZXRBY3RpdmVPYmplY3RzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYWN0aXZlID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICBpZiAoYWN0aXZlLnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nICYmIGFjdGl2ZS5fb2JqZWN0cykge1xuICAgICAgICAgIHJldHVybiBhY3RpdmUuX29iamVjdHMuc2xpY2UoMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFthY3RpdmVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gW107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgd2FzIHJlbW92ZWRcbiAgICAgKi9cbiAgICBfb25PYmplY3RSZW1vdmVkOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIC8vIHJlbW92aW5nIGFjdGl2ZSBvYmplY3Qgc2hvdWxkIGZpcmUgXCJzZWxlY3Rpb246Y2xlYXJlZFwiIGV2ZW50c1xuICAgICAgaWYgKG9iaiA9PT0gdGhpcy5fYWN0aXZlT2JqZWN0KSB7XG4gICAgICAgIHRoaXMuZmlyZSgnYmVmb3JlOnNlbGVjdGlvbjpjbGVhcmVkJywgeyB0YXJnZXQ6IG9iaiB9KTtcbiAgICAgICAgdGhpcy5fZGlzY2FyZEFjdGl2ZU9iamVjdCgpO1xuICAgICAgICB0aGlzLmZpcmUoJ3NlbGVjdGlvbjpjbGVhcmVkJywgeyB0YXJnZXQ6IG9iaiB9KTtcbiAgICAgICAgb2JqLmZpcmUoJ2Rlc2VsZWN0ZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmogPT09IHRoaXMuX2hvdmVyZWRUYXJnZXQpe1xuICAgICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5faG92ZXJlZFRhcmdldHMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfb25PYmplY3RSZW1vdmVkJywgb2JqKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBDb21wYXJlcyB0aGUgb2xkIGFjdGl2ZU9iamVjdCB3aXRoIHRoZSBjdXJyZW50IG9uZSBhbmQgZmlyZXMgY29ycmVjdCBldmVudHNcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iaiBvbGQgYWN0aXZlT2JqZWN0XG4gICAgICovXG4gICAgX2ZpcmVTZWxlY3Rpb25FdmVudHM6IGZ1bmN0aW9uKG9sZE9iamVjdHMsIGUpIHtcbiAgICAgIHZhciBzb21ldGhpbmdDaGFuZ2VkID0gZmFsc2UsIG9iamVjdHMgPSB0aGlzLmdldEFjdGl2ZU9iamVjdHMoKSxcbiAgICAgICAgICBhZGRlZCA9IFtdLCByZW1vdmVkID0gW107XG4gICAgICBvbGRPYmplY3RzLmZvckVhY2goZnVuY3Rpb24ob2xkT2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3RzLmluZGV4T2Yob2xkT2JqZWN0KSA9PT0gLTEpIHtcbiAgICAgICAgICBzb21ldGhpbmdDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICBvbGRPYmplY3QuZmlyZSgnZGVzZWxlY3RlZCcsIHtcbiAgICAgICAgICAgIGU6IGUsXG4gICAgICAgICAgICB0YXJnZXQ6IG9sZE9iamVjdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlbW92ZWQucHVzaChvbGRPYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9iamVjdHMuZm9yRWFjaChmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgaWYgKG9sZE9iamVjdHMuaW5kZXhPZihvYmplY3QpID09PSAtMSkge1xuICAgICAgICAgIHNvbWV0aGluZ0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIG9iamVjdC5maXJlKCdzZWxlY3RlZCcsIHtcbiAgICAgICAgICAgIGU6IGUsXG4gICAgICAgICAgICB0YXJnZXQ6IG9iamVjdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFkZGVkLnB1c2gob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAob2xkT2JqZWN0cy5sZW5ndGggPiAwICYmIG9iamVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBzb21ldGhpbmdDaGFuZ2VkICYmIHRoaXMuZmlyZSgnc2VsZWN0aW9uOnVwZGF0ZWQnLCB7XG4gICAgICAgICAgZTogZSxcbiAgICAgICAgICBzZWxlY3RlZDogYWRkZWQsXG4gICAgICAgICAgZGVzZWxlY3RlZDogcmVtb3ZlZCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5maXJlKCdzZWxlY3Rpb246Y3JlYXRlZCcsIHtcbiAgICAgICAgICBlOiBlLFxuICAgICAgICAgIHNlbGVjdGVkOiBhZGRlZCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvbGRPYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5maXJlKCdzZWxlY3Rpb246Y2xlYXJlZCcsIHtcbiAgICAgICAgICBlOiBlLFxuICAgICAgICAgIGRlc2VsZWN0ZWQ6IHJlbW92ZWQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGdpdmVuIG9iamVjdCBhcyB0aGUgb25seSBhY3RpdmUgb2JqZWN0IG9uIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzZXQgYXMgYW4gYWN0aXZlIG9uZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtlXSBFdmVudCAocGFzc2VkIGFsb25nIHdoZW4gZmlyaW5nIFwib2JqZWN0OnNlbGVjdGVkXCIpXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRBY3RpdmVPYmplY3Q6IGZ1bmN0aW9uIChvYmplY3QsIGUpIHtcbiAgICAgIHZhciBjdXJyZW50QWN0aXZlcyA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0cygpO1xuICAgICAgdGhpcy5fc2V0QWN0aXZlT2JqZWN0KG9iamVjdCwgZSk7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uRXZlbnRzKGN1cnJlbnRBY3RpdmVzLCBlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGEgcHJpdmF0ZSBtZXRob2QgZm9yIG5vdy5cbiAgICAgKiBUaGlzIGlzIHN1cHBvc2VkIHRvIGJlIGVxdWl2YWxlbnQgdG8gc2V0QWN0aXZlT2JqZWN0IGJ1dCB3aXRob3V0IGZpcmluZ1xuICAgICAqIGFueSBldmVudC4gVGhlcmUgaXMgY29tbWl0bWVudCB0byBoYXZlIHRoaXMgc3RheSB0aGlzIHdheS5cbiAgICAgKiBUaGlzIGlzIHRoZSBmdW5jdGlvbmFsIHBhcnQgb2Ygc2V0QWN0aXZlT2JqZWN0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBzZXQgYXMgYWN0aXZlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IChwYXNzZWQgYWxvbmcgd2hlbiBmaXJpbmcgXCJvYmplY3Q6c2VsZWN0ZWRcIilcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBzZWxlY3Rpb24gaGFwcGVuZWRcbiAgICAgKi9cbiAgICBfc2V0QWN0aXZlT2JqZWN0OiBmdW5jdGlvbihvYmplY3QsIGUpIHtcbiAgICAgIGlmICh0aGlzLl9hY3RpdmVPYmplY3QgPT09IG9iamVjdCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX2Rpc2NhcmRBY3RpdmVPYmplY3QoZSwgb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0Lm9uU2VsZWN0KHsgZTogZSB9KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLl9hY3RpdmVPYmplY3QgPSBvYmplY3Q7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhIHByaXZhdGUgbWV0aG9kIGZvciBub3cuXG4gICAgICogVGhpcyBpcyBzdXBwb3NlZCB0byBiZSBlcXVpdmFsZW50IHRvIGRpc2NhcmRBY3RpdmVPYmplY3QgYnV0IHdpdGhvdXQgZmlyaW5nXG4gICAgICogYW55IGV2ZW50cy4gVGhlcmUgaXMgY29tbWl0bWVudCB0byBoYXZlIHRoaXMgc3RheSB0aGlzIHdheS5cbiAgICAgKiBUaGlzIGlzIHRoZSBmdW5jdGlvbmFsIHBhcnQgb2YgZGlzY2FyZEFjdGl2ZU9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgKHBhc3NlZCBhbG9uZyB3aGVuIGZpcmluZyBcIm9iamVjdDpkZXNlbGVjdGVkXCIpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBzZXQgYXMgYWN0aXZlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2VsZWN0aW9uIGhhcHBlbmVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGlzY2FyZEFjdGl2ZU9iamVjdDogZnVuY3Rpb24oZSwgb2JqZWN0KSB7XG4gICAgICB2YXIgb2JqID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgICAgaWYgKG9iaikge1xuICAgICAgICAvLyBvbkRlc2VsZWN0IHJldHVybiBUUlVFIHRvIGNhbmNlbCBzZWxlY3Rpb247XG4gICAgICAgIGlmIChvYmoub25EZXNlbGVjdCh7IGU6IGUsIG9iamVjdDogb2JqZWN0IH0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FjdGl2ZU9iamVjdCA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlzY2FyZHMgY3VycmVudGx5IGFjdGl2ZSBvYmplY3QgYW5kIGZpcmUgZXZlbnRzLiBJZiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IGZhYnJpY1xuICAgICAqIGFzIGEgY29uc2VxdWVuY2Ugb2YgYSBtb3VzZSBldmVudCwgdGhlIGV2ZW50IGlzIHBhc3NlZCBhcyBhIHBhcmFtZXRlciBhbmRcbiAgICAgKiBzZW50IHRvIHRoZSBmaXJlIGZ1bmN0aW9uIGZvciB0aGUgY3VzdG9tIGV2ZW50cy4gV2hlbiB1c2VkIGFzIGEgbWV0aG9kIHRoZVxuICAgICAqIGUgcGFyYW0gZG9lcyBub3QgaGF2ZSBhbnkgYXBwbGljYXRpb24uXG4gICAgICogQHBhcmFtIHtldmVudH0gZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZGlzY2FyZEFjdGl2ZU9iamVjdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBjdXJyZW50QWN0aXZlcyA9IHRoaXMuZ2V0QWN0aXZlT2JqZWN0cygpLCBhY3RpdmVPYmplY3QgPSB0aGlzLmdldEFjdGl2ZU9iamVjdCgpO1xuICAgICAgaWYgKGN1cnJlbnRBY3RpdmVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmZpcmUoJ2JlZm9yZTpzZWxlY3Rpb246Y2xlYXJlZCcsIHsgdGFyZ2V0OiBhY3RpdmVPYmplY3QsIGU6IGUgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9kaXNjYXJkQWN0aXZlT2JqZWN0KGUpO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkV2ZW50cyhjdXJyZW50QWN0aXZlcywgZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGEgY2FudmFzIGVsZW1lbnQgYW5kIHJlbW92ZXMgYWxsIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHdyYXBwZXIgPSB0aGlzLndyYXBwZXJFbDtcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICB3cmFwcGVyLnJlbW92ZUNoaWxkKHRoaXMudXBwZXJDYW52YXNFbCk7XG4gICAgICB3cmFwcGVyLnJlbW92ZUNoaWxkKHRoaXMubG93ZXJDYW52YXNFbCk7XG4gICAgICB0aGlzLmNvbnRleHRDYWNoZSA9IG51bGw7XG4gICAgICB0aGlzLmNvbnRleHRUb3AgPSBudWxsO1xuICAgICAgWyd1cHBlckNhbnZhc0VsJywgJ2NhY2hlQ2FudmFzRWwnXS5mb3JFYWNoKChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIGZhYnJpYy51dGlsLmNsZWFuVXBKc2RvbU5vZGUodGhpc1tlbGVtZW50XSk7XG4gICAgICAgIHRoaXNbZWxlbWVudF0gPSB1bmRlZmluZWQ7XG4gICAgICB9KS5iaW5kKHRoaXMpKTtcbiAgICAgIGlmICh3cmFwcGVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgd3JhcHBlci5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh0aGlzLmxvd2VyQ2FudmFzRWwsIHRoaXMud3JhcHBlckVsKTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0aGlzLndyYXBwZXJFbDtcbiAgICAgIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIGNvbnRleHRzIChiYWNrZ3JvdW5kLCBtYWluLCB0b3ApIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7ZmFicmljLkNhbnZhc30gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gdGhpcy5kaXNjYXJkQWN0aXZlR3JvdXAoKTtcbiAgICAgIHRoaXMuZGlzY2FyZEFjdGl2ZU9iamVjdCgpO1xuICAgICAgdGhpcy5jbGVhckNvbnRleHQodGhpcy5jb250ZXh0VG9wKTtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcignY2xlYXInKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhd3Mgb2JqZWN0cycgY29udHJvbHMgKGJvcmRlcnMvY29udHJvbHMpXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBjb250cm9scyBvblxuICAgICAqL1xuICAgIGRyYXdDb250cm9sczogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgYWN0aXZlT2JqZWN0ID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuXG4gICAgICBpZiAoYWN0aXZlT2JqZWN0KSB7XG4gICAgICAgIGFjdGl2ZU9iamVjdC5fcmVuZGVyQ29udHJvbHMoY3R4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdG9PYmplY3Q6IGZ1bmN0aW9uKGluc3RhbmNlLCBtZXRob2ROYW1lLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICAvL0lmIHRoZSBvYmplY3QgaXMgcGFydCBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24gZ3JvdXAsIGl0IHNob3VsZFxuICAgICAgLy9iZSB0cmFuc2Zvcm1lZCBhcHByb3ByaWF0ZWx5XG4gICAgICAvL2kuZS4gaXQgc2hvdWxkIGJlIHNlcmlhbGlzZWQgYXMgaXQgd291bGQgYXBwZWFyIGlmIHRoZSBzZWxlY3Rpb24gZ3JvdXBcbiAgICAgIC8vd2VyZSB0byBiZSBkZXN0cm95ZWQuXG4gICAgICB2YXIgb3JpZ2luYWxQcm9wZXJ0aWVzID0gdGhpcy5fcmVhbGl6ZUdyb3VwVHJhbnNmb3JtT25PYmplY3QoaW5zdGFuY2UpLFxuICAgICAgICAgIG9iamVjdCA9IHRoaXMuY2FsbFN1cGVyKCdfdG9PYmplY3QnLCBpbnN0YW5jZSwgbWV0aG9kTmFtZSwgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICAvL1VuZG8gdGhlIGRhbWFnZSB3ZSBkaWQgYnkgY2hhbmdpbmcgYWxsIG9mIGl0cyBwcm9wZXJ0aWVzXG4gICAgICB0aGlzLl91bndpbmRHcm91cFRyYW5zZm9ybU9uT2JqZWN0KGluc3RhbmNlLCBvcmlnaW5hbFByb3BlcnRpZXMpO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVhbGlzZXMgYW4gb2JqZWN0J3MgZ3JvdXAgdHJhbnNmb3JtYXRpb24gb24gaXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gW2luc3RhbmNlXSB0aGUgb2JqZWN0IHRvIHRyYW5zZm9ybSAoZ2V0cyBtdXRhdGVkKVxuICAgICAqIEByZXR1cm5zIHRoZSBvcmlnaW5hbCB2YWx1ZXMgb2YgaW5zdGFuY2Ugd2hpY2ggd2VyZSBjaGFuZ2VkXG4gICAgICovXG4gICAgX3JlYWxpemVHcm91cFRyYW5zZm9ybU9uT2JqZWN0OiBmdW5jdGlvbihpbnN0YW5jZSkge1xuICAgICAgaWYgKGluc3RhbmNlLmdyb3VwICYmIGluc3RhbmNlLmdyb3VwLnR5cGUgPT09ICdhY3RpdmVTZWxlY3Rpb24nICYmIHRoaXMuX2FjdGl2ZU9iamVjdCA9PT0gaW5zdGFuY2UuZ3JvdXApIHtcbiAgICAgICAgdmFyIGxheW91dFByb3BzID0gWydhbmdsZScsICdmbGlwWCcsICdmbGlwWScsICdsZWZ0JywgJ3NjYWxlWCcsICdzY2FsZVknLCAnc2tld1gnLCAnc2tld1knLCAndG9wJ107XG4gICAgICAgIC8vQ29weSBhbGwgdGhlIHBvc2l0aW9uYWxseSByZWxldmFudCBwcm9wZXJ0aWVzIGFjcm9zcyBub3dcbiAgICAgICAgdmFyIG9yaWdpbmFsVmFsdWVzID0ge307XG4gICAgICAgIGxheW91dFByb3BzLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgIG9yaWdpbmFsVmFsdWVzW3Byb3BdID0gaW5zdGFuY2VbcHJvcF07XG4gICAgICAgIH0pO1xuICAgICAgICBmYWJyaWMudXRpbC5hZGRUcmFuc2Zvcm1Ub09iamVjdChpbnN0YW5jZSwgdGhpcy5fYWN0aXZlT2JqZWN0LmNhbGNPd25NYXRyaXgoKSk7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFZhbHVlcztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzdG9yZXMgdGhlIGNoYW5nZWQgcHJvcGVydGllcyBvZiBpbnN0YW5jZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBbaW5zdGFuY2VdIHRoZSBvYmplY3QgdG8gdW4tdHJhbnNmb3JtIChnZXRzIG11dGF0ZWQpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcmlnaW5hbFZhbHVlc10gdGhlIG9yaWdpbmFsIHZhbHVlcyBvZiBpbnN0YW5jZSwgYXMgcmV0dXJuZWQgYnkgX3JlYWxpemVHcm91cFRyYW5zZm9ybU9uT2JqZWN0XG4gICAgICovXG4gICAgX3Vud2luZEdyb3VwVHJhbnNmb3JtT25PYmplY3Q6IGZ1bmN0aW9uKGluc3RhbmNlLCBvcmlnaW5hbFZhbHVlcykge1xuICAgICAgaWYgKG9yaWdpbmFsVmFsdWVzKSB7XG4gICAgICAgIGluc3RhbmNlLnNldChvcmlnaW5hbFZhbHVlcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFNWR09iamVjdDogZnVuY3Rpb24obWFya3VwLCBpbnN0YW5jZSwgcmV2aXZlcikge1xuICAgICAgLy9JZiB0aGUgb2JqZWN0IGlzIGluIGEgc2VsZWN0aW9uIGdyb3VwLCBzaW11bGF0ZSB3aGF0IHdvdWxkIGhhcHBlbiB0byB0aGF0XG4gICAgICAvL29iamVjdCB3aGVuIHRoZSBncm91cCBpcyBkZXNlbGVjdGVkXG4gICAgICB2YXIgb3JpZ2luYWxQcm9wZXJ0aWVzID0gdGhpcy5fcmVhbGl6ZUdyb3VwVHJhbnNmb3JtT25PYmplY3QoaW5zdGFuY2UpO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19zZXRTVkdPYmplY3QnLCBtYXJrdXAsIGluc3RhbmNlLCByZXZpdmVyKTtcbiAgICAgIHRoaXMuX3Vud2luZEdyb3VwVHJhbnNmb3JtT25PYmplY3QoaW5zdGFuY2UsIG9yaWdpbmFsUHJvcGVydGllcyk7XG4gICAgfSxcblxuICAgIHNldFZpZXdwb3J0VHJhbnNmb3JtOiBmdW5jdGlvbiAodnB0KSB7XG4gICAgICBpZiAodGhpcy5yZW5kZXJPbkFkZFJlbW92ZSAmJiB0aGlzLl9hY3RpdmVPYmplY3QgJiYgdGhpcy5fYWN0aXZlT2JqZWN0LmlzRWRpdGluZykge1xuICAgICAgICB0aGlzLl9hY3RpdmVPYmplY3QuY2xlYXJDb250ZXh0VG9wKCk7XG4gICAgICB9XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5zZXRWaWV3cG9ydFRyYW5zZm9ybS5jYWxsKHRoaXMsIHZwdCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBjb3B5aW5nIHN0YXRpYyBwcm9wZXJ0aWVzIG1hbnVhbGx5IHRvIHdvcmsgYXJvdW5kIE9wZXJhJ3MgYnVnLFxuICAvLyB3aGVyZSBcInByb3RvdHlwZVwiIHByb3BlcnR5IGlzIGVudW1lcmFibGUgYW5kIG92ZXJyaWRlcyBleGlzdGluZyBwcm90b3R5cGVcbiAgZm9yICh2YXIgcHJvcCBpbiBmYWJyaWMuU3RhdGljQ2FudmFzKSB7XG4gICAgaWYgKHByb3AgIT09ICdwcm90b3R5cGUnKSB7XG4gICAgICBmYWJyaWMuQ2FudmFzW3Byb3BdID0gZmFicmljLlN0YXRpY0NhbnZhc1twcm9wXTtcbiAgICB9XG4gIH1cbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBhZGRMaXN0ZW5lciA9IGZhYnJpYy51dGlsLmFkZExpc3RlbmVyLFxuICAgICAgcmVtb3ZlTGlzdGVuZXIgPSBmYWJyaWMudXRpbC5yZW1vdmVMaXN0ZW5lcixcbiAgICAgIFJJR0hUX0NMSUNLID0gMywgTUlERExFX0NMSUNLID0gMiwgTEVGVF9DTElDSyA9IDEsXG4gICAgICBhZGRFdmVudE9wdGlvbnMgPSB7IHBhc3NpdmU6IGZhbHNlIH07XG5cbiAgZnVuY3Rpb24gY2hlY2tDbGljayhlLCB2YWx1ZSkge1xuICAgIHJldHVybiBlLmJ1dHRvbiAmJiAoZS5idXR0b24gPT09IHZhbHVlIC0gMSk7XG4gIH1cblxuICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5DYW52YXMucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5DYW52YXMucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIENvbnRhaW5zIHRoZSBpZCBvZiB0aGUgdG91Y2ggZXZlbnQgdGhhdCBvd25zIHRoZSBmYWJyaWMgdHJhbnNmb3JtXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBtYWluVG91Y2hJZDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgbW91c2UgbGlzdGVuZXJzIHRvIGNhbnZhc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRFdmVudExpc3RlbmVyczogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gaW4gY2FzZSB3ZSBpbml0aWFsaXplZCB0aGUgY2xhc3MgdHdpY2UuIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW4gbm9ybWFsbHlcbiAgICAgIC8vIGJ1dCBpbiBzb21lIGtpbmQgb2YgYXBwbGljYXRpb25zIHdoZXJlIHRoZSBjYW52YXMgZWxlbWVudCBtYXkgYmUgY2hhbmdlZFxuICAgICAgLy8gdGhpcyBpcyBhIHdvcmthcm91bmQgdG8gaGF2aW5nIGRvdWJsZSBsaXN0ZW5lcnMuXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICAgICAgdGhpcy5hZGRPclJlbW92ZShhZGRMaXN0ZW5lciwgJ2FkZCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gYW4gZXZlbnQgcHJlZml4IHBvaW50ZXIgb3IgbW91c2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0RXZlbnRQcmVmaXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuYWJsZVBvaW50ZXJFdmVudHMgPyAncG9pbnRlcicgOiAnbW91c2UnO1xuICAgIH0sXG5cbiAgICBhZGRPclJlbW92ZTogZnVuY3Rpb24oZnVuY3RvciwgZXZlbnRqc0Z1bmN0b3IpIHtcbiAgICAgIHZhciBjYW52YXNFbGVtZW50ID0gdGhpcy51cHBlckNhbnZhc0VsLFxuICAgICAgICAgIGV2ZW50VHlwZVByZWZpeCA9IHRoaXMuX2dldEV2ZW50UHJlZml4KCk7XG4gICAgICBmdW5jdG9yKGZhYnJpYy53aW5kb3csICdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZSk7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsIGV2ZW50VHlwZVByZWZpeCArICdkb3duJywgdGhpcy5fb25Nb3VzZURvd24pO1xuICAgICAgZnVuY3RvcihjYW52YXNFbGVtZW50LCBldmVudFR5cGVQcmVmaXggKyAnbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgZnVuY3RvcihjYW52YXNFbGVtZW50LCBldmVudFR5cGVQcmVmaXggKyAnb3V0JywgdGhpcy5fb25Nb3VzZU91dCk7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsIGV2ZW50VHlwZVByZWZpeCArICdlbnRlcicsIHRoaXMuX29uTW91c2VFbnRlcik7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsICd3aGVlbCcsIHRoaXMuX29uTW91c2VXaGVlbCk7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsICdjb250ZXh0bWVudScsIHRoaXMuX29uQ29udGV4dE1lbnUpO1xuICAgICAgZnVuY3RvcihjYW52YXNFbGVtZW50LCAnZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrKTtcbiAgICAgIGZ1bmN0b3IoY2FudmFzRWxlbWVudCwgJ2RyYWdvdmVyJywgdGhpcy5fb25EcmFnT3Zlcik7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsICdkcmFnZW50ZXInLCB0aGlzLl9vbkRyYWdFbnRlcik7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsICdkcmFnbGVhdmUnLCB0aGlzLl9vbkRyYWdMZWF2ZSk7XG4gICAgICBmdW5jdG9yKGNhbnZhc0VsZW1lbnQsICdkcm9wJywgdGhpcy5fb25Ecm9wKTtcbiAgICAgIGlmICghdGhpcy5lbmFibGVQb2ludGVyRXZlbnRzKSB7XG4gICAgICAgIGZ1bmN0b3IoY2FudmFzRWxlbWVudCwgJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoU3RhcnQsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGV2ZW50anMgIT09ICd1bmRlZmluZWQnICYmIGV2ZW50anNGdW5jdG9yIGluIGV2ZW50anMpIHtcbiAgICAgICAgZXZlbnRqc1tldmVudGpzRnVuY3Rvcl0oY2FudmFzRWxlbWVudCwgJ2dlc3R1cmUnLCB0aGlzLl9vbkdlc3R1cmUpO1xuICAgICAgICBldmVudGpzW2V2ZW50anNGdW5jdG9yXShjYW52YXNFbGVtZW50LCAnZHJhZycsIHRoaXMuX29uRHJhZyk7XG4gICAgICAgIGV2ZW50anNbZXZlbnRqc0Z1bmN0b3JdKGNhbnZhc0VsZW1lbnQsICdvcmllbnRhdGlvbicsIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UpO1xuICAgICAgICBldmVudGpzW2V2ZW50anNGdW5jdG9yXShjYW52YXNFbGVtZW50LCAnc2hha2UnLCB0aGlzLl9vblNoYWtlKTtcbiAgICAgICAgZXZlbnRqc1tldmVudGpzRnVuY3Rvcl0oY2FudmFzRWxlbWVudCwgJ2xvbmdwcmVzcycsIHRoaXMuX29uTG9uZ1ByZXNzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgZXZlbnQgbGlzdGVuZXJzXG4gICAgICovXG4gICAgcmVtb3ZlTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuYWRkT3JSZW1vdmUocmVtb3ZlTGlzdGVuZXIsICdyZW1vdmUnKTtcbiAgICAgIC8vIGlmIHlvdSBkaXNwb3NlIG9uIGEgbW91c2VEb3duLCBiZWZvcmUgbW91c2UgdXAsIHlvdSBuZWVkIHRvIGNsZWFuIGRvY3VtZW50IHRvLi4uXG4gICAgICB2YXIgZXZlbnRUeXBlUHJlZml4ID0gdGhpcy5fZ2V0RXZlbnRQcmVmaXgoKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgZXZlbnRUeXBlUHJlZml4ICsgJ3VwJywgdGhpcy5fb25Nb3VzZVVwKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgZXZlbnRUeXBlUHJlZml4ICsgJ21vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9iaW5kRXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmV2ZW50c0JvdW5kKSB7XG4gICAgICAgIC8vIGZvciBhbnkgcmVhc29uIHdlIHBhc3MgaGVyZSB0d2ljZSB3ZSBkbyBub3Qgd2FudCB0byBiaW5kIGV2ZW50cyB0d2ljZS5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fb25Nb3VzZURvd24gPSB0aGlzLl9vbk1vdXNlRG93bi5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Ub3VjaFN0YXJ0ID0gdGhpcy5fb25Ub3VjaFN0YXJ0LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbk1vdXNlTW92ZSA9IHRoaXMuX29uTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbk1vdXNlVXAgPSB0aGlzLl9vbk1vdXNlVXAuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uVG91Y2hFbmQgPSB0aGlzLl9vblRvdWNoRW5kLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vblJlc2l6ZSA9IHRoaXMuX29uUmVzaXplLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbkdlc3R1cmUgPSB0aGlzLl9vbkdlc3R1cmUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uRHJhZyA9IHRoaXMuX29uRHJhZy5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25TaGFrZSA9IHRoaXMuX29uU2hha2UuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uTG9uZ1ByZXNzID0gdGhpcy5fb25Mb25nUHJlc3MuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UgPSB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbk1vdXNlV2hlZWwgPSB0aGlzLl9vbk1vdXNlV2hlZWwuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uTW91c2VPdXQgPSB0aGlzLl9vbk1vdXNlT3V0LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbk1vdXNlRW50ZXIgPSB0aGlzLl9vbk1vdXNlRW50ZXIuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uQ29udGV4dE1lbnUgPSB0aGlzLl9vbkNvbnRleHRNZW51LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbkRvdWJsZUNsaWNrID0gdGhpcy5fb25Eb3VibGVDbGljay5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25EcmFnT3ZlciA9IHRoaXMuX29uRHJhZ092ZXIuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uRHJhZ0VudGVyID0gdGhpcy5fc2ltcGxlRXZlbnRIYW5kbGVyLmJpbmQodGhpcywgJ2RyYWdlbnRlcicpO1xuICAgICAgdGhpcy5fb25EcmFnTGVhdmUgPSB0aGlzLl9zaW1wbGVFdmVudEhhbmRsZXIuYmluZCh0aGlzLCAnZHJhZ2xlYXZlJyk7XG4gICAgICB0aGlzLl9vbkRyb3AgPSB0aGlzLl9vbkRyb3AuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuZXZlbnRzQm91bmQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtlXSBFdmVudCBvYmplY3QgZmlyZWQgb24gRXZlbnQuanMgZ2VzdHVyZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtzZWxmXSBJbm5lciBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfb25HZXN0dXJlOiBmdW5jdGlvbihlLCBzZWxmKSB7XG4gICAgICB0aGlzLl9fb25UcmFuc2Zvcm1HZXN0dXJlICYmIHRoaXMuX19vblRyYW5zZm9ybUdlc3R1cmUoZSwgc2VsZik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBFdmVudC5qcyBkcmFnXG4gICAgICogQHBhcmFtIHtFdmVudH0gW3NlbGZdIElubmVyIEV2ZW50IG9iamVjdFxuICAgICAqL1xuICAgIF9vbkRyYWc6IGZ1bmN0aW9uKGUsIHNlbGYpIHtcbiAgICAgIHRoaXMuX19vbkRyYWcgJiYgdGhpcy5fX29uRHJhZyhlLCBzZWxmKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgb2JqZWN0IGZpcmVkIG9uIHdoZWVsIGV2ZW50XG4gICAgICovXG4gICAgX29uTW91c2VXaGVlbDogZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy5fX29uTW91c2VXaGVlbChlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBfb25Nb3VzZU91dDogZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX2hvdmVyZWRUYXJnZXQ7XG4gICAgICB0aGlzLmZpcmUoJ21vdXNlOm91dCcsIHsgdGFyZ2V0OiB0YXJnZXQsIGU6IGUgfSk7XG4gICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0ID0gbnVsbDtcbiAgICAgIHRhcmdldCAmJiB0YXJnZXQuZmlyZSgnbW91c2VvdXQnLCB7IGU6IGUgfSk7XG5cbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uKF90YXJnZXQpe1xuICAgICAgICBfdGhpcy5maXJlKCdtb3VzZTpvdXQnLCB7IHRhcmdldDogX3RhcmdldCwgZTogZSB9KTtcbiAgICAgICAgX3RhcmdldCAmJiBfdGFyZ2V0LmZpcmUoJ21vdXNlb3V0JywgeyBlOiBlIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0cyA9IFtdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlZW50ZXJcbiAgICAgKi9cbiAgICBfb25Nb3VzZUVudGVyOiBmdW5jdGlvbihlKSB7XG4gICAgICAvLyBUaGlzIGZpbmQgdGFyZ2V0IGFuZCBjb25zZXF1ZW50ICdtb3VzZTpvdmVyJyBpcyB1c2VkIHRvXG4gICAgICAvLyBjbGVhciBvbGQgaW5zdGFuY2VzIG9uIGhvdmVyZWQgdGFyZ2V0LlxuICAgICAgLy8gY2FsbGluZyBmaW5kVGFyZ2V0IGhhcyB0aGUgc2lkZSBlZmZlY3Qgb2Yga2lsbGluZyB0YXJnZXQuX19jb3JuZXIuXG4gICAgICAvLyBhcyBhIHNob3J0IHRlcm0gZml4IHdlIGFyZSBub3QgZmlyaW5nIHRoaXMgaWYgd2UgYXJlIGN1cnJlbnRseSB0cmFuc2Zvcm1pbmcuXG4gICAgICAvLyBhcyBhIGxvbmcgdGVybSBmaXggd2UgbmVlZCB0byBzZXBhcmF0ZSB0aGUgYWN0aW9uIG9mIGZpbmRpbmcgYSB0YXJnZXQgd2l0aCB0aGVcbiAgICAgIC8vIHNpZGUgZWZmZWN0cyB3ZSBhZGRlZCB0byBpdC5cbiAgICAgIGlmICghdGhpcy5fY3VycmVudFRyYW5zZm9ybSAmJiAhdGhpcy5maW5kVGFyZ2V0KGUpKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnbW91c2U6b3ZlcicsIHsgdGFyZ2V0OiBudWxsLCBlOiBlIH0pO1xuICAgICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5faG92ZXJlZFRhcmdldHMgPSBbXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgb2JqZWN0IGZpcmVkIG9uIEV2ZW50LmpzIG9yaWVudGF0aW9uIGNoYW5nZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtzZWxmXSBJbm5lciBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfb25PcmllbnRhdGlvbkNoYW5nZTogZnVuY3Rpb24oZSwgc2VsZikge1xuICAgICAgdGhpcy5fX29uT3JpZW50YXRpb25DaGFuZ2UgJiYgdGhpcy5fX29uT3JpZW50YXRpb25DaGFuZ2UoZSwgc2VsZik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBFdmVudC5qcyBzaGFrZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtzZWxmXSBJbm5lciBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfb25TaGFrZTogZnVuY3Rpb24oZSwgc2VsZikge1xuICAgICAgdGhpcy5fX29uU2hha2UgJiYgdGhpcy5fX29uU2hha2UoZSwgc2VsZik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gW2VdIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBFdmVudC5qcyBzaGFrZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtzZWxmXSBJbm5lciBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBfb25Mb25nUHJlc3M6IGZ1bmN0aW9uKGUsIHNlbGYpIHtcbiAgICAgIHRoaXMuX19vbkxvbmdQcmVzcyAmJiB0aGlzLl9fb25Mb25nUHJlc3MoZSwgc2VsZik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHByZXZlbnQgZGVmYXVsdCB0byBhbGxvdyBkcm9wIGV2ZW50IHRvIGJlIGZpcmVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbZV0gRXZlbnQgb2JqZWN0IGZpcmVkIG9uIEV2ZW50LmpzIHNoYWtlXG4gICAgICovXG4gICAgX29uRHJhZ092ZXI6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9zaW1wbGVFdmVudEhhbmRsZXIoJ2RyYWdvdmVyJywgZSk7XG4gICAgICB0aGlzLl9maXJlRW50ZXJMZWF2ZUV2ZW50cyh0YXJnZXQsIGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBgZHJvcDpiZWZvcmVgIGlzIGEgYW4gZXZlbnQgdGhhdCBhbGxvdyB5b3UgdG8gc2NoZWR1bGUgbG9naWNcbiAgICAgKiBiZWZvcmUgdGhlIGBkcm9wYCBldmVudC4gUHJlZmVyIGBkcm9wYCBldmVudCBhbHdheXMsIGJ1dCBpZiB5b3UgbmVlZFxuICAgICAqIHRvIHJ1biBzb21lIGRyb3AtZGlzYWJsaW5nIGxvZ2ljIG9uIGFuIGV2ZW50LCBzaW5jZSB0aGVyZSBpcyBubyB3YXlcbiAgICAgKiB0byBoYW5kbGUgZXZlbnQgaGFuZGxlcnMgb3JkZXJpbmcsIHVzZSBgZHJvcDpiZWZvcmVgXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqL1xuICAgIF9vbkRyb3A6IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9zaW1wbGVFdmVudEhhbmRsZXIoJ2Ryb3A6YmVmb3JlJywgZSk7XG4gICAgICByZXR1cm4gdGhpcy5fc2ltcGxlRXZlbnRIYW5kbGVyKCdkcm9wJywgZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vkb3duXG4gICAgICovXG4gICAgX29uQ29udGV4dE1lbnU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAodGhpcy5zdG9wQ29udGV4dE1lbnUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlZG93blxuICAgICAqL1xuICAgIF9vbkRvdWJsZUNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fY2FjaGVUcmFuc2Zvcm1FdmVudERhdGEoZSk7XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnZGJsY2xpY2snKTtcbiAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSB0aGUgaWQgb2YgYW4gZXZlbnQuXG4gICAgICogcmV0dXJucyBlaXRoZXIgdGhlIHBvaW50ZXJJZCBvciB0aGUgaWRlbnRpZmllciBvciAwIGZvciB0aGUgbW91c2UgZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2dCBFdmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBnZXRQb2ludGVySWQ6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdmFyIGNoYW5nZWRUb3VjaGVzID0gZXZ0LmNoYW5nZWRUb3VjaGVzO1xuXG4gICAgICBpZiAoY2hhbmdlZFRvdWNoZXMpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5nZWRUb3VjaGVzWzBdICYmIGNoYW5nZWRUb3VjaGVzWzBdLmlkZW50aWZpZXI7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmVuYWJsZVBvaW50ZXJFdmVudHMpIHtcbiAgICAgICAgcmV0dXJuIGV2dC5wb2ludGVySWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAtMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhbiBldmVudCBoYXMgdGhlIGlkIG9mIHRoZSBldmVudCB0aGF0IGlzIGNvbnNpZGVyZWQgbWFpblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtldnR9IGV2ZW50IEV2ZW50IG9iamVjdFxuICAgICAqL1xuICAgIF9pc01haW5FdmVudDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICBpZiAoZXZ0LmlzUHJpbWFyeSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChldnQuaXNQcmltYXJ5ID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoZXZ0LnR5cGUgPT09ICd0b3VjaGVuZCcgJiYgZXZ0LnRvdWNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGV2dC5jaGFuZ2VkVG91Y2hlcykge1xuICAgICAgICByZXR1cm4gZXZ0LmNoYW5nZWRUb3VjaGVzWzBdLmlkZW50aWZpZXIgPT09IHRoaXMubWFpblRvdWNoSWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBfb25Ub3VjaFN0YXJ0OiBmdW5jdGlvbihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAodGhpcy5tYWluVG91Y2hJZCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLm1haW5Ub3VjaElkID0gdGhpcy5nZXRQb2ludGVySWQoZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9fb25Nb3VzZURvd24oZSk7XG4gICAgICB0aGlzLl9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YSgpO1xuICAgICAgdmFyIGNhbnZhc0VsZW1lbnQgPSB0aGlzLnVwcGVyQ2FudmFzRWwsXG4gICAgICAgICAgZXZlbnRUeXBlUHJlZml4ID0gdGhpcy5fZ2V0RXZlbnRQcmVmaXgoKTtcbiAgICAgIGFkZExpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICAgIGFkZExpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgLy8gVW5iaW5kIG1vdXNlZG93biB0byBwcmV2ZW50IGRvdWJsZSB0cmlnZ2VycyBmcm9tIHRvdWNoIGRldmljZXNcbiAgICAgIHJlbW92ZUxpc3RlbmVyKGNhbnZhc0VsZW1lbnQsIGV2ZW50VHlwZVByZWZpeCArICdkb3duJywgdGhpcy5fb25Nb3VzZURvd24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlZG93blxuICAgICAqL1xuICAgIF9vbk1vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX19vbk1vdXNlRG93bihlKTtcbiAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKCk7XG4gICAgICB2YXIgY2FudmFzRWxlbWVudCA9IHRoaXMudXBwZXJDYW52YXNFbCxcbiAgICAgICAgICBldmVudFR5cGVQcmVmaXggPSB0aGlzLl9nZXRFdmVudFByZWZpeCgpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoY2FudmFzRWxlbWVudCwgZXZlbnRUeXBlUHJlZml4ICsgJ21vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICAgIGFkZExpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgZXZlbnRUeXBlUHJlZml4ICsgJ3VwJywgdGhpcy5fb25Nb3VzZVVwKTtcbiAgICAgIGFkZExpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgZXZlbnRUeXBlUHJlZml4ICsgJ21vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZWRvd25cbiAgICAgKi9cbiAgICBfb25Ub3VjaEVuZDogZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIGlmIHRoZXJlIGFyZSBzdGlsbCB0b3VjaGVzIHN0b3AgaGVyZVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9fb25Nb3VzZVVwKGUpO1xuICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKTtcbiAgICAgIHRoaXMubWFpblRvdWNoSWQgPSBudWxsO1xuICAgICAgdmFyIGV2ZW50VHlwZVByZWZpeCA9IHRoaXMuX2dldEV2ZW50UHJlZml4KCk7XG4gICAgICByZW1vdmVMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQsIGFkZEV2ZW50T3B0aW9ucyk7XG4gICAgICByZW1vdmVMaXN0ZW5lcihmYWJyaWMuZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgYWRkRXZlbnRPcHRpb25zKTtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5fd2lsbEFkZE1vdXNlRG93bikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fd2lsbEFkZE1vdXNlRG93bik7XG4gICAgICB9XG4gICAgICB0aGlzLl93aWxsQWRkTW91c2VEb3duID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gV2FpdCA0MDBtcyBiZWZvcmUgcmViaW5kaW5nIG1vdXNlZG93biB0byBwcmV2ZW50IGRvdWJsZSB0cmlnZ2Vyc1xuICAgICAgICAvLyBmcm9tIHRvdWNoIGRldmljZXNcbiAgICAgICAgYWRkTGlzdGVuZXIoX3RoaXMudXBwZXJDYW52YXNFbCwgZXZlbnRUeXBlUHJlZml4ICsgJ2Rvd24nLCBfdGhpcy5fb25Nb3VzZURvd24pO1xuICAgICAgICBfdGhpcy5fd2lsbEFkZE1vdXNlRG93biA9IDA7XG4gICAgICB9LCA0MDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNldXBcbiAgICAgKi9cbiAgICBfb25Nb3VzZVVwOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5fX29uTW91c2VVcChlKTtcbiAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKCk7XG4gICAgICB2YXIgY2FudmFzRWxlbWVudCA9IHRoaXMudXBwZXJDYW52YXNFbCxcbiAgICAgICAgICBldmVudFR5cGVQcmVmaXggPSB0aGlzLl9nZXRFdmVudFByZWZpeCgpO1xuICAgICAgaWYgKHRoaXMuX2lzTWFpbkV2ZW50KGUpKSB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKGZhYnJpYy5kb2N1bWVudCwgZXZlbnRUeXBlUHJlZml4ICsgJ3VwJywgdGhpcy5fb25Nb3VzZVVwKTtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoZmFicmljLmRvY3VtZW50LCBldmVudFR5cGVQcmVmaXggKyAnbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgICBhZGRMaXN0ZW5lcihjYW52YXNFbGVtZW50LCBldmVudFR5cGVQcmVmaXggKyAnbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCBhZGRFdmVudE9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlbW92ZVxuICAgICAqL1xuICAgIF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICF0aGlzLmFsbG93VG91Y2hTY3JvbGxpbmcgJiYgZS5wcmV2ZW50RGVmYXVsdCAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLl9fb25Nb3VzZU1vdmUoZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uUmVzaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmNhbGNPZmZzZXQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVjaWRlcyB3aGV0aGVyIHRoZSBjYW52YXMgc2hvdWxkIGJlIHJlZHJhd24gaW4gbW91c2V1cCBhbmQgbW91c2Vkb3duIGV2ZW50cy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cbiAgICBfc2hvdWxkUmVuZGVyOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgIHZhciBhY3RpdmVPYmplY3QgPSB0aGlzLl9hY3RpdmVPYmplY3Q7XG5cbiAgICAgIGlmIChcbiAgICAgICAgISFhY3RpdmVPYmplY3QgIT09ICEhdGFyZ2V0IHx8XG4gICAgICAgIChhY3RpdmVPYmplY3QgJiYgdGFyZ2V0ICYmIChhY3RpdmVPYmplY3QgIT09IHRhcmdldCkpXG4gICAgICApIHtcbiAgICAgICAgLy8gdGhpcyBjb3ZlcnM6IHN3aXRjaCBvZiB0YXJnZXQsIGZyb20gdGFyZ2V0IHRvIG5vIHRhcmdldCwgc2VsZWN0aW9uIG9mIHRhcmdldFxuICAgICAgICAvLyBtdWx0aVNlbGVjdGlvbiB3aXRoIGtleSBhbmQgbW91c2VcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhY3RpdmVPYmplY3QgJiYgYWN0aXZlT2JqZWN0LmlzRWRpdGluZykge1xuICAgICAgICAvLyBpZiB3ZSBtb3VzZSB1cC9kb3duIG92ZXIgYSBlZGl0aW5nIHRleHRib3ggYSBjdXJzb3IgY2hhbmdlLFxuICAgICAgICAvLyB0aGVyZSBpcyBubyBuZWVkIHRvIHJlIHJlbmRlclxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IGRlZmluZXMgdGhlIGFjdGlvbnMgd2hlbiBtb3VzZSBpcyByZWxlYXNlZCBvbiBjYW52YXMuXG4gICAgICogVGhlIG1ldGhvZCByZXNldHMgdGhlIGN1cnJlbnRUcmFuc2Zvcm0gcGFyYW1ldGVycywgc3RvcmUgdGhlIGltYWdlIGNvcm5lclxuICAgICAqIHBvc2l0aW9uIGluIHRoZSBpbWFnZSBvYmplY3QgYW5kIHJlbmRlciB0aGUgY2FudmFzIG9uIHRvcC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNldXBcbiAgICAgKi9cbiAgICBfX29uTW91c2VVcDogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciB0YXJnZXQsIHRyYW5zZm9ybSA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0sXG4gICAgICAgICAgZ3JvdXBTZWxlY3RvciA9IHRoaXMuX2dyb3VwU2VsZWN0b3IsIHNob3VsZFJlbmRlciA9IGZhbHNlLFxuICAgICAgICAgIGlzQ2xpY2sgPSAoIWdyb3VwU2VsZWN0b3IgfHwgKGdyb3VwU2VsZWN0b3IubGVmdCA9PT0gMCAmJiBncm91cFNlbGVjdG9yLnRvcCA9PT0gMCkpO1xuICAgICAgdGhpcy5fY2FjaGVUcmFuc2Zvcm1FdmVudERhdGEoZSk7XG4gICAgICB0YXJnZXQgPSB0aGlzLl90YXJnZXQ7XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAndXA6YmVmb3JlJyk7XG4gICAgICAvLyBpZiByaWdodC9taWRkbGUgY2xpY2sganVzdCBmaXJlIGV2ZW50cyBhbmQgcmV0dXJuXG4gICAgICAvLyB0YXJnZXQgdW5kZWZpbmVkIHdpbGwgbWFrZSB0aGUgX2hhbmRsZUV2ZW50IHNlYXJjaCB0aGUgdGFyZ2V0XG4gICAgICBpZiAoY2hlY2tDbGljayhlLCBSSUdIVF9DTElDSykpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlyZVJpZ2h0Q2xpY2spIHtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAndXAnLCBSSUdIVF9DTElDSywgaXNDbGljayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hlY2tDbGljayhlLCBNSURETEVfQ0xJQ0spKSB7XG4gICAgICAgIGlmICh0aGlzLmZpcmVNaWRkbGVDbGljaykge1xuICAgICAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICd1cCcsIE1JRERMRV9DTElDSywgaXNDbGljayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc0RyYXdpbmdNb2RlICYmIHRoaXMuX2lzQ3VycmVudGx5RHJhd2luZykge1xuICAgICAgICB0aGlzLl9vbk1vdXNlVXBJbkRyYXdpbmdNb2RlKGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5faXNNYWluRXZlbnQoZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICB0aGlzLl9maW5hbGl6ZUN1cnJlbnRUcmFuc2Zvcm0oZSk7XG4gICAgICAgIHNob3VsZFJlbmRlciA9IHRyYW5zZm9ybS5hY3Rpb25QZXJmb3JtZWQ7XG4gICAgICB9XG4gICAgICBpZiAoIWlzQ2xpY2spIHtcbiAgICAgICAgdmFyIHRhcmdldFdhc0FjdGl2ZSA9IHRhcmdldCA9PT0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgICAgICB0aGlzLl9tYXliZUdyb3VwT2JqZWN0cyhlKTtcbiAgICAgICAgaWYgKCFzaG91bGRSZW5kZXIpIHtcbiAgICAgICAgICBzaG91bGRSZW5kZXIgPSAoXG4gICAgICAgICAgICB0aGlzLl9zaG91bGRSZW5kZXIodGFyZ2V0KSB8fFxuICAgICAgICAgICAgKCF0YXJnZXRXYXNBY3RpdmUgJiYgdGFyZ2V0ID09PSB0aGlzLl9hY3RpdmVPYmplY3QpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNvcm5lciwgcG9pbnRlcjtcbiAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgY29ybmVyID0gdGFyZ2V0Ll9maW5kVGFyZ2V0Q29ybmVyKFxuICAgICAgICAgIHRoaXMuZ2V0UG9pbnRlcihlLCB0cnVlKSxcbiAgICAgICAgICBmYWJyaWMudXRpbC5pc1RvdWNoRXZlbnQoZSlcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHRhcmdldC5zZWxlY3RhYmxlICYmIHRhcmdldCAhPT0gdGhpcy5fYWN0aXZlT2JqZWN0ICYmIHRhcmdldC5hY3RpdmVPbiA9PT0gJ3VwJykge1xuICAgICAgICAgIHRoaXMuc2V0QWN0aXZlT2JqZWN0KHRhcmdldCwgZSk7XG4gICAgICAgICAgc2hvdWxkUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgY29udHJvbCA9IHRhcmdldC5jb250cm9sc1tjb3JuZXJdLFxuICAgICAgICAgICAgICBtb3VzZVVwSGFuZGxlciA9IGNvbnRyb2wgJiYgY29udHJvbC5nZXRNb3VzZVVwSGFuZGxlcihlLCB0YXJnZXQsIGNvbnRyb2wpO1xuICAgICAgICAgIGlmIChtb3VzZVVwSGFuZGxlcikge1xuICAgICAgICAgICAgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihlKTtcbiAgICAgICAgICAgIG1vdXNlVXBIYW5kbGVyKGUsIHRyYW5zZm9ybSwgcG9pbnRlci54LCBwb2ludGVyLnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQuaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHdlIGFyZSBlbmRpbmcgdXAgYSB0cmFuc2Zvcm0gb24gYSBkaWZmZXJlbnQgY29udHJvbCBvciBhIG5ldyBvYmplY3RcbiAgICAgIC8vIGZpcmUgdGhlIG9yaWdpbmFsIG1vdXNlIHVwIGZyb20gdGhlIGNvcm5lciB0aGF0IHN0YXJ0ZWQgdGhlIHRyYW5zZm9ybVxuICAgICAgaWYgKHRyYW5zZm9ybSAmJiAodHJhbnNmb3JtLnRhcmdldCAhPT0gdGFyZ2V0IHx8IHRyYW5zZm9ybS5jb3JuZXIgIT09IGNvcm5lcikpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsQ29udHJvbCA9IHRyYW5zZm9ybS50YXJnZXQgJiYgdHJhbnNmb3JtLnRhcmdldC5jb250cm9sc1t0cmFuc2Zvcm0uY29ybmVyXSxcbiAgICAgICAgICAgIG9yaWdpbmFsTW91c2VVcEhhbmRsZXIgPSBvcmlnaW5hbENvbnRyb2wgJiYgb3JpZ2luYWxDb250cm9sLmdldE1vdXNlVXBIYW5kbGVyKGUsIHRhcmdldCwgY29udHJvbCk7XG4gICAgICAgIHBvaW50ZXIgPSBwb2ludGVyIHx8IHRoaXMuZ2V0UG9pbnRlcihlKTtcbiAgICAgICAgb3JpZ2luYWxNb3VzZVVwSGFuZGxlciAmJiBvcmlnaW5hbE1vdXNlVXBIYW5kbGVyKGUsIHRyYW5zZm9ybSwgcG9pbnRlci54LCBwb2ludGVyLnkpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0Q3Vyc29yRnJvbUV2ZW50KGUsIHRhcmdldCk7XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAndXAnLCBMRUZUX0NMSUNLLCBpc0NsaWNrKTtcbiAgICAgIHRoaXMuX2dyb3VwU2VsZWN0b3IgPSBudWxsO1xuICAgICAgdGhpcy5fY3VycmVudFRyYW5zZm9ybSA9IG51bGw7XG4gICAgICAvLyByZXNldCB0aGUgdGFyZ2V0IGluZm9ybWF0aW9uIGFib3V0IHdoaWNoIGNvcm5lciBpcyBzZWxlY3RlZFxuICAgICAgdGFyZ2V0ICYmICh0YXJnZXQuX19jb3JuZXIgPSAwKTtcbiAgICAgIGlmIChzaG91bGRSZW5kZXIpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghaXNDbGljaykge1xuICAgICAgICB0aGlzLnJlbmRlclRvcCgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEhhbmRsZSBldmVudCBmaXJpbmcgZm9yIHRhcmdldCBhbmQgc3VidGFyZ2V0c1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgZXZlbnQgZnJvbSBtb3VzZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgZXZlbnQgdG8gZmlyZSAodXAsIGRvd24gb3IgbW92ZSlcbiAgICAgKiBAcmV0dXJuIHtGYWJyaWMuT2JqZWN0fSB0YXJnZXQgcmV0dXJuIHRoZSB0aGUgdGFyZ2V0IGZvdW5kLCBmb3IgaW50ZXJuYWwgcmVhc29ucy5cbiAgICAgKi9cbiAgICBfc2ltcGxlRXZlbnRIYW5kbGVyOiBmdW5jdGlvbihldmVudFR5cGUsIGUpIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmZpbmRUYXJnZXQoZSksXG4gICAgICAgICAgdGFyZ2V0cyA9IHRoaXMudGFyZ2V0cyxcbiAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgZTogZSxcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgc3ViVGFyZ2V0czogdGFyZ2V0cyxcbiAgICAgICAgICB9O1xuICAgICAgdGhpcy5maXJlKGV2ZW50VHlwZSwgb3B0aW9ucyk7XG4gICAgICB0YXJnZXQgJiYgdGFyZ2V0LmZpcmUoZXZlbnRUeXBlLCBvcHRpb25zKTtcbiAgICAgIGlmICghdGFyZ2V0cykge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRhcmdldHNbaV0uZmlyZShldmVudFR5cGUsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBIYW5kbGUgZXZlbnQgZmlyaW5nIGZvciB0YXJnZXQgYW5kIHN1YnRhcmdldHNcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIGV2ZW50IGZyb20gbW91c2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIGV2ZW50IHRvIGZpcmUgKHVwLCBkb3duIG9yIG1vdmUpXG4gICAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSB0YXJnZXRPYmogcmVjZWl2aW5nIGV2ZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtidXR0b25dIGJ1dHRvbiB1c2VkIGluIHRoZSBldmVudCAxID0gbGVmdCwgMiA9IG1pZGRsZSwgMyA9IHJpZ2h0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpc0NsaWNrIGZvciBsZWZ0IGJ1dHRvbiBvbmx5LCBpbmRpY2F0ZXMgdGhhdCB0aGUgbW91c2UgdXAgaGFwcGVuZWQgd2l0aG91dCBtb3ZlLlxuICAgICAqL1xuICAgIF9oYW5kbGVFdmVudDogZnVuY3Rpb24oZSwgZXZlbnRUeXBlLCBidXR0b24sIGlzQ2xpY2spIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXQsXG4gICAgICAgICAgdGFyZ2V0cyA9IHRoaXMudGFyZ2V0cyB8fCBbXSxcbiAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgZTogZSxcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgc3ViVGFyZ2V0czogdGFyZ2V0cyxcbiAgICAgICAgICAgIGJ1dHRvbjogYnV0dG9uIHx8IExFRlRfQ0xJQ0ssXG4gICAgICAgICAgICBpc0NsaWNrOiBpc0NsaWNrIHx8IGZhbHNlLFxuICAgICAgICAgICAgcG9pbnRlcjogdGhpcy5fcG9pbnRlcixcbiAgICAgICAgICAgIGFic29sdXRlUG9pbnRlcjogdGhpcy5fYWJzb2x1dGVQb2ludGVyLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLl9jdXJyZW50VHJhbnNmb3JtXG4gICAgICAgICAgfTtcbiAgICAgIGlmIChldmVudFR5cGUgPT09ICd1cCcpIHtcbiAgICAgICAgb3B0aW9ucy5jdXJyZW50VGFyZ2V0ID0gdGhpcy5maW5kVGFyZ2V0KGUpO1xuICAgICAgICBvcHRpb25zLmN1cnJlbnRTdWJUYXJnZXRzID0gdGhpcy50YXJnZXRzO1xuICAgICAgfVxuICAgICAgdGhpcy5maXJlKCdtb3VzZTonICsgZXZlbnRUeXBlLCBvcHRpb25zKTtcbiAgICAgIHRhcmdldCAmJiB0YXJnZXQuZmlyZSgnbW91c2UnICsgZXZlbnRUeXBlLCBvcHRpb25zKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0YXJnZXRzW2ldLmZpcmUoJ21vdXNlJyArIGV2ZW50VHlwZSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBzZW5kIHRoZSBtb3VzZSBldmVudCB0aGF0IGdlbmVyYXRlIHRoZSBmaW5hbGl6ZSBkb3duLCBzbyBpdCBjYW4gYmUgdXNlZCBpbiB0aGUgZXZlbnRcbiAgICAgKi9cbiAgICBfZmluYWxpemVDdXJyZW50VHJhbnNmb3JtOiBmdW5jdGlvbihlKSB7XG5cbiAgICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLl9jdXJyZW50VHJhbnNmb3JtLFxuICAgICAgICAgIHRhcmdldCA9IHRyYW5zZm9ybS50YXJnZXQsXG4gICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGU6IGUsXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgICAgICAgYWN0aW9uOiB0cmFuc2Zvcm0uYWN0aW9uLFxuICAgICAgICAgIH07XG5cbiAgICAgIGlmICh0YXJnZXQuX3NjYWxpbmcpIHtcbiAgICAgICAgdGFyZ2V0Ll9zY2FsaW5nID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldC5zZXRDb29yZHMoKTtcblxuICAgICAgaWYgKHRyYW5zZm9ybS5hY3Rpb25QZXJmb3JtZWQgfHwgKHRoaXMuc3RhdGVmdWwgJiYgdGFyZ2V0Lmhhc1N0YXRlQ2hhbmdlZCgpKSkge1xuICAgICAgICB0aGlzLl9maXJlKCdtb2RpZmllZCcsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlZG93blxuICAgICAqL1xuICAgIF9vbk1vdXNlRG93bkluRHJhd2luZ01vZGU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMuX2lzQ3VycmVudGx5RHJhd2luZyA9IHRydWU7XG4gICAgICBpZiAodGhpcy5nZXRBY3RpdmVPYmplY3QoKSkge1xuICAgICAgICB0aGlzLmRpc2NhcmRBY3RpdmVPYmplY3QoZSkucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgfVxuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSk7XG4gICAgICB0aGlzLmZyZWVEcmF3aW5nQnJ1c2gub25Nb3VzZURvd24ocG9pbnRlciwgeyBlOiBlLCBwb2ludGVyOiBwb2ludGVyIH0pO1xuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ2Rvd24nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBtb3VzZW1vdmVcbiAgICAgKi9cbiAgICBfb25Nb3VzZU1vdmVJbkRyYXdpbmdNb2RlOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAodGhpcy5faXNDdXJyZW50bHlEcmF3aW5nKSB7XG4gICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUpO1xuICAgICAgICB0aGlzLmZyZWVEcmF3aW5nQnJ1c2gub25Nb3VzZU1vdmUocG9pbnRlciwgeyBlOiBlLCBwb2ludGVyOiBwb2ludGVyIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRDdXJzb3IodGhpcy5mcmVlRHJhd2luZ0N1cnNvcik7XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnbW92ZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNldXBcbiAgICAgKi9cbiAgICBfb25Nb3VzZVVwSW5EcmF3aW5nTW9kZTogZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSk7XG4gICAgICB0aGlzLl9pc0N1cnJlbnRseURyYXdpbmcgPSB0aGlzLmZyZWVEcmF3aW5nQnJ1c2gub25Nb3VzZVVwKHsgZTogZSwgcG9pbnRlcjogcG9pbnRlciB9KTtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICd1cCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCBkZWZpbmVzIHRoZSBhY3Rpb25zIHdoZW4gbW91c2UgaXMgY2xpY2tlZCBvbiBjYW52YXMuXG4gICAgICogVGhlIG1ldGhvZCBpbml0cyB0aGUgY3VycmVudFRyYW5zZm9ybSBwYXJhbWV0ZXJzIGFuZCByZW5kZXJzIGFsbCB0aGVcbiAgICAgKiBjYW52YXMgc28gdGhlIGN1cnJlbnQgaW1hZ2UgY2FuIGJlIHBsYWNlZCBvbiB0aGUgdG9wIGNhbnZhcyBhbmQgdGhlIHJlc3RcbiAgICAgKiBpbiBvbiB0aGUgY29udGFpbmVyIG9uZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG1vdXNlZG93blxuICAgICAqL1xuICAgIF9fb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLl9jYWNoZVRyYW5zZm9ybUV2ZW50RGF0YShlKTtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdkb3duOmJlZm9yZScpO1xuICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX3RhcmdldDtcbiAgICAgIC8vIGlmIHJpZ2h0IGNsaWNrIGp1c3QgZmlyZSBldmVudHNcbiAgICAgIGlmIChjaGVja0NsaWNrKGUsIFJJR0hUX0NMSUNLKSkge1xuICAgICAgICBpZiAodGhpcy5maXJlUmlnaHRDbGljaykge1xuICAgICAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdkb3duJywgUklHSFRfQ0xJQ0spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoZWNrQ2xpY2soZSwgTUlERExFX0NMSUNLKSkge1xuICAgICAgICBpZiAodGhpcy5maXJlTWlkZGxlQ2xpY2spIHtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnZG93bicsIE1JRERMRV9DTElDSyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc0RyYXdpbmdNb2RlKSB7XG4gICAgICAgIHRoaXMuX29uTW91c2VEb3duSW5EcmF3aW5nTW9kZShlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2lzTWFpbkV2ZW50KGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gaWdub3JlIGlmIHNvbWUgb2JqZWN0IGlzIGJlaW5nIHRyYW5zZm9ybWVkIGF0IHRoaXMgbW9tZW50XG4gICAgICBpZiAodGhpcy5fY3VycmVudFRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5fcG9pbnRlcjtcbiAgICAgIC8vIHNhdmUgcG9pbnRlciBmb3IgY2hlY2sgaW4gX19vbk1vdXNlVXAgZXZlbnRcbiAgICAgIHRoaXMuX3ByZXZpb3VzUG9pbnRlciA9IHBvaW50ZXI7XG4gICAgICB2YXIgc2hvdWxkUmVuZGVyID0gdGhpcy5fc2hvdWxkUmVuZGVyKHRhcmdldCksXG4gICAgICAgICAgc2hvdWxkR3JvdXAgPSB0aGlzLl9zaG91bGRHcm91cChlLCB0YXJnZXQpO1xuICAgICAgaWYgKHRoaXMuX3Nob3VsZENsZWFyU2VsZWN0aW9uKGUsIHRhcmdldCkpIHtcbiAgICAgICAgdGhpcy5kaXNjYXJkQWN0aXZlT2JqZWN0KGUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2hvdWxkR3JvdXApIHtcbiAgICAgICAgdGhpcy5faGFuZGxlR3JvdXBpbmcoZSwgdGFyZ2V0KTtcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy5fYWN0aXZlT2JqZWN0O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb24gJiYgKCF0YXJnZXQgfHxcbiAgICAgICAgKCF0YXJnZXQuc2VsZWN0YWJsZSAmJiAhdGFyZ2V0LmlzRWRpdGluZyAmJiB0YXJnZXQgIT09IHRoaXMuX2FjdGl2ZU9iamVjdCkpKSB7XG4gICAgICAgIHRoaXMuX2dyb3VwU2VsZWN0b3IgPSB7XG4gICAgICAgICAgZXg6IHRoaXMuX2Fic29sdXRlUG9pbnRlci54LFxuICAgICAgICAgIGV5OiB0aGlzLl9hYnNvbHV0ZVBvaW50ZXIueSxcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgbGVmdDogMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIHZhciBhbHJlYWR5U2VsZWN0ZWQgPSB0YXJnZXQgPT09IHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICAgICAgaWYgKHRhcmdldC5zZWxlY3RhYmxlICYmIHRhcmdldC5hY3RpdmVPbiA9PT0gJ2Rvd24nKSB7XG4gICAgICAgICAgdGhpcy5zZXRBY3RpdmVPYmplY3QodGFyZ2V0LCBlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29ybmVyID0gdGFyZ2V0Ll9maW5kVGFyZ2V0Q29ybmVyKFxuICAgICAgICAgIHRoaXMuZ2V0UG9pbnRlcihlLCB0cnVlKSxcbiAgICAgICAgICBmYWJyaWMudXRpbC5pc1RvdWNoRXZlbnQoZSlcbiAgICAgICAgKTtcbiAgICAgICAgdGFyZ2V0Ll9fY29ybmVyID0gY29ybmVyO1xuICAgICAgICBpZiAodGFyZ2V0ID09PSB0aGlzLl9hY3RpdmVPYmplY3QgJiYgKGNvcm5lciB8fCAhc2hvdWxkR3JvdXApKSB7XG4gICAgICAgICAgdGhpcy5fc2V0dXBDdXJyZW50VHJhbnNmb3JtKGUsIHRhcmdldCwgYWxyZWFkeVNlbGVjdGVkKTtcbiAgICAgICAgICB2YXIgY29udHJvbCA9IHRhcmdldC5jb250cm9sc1tjb3JuZXJdLFxuICAgICAgICAgICAgICBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUpLFxuICAgICAgICAgICAgICBtb3VzZURvd25IYW5kbGVyID0gY29udHJvbCAmJiBjb250cm9sLmdldE1vdXNlRG93bkhhbmRsZXIoZSwgdGFyZ2V0LCBjb250cm9sKTtcbiAgICAgICAgICBpZiAobW91c2VEb3duSGFuZGxlcikge1xuICAgICAgICAgICAgbW91c2VEb3duSGFuZGxlcihlLCB0aGlzLl9jdXJyZW50VHJhbnNmb3JtLCBwb2ludGVyLngsIHBvaW50ZXIueSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9oYW5kbGVFdmVudChlLCAnZG93bicpO1xuICAgICAgLy8gd2UgbXVzdCByZW5kZXJBbGwgc28gdGhhdCB3ZSB1cGRhdGUgdGhlIHZpc3VhbHNcbiAgICAgIChzaG91bGRSZW5kZXIgfHwgc2hvdWxkR3JvdXApICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXNldCBjYWNoZSBmb3JtIGNvbW1vbiBpbmZvcm1hdGlvbiBuZWVkZWQgZHVyaW5nIGV2ZW50IHByb2Nlc3NpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZXNldFRyYW5zZm9ybUV2ZW50RGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl90YXJnZXQgPSBudWxsO1xuICAgICAgdGhpcy5fcG9pbnRlciA9IG51bGw7XG4gICAgICB0aGlzLl9hYnNvbHV0ZVBvaW50ZXIgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWNoZSBjb21tb24gaW5mb3JtYXRpb24gbmVlZGVkIGR1cmluZyBldmVudCBwcm9jZXNzaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdCBmaXJlZCBvbiBldmVudFxuICAgICAqL1xuICAgIF9jYWNoZVRyYW5zZm9ybUV2ZW50RGF0YTogZnVuY3Rpb24oZSkge1xuICAgICAgLy8gcmVzZXQgaW4gb3JkZXIgdG8gYXZvaWQgc3RhbGUgY2FjaGluZ1xuICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKTtcbiAgICAgIHRoaXMuX3BvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZSwgdHJ1ZSk7XG4gICAgICB0aGlzLl9hYnNvbHV0ZVBvaW50ZXIgPSB0aGlzLnJlc3RvcmVQb2ludGVyVnB0KHRoaXMuX3BvaW50ZXIpO1xuICAgICAgdGhpcy5fdGFyZ2V0ID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybSA/IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0udGFyZ2V0IDogdGhpcy5maW5kVGFyZ2V0KGUpIHx8IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2JlZm9yZVRyYW5zZm9ybTogZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHQgPSB0aGlzLl9jdXJyZW50VHJhbnNmb3JtO1xuICAgICAgdGhpcy5zdGF0ZWZ1bCAmJiB0LnRhcmdldC5zYXZlU3RhdGUoKTtcbiAgICAgIHRoaXMuZmlyZSgnYmVmb3JlOnRyYW5zZm9ybScsIHtcbiAgICAgICAgZTogZSxcbiAgICAgICAgdHJhbnNmb3JtOiB0LFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IGRlZmluZXMgdGhlIGFjdGlvbnMgd2hlbiBtb3VzZSBpcyBob3ZlcmluZyB0aGUgY2FudmFzLlxuICAgICAqIFRoZSBjdXJyZW50VHJhbnNmb3JtIHBhcmFtZXRlciB3aWxsIGRlZmluZSB3aGV0aGVyIHRoZSB1c2VyIGlzIHJvdGF0aW5nL3NjYWxpbmcvdHJhbnNsYXRpbmdcbiAgICAgKiBhbiBpbWFnZSBvciBuZWl0aGVyIG9mIHRoZW0gKG9ubHkgaG92ZXJpbmcpLiBBIGdyb3VwIHNlbGVjdGlvbiBpcyBhbHNvIHBvc3NpYmxlIGFuZCB3b3VsZCBjYW5jZWxcbiAgICAgKiBhbGwgYW55IG90aGVyIHR5cGUgb2YgYWN0aW9uLlxuICAgICAqIEluIGNhc2Ugb2YgYW4gaW1hZ2UgdHJhbnNmb3JtYXRpb24gb25seSB0aGUgdG9wIGNhbnZhcyB3aWxsIGJlIHJlbmRlcmVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vtb3ZlXG4gICAgICovXG4gICAgX19vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICdtb3ZlOmJlZm9yZScpO1xuICAgICAgdGhpcy5fY2FjaGVUcmFuc2Zvcm1FdmVudERhdGEoZSk7XG4gICAgICB2YXIgdGFyZ2V0LCBwb2ludGVyO1xuXG4gICAgICBpZiAodGhpcy5pc0RyYXdpbmdNb2RlKSB7XG4gICAgICAgIHRoaXMuX29uTW91c2VNb3ZlSW5EcmF3aW5nTW9kZShlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2lzTWFpbkV2ZW50KGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGdyb3VwU2VsZWN0b3IgPSB0aGlzLl9ncm91cFNlbGVjdG9yO1xuXG4gICAgICAvLyBXZSBpbml0aWFsbHkgY2xpY2tlZCBpbiBhbiBlbXB0eSBhcmVhLCBzbyB3ZSBkcmF3IGEgYm94IGZvciBtdWx0aXBsZSBzZWxlY3Rpb25cbiAgICAgIGlmIChncm91cFNlbGVjdG9yKSB7XG4gICAgICAgIHBvaW50ZXIgPSB0aGlzLl9hYnNvbHV0ZVBvaW50ZXI7XG5cbiAgICAgICAgZ3JvdXBTZWxlY3Rvci5sZWZ0ID0gcG9pbnRlci54IC0gZ3JvdXBTZWxlY3Rvci5leDtcbiAgICAgICAgZ3JvdXBTZWxlY3Rvci50b3AgPSBwb2ludGVyLnkgLSBncm91cFNlbGVjdG9yLmV5O1xuXG4gICAgICAgIHRoaXMucmVuZGVyVG9wKCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghdGhpcy5fY3VycmVudFRyYW5zZm9ybSkge1xuICAgICAgICB0YXJnZXQgPSB0aGlzLmZpbmRUYXJnZXQoZSkgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5fc2V0Q3Vyc29yRnJvbUV2ZW50KGUsIHRhcmdldCk7XG4gICAgICAgIHRoaXMuX2ZpcmVPdmVyT3V0RXZlbnRzKHRhcmdldCwgZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtT2JqZWN0KGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5faGFuZGxlRXZlbnQoZSwgJ21vdmUnKTtcbiAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1hbmFnZSB0aGUgbW91c2VvdXQsIG1vdXNlb3ZlciBldmVudHMgZm9yIHRoZSBmYWJyaWMgb2JqZWN0IG9uIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0ge0ZhYnJpYy5PYmplY3R9IHRhcmdldCB0aGUgdGFyZ2V0IHdoZXJlIHRoZSB0YXJnZXQgZnJvbSB0aGUgbW91c2Vtb3ZlIGV2ZW50XG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2Vtb3ZlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlyZU92ZXJPdXRFdmVudHM6IGZ1bmN0aW9uKHRhcmdldCwgZSkge1xuICAgICAgdmFyIF9ob3ZlcmVkVGFyZ2V0ID0gdGhpcy5faG92ZXJlZFRhcmdldCxcbiAgICAgICAgICBfaG92ZXJlZFRhcmdldHMgPSB0aGlzLl9ob3ZlcmVkVGFyZ2V0cywgdGFyZ2V0cyA9IHRoaXMudGFyZ2V0cyxcbiAgICAgICAgICBsZW5ndGggPSBNYXRoLm1heChfaG92ZXJlZFRhcmdldHMubGVuZ3RoLCB0YXJnZXRzLmxlbmd0aCk7XG5cbiAgICAgIHRoaXMuZmlyZVN5bnRoZXRpY0luT3V0RXZlbnRzKHRhcmdldCwgZSwge1xuICAgICAgICBvbGRUYXJnZXQ6IF9ob3ZlcmVkVGFyZ2V0LFxuICAgICAgICBldnRPdXQ6ICdtb3VzZW91dCcsXG4gICAgICAgIGNhbnZhc0V2dE91dDogJ21vdXNlOm91dCcsXG4gICAgICAgIGV2dEluOiAnbW91c2VvdmVyJyxcbiAgICAgICAgY2FudmFzRXZ0SW46ICdtb3VzZTpvdmVyJyxcbiAgICAgIH0pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuZmlyZVN5bnRoZXRpY0luT3V0RXZlbnRzKHRhcmdldHNbaV0sIGUsIHtcbiAgICAgICAgICBvbGRUYXJnZXQ6IF9ob3ZlcmVkVGFyZ2V0c1tpXSxcbiAgICAgICAgICBldnRPdXQ6ICdtb3VzZW91dCcsXG4gICAgICAgICAgZXZ0SW46ICdtb3VzZW92ZXInLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXQgPSB0YXJnZXQ7XG4gICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0cyA9IHRoaXMudGFyZ2V0cy5jb25jYXQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFuYWdlIHRoZSBkcmFnRW50ZXIsIGRyYWdMZWF2ZSBldmVudHMgZm9yIHRoZSBmYWJyaWMgb2JqZWN0cyBvbiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIHtGYWJyaWMuT2JqZWN0fSB0YXJnZXQgdGhlIHRhcmdldCB3aGVyZSB0aGUgdGFyZ2V0IGZyb20gdGhlIG9uRHJhZyBldmVudFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkIG9uIG9uZHJhZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpcmVFbnRlckxlYXZlRXZlbnRzOiBmdW5jdGlvbih0YXJnZXQsIGUpIHtcbiAgICAgIHZhciBfZHJhZ2dlZG92ZXJUYXJnZXQgPSB0aGlzLl9kcmFnZ2Vkb3ZlclRhcmdldCxcbiAgICAgICAgICBfaG92ZXJlZFRhcmdldHMgPSB0aGlzLl9ob3ZlcmVkVGFyZ2V0cywgdGFyZ2V0cyA9IHRoaXMudGFyZ2V0cyxcbiAgICAgICAgICBsZW5ndGggPSBNYXRoLm1heChfaG92ZXJlZFRhcmdldHMubGVuZ3RoLCB0YXJnZXRzLmxlbmd0aCk7XG5cbiAgICAgIHRoaXMuZmlyZVN5bnRoZXRpY0luT3V0RXZlbnRzKHRhcmdldCwgZSwge1xuICAgICAgICBvbGRUYXJnZXQ6IF9kcmFnZ2Vkb3ZlclRhcmdldCxcbiAgICAgICAgZXZ0T3V0OiAnZHJhZ2xlYXZlJyxcbiAgICAgICAgZXZ0SW46ICdkcmFnZW50ZXInLFxuICAgICAgfSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZmlyZVN5bnRoZXRpY0luT3V0RXZlbnRzKHRhcmdldHNbaV0sIGUsIHtcbiAgICAgICAgICBvbGRUYXJnZXQ6IF9ob3ZlcmVkVGFyZ2V0c1tpXSxcbiAgICAgICAgICBldnRPdXQ6ICdkcmFnbGVhdmUnLFxuICAgICAgICAgIGV2dEluOiAnZHJhZ2VudGVyJyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9kcmFnZ2Vkb3ZlclRhcmdldCA9IHRhcmdldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFuYWdlIHRoZSBzeW50aGV0aWMgaW4vb3V0IGV2ZW50cyBmb3IgdGhlIGZhYnJpYyBvYmplY3RzIG9uIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0ge0ZhYnJpYy5PYmplY3R9IHRhcmdldCB0aGUgdGFyZ2V0IHdoZXJlIHRoZSB0YXJnZXQgZnJvbSB0aGUgc3VwcG9ydGVkIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0IGZpcmVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBjb25maWd1cmF0aW9uIGZvciB0aGUgZnVuY3Rpb24gdG8gd29ya1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcudGFyZ2V0TmFtZSBwcm9wZXJ0eSBvbiB0aGUgY2FudmFzIHdoZXJlIHRoZSBvbGQgdGFyZ2V0IGlzIHN0b3JlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmNhbnZhc0V2dE91dF0gbmFtZSBvZiB0aGUgZXZlbnQgdG8gZmlyZSBhdCBjYW52YXMgbGV2ZWwgZm9yIG91dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuZXZ0T3V0IG5hbWUgb2YgdGhlIGV2ZW50IHRvIGZpcmUgZm9yIG91dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmNhbnZhc0V2dEluXSBuYW1lIG9mIHRoZSBldmVudCB0byBmaXJlIGF0IGNhbnZhcyBsZXZlbCBmb3IgaW5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmV2dEluIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGZpcmUgZm9yIGluXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljSW5PdXRFdmVudHM6IGZ1bmN0aW9uKHRhcmdldCwgZSwgY29uZmlnKSB7XG4gICAgICB2YXIgaW5PcHQsIG91dE9wdCwgb2xkVGFyZ2V0ID0gY29uZmlnLm9sZFRhcmdldCwgb3V0RmlyZXMsIGluRmlyZXMsXG4gICAgICAgICAgdGFyZ2V0Q2hhbmdlZCA9IG9sZFRhcmdldCAhPT0gdGFyZ2V0LCBjYW52YXNFdnRJbiA9IGNvbmZpZy5jYW52YXNFdnRJbiwgY2FudmFzRXZ0T3V0ID0gY29uZmlnLmNhbnZhc0V2dE91dDtcbiAgICAgIGlmICh0YXJnZXRDaGFuZ2VkKSB7XG4gICAgICAgIGluT3B0ID0geyBlOiBlLCB0YXJnZXQ6IHRhcmdldCwgcHJldmlvdXNUYXJnZXQ6IG9sZFRhcmdldCB9O1xuICAgICAgICBvdXRPcHQgPSB7IGU6IGUsIHRhcmdldDogb2xkVGFyZ2V0LCBuZXh0VGFyZ2V0OiB0YXJnZXQgfTtcbiAgICAgIH1cbiAgICAgIGluRmlyZXMgPSB0YXJnZXQgJiYgdGFyZ2V0Q2hhbmdlZDtcbiAgICAgIG91dEZpcmVzID0gb2xkVGFyZ2V0ICYmIHRhcmdldENoYW5nZWQ7XG4gICAgICBpZiAob3V0RmlyZXMpIHtcbiAgICAgICAgY2FudmFzRXZ0T3V0ICYmIHRoaXMuZmlyZShjYW52YXNFdnRPdXQsIG91dE9wdCk7XG4gICAgICAgIG9sZFRhcmdldC5maXJlKGNvbmZpZy5ldnRPdXQsIG91dE9wdCk7XG4gICAgICB9XG4gICAgICBpZiAoaW5GaXJlcykge1xuICAgICAgICBjYW52YXNFdnRJbiAmJiB0aGlzLmZpcmUoY2FudmFzRXZ0SW4sIGluT3B0KTtcbiAgICAgICAgdGFyZ2V0LmZpcmUoY29uZmlnLmV2dEluLCBpbk9wdCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IGRlZmluZXMgYWN0aW9ucyB3aGVuIGFuIEV2ZW50IE1vdXNlIFdoZWVsXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3QgZmlyZWQgb24gbW91c2V1cFxuICAgICAqL1xuICAgIF9fb25Nb3VzZVdoZWVsOiBmdW5jdGlvbihlKSB7XG4gICAgICB0aGlzLl9jYWNoZVRyYW5zZm9ybUV2ZW50RGF0YShlKTtcbiAgICAgIHRoaXMuX2hhbmRsZUV2ZW50KGUsICd3aGVlbCcpO1xuICAgICAgdGhpcy5fcmVzZXRUcmFuc2Zvcm1FdmVudERhdGEoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IGZpcmVkIG9uIG1vdXNlbW92ZVxuICAgICAqL1xuICAgIF90cmFuc2Zvcm1PYmplY3Q6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGUpLFxuICAgICAgICAgIHRyYW5zZm9ybSA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm07XG5cbiAgICAgIHRyYW5zZm9ybS5yZXNldCA9IGZhbHNlO1xuICAgICAgdHJhbnNmb3JtLnNoaWZ0S2V5ID0gZS5zaGlmdEtleTtcbiAgICAgIHRyYW5zZm9ybS5hbHRLZXkgPSBlW3RoaXMuY2VudGVyZWRLZXldO1xuXG4gICAgICB0aGlzLl9wZXJmb3JtVHJhbnNmb3JtQWN0aW9uKGUsIHRyYW5zZm9ybSwgcG9pbnRlcik7XG4gICAgICB0cmFuc2Zvcm0uYWN0aW9uUGVyZm9ybWVkICYmIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wZXJmb3JtVHJhbnNmb3JtQWN0aW9uOiBmdW5jdGlvbihlLCB0cmFuc2Zvcm0sIHBvaW50ZXIpIHtcbiAgICAgIHZhciB4ID0gcG9pbnRlci54LFxuICAgICAgICAgIHkgPSBwb2ludGVyLnksXG4gICAgICAgICAgYWN0aW9uID0gdHJhbnNmb3JtLmFjdGlvbixcbiAgICAgICAgICBhY3Rpb25QZXJmb3JtZWQgPSBmYWxzZSxcbiAgICAgICAgICBhY3Rpb25IYW5kbGVyID0gdHJhbnNmb3JtLmFjdGlvbkhhbmRsZXI7XG4gICAgICAgICAgLy8gdGhpcyBvYmplY3QgY291bGQgYmUgY3JlYXRlZCBmcm9tIHRoZSBmdW5jdGlvbiBpbiB0aGUgY29udHJvbCBoYW5kbGVyc1xuXG5cbiAgICAgIGlmIChhY3Rpb25IYW5kbGVyKSB7XG4gICAgICAgIGFjdGlvblBlcmZvcm1lZCA9IGFjdGlvbkhhbmRsZXIoZSwgdHJhbnNmb3JtLCB4LCB5KTtcbiAgICAgIH1cbiAgICAgIGlmIChhY3Rpb24gPT09ICdkcmFnJyAmJiBhY3Rpb25QZXJmb3JtZWQpIHtcbiAgICAgICAgdHJhbnNmb3JtLnRhcmdldC5pc01vdmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuc2V0Q3Vyc29yKHRyYW5zZm9ybS50YXJnZXQubW92ZUN1cnNvciB8fCB0aGlzLm1vdmVDdXJzb3IpO1xuICAgICAgfVxuICAgICAgdHJhbnNmb3JtLmFjdGlvblBlcmZvcm1lZCA9IHRyYW5zZm9ybS5hY3Rpb25QZXJmb3JtZWQgfHwgYWN0aW9uUGVyZm9ybWVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maXJlOiBmYWJyaWMuY29udHJvbHNVdGlscy5maXJlRXZlbnQsXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJzb3IgZGVwZW5kaW5nIG9uIHdoZXJlIHRoZSBjYW52YXMgaXMgYmVpbmcgaG92ZXJlZC5cbiAgICAgKiBOb3RlOiB2ZXJ5IGJ1Z2d5IGluIE9wZXJhXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IE9iamVjdCB0aGF0IHRoZSBtb3VzZSBpcyBob3ZlcmluZywgaWYgc28uXG4gICAgICovXG4gICAgX3NldEN1cnNvckZyb21FdmVudDogZnVuY3Rpb24gKGUsIHRhcmdldCkge1xuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgdGhpcy5zZXRDdXJzb3IodGhpcy5kZWZhdWx0Q3Vyc29yKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGhvdmVyQ3Vyc29yID0gdGFyZ2V0LmhvdmVyQ3Vyc29yIHx8IHRoaXMuaG92ZXJDdXJzb3IsXG4gICAgICAgICAgYWN0aXZlU2VsZWN0aW9uID0gdGhpcy5fYWN0aXZlT2JqZWN0ICYmIHRoaXMuX2FjdGl2ZU9iamVjdC50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJyA/XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVPYmplY3QgOiBudWxsLFxuICAgICAgICAgIC8vIG9ubHkgc2hvdyBwcm9wZXIgY29ybmVyIHdoZW4gZ3JvdXAgc2VsZWN0aW9uIGlzIG5vdCBhY3RpdmVcbiAgICAgICAgICBjb3JuZXIgPSAoIWFjdGl2ZVNlbGVjdGlvbiB8fCAhYWN0aXZlU2VsZWN0aW9uLmNvbnRhaW5zKHRhcmdldCkpXG4gICAgICAgICAgLy8gaGVyZSB3ZSBjYWxsIGZpbmRUYXJnZXRDb3JuZXIgYWx3YXlzIHdpdGggdW5kZWZpbmVkIGZvciB0aGUgdG91Y2ggcGFyYW1ldGVyLlxuICAgICAgICAgIC8vIHdlIGFzc3VtZSB0aGF0IGlmIHlvdSBhcmUgdXNpbmcgYSBjdXJzb3IgeW91IGRvIG5vdCBuZWVkIHRvIGludGVyYWN0IHdpdGhcbiAgICAgICAgICAvLyB0aGUgYmlnZ2VyIHRvdWNoIGFyZWEuXG4gICAgICAgICAgICAgICAgICAgICYmIHRhcmdldC5fZmluZFRhcmdldENvcm5lcih0aGlzLmdldFBvaW50ZXIoZSwgdHJ1ZSkpO1xuXG4gICAgICBpZiAoIWNvcm5lcikge1xuICAgICAgICBpZiAodGFyZ2V0LnN1YlRhcmdldENoZWNrKXtcbiAgICAgICAgICAvLyBob3ZlckN1cnNvciBzaG91bGQgY29tZSBmcm9tIHRvcC1tb3N0IHN1YlRhcmdldCxcbiAgICAgICAgICAvLyBzbyB3ZSB3YWxrIHRoZSBhcnJheSBiYWNrd2FyZHNcbiAgICAgICAgICB0aGlzLnRhcmdldHMuY29uY2F0KCkucmV2ZXJzZSgpLm1hcChmdW5jdGlvbihfdGFyZ2V0KXtcbiAgICAgICAgICAgIGhvdmVyQ3Vyc29yID0gX3RhcmdldC5ob3ZlckN1cnNvciB8fCBob3ZlckN1cnNvcjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEN1cnNvcihob3ZlckN1cnNvcik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRDdXJzb3IodGhpcy5nZXRDb3JuZXJDdXJzb3IoY29ybmVyLCB0YXJnZXQsIGUpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRDb3JuZXJDdXJzb3I6IGZ1bmN0aW9uKGNvcm5lciwgdGFyZ2V0LCBlKSB7XG4gICAgICB2YXIgY29udHJvbCA9IHRhcmdldC5jb250cm9sc1tjb3JuZXJdO1xuICAgICAgcmV0dXJuIGNvbnRyb2wuY3Vyc29yU3R5bGVIYW5kbGVyKGUsIGNvbnRyb2wsIHRhcmdldCk7XG4gICAgfVxuICB9KTtcbn0pKCk7XG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIHZhciBtaW4gPSBNYXRoLm1pbixcbiAgICAgIG1heCA9IE1hdGgubWF4O1xuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLkNhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLkNhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gdGFyZ2V0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBfc2hvdWxkR3JvdXA6IGZ1bmN0aW9uKGUsIHRhcmdldCkge1xuICAgICAgdmFyIGFjdGl2ZU9iamVjdCA9IHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICAgIHJldHVybiBhY3RpdmVPYmplY3QgJiYgdGhpcy5faXNTZWxlY3Rpb25LZXlQcmVzc2VkKGUpICYmIHRhcmdldCAmJiB0YXJnZXQuc2VsZWN0YWJsZSAmJiB0aGlzLnNlbGVjdGlvbiAmJlxuICAgICAgICAgICAgKGFjdGl2ZU9iamVjdCAhPT0gdGFyZ2V0IHx8IGFjdGl2ZU9iamVjdC50eXBlID09PSAnYWN0aXZlU2VsZWN0aW9uJykgJiYgIXRhcmdldC5vblNlbGVjdCh7IGU6IGUgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IHRhcmdldFxuICAgICAqL1xuICAgIF9oYW5kbGVHcm91cGluZzogZnVuY3Rpb24gKGUsIHRhcmdldCkge1xuICAgICAgdmFyIGFjdGl2ZU9iamVjdCA9IHRoaXMuX2FjdGl2ZU9iamVjdDtcbiAgICAgIC8vIGF2b2lkIG11bHRpIHNlbGVjdCB3aGVuIHNoaWZ0IGNsaWNrIG9uIGEgY29ybmVyXG4gICAgICBpZiAoYWN0aXZlT2JqZWN0Ll9fY29ybmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXQgPT09IGFjdGl2ZU9iamVjdCkge1xuICAgICAgICAvLyBpZiBpdCdzIGEgZ3JvdXAsIGZpbmQgdGFyZ2V0IGFnYWluLCB1c2luZyBhY3RpdmVHcm91cCBvYmplY3RzXG4gICAgICAgIHRhcmdldCA9IHRoaXMuZmluZFRhcmdldChlLCB0cnVlKTtcbiAgICAgICAgLy8gaWYgZXZlbiBvYmplY3QgaXMgbm90IGZvdW5kIG9yIHdlIGFyZSBvbiBhY3RpdmVPYmplY3RDb3JuZXIsIGJhaWwgb3V0XG4gICAgICAgIGlmICghdGFyZ2V0IHx8ICF0YXJnZXQuc2VsZWN0YWJsZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFjdGl2ZU9iamVjdCAmJiBhY3RpdmVPYmplY3QudHlwZSA9PT0gJ2FjdGl2ZVNlbGVjdGlvbicpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlQWN0aXZlU2VsZWN0aW9uKHRhcmdldCwgZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlQWN0aXZlU2VsZWN0aW9uKHRhcmdldCwgZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZUFjdGl2ZVNlbGVjdGlvbjogZnVuY3Rpb24odGFyZ2V0LCBlKSB7XG4gICAgICB2YXIgYWN0aXZlU2VsZWN0aW9uID0gdGhpcy5fYWN0aXZlT2JqZWN0LFxuICAgICAgICAgIGN1cnJlbnRBY3RpdmVPYmplY3RzID0gYWN0aXZlU2VsZWN0aW9uLl9vYmplY3RzLnNsaWNlKDApO1xuICAgICAgaWYgKGFjdGl2ZVNlbGVjdGlvbi5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgIGFjdGl2ZVNlbGVjdGlvbi5yZW1vdmVXaXRoVXBkYXRlKHRhcmdldCk7XG4gICAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXRzID0gdGhpcy50YXJnZXRzLmNvbmNhdCgpO1xuICAgICAgICBpZiAoYWN0aXZlU2VsZWN0aW9uLnNpemUoKSA9PT0gMSkge1xuICAgICAgICAgIC8vIGFjdGl2YXRlIGxhc3QgcmVtYWluaW5nIG9iamVjdFxuICAgICAgICAgIHRoaXMuX3NldEFjdGl2ZU9iamVjdChhY3RpdmVTZWxlY3Rpb24uaXRlbSgwKSwgZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBhY3RpdmVTZWxlY3Rpb24uYWRkV2l0aFVwZGF0ZSh0YXJnZXQpO1xuICAgICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0ID0gYWN0aXZlU2VsZWN0aW9uO1xuICAgICAgICB0aGlzLl9ob3ZlcmVkVGFyZ2V0cyA9IHRoaXMudGFyZ2V0cy5jb25jYXQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25FdmVudHMoY3VycmVudEFjdGl2ZU9iamVjdHMsIGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVBY3RpdmVTZWxlY3Rpb246IGZ1bmN0aW9uKHRhcmdldCwgZSkge1xuICAgICAgdmFyIGN1cnJlbnRBY3RpdmVzID0gdGhpcy5nZXRBY3RpdmVPYmplY3RzKCksIGdyb3VwID0gdGhpcy5fY3JlYXRlR3JvdXAodGFyZ2V0KTtcbiAgICAgIHRoaXMuX2hvdmVyZWRUYXJnZXQgPSBncm91cDtcbiAgICAgIC8vIElTU1VFIDQxMTU6IHNob3VsZCB3ZSBjb25zaWRlciBzdWJUYXJnZXRzIGhlcmU/XG4gICAgICAvLyB0aGlzLl9ob3ZlcmVkVGFyZ2V0cyA9IFtdO1xuICAgICAgLy8gdGhpcy5faG92ZXJlZFRhcmdldHMgPSB0aGlzLnRhcmdldHMuY29uY2F0KCk7XG4gICAgICB0aGlzLl9zZXRBY3RpdmVPYmplY3QoZ3JvdXAsIGUpO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkV2ZW50cyhjdXJyZW50QWN0aXZlcywgZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAqL1xuICAgIF9jcmVhdGVHcm91cDogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICB2YXIgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXG4gICAgICAgICAgaXNBY3RpdmVMb3dlciA9IG9iamVjdHMuaW5kZXhPZih0aGlzLl9hY3RpdmVPYmplY3QpIDwgb2JqZWN0cy5pbmRleE9mKHRhcmdldCksXG4gICAgICAgICAgZ3JvdXBPYmplY3RzID0gaXNBY3RpdmVMb3dlclxuICAgICAgICAgICAgPyBbdGhpcy5fYWN0aXZlT2JqZWN0LCB0YXJnZXRdXG4gICAgICAgICAgICA6IFt0YXJnZXQsIHRoaXMuX2FjdGl2ZU9iamVjdF07XG4gICAgICB0aGlzLl9hY3RpdmVPYmplY3QuaXNFZGl0aW5nICYmIHRoaXMuX2FjdGl2ZU9iamVjdC5leGl0RWRpdGluZygpO1xuICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uKGdyb3VwT2JqZWN0cywge1xuICAgICAgICBjYW52YXM6IHRoaXNcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgbW91c2UgZXZlbnRcbiAgICAgKi9cbiAgICBfZ3JvdXBTZWxlY3RlZE9iamVjdHM6IGZ1bmN0aW9uIChlKSB7XG5cbiAgICAgIHZhciBncm91cCA9IHRoaXMuX2NvbGxlY3RPYmplY3RzKGUpLFxuICAgICAgICAgIGFHcm91cDtcblxuICAgICAgLy8gZG8gbm90IGNyZWF0ZSBncm91cCBmb3IgMSBlbGVtZW50IG9ubHlcbiAgICAgIGlmIChncm91cC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGhpcy5zZXRBY3RpdmVPYmplY3QoZ3JvdXBbMF0sIGUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZ3JvdXAubGVuZ3RoID4gMSkge1xuICAgICAgICBhR3JvdXAgPSBuZXcgZmFicmljLkFjdGl2ZVNlbGVjdGlvbihncm91cC5yZXZlcnNlKCksIHtcbiAgICAgICAgICBjYW52YXM6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0QWN0aXZlT2JqZWN0KGFHcm91cCwgZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NvbGxlY3RPYmplY3RzOiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgZ3JvdXAgPSBbXSxcbiAgICAgICAgICBjdXJyZW50T2JqZWN0LFxuICAgICAgICAgIHgxID0gdGhpcy5fZ3JvdXBTZWxlY3Rvci5leCxcbiAgICAgICAgICB5MSA9IHRoaXMuX2dyb3VwU2VsZWN0b3IuZXksXG4gICAgICAgICAgeDIgPSB4MSArIHRoaXMuX2dyb3VwU2VsZWN0b3IubGVmdCxcbiAgICAgICAgICB5MiA9IHkxICsgdGhpcy5fZ3JvdXBTZWxlY3Rvci50b3AsXG4gICAgICAgICAgc2VsZWN0aW9uWDFZMSA9IG5ldyBmYWJyaWMuUG9pbnQobWluKHgxLCB4MiksIG1pbih5MSwgeTIpKSxcbiAgICAgICAgICBzZWxlY3Rpb25YMlkyID0gbmV3IGZhYnJpYy5Qb2ludChtYXgoeDEsIHgyKSwgbWF4KHkxLCB5MikpLFxuICAgICAgICAgIGFsbG93SW50ZXJzZWN0ID0gIXRoaXMuc2VsZWN0aW9uRnVsbHlDb250YWluZWQsXG4gICAgICAgICAgaXNDbGljayA9IHgxID09PSB4MiAmJiB5MSA9PT0geTI7XG4gICAgICAvLyB3ZSBpdGVyYXRlIHJldmVyc2Ugb3JkZXIgdG8gY29sbGVjdCB0b3AgZmlyc3QgaW4gY2FzZSBvZiBjbGljay5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgY3VycmVudE9iamVjdCA9IHRoaXMuX29iamVjdHNbaV07XG5cbiAgICAgICAgaWYgKCFjdXJyZW50T2JqZWN0IHx8ICFjdXJyZW50T2JqZWN0LnNlbGVjdGFibGUgfHwgIWN1cnJlbnRPYmplY3QudmlzaWJsZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChhbGxvd0ludGVyc2VjdCAmJiBjdXJyZW50T2JqZWN0LmludGVyc2VjdHNXaXRoUmVjdChzZWxlY3Rpb25YMVkxLCBzZWxlY3Rpb25YMlkyLCB0cnVlKSkgfHxcbiAgICAgICAgICAgIGN1cnJlbnRPYmplY3QuaXNDb250YWluZWRXaXRoaW5SZWN0KHNlbGVjdGlvblgxWTEsIHNlbGVjdGlvblgyWTIsIHRydWUpIHx8XG4gICAgICAgICAgICAoYWxsb3dJbnRlcnNlY3QgJiYgY3VycmVudE9iamVjdC5jb250YWluc1BvaW50KHNlbGVjdGlvblgxWTEsIG51bGwsIHRydWUpKSB8fFxuICAgICAgICAgICAgKGFsbG93SW50ZXJzZWN0ICYmIGN1cnJlbnRPYmplY3QuY29udGFpbnNQb2ludChzZWxlY3Rpb25YMlkyLCBudWxsLCB0cnVlKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgZ3JvdXAucHVzaChjdXJyZW50T2JqZWN0KTtcbiAgICAgICAgICAvLyBvbmx5IGFkZCBvbmUgb2JqZWN0IGlmIGl0J3MgYSBjbGlja1xuICAgICAgICAgIGlmIChpc0NsaWNrKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGdyb3VwLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZ3JvdXAgPSBncm91cC5maWx0ZXIoZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuICFvYmplY3Qub25TZWxlY3QoeyBlOiBlIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tYXliZUdyb3VwT2JqZWN0czogZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uICYmIHRoaXMuX2dyb3VwU2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5fZ3JvdXBTZWxlY3RlZE9iamVjdHMoZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldEN1cnNvcih0aGlzLmRlZmF1bHRDdXJzb3IpO1xuICAgICAgLy8gY2xlYXIgc2VsZWN0aW9uIGFuZCBjdXJyZW50IHRyYW5zZm9ybWF0aW9uXG4gICAgICB0aGlzLl9ncm91cFNlbGVjdG9yID0gbnVsbDtcbiAgICB9XG4gIH0pO1xuXG59KSgpO1xuXG5cbihmdW5jdGlvbiAoKSB7XG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRXhwb3J0cyBjYW52YXMgZWxlbWVudCB0byBhIGRhdGF1cmwgaW1hZ2UuIE5vdGUgdGhhdCB3aGVuIG11bHRpcGxpZXIgaXMgdXNlZCwgY3JvcHBpbmcgaXMgc2NhbGVkIGFwcHJvcHJpYXRlbHlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmZvcm1hdD1wbmddIFRoZSBmb3JtYXQgb2YgdGhlIG91dHB1dCBpbWFnZS4gRWl0aGVyIFwianBlZ1wiIG9yIFwicG5nXCJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucXVhbGl0eT0xXSBRdWFsaXR5IGxldmVsICgwLi4xKS4gT25seSB1c2VkIGZvciBqcGVnLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tdWx0aXBsaWVyPTFdIE11bHRpcGxpZXIgdG8gc2NhbGUgYnksIHRvIGhhdmUgY29uc2lzdGVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sZWZ0XSBDcm9wcGluZyBsZWZ0IG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRvcF0gQ3JvcHBpbmcgdG9wIG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoXSBDcm9wcGluZyB3aWR0aC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gQ3JvcHBpbmcgaGVpZ2h0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZVJldGluYVNjYWxpbmddIEVuYWJsZSByZXRpbmEgc2NhbGluZyBmb3IgY2xvbmUgaW1hZ2UuIEludHJvZHVjZSBpbiAyLjAuMFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gUmV0dXJucyBhIGRhdGE6IFVSTCBjb250YWluaW5nIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdCBpbiB0aGUgZm9ybWF0IHNwZWNpZmllZCBieSBvcHRpb25zLmZvcm1hdFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvZmFicmljanMvTmZaVmIvfGpzRmlkZGxlIGRlbW99XG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+R2VuZXJhdGUganBlZyBkYXRhVVJMIHdpdGggbG93ZXIgcXVhbGl0eTwvY2FwdGlvbj5cbiAgICAgKiB2YXIgZGF0YVVSTCA9IGNhbnZhcy50b0RhdGFVUkwoe1xuICAgICAqICAgZm9ybWF0OiAnanBlZycsXG4gICAgICogICBxdWFsaXR5OiAwLjhcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5HZW5lcmF0ZSBjcm9wcGVkIHBuZyBkYXRhVVJMIChjbGlwcGluZyBvZiBjYW52YXMpPC9jYXB0aW9uPlxuICAgICAqIHZhciBkYXRhVVJMID0gY2FudmFzLnRvRGF0YVVSTCh7XG4gICAgICogICBmb3JtYXQ6ICdwbmcnLFxuICAgICAqICAgbGVmdDogMTAwLFxuICAgICAqICAgdG9wOiAxMDAsXG4gICAgICogICB3aWR0aDogMjAwLFxuICAgICAqICAgaGVpZ2h0OiAyMDBcbiAgICAgKiB9KTtcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5HZW5lcmF0ZSBkb3VibGUgc2NhbGVkIHBuZyBkYXRhVVJMPC9jYXB0aW9uPlxuICAgICAqIHZhciBkYXRhVVJMID0gY2FudmFzLnRvRGF0YVVSTCh7XG4gICAgICogICBmb3JtYXQ6ICdwbmcnLFxuICAgICAqICAgbXVsdGlwbGllcjogMlxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHRvRGF0YVVSTDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgICB2YXIgZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgfHwgJ3BuZycsXG4gICAgICAgICAgcXVhbGl0eSA9IG9wdGlvbnMucXVhbGl0eSB8fCAxLFxuICAgICAgICAgIG11bHRpcGxpZXIgPSAob3B0aW9ucy5tdWx0aXBsaWVyIHx8IDEpICogKG9wdGlvbnMuZW5hYmxlUmV0aW5hU2NhbGluZyA/IHRoaXMuZ2V0UmV0aW5hU2NhbGluZygpIDogMSksXG4gICAgICAgICAgY2FudmFzRWwgPSB0aGlzLnRvQ2FudmFzRWxlbWVudChtdWx0aXBsaWVyLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBmYWJyaWMudXRpbC50b0RhdGFVUkwoY2FudmFzRWwsIGZvcm1hdCwgcXVhbGl0eSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBIVE1MQ2FudmFzIGVsZW1lbnQgcGFpbnRlZCB3aXRoIHRoZSBjdXJyZW50IGNhbnZhcyBjb250ZW50LlxuICAgICAqIE5vIG5lZWQgdG8gcmVzaXplIHRoZSBhY3R1YWwgb25lIG9yIHJlcGFpbnQgaXQuXG4gICAgICogV2lsbCB0cmFuc2ZlciBvYmplY3Qgb3duZXJzaGlwIHRvIGEgbmV3IGNhbnZhcywgcGFpbnQgaXQsIGFuZCBzZXQgZXZlcnl0aGluZyBiYWNrLlxuICAgICAqIFRoaXMgaXMgYW4gaW50ZXJtZWRpYXJ5IHN0ZXAgdXNlZCB0byBnZXQgdG8gYSBkYXRhVXJsIGJ1dCBhbHNvIGl0IGlzIHVzZWZ1bCB0b1xuICAgICAqIGNyZWF0ZSBxdWljayBpbWFnZSBjb3BpZXMgb2YgYSBjYW52YXMgd2l0aG91dCBwYXNzaW5nIGZvciB0aGUgZGF0YVVybCBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW211bHRpcGxpZXJdIGEgem9vbSBmYWN0b3IuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjcm9wcGluZ10gQ3JvcHBpbmcgaW5mb3JtYXRpb25zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjcm9wcGluZy5sZWZ0XSBDcm9wcGluZyBsZWZ0IG9mZnNldC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2Nyb3BwaW5nLnRvcF0gQ3JvcHBpbmcgdG9wIG9mZnNldC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2Nyb3BwaW5nLndpZHRoXSBDcm9wcGluZyB3aWR0aC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2Nyb3BwaW5nLmhlaWdodF0gQ3JvcHBpbmcgaGVpZ2h0LlxuICAgICAqL1xuICAgIHRvQ2FudmFzRWxlbWVudDogZnVuY3Rpb24obXVsdGlwbGllciwgY3JvcHBpbmcpIHtcbiAgICAgIG11bHRpcGxpZXIgPSBtdWx0aXBsaWVyIHx8IDE7XG4gICAgICBjcm9wcGluZyA9IGNyb3BwaW5nIHx8IHsgfTtcbiAgICAgIHZhciBzY2FsZWRXaWR0aCA9IChjcm9wcGluZy53aWR0aCB8fCB0aGlzLndpZHRoKSAqIG11bHRpcGxpZXIsXG4gICAgICAgICAgc2NhbGVkSGVpZ2h0ID0gKGNyb3BwaW5nLmhlaWdodCB8fCB0aGlzLmhlaWdodCkgKiBtdWx0aXBsaWVyLFxuICAgICAgICAgIHpvb20gPSB0aGlzLmdldFpvb20oKSxcbiAgICAgICAgICBvcmlnaW5hbFdpZHRoID0gdGhpcy53aWR0aCxcbiAgICAgICAgICBvcmlnaW5hbEhlaWdodCA9IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgIG5ld1pvb20gPSB6b29tICogbXVsdGlwbGllcixcbiAgICAgICAgICB2cCA9IHRoaXMudmlld3BvcnRUcmFuc2Zvcm0sXG4gICAgICAgICAgdHJhbnNsYXRlWCA9ICh2cFs0XSAtIChjcm9wcGluZy5sZWZ0IHx8IDApKSAqIG11bHRpcGxpZXIsXG4gICAgICAgICAgdHJhbnNsYXRlWSA9ICh2cFs1XSAtIChjcm9wcGluZy50b3AgfHwgMCkpICogbXVsdGlwbGllcixcbiAgICAgICAgICBvcmlnaW5hbEludGVyYWN0aXZlID0gdGhpcy5pbnRlcmFjdGl2ZSxcbiAgICAgICAgICBuZXdWcCA9IFtuZXdab29tLCAwLCAwLCBuZXdab29tLCB0cmFuc2xhdGVYLCB0cmFuc2xhdGVZXSxcbiAgICAgICAgICBvcmlnaW5hbFJldGluYSA9IHRoaXMuZW5hYmxlUmV0aW5hU2NhbGluZyxcbiAgICAgICAgICBjYW52YXNFbCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKSxcbiAgICAgICAgICBvcmlnaW5hbENvbnRleHRUb3AgPSB0aGlzLmNvbnRleHRUb3A7XG4gICAgICBjYW52YXNFbC53aWR0aCA9IHNjYWxlZFdpZHRoO1xuICAgICAgY2FudmFzRWwuaGVpZ2h0ID0gc2NhbGVkSGVpZ2h0O1xuICAgICAgdGhpcy5jb250ZXh0VG9wID0gbnVsbDtcbiAgICAgIHRoaXMuZW5hYmxlUmV0aW5hU2NhbGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5pbnRlcmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy52aWV3cG9ydFRyYW5zZm9ybSA9IG5ld1ZwO1xuICAgICAgdGhpcy53aWR0aCA9IHNjYWxlZFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSBzY2FsZWRIZWlnaHQ7XG4gICAgICB0aGlzLmNhbGNWaWV3cG9ydEJvdW5kYXJpZXMoKTtcbiAgICAgIHRoaXMucmVuZGVyQ2FudmFzKGNhbnZhc0VsLmdldENvbnRleHQoJzJkJyksIHRoaXMuX29iamVjdHMpO1xuICAgICAgdGhpcy52aWV3cG9ydFRyYW5zZm9ybSA9IHZwO1xuICAgICAgdGhpcy53aWR0aCA9IG9yaWdpbmFsV2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IG9yaWdpbmFsSGVpZ2h0O1xuICAgICAgdGhpcy5jYWxjVmlld3BvcnRCb3VuZGFyaWVzKCk7XG4gICAgICB0aGlzLmludGVyYWN0aXZlID0gb3JpZ2luYWxJbnRlcmFjdGl2ZTtcbiAgICAgIHRoaXMuZW5hYmxlUmV0aW5hU2NhbGluZyA9IG9yaWdpbmFsUmV0aW5hO1xuICAgICAgdGhpcy5jb250ZXh0VG9wID0gb3JpZ2luYWxDb250ZXh0VG9wO1xuICAgICAgcmV0dXJuIGNhbnZhc0VsO1xuICAgIH0sXG4gIH0pO1xuXG59KSgpO1xuXG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUgKi8ge1xuICAvKipcbiAgICogUG9wdWxhdGVzIGNhbnZhcyB3aXRoIGRhdGEgZnJvbSB0aGUgc3BlY2lmaWVkIEpTT04uXG4gICAqIEpTT04gZm9ybWF0IG11c3QgY29uZm9ybSB0byB0aGUgb25lIG9mIHtAbGluayBmYWJyaWMuQ2FudmFzI3RvSlNPTn1cbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBqc29uIEpTT04gc3RyaW5nIG9yIG9iamVjdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjaywgaW52b2tlZCB3aGVuIGpzb24gaXMgcGFyc2VkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBjb3JyZXNwb25kaW5nIG9iamVjdHMgKGUuZzoge0BsaW5rIGZhYnJpYy5JbWFnZX0pXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBpbml0aWFsaXplZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2YgSlNPTiBlbGVtZW50cywgY2FsbGVkIGFmdGVyIGVhY2ggZmFicmljIG9iamVjdCBjcmVhdGVkLlxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSBpbnN0YW5jZVxuICAgKiBAY2hhaW5hYmxlXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0zI2Rlc2VyaWFsaXphdGlvbn1cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzZmlkZGxlLm5ldC9mYWJyaWNqcy9mbWdYdC98anNGaWRkbGUgZGVtb31cbiAgICogQGV4YW1wbGUgPGNhcHRpb24+bG9hZEZyb21KU09OPC9jYXB0aW9uPlxuICAgKiBjYW52YXMubG9hZEZyb21KU09OKGpzb24sIGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+bG9hZEZyb21KU09OIHdpdGggcmV2aXZlcjwvY2FwdGlvbj5cbiAgICogY2FudmFzLmxvYWRGcm9tSlNPTihqc29uLCBjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSwgZnVuY3Rpb24obywgb2JqZWN0KSB7XG4gICAqICAgLy8gYG9gID0ganNvbiBvYmplY3RcbiAgICogICAvLyBgb2JqZWN0YCA9IGZhYnJpYy5PYmplY3QgaW5zdGFuY2VcbiAgICogICAvLyAuLi4gZG8gc29tZSBzdHVmZiAuLi5cbiAgICogfSk7XG4gICAqL1xuICBsb2FkRnJvbUpTT046IGZ1bmN0aW9uIChqc29uLCBjYWxsYmFjaywgcmV2aXZlcikge1xuICAgIGlmICghanNvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNlcmlhbGl6ZSBpZiBpdCB3YXNuJ3QgYWxyZWFkeVxuICAgIHZhciBzZXJpYWxpemVkID0gKHR5cGVvZiBqc29uID09PSAnc3RyaW5nJylcbiAgICAgID8gSlNPTi5wYXJzZShqc29uKVxuICAgICAgOiBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUoanNvbik7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICBjbGlwUGF0aCA9IHNlcmlhbGl6ZWQuY2xpcFBhdGgsXG4gICAgICAgIHJlbmRlck9uQWRkUmVtb3ZlID0gdGhpcy5yZW5kZXJPbkFkZFJlbW92ZTtcblxuICAgIHRoaXMucmVuZGVyT25BZGRSZW1vdmUgPSBmYWxzZTtcblxuICAgIGRlbGV0ZSBzZXJpYWxpemVkLmNsaXBQYXRoO1xuXG4gICAgdGhpcy5fZW5saXZlbk9iamVjdHMoc2VyaWFsaXplZC5vYmplY3RzLCBmdW5jdGlvbiAoZW5saXZlbmVkT2JqZWN0cykge1xuICAgICAgX3RoaXMuY2xlYXIoKTtcbiAgICAgIF90aGlzLl9zZXRCZ092ZXJsYXkoc2VyaWFsaXplZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoY2xpcFBhdGgpIHtcbiAgICAgICAgICBfdGhpcy5fZW5saXZlbk9iamVjdHMoW2NsaXBQYXRoXSwgZnVuY3Rpb24gKGVubGl2ZW5lZENhbnZhc0NsaXApIHtcbiAgICAgICAgICAgIF90aGlzLmNsaXBQYXRoID0gZW5saXZlbmVkQ2FudmFzQ2xpcFswXTtcbiAgICAgICAgICAgIF90aGlzLl9fc2V0dXBDYW52YXMuY2FsbChfdGhpcywgc2VyaWFsaXplZCwgZW5saXZlbmVkT2JqZWN0cywgcmVuZGVyT25BZGRSZW1vdmUsIGNhbGxiYWNrKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5fX3NldHVwQ2FudmFzLmNhbGwoX3RoaXMsIHNlcmlhbGl6ZWQsIGVubGl2ZW5lZE9iamVjdHMsIHJlbmRlck9uQWRkUmVtb3ZlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIHJldml2ZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2VyaWFsaXplZCBPYmplY3Qgd2l0aCBiYWNrZ3JvdW5kIGFuZCBvdmVybGF5IGluZm9ybWF0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJlc3RvcmVkIGNhbnZhcyBvYmplY3RzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhY2hlZCByZW5kZXJPbkFkZFJlbW92ZSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBJbnZva2VkIGFmdGVyIGFsbCBiYWNrZ3JvdW5kIGFuZCBvdmVybGF5IGltYWdlcy9wYXR0ZXJucyBsb2FkZWRcbiAgICovXG4gIF9fc2V0dXBDYW52YXM6IGZ1bmN0aW9uKHNlcmlhbGl6ZWQsIGVubGl2ZW5lZE9iamVjdHMsIHJlbmRlck9uQWRkUmVtb3ZlLCBjYWxsYmFjaykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgZW5saXZlbmVkT2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iaiwgaW5kZXgpIHtcbiAgICAgIC8vIHdlIHNwbGljZSB0aGUgYXJyYXkganVzdCBpbiBjYXNlIHNvbWUgY3VzdG9tIGNsYXNzZXMgcmVzdG9yZWQgZnJvbSBKU09OXG4gICAgICAvLyB3aWxsIGFkZCBtb3JlIG9iamVjdCB0byBjYW52YXMgYXQgY2FudmFzIGluaXQuXG4gICAgICBfdGhpcy5pbnNlcnRBdChvYmosIGluZGV4KTtcbiAgICB9KTtcbiAgICB0aGlzLnJlbmRlck9uQWRkUmVtb3ZlID0gcmVuZGVyT25BZGRSZW1vdmU7XG4gICAgLy8gcmVtb3ZlIHBhcnRzIGkgY2Fubm90IHNldCBhcyBvcHRpb25zXG4gICAgZGVsZXRlIHNlcmlhbGl6ZWQub2JqZWN0cztcbiAgICBkZWxldGUgc2VyaWFsaXplZC5iYWNrZ3JvdW5kSW1hZ2U7XG4gICAgZGVsZXRlIHNlcmlhbGl6ZWQub3ZlcmxheUltYWdlO1xuICAgIGRlbGV0ZSBzZXJpYWxpemVkLmJhY2tncm91bmQ7XG4gICAgZGVsZXRlIHNlcmlhbGl6ZWQub3ZlcmxheTtcbiAgICAvLyB0aGlzLl9pbml0T3B0aW9ucyBkb2VzIHRvbyBtYW55IHRoaW5ncyB0byBqdXN0XG4gICAgLy8gY2FsbCBpdC4gTm9ybWFsbHkgbG9hZGluZyBhbiBPYmplY3QgZnJvbSBKU09OXG4gICAgLy8gY3JlYXRlIHRoZSBPYmplY3QgaW5zdGFuY2UuIEhlcmUgdGhlIENhbnZhcyBpc1xuICAgIC8vIGFscmVhZHkgYW4gaW5zdGFuY2UgYW5kIHdlIGFyZSBqdXN0IGxvYWRpbmcgdGhpbmdzIG92ZXIgaXRcbiAgICB0aGlzLl9zZXRPcHRpb25zKHNlcmlhbGl6ZWQpO1xuICAgIHRoaXMucmVuZGVyQWxsKCk7XG4gICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNlcmlhbGl6ZWQgT2JqZWN0IHdpdGggYmFja2dyb3VuZCBhbmQgb3ZlcmxheSBpbmZvcm1hdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBJbnZva2VkIGFmdGVyIGFsbCBiYWNrZ3JvdW5kIGFuZCBvdmVybGF5IGltYWdlcy9wYXR0ZXJucyBsb2FkZWRcbiAgICovXG4gIF9zZXRCZ092ZXJsYXk6IGZ1bmN0aW9uKHNlcmlhbGl6ZWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGxvYWRlZCA9IHtcbiAgICAgIGJhY2tncm91bmRDb2xvcjogZmFsc2UsXG4gICAgICBvdmVybGF5Q29sb3I6IGZhbHNlLFxuICAgICAgYmFja2dyb3VuZEltYWdlOiBmYWxzZSxcbiAgICAgIG92ZXJsYXlJbWFnZTogZmFsc2VcbiAgICB9O1xuXG4gICAgaWYgKCFzZXJpYWxpemVkLmJhY2tncm91bmRJbWFnZSAmJiAhc2VyaWFsaXplZC5vdmVybGF5SW1hZ2UgJiYgIXNlcmlhbGl6ZWQuYmFja2dyb3VuZCAmJiAhc2VyaWFsaXplZC5vdmVybGF5KSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjYklmTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGxvYWRlZC5iYWNrZ3JvdW5kSW1hZ2UgJiYgbG9hZGVkLm92ZXJsYXlJbWFnZSAmJiBsb2FkZWQuYmFja2dyb3VuZENvbG9yICYmIGxvYWRlZC5vdmVybGF5Q29sb3IpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5fX3NldEJnT3ZlcmxheSgnYmFja2dyb3VuZEltYWdlJywgc2VyaWFsaXplZC5iYWNrZ3JvdW5kSW1hZ2UsIGxvYWRlZCwgY2JJZkxvYWRlZCk7XG4gICAgdGhpcy5fX3NldEJnT3ZlcmxheSgnb3ZlcmxheUltYWdlJywgc2VyaWFsaXplZC5vdmVybGF5SW1hZ2UsIGxvYWRlZCwgY2JJZkxvYWRlZCk7XG4gICAgdGhpcy5fX3NldEJnT3ZlcmxheSgnYmFja2dyb3VuZENvbG9yJywgc2VyaWFsaXplZC5iYWNrZ3JvdW5kLCBsb2FkZWQsIGNiSWZMb2FkZWQpO1xuICAgIHRoaXMuX19zZXRCZ092ZXJsYXkoJ292ZXJsYXlDb2xvcicsIHNlcmlhbGl6ZWQub3ZlcmxheSwgbG9hZGVkLCBjYklmTG9hZGVkKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRvIHNldCAoYmFja2dyb3VuZEltYWdlLCBvdmVybGF5SW1hZ2UsIGJhY2tncm91bmRDb2xvciwgb3ZlcmxheUNvbG9yKVxuICAgKiBAcGFyYW0geyhPYmplY3R8U3RyaW5nKX0gdmFsdWUgVmFsdWUgdG8gc2V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsb2FkZWQgU2V0IGxvYWRlZCBwcm9wZXJ0eSB0byB0cnVlIGlmIHByb3BlcnR5IGlzIHNldFxuICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gaW52b2tlIGFmdGVyIHByb3BlcnR5IGlzIHNldFxuICAgKi9cbiAgX19zZXRCZ092ZXJsYXk6IGZ1bmN0aW9uKHByb3BlcnR5LCB2YWx1ZSwgbG9hZGVkLCBjYWxsYmFjaykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICBsb2FkZWRbcHJvcGVydHldID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BlcnR5ID09PSAnYmFja2dyb3VuZEltYWdlJyB8fCBwcm9wZXJ0eSA9PT0gJ292ZXJsYXlJbWFnZScpIHtcbiAgICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RzKFt2YWx1ZV0sIGZ1bmN0aW9uKGVubGl2ZWRPYmplY3Qpe1xuICAgICAgICBfdGhpc1twcm9wZXJ0eV0gPSBlbmxpdmVkT2JqZWN0WzBdO1xuICAgICAgICBsb2FkZWRbcHJvcGVydHldID0gdHJ1ZTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXNbJ3NldCcgKyBmYWJyaWMudXRpbC5zdHJpbmcuY2FwaXRhbGl6ZShwcm9wZXJ0eSwgdHJ1ZSldKHZhbHVlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgbG9hZGVkW3Byb3BlcnR5XSA9IHRydWU7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IG9iamVjdHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdXG4gICAqL1xuICBfZW5saXZlbk9iamVjdHM6IGZ1bmN0aW9uIChvYmplY3RzLCBjYWxsYmFjaywgcmV2aXZlcikge1xuICAgIGlmICghb2JqZWN0cyB8fCBvYmplY3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soW10pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RzKG9iamVjdHMsIGZ1bmN0aW9uKGVubGl2ZW5lZE9iamVjdHMpIHtcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVubGl2ZW5lZE9iamVjdHMpO1xuICAgIH0sIG51bGwsIHJldml2ZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBfdG9EYXRhVVJMOiBmdW5jdGlvbiAoZm9ybWF0LCBjYWxsYmFjaykge1xuICAgIHRoaXMuY2xvbmUoZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICBjYWxsYmFjayhjbG9uZS50b0RhdGFVUkwoZm9ybWF0KSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG11bHRpcGxpZXJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIF90b0RhdGFVUkxXaXRoTXVsdGlwbGllcjogZnVuY3Rpb24gKGZvcm1hdCwgbXVsdGlwbGllciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmNsb25lKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgY2FsbGJhY2soY2xvbmUudG9EYXRhVVJMV2l0aE11bHRpcGxpZXIoZm9ybWF0LCBtdWx0aXBsaWVyKSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsb25lcyBjYW52YXMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjYWxsYmFja10gUmVjZWl2ZXMgY2xvbmVkIGluc3RhbmNlIGFzIGEgZmlyc3QgYXJndW1lbnRcbiAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNdIEFycmF5IG9mIHByb3BlcnRpZXMgdG8gaW5jbHVkZSBpbiB0aGUgY2xvbmVkIGNhbnZhcyBhbmQgY2hpbGRyZW5cbiAgICovXG4gIGNsb25lOiBmdW5jdGlvbiAoY2FsbGJhY2ssIHByb3BlcnRpZXMpIHtcbiAgICB2YXIgZGF0YSA9IEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKHByb3BlcnRpZXMpKTtcbiAgICB0aGlzLmNsb25lV2l0aG91dERhdGEoZnVuY3Rpb24oY2xvbmUpIHtcbiAgICAgIGNsb25lLmxvYWRGcm9tSlNPTihkYXRhLCBmdW5jdGlvbigpIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soY2xvbmUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsb25lcyBjYW52YXMgaW5zdGFuY2Ugd2l0aG91dCBjbG9uaW5nIGV4aXN0aW5nIGRhdGEuXG4gICAqIFRoaXMgZXNzZW50aWFsbHkgY29waWVzIGNhbnZhcyBkaW1lbnNpb25zLCBjbGlwcGluZyBwcm9wZXJ0aWVzLCBldGMuXG4gICAqIGJ1dCBsZWF2ZXMgZGF0YSBlbXB0eSAoc28gdGhhdCB5b3UgY2FuIHBvcHVsYXRlIGl0IHdpdGggeW91ciBvd24pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY2FsbGJhY2tdIFJlY2VpdmVzIGNsb25lZCBpbnN0YW5jZSBhcyBhIGZpcnN0IGFyZ3VtZW50XG4gICAqL1xuICBjbG9uZVdpdGhvdXREYXRhOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciBlbCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcblxuICAgIGVsLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICBlbC5oZWlnaHQgPSB0aGlzLmhlaWdodDtcblxuICAgIHZhciBjbG9uZSA9IG5ldyBmYWJyaWMuQ2FudmFzKGVsKTtcbiAgICBpZiAodGhpcy5iYWNrZ3JvdW5kSW1hZ2UpIHtcbiAgICAgIGNsb25lLnNldEJhY2tncm91bmRJbWFnZSh0aGlzLmJhY2tncm91bmRJbWFnZS5zcmMsIGZ1bmN0aW9uKCkge1xuICAgICAgICBjbG9uZS5yZW5kZXJBbGwoKTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soY2xvbmUpO1xuICAgICAgfSk7XG4gICAgICBjbG9uZS5iYWNrZ3JvdW5kSW1hZ2VPcGFjaXR5ID0gdGhpcy5iYWNrZ3JvdW5kSW1hZ2VPcGFjaXR5O1xuICAgICAgY2xvbmUuYmFja2dyb3VuZEltYWdlU3RyZXRjaCA9IHRoaXMuYmFja2dyb3VuZEltYWdlU3RyZXRjaDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhjbG9uZSk7XG4gICAgfVxuICB9XG59KTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBjbG9uZSA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZSxcbiAgICAgIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkLFxuICAgICAgY2FwaXRhbGl6ZSA9IGZhYnJpYy51dGlsLnN0cmluZy5jYXBpdGFsaXplLFxuICAgICAgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnMsXG4gICAgICBvYmplY3RDYWNoaW5nID0gIWZhYnJpYy5pc0xpa2VseU5vZGUsXG4gICAgICBBTElBU0lOR19MSU1JVCA9IDI7XG5cbiAgaWYgKGZhYnJpYy5PYmplY3QpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogUm9vdCBvYmplY3QgY2xhc3MgZnJvbSB3aGljaCBhbGwgMmQgc2hhcGUgY2xhc3NlcyBpbmhlcml0IGZyb21cbiAgICogQGNsYXNzIGZhYnJpYy5PYmplY3RcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTEjb2JqZWN0c31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLk9iamVjdCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKlxuICAgKiBAZmlyZXMgYWRkZWRcbiAgICogQGZpcmVzIHJlbW92ZWRcbiAgICpcbiAgICogQGZpcmVzIHNlbGVjdGVkXG4gICAqIEBmaXJlcyBkZXNlbGVjdGVkXG4gICAqIEBmaXJlcyBtb2RpZmllZFxuICAgKiBAZmlyZXMgbW9kaWZpZWRcbiAgICogQGZpcmVzIG1vdmVkXG4gICAqIEBmaXJlcyBzY2FsZWRcbiAgICogQGZpcmVzIHJvdGF0ZWRcbiAgICogQGZpcmVzIHNrZXdlZFxuICAgKlxuICAgKiBAZmlyZXMgcm90YXRpbmdcbiAgICogQGZpcmVzIHNjYWxpbmdcbiAgICogQGZpcmVzIG1vdmluZ1xuICAgKiBAZmlyZXMgc2tld2luZ1xuICAgKlxuICAgKiBAZmlyZXMgbW91c2Vkb3duXG4gICAqIEBmaXJlcyBtb3VzZXVwXG4gICAqIEBmaXJlcyBtb3VzZW92ZXJcbiAgICogQGZpcmVzIG1vdXNlb3V0XG4gICAqIEBmaXJlcyBtb3VzZXdoZWVsXG4gICAqIEBmaXJlcyBtb3VzZWRibGNsaWNrXG4gICAqXG4gICAqIEBmaXJlcyBkcmFnb3ZlclxuICAgKiBAZmlyZXMgZHJhZ2VudGVyXG4gICAqIEBmaXJlcyBkcmFnbGVhdmVcbiAgICogQGZpcmVzIGRyb3BcbiAgICovXG4gIGZhYnJpYy5PYmplY3QgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuQ29tbW9uTWV0aG9kcywgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdCAocmVjdCwgY2lyY2xlLCBwYXRoLCBldGMuKS5cbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyBtZWFudCB0byBiZSByZWFkLW9ubHkgYW5kIG5vdCBtZWFudCB0byBiZSBtb2RpZmllZC5cbiAgICAgKiBJZiB5b3UgbW9kaWZ5LCBjZXJ0YWluIHBhcnRzIG9mIEZhYnJpYyAoc3VjaCBhcyBKU09OIGxvYWRpbmcpIHdvbid0IHdvcmsgY29ycmVjdGx5LlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogICAgICAgICAgICAgICAgICAgICAnb2JqZWN0JyxcblxuICAgIC8qKlxuICAgICAqIEhvcml6b250YWwgb3JpZ2luIG9mIHRyYW5zZm9ybWF0aW9uIG9mIGFuIG9iamVjdCAob25lIG9mIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwiY2VudGVyXCIpXG4gICAgICogU2VlIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvMW93MDJnZWEvMjQ0LyBvbiBob3cgb3JpZ2luWC9vcmlnaW5ZIGFmZmVjdCBvYmplY3RzIGluIGdyb3Vwc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb3JpZ2luWDogICAgICAgICAgICAgICAgICAnbGVmdCcsXG5cbiAgICAvKipcbiAgICAgKiBWZXJ0aWNhbCBvcmlnaW4gb2YgdHJhbnNmb3JtYXRpb24gb2YgYW4gb2JqZWN0IChvbmUgb2YgXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJjZW50ZXJcIilcbiAgICAgKiBTZWUgaHR0cDovL2pzZmlkZGxlLm5ldC8xb3cwMmdlYS8yNDQvIG9uIGhvdyBvcmlnaW5YL29yaWdpblkgYWZmZWN0IG9iamVjdHMgaW4gZ3JvdXBzXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBvcmlnaW5ZOiAgICAgICAgICAgICAgICAgICd0b3AnLFxuXG4gICAgLyoqXG4gICAgICogVG9wIHBvc2l0aW9uIG9mIGFuIG9iamVjdC4gTm90ZSB0aGF0IGJ5IGRlZmF1bHQgaXQncyByZWxhdGl2ZSB0byBvYmplY3QgdG9wLiBZb3UgY2FuIGNoYW5nZSB0aGlzIGJ5IHNldHRpbmcgb3JpZ2luWT17dG9wL2NlbnRlci9ib3R0b219XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0b3A6ICAgICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBMZWZ0IHBvc2l0aW9uIG9mIGFuIG9iamVjdC4gTm90ZSB0aGF0IGJ5IGRlZmF1bHQgaXQncyByZWxhdGl2ZSB0byBvYmplY3QgbGVmdC4gWW91IGNhbiBjaGFuZ2UgdGhpcyBieSBzZXR0aW5nIG9yaWdpblg9e2xlZnQvY2VudGVyL3JpZ2h0fVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbGVmdDogICAgICAgICAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IHdpZHRoXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB3aWR0aDogICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBPYmplY3QgaGVpZ2h0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBoZWlnaHQ6ICAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBPYmplY3Qgc2NhbGUgZmFjdG9yIChob3Jpem9udGFsKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2NhbGVYOiAgICAgICAgICAgICAgICAgICAxLFxuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IHNjYWxlIGZhY3RvciAodmVydGljYWwpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzY2FsZVk6ICAgICAgICAgICAgICAgICAgIDEsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIGFuIG9iamVjdCBpcyByZW5kZXJlZCBhcyBmbGlwcGVkIGhvcml6b250YWxseVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZsaXBYOiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIGFuIG9iamVjdCBpcyByZW5kZXJlZCBhcyBmbGlwcGVkIHZlcnRpY2FsbHlcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmbGlwWTogICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogT3BhY2l0eSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG9wYWNpdHk6ICAgICAgICAgICAgICAgICAgMSxcblxuICAgIC8qKlxuICAgICAqIEFuZ2xlIG9mIHJvdGF0aW9uIG9mIGFuIG9iamVjdCAoaW4gZGVncmVlcylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGFuZ2xlOiAgICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIEFuZ2xlIG9mIHNrZXcgb24geCBheGVzIG9mIGFuIG9iamVjdCAoaW4gZGVncmVlcylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNrZXdYOiAgICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIEFuZ2xlIG9mIHNrZXcgb24geSBheGVzIG9mIGFuIG9iamVjdCAoaW4gZGVncmVlcylcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNrZXdZOiAgICAgICAgICAgICAgICAgICAgMCxcblxuICAgIC8qKlxuICAgICAqIFNpemUgb2Ygb2JqZWN0J3MgY29udHJvbGxpbmcgY29ybmVycyAoaW4gcGl4ZWxzKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29ybmVyU2l6ZTogICAgICAgICAgICAgICAxMyxcblxuICAgIC8qKlxuICAgICAqIFNpemUgb2Ygb2JqZWN0J3MgY29udHJvbGxpbmcgY29ybmVycyB3aGVuIHRvdWNoIGludGVyYWN0aW9uIGlzIGRldGVjdGVkXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0b3VjaENvcm5lclNpemU6ICAgICAgICAgICAgICAgMjQsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIG9iamVjdCdzIGNvbnRyb2xsaW5nIGNvcm5lcnMgYXJlIHJlbmRlcmVkIGFzIHRyYW5zcGFyZW50IGluc2lkZSAoaS5lLiBzdHJva2UgaW5zdGVhZCBvZiBmaWxsKVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHRyYW5zcGFyZW50Q29ybmVyczogICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgY3Vyc29yIHZhbHVlIHVzZWQgd2hlbiBob3ZlcmluZyBvdmVyIHRoaXMgb2JqZWN0IG9uIGNhbnZhc1xuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaG92ZXJDdXJzb3I6ICAgICAgICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBjdXJzb3IgdmFsdWUgdXNlZCB3aGVuIG1vdmluZyB0aGlzIG9iamVjdCBvbiBjYW52YXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1vdmVDdXJzb3I6ICAgICAgICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFBhZGRpbmcgYmV0d2VlbiBvYmplY3QgYW5kIGl0cyBjb250cm9sbGluZyBib3JkZXJzIChpbiBwaXhlbHMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwYWRkaW5nOiAgICAgICAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBvZiBjb250cm9sbGluZyBib3JkZXJzIG9mIGFuIG9iamVjdCAod2hlbiBpdCdzIGFjdGl2ZSlcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJvcmRlckNvbG9yOiAgICAgICAgICAgICAgJ3JnYigxNzgsMjA0LDI1NSknLFxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgc3BlY2lmeWluZyBkYXNoIHBhdHRlcm4gb2YgYW4gb2JqZWN0J3MgYm9yZGVycyAoaGFzQm9yZGVyIG11c3QgYmUgdHJ1ZSlcbiAgICAgKiBAc2luY2UgMS42LjJcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIGJvcmRlckRhc2hBcnJheTogICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIGNvbnRyb2xsaW5nIGNvcm5lcnMgb2YgYW4gb2JqZWN0ICh3aGVuIGl0J3MgYWN0aXZlKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29ybmVyQ29sb3I6ICAgICAgICAgICAgICAncmdiKDE3OCwyMDQsMjU1KScsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBvZiBjb250cm9sbGluZyBjb3JuZXJzIG9mIGFuIG9iamVjdCAod2hlbiBpdCdzIGFjdGl2ZSBhbmQgdHJhbnNwYXJlbnRDb3JuZXJzIGZhbHNlKVxuICAgICAqIEBzaW5jZSAxLjYuMlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY29ybmVyU3Ryb2tlQ29sb3I6ICAgICAgICBudWxsLFxuXG4gICAgLyoqXG4gICAgICogU3BlY2lmeSBzdHlsZSBvZiBjb250cm9sLCAncmVjdCcgb3IgJ2NpcmNsZSdcbiAgICAgKiBAc2luY2UgMS42LjJcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICBjb3JuZXJTdHlsZTogICAgICAgICAgJ3JlY3QnLFxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgc3BlY2lmeWluZyBkYXNoIHBhdHRlcm4gb2YgYW4gb2JqZWN0J3MgY29udHJvbCAoaGFzQm9yZGVyIG11c3QgYmUgdHJ1ZSlcbiAgICAgKiBAc2luY2UgMS42LjJcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIGNvcm5lckRhc2hBcnJheTogICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgdGhpcyBvYmplY3Qgd2lsbCB1c2UgY2VudGVyIHBvaW50IGFzIHRoZSBvcmlnaW4gb2YgdHJhbnNmb3JtYXRpb25cbiAgICAgKiB3aGVuIGJlaW5nIHNjYWxlZCB2aWEgdGhlIGNvbnRyb2xzLlxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgcmVwbGFjZXMgXCJjZW50ZXJUcmFuc2Zvcm1cIiAoQm9vbGVhbikuXG4gICAgICogQHNpbmNlIDEuMy40XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY2VudGVyZWRTY2FsaW5nOiAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgdGhpcyBvYmplY3Qgd2lsbCB1c2UgY2VudGVyIHBvaW50IGFzIHRoZSBvcmlnaW4gb2YgdHJhbnNmb3JtYXRpb25cbiAgICAgKiB3aGVuIGJlaW5nIHJvdGF0ZWQgdmlhIHRoZSBjb250cm9scy5cbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHJlcGxhY2VzIFwiY2VudGVyVHJhbnNmb3JtXCIgKEJvb2xlYW4pLlxuICAgICAqIEBzaW5jZSAxLjMuNFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNlbnRlcmVkUm90YXRpb246ICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIG9iamVjdCdzIGZpbGxcbiAgICAgKiB0YWtlcyBjc3MgY29sb3JzIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3MtY29sb3ItMy9cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZpbGw6ICAgICAgICAgICAgICAgICAgICAgJ3JnYigwLDAsMCknLFxuXG4gICAgLyoqXG4gICAgICogRmlsbCBydWxlIHVzZWQgdG8gZmlsbCBhbiBvYmplY3RcbiAgICAgKiBhY2NlcHRlZCB2YWx1ZXMgYXJlIG5vbnplcm8sIGV2ZW5vZGRcbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHdhcyB1c2VkIGZvciBzZXR0aW5nIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiB1bnRpbCB2MS40LjEyICh1c2UgYGZhYnJpYy5PYmplY3QjZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uYCBpbnN0ZWFkKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZmlsbFJ1bGU6ICAgICAgICAgICAgICAgICAnbm9uemVybycsXG5cbiAgICAvKipcbiAgICAgKiBDb21wb3NpdGUgcnVsZSB1c2VkIGZvciBjYW52YXMgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb246ICdzb3VyY2Utb3ZlcicsXG5cbiAgICAvKipcbiAgICAgKiBCYWNrZ3JvdW5kIGNvbG9yIG9mIGFuIG9iamVjdC5cbiAgICAgKiB0YWtlcyBjc3MgY29sb3JzIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3MtY29sb3ItMy9cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJhY2tncm91bmRDb2xvcjogICAgICAgICAgJycsXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3Rpb24gQmFja2dyb3VuZCBjb2xvciBvZiBhbiBvYmplY3QuIGNvbG9yZWQgbGF5ZXIgYmVoaW5kIHRoZSBvYmplY3Qgd2hlbiBpdCBpcyBhY3RpdmUuXG4gICAgICogZG9lcyBub3QgbWl4IGdvb2Qgd2l0aCBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gbWV0aG9kcy5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHNlbGVjdGlvbkJhY2tncm91bmRDb2xvcjogICAgICAgICAgJycsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGRlZmluZWQsIGFuIG9iamVjdCBpcyByZW5kZXJlZCB2aWEgc3Ryb2tlIGFuZCB0aGlzIHByb3BlcnR5IHNwZWNpZmllcyBpdHMgY29sb3JcbiAgICAgKiB0YWtlcyBjc3MgY29sb3JzIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3MtY29sb3ItMy9cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZTogICAgICAgICAgICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFdpZHRoIG9mIGEgc3Ryb2tlIHVzZWQgdG8gcmVuZGVyIHRoaXMgb2JqZWN0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2VXaWR0aDogICAgICAgICAgICAgIDEsXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBzcGVjaWZ5aW5nIGRhc2ggcGF0dGVybiBvZiBhbiBvYmplY3QncyBzdHJva2UgKHN0cm9rZSBtdXN0IGJlIGRlZmluZWQpXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBzdHJva2VEYXNoQXJyYXk6ICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBMaW5lIG9mZnNldCBvZiBhbiBvYmplY3QncyBzdHJva2VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZURhc2hPZmZzZXQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBMaW5lIGVuZGluZ3Mgc3R5bGUgb2YgYW4gb2JqZWN0J3Mgc3Ryb2tlIChvbmUgb2YgXCJidXR0XCIsIFwicm91bmRcIiwgXCJzcXVhcmVcIilcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHN0cm9rZUxpbmVDYXA6ICAgICAgICAgICAgJ2J1dHQnLFxuXG4gICAgLyoqXG4gICAgICogQ29ybmVyIHN0eWxlIG9mIGFuIG9iamVjdCdzIHN0cm9rZSAob25lIG9mIFwiYmV2ZWxcIiwgXCJyb3VuZFwiLCBcIm1pdGVyXCIpXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2VMaW5lSm9pbjogICAgICAgICAgICdtaXRlcicsXG5cbiAgICAvKipcbiAgICAgKiBNYXhpbXVtIG1pdGVyIGxlbmd0aCAodXNlZCBmb3Igc3Ryb2tlTGluZUpvaW4gPSBcIm1pdGVyXCIpIG9mIGFuIG9iamVjdCdzIHN0cm9rZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlTWl0ZXJMaW1pdDogICAgICAgICA0LFxuXG4gICAgLyoqXG4gICAgICogU2hhZG93IG9iamVjdCByZXByZXNlbnRpbmcgc2hhZG93IG9mIHRoaXMgc2hhcGVcbiAgICAgKiBAdHlwZSBmYWJyaWMuU2hhZG93XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzaGFkb3c6ICAgICAgICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBPcGFjaXR5IG9mIG9iamVjdCdzIGNvbnRyb2xsaW5nIGJvcmRlcnMgd2hlbiBvYmplY3QgaXMgYWN0aXZlIGFuZCBtb3ZpbmdcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJvcmRlck9wYWNpdHlXaGVuTW92aW5nOiAgMC40LFxuXG4gICAgLyoqXG4gICAgICogU2NhbGUgZmFjdG9yIG9mIG9iamVjdCdzIGNvbnRyb2xsaW5nIGJvcmRlcnNcbiAgICAgKiBiaWdnZXIgbnVtYmVyIHdpbGwgbWFrZSBhIHRoaWNrZXIgYm9yZGVyXG4gICAgICogYm9yZGVyIGlzIDEsIHNvIHRoaXMgaXMgYmFzaWNhbGx5IGEgYm9yZGVyIHRoaWNrbmVzc1xuICAgICAqIHNpbmNlIHRoZXJlIGlzIG5vIHdheSB0byBjaGFuZ2UgdGhlIGJvcmRlciBpdHNlbGYuXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBib3JkZXJTY2FsZUZhY3RvcjogICAgICAgIDEsXG5cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIGFsbG93ZWQgc2NhbGUgdmFsdWUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtaW5TY2FsZUxpbWl0OiAgICAgICAgICAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNldCB0byBgZmFsc2VgLCBhbiBvYmplY3QgY2FuIG5vdCBiZSBzZWxlY3RlZCBmb3IgbW9kaWZpY2F0aW9uICh1c2luZyBlaXRoZXIgcG9pbnQtY2xpY2stYmFzZWQgb3IgZ3JvdXAtYmFzZWQgc2VsZWN0aW9uKS5cbiAgICAgKiBCdXQgZXZlbnRzIHN0aWxsIGZpcmUgb24gaXQuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0YWJsZTogICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYGZhbHNlYCwgYW4gb2JqZWN0IGNhbiBub3QgYmUgYSB0YXJnZXQgb2YgZXZlbnRzLiBBbGwgZXZlbnRzIHByb3BhZ2F0ZSB0aHJvdWdoIGl0LiBJbnRyb2R1Y2VkIGluIHYxLjMuNFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGV2ZW50ZWQ6ICAgICAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGBmYWxzZWAsIGFuIG9iamVjdCBpcyBub3QgcmVuZGVyZWQgb24gY2FudmFzXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdmlzaWJsZTogICAgICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYGZhbHNlYCwgb2JqZWN0J3MgY29udHJvbHMgYXJlIG5vdCBkaXNwbGF5ZWQgYW5kIGNhbiBub3QgYmUgdXNlZCB0byBtYW5pcHVsYXRlIG9iamVjdFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGhhc0NvbnRyb2xzOiAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGBmYWxzZWAsIG9iamVjdCdzIGNvbnRyb2xsaW5nIGJvcmRlcnMgYXJlIG5vdCByZW5kZXJlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGhhc0JvcmRlcnM6ICAgICAgICAgICAgICAgdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gc2V0IHRvIGB0cnVlYCwgb2JqZWN0cyBhcmUgXCJmb3VuZFwiIG9uIGNhbnZhcyBvbiBwZXItcGl4ZWwgYmFzaXMgcmF0aGVyIHRoYW4gYWNjb3JkaW5nIHRvIGJvdW5kaW5nIGJveFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBlclBpeGVsVGFyZ2V0RmluZDogICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGBmYWxzZWAsIGRlZmF1bHQgb2JqZWN0J3MgdmFsdWVzIGFyZSBub3QgaW5jbHVkZWQgaW4gaXRzIHNlcmlhbGl6YXRpb25cbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbmNsdWRlRGVmYXVsdFZhbHVlczogICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IGhvcml6b250YWwgbW92ZW1lbnQgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja01vdmVtZW50WDogICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgdmVydGljYWwgbW92ZW1lbnQgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja01vdmVtZW50WTogICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3Qgcm90YXRpb24gaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1JvdGF0aW9uOiAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgaG9yaXpvbnRhbCBzY2FsaW5nIGlzIGxvY2tlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxvY2tTY2FsaW5nWDogICAgICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IHZlcnRpY2FsIHNjYWxpbmcgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1NjYWxpbmdZOiAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgaG9yaXpvbnRhbCBza2V3aW5nIGlzIGxvY2tlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxvY2tTa2V3aW5nWDogICAgICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IHZlcnRpY2FsIHNrZXdpbmcgaXMgbG9ja2VkXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbG9ja1NrZXdpbmdZOiAgICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBvYmplY3QgY2Fubm90IGJlIGZsaXBwZWQgYnkgc2NhbGluZyBpbnRvIG5lZ2F0aXZlIHZhbHVlc1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxvY2tTY2FsaW5nRmxpcDogICAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IGlzIG5vdCBleHBvcnRlZCBpbiBPQkpFQ1QvSlNPTlxuICAgICAqIEBzaW5jZSAxLjYuM1xuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGV4Y2x1ZGVGcm9tRXhwb3J0OiAgICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IGlzIGNhY2hlZCBvbiBhbiBhZGRpdGlvbmFsIGNhbnZhcy5cbiAgICAgKiBXaGVuIGBmYWxzZWAsIG9iamVjdCBpcyBub3QgY2FjaGVkIHVubGVzcyBuZWNlc3NhcnkgKCBjbGlwUGF0aCApXG4gICAgICogZGVmYXVsdCB0byB0cnVlXG4gICAgICogQHNpbmNlIDEuNy4wXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBvYmplY3RDYWNoaW5nOiAgICAgICAgICAgIG9iamVjdENhY2hpbmcsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGB0cnVlYCwgb2JqZWN0IHByb3BlcnRpZXMgYXJlIGNoZWNrZWQgZm9yIGNhY2hlIGludmFsaWRhdGlvbi4gSW4gc29tZSBwYXJ0aWN1bGFyXG4gICAgICogc2l0dWF0aW9uIHlvdSBtYXkgd2FudCB0aGlzIHRvIGJlIGRpc2FibGVkICggc3ByYXkgYnJ1c2gsIHZlcnkgYmlnLCBncm91cHMpXG4gICAgICogb3IgaWYgeW91ciBhcHBsaWNhdGlvbiBkb2VzIG5vdCBhbGxvdyB5b3UgdG8gbW9kaWZ5IHByb3BlcnRpZXMgZm9yIGdyb3VwcyBjaGlsZCB5b3Ugd2FudFxuICAgICAqIHRvIGRpc2FibGUgaXQgZm9yIGdyb3Vwcy5cbiAgICAgKiBkZWZhdWx0IHRvIGZhbHNlXG4gICAgICogc2luY2UgMS43LjBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBzdGF0ZWZ1bGxDYWNoZTogICAgICAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYHRydWVgLCBjYWNoZSBkb2VzIG5vdCBnZXQgdXBkYXRlZCBkdXJpbmcgc2NhbGluZy4gVGhlIHBpY3R1cmUgd2lsbCBnZXQgYmxvY2t5IGlmIHNjYWxlZFxuICAgICAqIHRvbyBtdWNoIGFuZCB3aWxsIGJlIHJlZHJhd24gd2l0aCBjb3JyZWN0IGRldGFpbHMgYXQgdGhlIGVuZCBvZiBzY2FsaW5nLlxuICAgICAqIHRoaXMgc2V0dGluZyBpcyBwZXJmb3JtYW5jZSBhbmQgYXBwbGljYXRpb24gZGVwZW5kYW50LlxuICAgICAqIGRlZmF1bHQgdG8gdHJ1ZVxuICAgICAqIHNpbmNlIDEuNy4wXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBub1NjYWxlQ2FjaGU6ICAgICAgICAgICAgICB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBgZmFsc2VgLCB0aGUgc3Rva2Ugd2lkdGggd2lsbCBzY2FsZSB3aXRoIHRoZSBvYmplY3QuXG4gICAgICogV2hlbiBgdHJ1ZWAsIHRoZSBzdHJva2Ugd2lsbCBhbHdheXMgbWF0Y2ggdGhlIGV4YWN0IHBpeGVsIHNpemUgZW50ZXJlZCBmb3Igc3Ryb2tlIHdpZHRoLlxuICAgICAqIHRoaXMgUHJvcGVydHkgZG9lcyBub3Qgd29yayBvbiBUZXh0IGNsYXNzZXMgb3IgZHJhd2luZyBjYWxsIHRoYXQgdXNlcyBzdHJva2VUZXh0LGZpbGxUZXh0IG1ldGhvZHNcbiAgICAgKiBkZWZhdWx0IHRvIGZhbHNlXG4gICAgICogQHNpbmNlIDIuNi4wXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgc3Ryb2tlVW5pZm9ybTogICAgICAgICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYHRydWVgLCBvYmplY3QncyBjYWNoZSB3aWxsIGJlIHJlcmVuZGVyZWQgbmV4dCByZW5kZXIgY2FsbC5cbiAgICAgKiBzaW5jZSAxLjcuMFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgZGlydHk6ICAgICAgICAgICAgICAgIHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBrZWVwcyB0aGUgdmFsdWUgb2YgdGhlIGxhc3QgaG92ZXJlZCBjb3JuZXIgZHVyaW5nIG1vdXNlIG1vdmUuXG4gICAgICogMCBpcyBubyBjb3JuZXIsIG9yICdtdCcsICdtbCcsICdtdHInIGV0Yy4uXG4gICAgICogSXQgc2hvdWxkIGJlIHByaXZhdGUsIGJ1dCB0aGVyZSBpcyBubyBoYXJtIGluIHVzaW5nIGl0IGFzXG4gICAgICogYSByZWFkLW9ubHkgcHJvcGVydHkuXG4gICAgICogQHR5cGUgbnVtYmVyfHN0cmluZ3xhbnlcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgX19jb3JuZXI6IDAsXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBmaWxsIG9yIHRoZSBzdHJva2UgaXMgZHJhd24gZmlyc3QgKG9uZSBvZiBcImZpbGxcIiBvciBcInN0cm9rZVwiKVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcGFpbnRGaXJzdDogICAgICAgICAgICdmaWxsJyxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gJ2Rvd24nLCBvYmplY3QgaXMgc2V0IHRvIGFjdGl2ZSBvbiBtb3VzZWRvd24vdG91Y2hzdGFydFxuICAgICAqIFdoZW4gJ3VwJywgb2JqZWN0IGlzIHNldCB0byBhY3RpdmUgb24gbW91c2V1cC90b3VjaGVuZFxuICAgICAqIEV4cGVyaW1lbnRhbC4gTGV0J3Mgc2VlIGlmIHRoaXMgYnJlYWtzIGFueXRoaW5nIGJlZm9yZSBzdXBwb3J0aW5nIG9mZmljaWFsbHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIHNpbmNlIDQuNC4wXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHQgJ2Rvd24nXG4gICAgICovXG4gICAgYWN0aXZlT246ICAgICAgICAgICAnZG93bicsXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgd2hlbiBjaGVja2luZyBpZiBzdGF0ZVxuICAgICAqIG9mIGFuIG9iamVjdCBpcyBjaGFuZ2VkIChmYWJyaWMuT2JqZWN0I2hhc1N0YXRlQ2hhbmdlZClcbiAgICAgKiBhcyB3ZWxsIGFzIGZvciBoaXN0b3J5ICh1bmRvL3JlZG8pIHB1cnBvc2VzXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBzdGF0ZVByb3BlcnRpZXM6IChcbiAgICAgICd0b3AgbGVmdCB3aWR0aCBoZWlnaHQgc2NhbGVYIHNjYWxlWSBmbGlwWCBmbGlwWSBvcmlnaW5YIG9yaWdpblkgdHJhbnNmb3JtTWF0cml4ICcgK1xuICAgICAgJ3N0cm9rZSBzdHJva2VXaWR0aCBzdHJva2VEYXNoQXJyYXkgc3Ryb2tlTGluZUNhcCBzdHJva2VEYXNoT2Zmc2V0IHN0cm9rZUxpbmVKb2luIHN0cm9rZU1pdGVyTGltaXQgJyArXG4gICAgICAnYW5nbGUgb3BhY2l0eSBmaWxsIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiBzaGFkb3cgdmlzaWJsZSBiYWNrZ3JvdW5kQ29sb3IgJyArXG4gICAgICAnc2tld1ggc2tld1kgZmlsbFJ1bGUgcGFpbnRGaXJzdCBjbGlwUGF0aCBzdHJva2VVbmlmb3JtJ1xuICAgICkuc3BsaXQoJyAnKSxcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgcHJvcGVydGllcyB0byBjb25zaWRlciB3aGVuIGNoZWNraW5nIGlmIGNhY2hlIG5lZWRzIHJlZnJlc2hcbiAgICAgKiBUaG9zZSBwcm9wZXJ0aWVzIGFyZSBjaGVja2VkIGJ5IHN0YXRlZnVsbENhY2hlIE9OICggb3IgbGF6eSBtb2RlIGlmIHdlIHdhbnQgKSBvciBmcm9tIHNpbmdsZVxuICAgICAqIGNhbGxzIHRvIE9iamVjdC5zZXQoa2V5LCB2YWx1ZSkuIElmIHRoZSBrZXkgaXMgaW4gdGhpcyBsaXN0LCB0aGUgb2JqZWN0IGlzIG1hcmtlZCBhcyBkaXJ0eVxuICAgICAqIGFuZCByZWZyZXNoZWQgYXQgdGhlIG5leHQgcmVuZGVyXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBjYWNoZVByb3BlcnRpZXM6IChcbiAgICAgICdmaWxsIHN0cm9rZSBzdHJva2VXaWR0aCBzdHJva2VEYXNoQXJyYXkgd2lkdGggaGVpZ2h0IHBhaW50Rmlyc3Qgc3Ryb2tlVW5pZm9ybScgK1xuICAgICAgJyBzdHJva2VMaW5lQ2FwIHN0cm9rZURhc2hPZmZzZXQgc3Ryb2tlTGluZUpvaW4gc3Ryb2tlTWl0ZXJMaW1pdCBiYWNrZ3JvdW5kQ29sb3IgY2xpcFBhdGgnXG4gICAgKS5zcGxpdCgnICcpLFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBwcm9wZXJ0aWVzIHRvIGNvbnNpZGVyIGZvciBhbmltYXRpbmcgY29sb3JzLlxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgY29sb3JQcm9wZXJ0aWVzOiAoXG4gICAgICAnZmlsbCBzdHJva2UgYmFja2dyb3VuZENvbG9yJ1xuICAgICkuc3BsaXQoJyAnKSxcblxuICAgIC8qKlxuICAgICAqIGEgZmFicmljT2JqZWN0IHRoYXQsIHdpdGhvdXQgc3Ryb2tlIGRlZmluZSBhIGNsaXBwaW5nIGFyZWEgd2l0aCB0aGVpciBzaGFwZS4gZmlsbGVkIGluIGJsYWNrXG4gICAgICogdGhlIGNsaXBQYXRoIG9iamVjdCBnZXRzIHVzZWQgd2hlbiB0aGUgb2JqZWN0IGhhcyByZW5kZXJlZCwgYW5kIHRoZSBjb250ZXh0IGlzIHBsYWNlZCBpbiB0aGUgY2VudGVyXG4gICAgICogb2YgdGhlIG9iamVjdCBjYWNoZUNhbnZhcy5cbiAgICAgKiBJZiB5b3Ugd2FudCAwLDAgb2YgYSBjbGlwUGF0aCB0byBhbGlnbiB3aXRoIGFuIG9iamVjdCBjZW50ZXIsIHVzZSBjbGlwUGF0aC5vcmlnaW5YL1kgdG8gJ2NlbnRlcidcbiAgICAgKiBAdHlwZSBmYWJyaWMuT2JqZWN0XG4gICAgICovXG4gICAgY2xpcFBhdGg6IHVuZGVmaW5lZCxcblxuICAgIC8qKlxuICAgICAqIE1lYW5pbmdmdWwgT05MWSB3aGVuIHRoZSBvYmplY3QgaXMgdXNlZCBhcyBjbGlwUGF0aC5cbiAgICAgKiBpZiB0cnVlLCB0aGUgY2xpcFBhdGggd2lsbCBtYWtlIHRoZSBvYmplY3QgY2xpcCB0byB0aGUgb3V0c2lkZSBvZiB0aGUgY2xpcFBhdGhcbiAgICAgKiBzaW5jZSAyLjQuMFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGludmVydGVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIE1lYW5pbmdmdWwgT05MWSB3aGVuIHRoZSBvYmplY3QgaXMgdXNlZCBhcyBjbGlwUGF0aC5cbiAgICAgKiBpZiB0cnVlLCB0aGUgY2xpcFBhdGggd2lsbCBoYXZlIGl0cyB0b3AgYW5kIGxlZnQgcmVsYXRpdmUgdG8gY2FudmFzLCBhbmQgd2lsbFxuICAgICAqIG5vdCBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBvYmplY3QgdHJhbnNmb3JtLiBUaGlzIHdpbGwgbWFrZSB0aGUgY2xpcFBhdGggcmVsYXRpdmVcbiAgICAgKiB0byB0aGUgY2FudmFzLCBidXQgY2xpcHBpbmcganVzdCBhIHBhcnRpY3VsYXIgb2JqZWN0LlxuICAgICAqIFdBUk5JTkcgdGhpcyBpcyBiZXRhLCB0aGlzIGZlYXR1cmUgbWF5IGNoYW5nZSBvciBiZSByZW5hbWVkLlxuICAgICAqIHNpbmNlIDIuNC4wXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgYWJzb2x1dGVQb3NpdGlvbmVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgdGhlIGNhbnZhcyB1c2VkIHRvIGtlZXAgdGhlIGNhY2hlZCBjb3B5IG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVDYWNoZUNhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9jYWNoZVByb3BlcnRpZXMgPSB7fTtcbiAgICAgIHRoaXMuX2NhY2hlQ2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgdGhpcy5fY2FjaGVDb250ZXh0ID0gdGhpcy5fY2FjaGVDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIHRoaXMuX3VwZGF0ZUNhY2hlQ2FudmFzKCk7XG4gICAgICAvLyBpZiBjYW52YXMgZ2V0cyBjcmVhdGVkLCBpcyBlbXB0eSwgc28gZGlydHkuXG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTGltaXQgdGhlIGNhY2hlIGRpbWVuc2lvbnMgc28gdGhhdCBYICogWSBkbyBub3QgY3Jvc3MgZmFicmljLnBlcmZMaW1pdFNpemVUb3RhbFxuICAgICAqIGFuZCBlYWNoIHNpZGUgZG8gbm90IGNyb3NzIGZhYnJpYy5jYWNoZVNpZGVMaW1pdFxuICAgICAqIHRob3NlIG51bWJlcnMgYXJlIGNvbmZpZ3VyYWJsZSBzbyB0aGF0IHlvdSBjYW4gZ2V0IGFzIG11Y2ggZGV0YWlsIGFzIHlvdSB3YW50XG4gICAgICogbWFraW5nIGJhcmdhaW4gd2l0aCBwZXJmb3JtYW5jZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRpbXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGltcy53aWR0aCB3aWR0aCBvZiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGltcy5oZWlnaHQgaGVpZ2h0IG9mIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkaW1zLnpvb21YIHpvb21YIHpvb20gdmFsdWUgdG8gdW5zY2FsZSB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIGNhY2hlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRpbXMuem9vbVkgem9vbVkgem9vbSB2YWx1ZSB0byB1bnNjYWxlIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgY2FjaGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9LndpZHRoIHdpZHRoIG9mIGNhbnZhc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0uaGVpZ2h0IGhlaWdodCBvZiBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9Lnpvb21YIHpvb21YIHpvb20gdmFsdWUgdG8gdW5zY2FsZSB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIGNhY2hlXG4gICAgICogQHJldHVybiB7T2JqZWN0fS56b29tWSB6b29tWSB6b29tIHZhbHVlIHRvIHVuc2NhbGUgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZyBjYWNoZVxuICAgICAqL1xuICAgIF9saW1pdENhY2hlU2l6ZTogZnVuY3Rpb24oZGltcykge1xuICAgICAgdmFyIHBlcmZMaW1pdFNpemVUb3RhbCA9IGZhYnJpYy5wZXJmTGltaXRTaXplVG90YWwsXG4gICAgICAgICAgd2lkdGggPSBkaW1zLndpZHRoLCBoZWlnaHQgPSBkaW1zLmhlaWdodCxcbiAgICAgICAgICBtYXggPSBmYWJyaWMubWF4Q2FjaGVTaWRlTGltaXQsIG1pbiA9IGZhYnJpYy5taW5DYWNoZVNpZGVMaW1pdDtcbiAgICAgIGlmICh3aWR0aCA8PSBtYXggJiYgaGVpZ2h0IDw9IG1heCAmJiB3aWR0aCAqIGhlaWdodCA8PSBwZXJmTGltaXRTaXplVG90YWwpIHtcbiAgICAgICAgaWYgKHdpZHRoIDwgbWluKSB7XG4gICAgICAgICAgZGltcy53aWR0aCA9IG1pbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0IDwgbWluKSB7XG4gICAgICAgICAgZGltcy5oZWlnaHQgPSBtaW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpbXM7XG4gICAgICB9XG4gICAgICB2YXIgYXIgPSB3aWR0aCAvIGhlaWdodCwgbGltaXRlZERpbXMgPSBmYWJyaWMudXRpbC5saW1pdERpbXNCeUFyZWEoYXIsIHBlcmZMaW1pdFNpemVUb3RhbCksXG4gICAgICAgICAgY2FwVmFsdWUgPSBmYWJyaWMudXRpbC5jYXBWYWx1ZSxcbiAgICAgICAgICB4ID0gY2FwVmFsdWUobWluLCBsaW1pdGVkRGltcy54LCBtYXgpLFxuICAgICAgICAgIHkgPSBjYXBWYWx1ZShtaW4sIGxpbWl0ZWREaW1zLnksIG1heCk7XG4gICAgICBpZiAod2lkdGggPiB4KSB7XG4gICAgICAgIGRpbXMuem9vbVggLz0gd2lkdGggLyB4O1xuICAgICAgICBkaW1zLndpZHRoID0geDtcbiAgICAgICAgZGltcy5jYXBwZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGhlaWdodCA+IHkpIHtcbiAgICAgICAgZGltcy56b29tWSAvPSBoZWlnaHQgLyB5O1xuICAgICAgICBkaW1zLmhlaWdodCA9IHk7XG4gICAgICAgIGRpbXMuY2FwcGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkaW1zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGRpbWVuc2lvbiBhbmQgdGhlIHpvb20gbGV2ZWwgbmVlZGVkIHRvIGNyZWF0ZSBhIGNhY2hlIGNhbnZhc1xuICAgICAqIGJpZyBlbm91Z2ggdG8gaG9zdCB0aGUgb2JqZWN0IHRvIGJlIGNhY2hlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0ueCB3aWR0aCBvZiBvYmplY3QgdG8gYmUgY2FjaGVkXG4gICAgICogQHJldHVybiB7T2JqZWN0fS55IGhlaWdodCBvZiBvYmplY3QgdG8gYmUgY2FjaGVkXG4gICAgICogQHJldHVybiB7T2JqZWN0fS53aWR0aCB3aWR0aCBvZiBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9LmhlaWdodCBoZWlnaHQgb2YgY2FudmFzXG4gICAgICogQHJldHVybiB7T2JqZWN0fS56b29tWCB6b29tWCB6b29tIHZhbHVlIHRvIHVuc2NhbGUgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZyBjYWNoZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0uem9vbVkgem9vbVkgem9vbSB2YWx1ZSB0byB1bnNjYWxlIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgY2FjaGVcbiAgICAgKi9cbiAgICBfZ2V0Q2FjaGVDYW52YXNEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmplY3RTY2FsZSA9IHRoaXMuZ2V0VG90YWxPYmplY3RTY2FsaW5nKCksXG4gICAgICAgICAgLy8gY2FjdWxhdGUgZGltZW5zaW9ucyB3aXRob3V0IHNrZXdpbmdcbiAgICAgICAgICBkaW0gPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoMCwgMCksXG4gICAgICAgICAgbmVlZGVkWCA9IGRpbS54ICogb2JqZWN0U2NhbGUuc2NhbGVYIC8gdGhpcy5zY2FsZVgsXG4gICAgICAgICAgbmVlZGVkWSA9IGRpbS55ICogb2JqZWN0U2NhbGUuc2NhbGVZIC8gdGhpcy5zY2FsZVk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyBmb3Igc3VyZSB0aGlzIEFMSUFTSU5HX0xJTUlUIGlzIHNsaWdodGx5IGNyZWF0aW5nIHByb2JsZW1cbiAgICAgICAgLy8gaW4gc2l0dWF0aW9uIGluIHdoaWNoIHRoZSBjYWNoZSBjYW52YXMgZ2V0cyBhbiB1cHBlciBsaW1pdFxuICAgICAgICAvLyBhbHNvIG9iamVjdFNjYWxlIGNvbnRhaW5zIGFscmVhZHkgc2NhbGVYIGFuZCBzY2FsZVlcbiAgICAgICAgd2lkdGg6IE1hdGguY2VpbChuZWVkZWRYICsgQUxJQVNJTkdfTElNSVQpLFxuICAgICAgICBoZWlnaHQ6IE1hdGguY2VpbChuZWVkZWRZICsgQUxJQVNJTkdfTElNSVQpLFxuICAgICAgICB6b29tWDogb2JqZWN0U2NhbGUuc2NhbGVYLFxuICAgICAgICB6b29tWTogb2JqZWN0U2NhbGUuc2NhbGVZLFxuICAgICAgICB4OiBuZWVkZWRYLFxuICAgICAgICB5OiBuZWVkZWRZXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgY2FudmFzIGZvciBjYWNoZVxuICAgICAqIHJldHVybnMgdHJ1ZSBvciBmYWxzZSBpZiBjYW52YXMgbmVlZGVkIHJlc2l6ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIGNhbnZhcyBoYXMgYmVlbiByZXNpemVkXG4gICAgICovXG4gICAgX3VwZGF0ZUNhY2hlQ2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0YXJnZXRDYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgIGlmICh0aGlzLm5vU2NhbGVDYWNoZSAmJiB0YXJnZXRDYW52YXMgJiYgdGFyZ2V0Q2FudmFzLl9jdXJyZW50VHJhbnNmb3JtKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0YXJnZXRDYW52YXMuX2N1cnJlbnRUcmFuc2Zvcm0udGFyZ2V0LFxuICAgICAgICAgICAgYWN0aW9uID0gdGFyZ2V0Q2FudmFzLl9jdXJyZW50VHJhbnNmb3JtLmFjdGlvbjtcbiAgICAgICAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBhY3Rpb24uc2xpY2UgJiYgYWN0aW9uLnNsaWNlKDAsIDUpID09PSAnc2NhbGUnKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5fY2FjaGVDYW52YXMsXG4gICAgICAgICAgZGltcyA9IHRoaXMuX2xpbWl0Q2FjaGVTaXplKHRoaXMuX2dldENhY2hlQ2FudmFzRGltZW5zaW9ucygpKSxcbiAgICAgICAgICB3aWR0aCA9IGRpbXMud2lkdGgsIGhlaWdodCA9IGRpbXMuaGVpZ2h0LCBkcmF3aW5nV2lkdGgsIGRyYXdpbmdIZWlnaHQsXG4gICAgICAgICAgem9vbVggPSBkaW1zLnpvb21YLCB6b29tWSA9IGRpbXMuem9vbVksXG4gICAgICAgICAgZGltZW5zaW9uc0NoYW5nZWQgPSB3aWR0aCAhPT0gdGhpcy5jYWNoZVdpZHRoIHx8IGhlaWdodCAhPT0gdGhpcy5jYWNoZUhlaWdodCxcbiAgICAgICAgICB6b29tQ2hhbmdlZCA9IHRoaXMuem9vbVggIT09IHpvb21YIHx8IHRoaXMuem9vbVkgIT09IHpvb21ZLFxuICAgICAgICAgIHNob3VsZFJlZHJhdyA9IGRpbWVuc2lvbnNDaGFuZ2VkIHx8IHpvb21DaGFuZ2VkO1xuXG4gICAgICBpZiAoc2hvdWxkUmVkcmF3KSB7XG4gICAgICAgIGlmIChkaW1lbnNpb25zQ2hhbmdlZCkge1xuICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5fY2FjaGVDb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZHJhd2luZ1dpZHRoID0gZGltcy54IC8gMjtcbiAgICAgICAgZHJhd2luZ0hlaWdodCA9IGRpbXMueSAvIDI7XG4gICAgICAgIHRoaXMuY2FjaGVUcmFuc2xhdGlvblggPSBNYXRoLnJvdW5kKGNhbnZhcy53aWR0aCAvIDIgLSBkcmF3aW5nV2lkdGgpICsgZHJhd2luZ1dpZHRoO1xuICAgICAgICB0aGlzLmNhY2hlVHJhbnNsYXRpb25ZID0gTWF0aC5yb3VuZChjYW52YXMuaGVpZ2h0IC8gMiAtIGRyYXdpbmdIZWlnaHQpICsgZHJhd2luZ0hlaWdodDtcbiAgICAgICAgdGhpcy5jYWNoZVdpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuY2FjaGVIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuX2NhY2hlQ29udGV4dC50cmFuc2xhdGUodGhpcy5jYWNoZVRyYW5zbGF0aW9uWCwgdGhpcy5jYWNoZVRyYW5zbGF0aW9uWSk7XG4gICAgICAgIHRoaXMuX2NhY2hlQ29udGV4dC5zY2FsZSh6b29tWCwgem9vbVkpO1xuICAgICAgICB0aGlzLnpvb21YID0gem9vbVg7XG4gICAgICAgIHRoaXMuem9vbVkgPSB6b29tWTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgb2JqZWN0J3MgcHJvcGVydGllcyBmcm9tIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgc2V0T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5fc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIHRoaXMuX2luaXRHcmFkaWVudChvcHRpb25zLmZpbGwsICdmaWxsJyk7XG4gICAgICB0aGlzLl9pbml0R3JhZGllbnQob3B0aW9ucy5zdHJva2UsICdzdHJva2UnKTtcbiAgICAgIHRoaXMuX2luaXRQYXR0ZXJuKG9wdGlvbnMuZmlsbCwgJ2ZpbGwnKTtcbiAgICAgIHRoaXMuX2luaXRQYXR0ZXJuKG9wdGlvbnMuc3Ryb2tlLCAnc3Ryb2tlJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgY29udGV4dCB3aGVuIHJlbmRlcmluZyBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHRcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIG5lZWRGdWxsVHJhbnNmb3JtID0gKHRoaXMuZ3JvdXAgJiYgIXRoaXMuZ3JvdXAuX3RyYW5zZm9ybURvbmUpIHx8XG4gICAgICAgICAodGhpcy5ncm91cCAmJiB0aGlzLmNhbnZhcyAmJiBjdHggPT09IHRoaXMuY2FudmFzLmNvbnRleHRUb3ApO1xuICAgICAgdmFyIG0gPSB0aGlzLmNhbGNUcmFuc2Zvcm1NYXRyaXgoIW5lZWRGdWxsVHJhbnNmb3JtKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0obVswXSwgbVsxXSwgbVsyXSwgbVszXSwgbVs0XSwgbVs1XSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHZhciBOVU1fRlJBQ1RJT05fRElHSVRTID0gZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTLFxuXG4gICAgICAgICAgb2JqZWN0ID0ge1xuICAgICAgICAgICAgdHlwZTogICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUsXG4gICAgICAgICAgICB2ZXJzaW9uOiAgICAgICAgICAgICAgICAgIGZhYnJpYy52ZXJzaW9uLFxuICAgICAgICAgICAgb3JpZ2luWDogICAgICAgICAgICAgICAgICB0aGlzLm9yaWdpblgsXG4gICAgICAgICAgICBvcmlnaW5ZOiAgICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luWSxcbiAgICAgICAgICAgIGxlZnQ6ICAgICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmxlZnQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgdG9wOiAgICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMudG9wLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIHdpZHRoOiAgICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLndpZHRoLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIGhlaWdodDogICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLmhlaWdodCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBmaWxsOiAgICAgICAgICAgICAgICAgICAgICh0aGlzLmZpbGwgJiYgdGhpcy5maWxsLnRvT2JqZWN0KSA/IHRoaXMuZmlsbC50b09iamVjdCgpIDogdGhpcy5maWxsLFxuICAgICAgICAgICAgc3Ryb2tlOiAgICAgICAgICAgICAgICAgICAodGhpcy5zdHJva2UgJiYgdGhpcy5zdHJva2UudG9PYmplY3QpID8gdGhpcy5zdHJva2UudG9PYmplY3QoKSA6IHRoaXMuc3Ryb2tlLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6ICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuc3Ryb2tlV2lkdGgsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgc3Ryb2tlRGFzaEFycmF5OiAgICAgICAgICB0aGlzLnN0cm9rZURhc2hBcnJheSA/IHRoaXMuc3Ryb2tlRGFzaEFycmF5LmNvbmNhdCgpIDogdGhpcy5zdHJva2VEYXNoQXJyYXksXG4gICAgICAgICAgICBzdHJva2VMaW5lQ2FwOiAgICAgICAgICAgIHRoaXMuc3Ryb2tlTGluZUNhcCxcbiAgICAgICAgICAgIHN0cm9rZURhc2hPZmZzZXQ6ICAgICAgICAgdGhpcy5zdHJva2VEYXNoT2Zmc2V0LFxuICAgICAgICAgICAgc3Ryb2tlTGluZUpvaW46ICAgICAgICAgICB0aGlzLnN0cm9rZUxpbmVKb2luLFxuICAgICAgICAgICAgc3Ryb2tlVW5pZm9ybTogICAgICAgICAgICB0aGlzLnN0cm9rZVVuaWZvcm0sXG4gICAgICAgICAgICBzdHJva2VNaXRlckxpbWl0OiAgICAgICAgIHRvRml4ZWQodGhpcy5zdHJva2VNaXRlckxpbWl0LCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAgIHNjYWxlWDogICAgICAgICAgICAgICAgICAgdG9GaXhlZCh0aGlzLnNjYWxlWCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBzY2FsZVk6ICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5zY2FsZVksIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgYW5nbGU6ICAgICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMuYW5nbGUsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICAgZmxpcFg6ICAgICAgICAgICAgICAgICAgICB0aGlzLmZsaXBYLFxuICAgICAgICAgICAgZmxpcFk6ICAgICAgICAgICAgICAgICAgICB0aGlzLmZsaXBZLFxuICAgICAgICAgICAgb3BhY2l0eTogICAgICAgICAgICAgICAgICB0b0ZpeGVkKHRoaXMub3BhY2l0eSwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBzaGFkb3c6ICAgICAgICAgICAgICAgICAgICh0aGlzLnNoYWRvdyAmJiB0aGlzLnNoYWRvdy50b09iamVjdCkgPyB0aGlzLnNoYWRvdy50b09iamVjdCgpIDogdGhpcy5zaGFkb3csXG4gICAgICAgICAgICB2aXNpYmxlOiAgICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZSxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBmaWxsUnVsZTogICAgICAgICAgICAgICAgIHRoaXMuZmlsbFJ1bGUsXG4gICAgICAgICAgICBwYWludEZpcnN0OiAgICAgICAgICAgICAgIHRoaXMucGFpbnRGaXJzdCxcbiAgICAgICAgICAgIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjogdGhpcy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24sXG4gICAgICAgICAgICBza2V3WDogICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5za2V3WCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgICBza2V3WTogICAgICAgICAgICAgICAgICAgIHRvRml4ZWQodGhpcy5za2V3WSwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuY2xpcFBhdGggJiYgIXRoaXMuY2xpcFBhdGguZXhjbHVkZUZyb21FeHBvcnQpIHtcbiAgICAgICAgb2JqZWN0LmNsaXBQYXRoID0gdGhpcy5jbGlwUGF0aC50b09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgICAgb2JqZWN0LmNsaXBQYXRoLmludmVydGVkID0gdGhpcy5jbGlwUGF0aC5pbnZlcnRlZDtcbiAgICAgICAgb2JqZWN0LmNsaXBQYXRoLmFic29sdXRlUG9zaXRpb25lZCA9IHRoaXMuY2xpcFBhdGguYWJzb2x1dGVQb3NpdGlvbmVkO1xuICAgICAgfVxuXG4gICAgICBmYWJyaWMudXRpbC5wb3B1bGF0ZVdpdGhQcm9wZXJ0aWVzKHRoaXMsIG9iamVjdCwgcHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICBpZiAoIXRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgb2JqZWN0ID0gdGhpcy5fcmVtb3ZlRGVmYXVsdFZhbHVlcyhvYmplY3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIChkYXRhbGVzcykgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9EYXRhbGVzc09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgLy8gd2lsbCBiZSBvdmVyd3JpdHRlbiBieSBzdWJjbGFzc2VzXG4gICAgICByZXR1cm4gdGhpcy50b09iamVjdChwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICovXG4gICAgX3JlbW92ZURlZmF1bHRWYWx1ZXM6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIHByb3RvdHlwZSA9IGZhYnJpYy51dGlsLmdldEtsYXNzKG9iamVjdC50eXBlKS5wcm90b3R5cGUsXG4gICAgICAgICAgc3RhdGVQcm9wZXJ0aWVzID0gcHJvdG90eXBlLnN0YXRlUHJvcGVydGllcztcbiAgICAgIHN0YXRlUHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgaWYgKHByb3AgPT09ICdsZWZ0JyB8fCBwcm9wID09PSAndG9wJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0W3Byb3BdID09PSBwcm90b3R5cGVbcHJvcF0pIHtcbiAgICAgICAgICBkZWxldGUgb2JqZWN0W3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJhc2ljYWxseSBhIGNoZWNrIGZvciBbXSA9PT0gW11cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0W3Byb3BdKSAmJiBBcnJheS5pc0FycmF5KHByb3RvdHlwZVtwcm9wXSlcbiAgICAgICAgICAmJiBvYmplY3RbcHJvcF0ubGVuZ3RoID09PSAwICYmIHByb3RvdHlwZVtwcm9wXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgb2JqZWN0W3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJyM8ZmFicmljLicgKyBjYXBpdGFsaXplKHRoaXMudHlwZSkgKyAnPic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgb2JqZWN0IHNjYWxlIGZhY3RvciBjb3VudGluZyBhbHNvIHRoZSBncm91cCBzY2FsaW5nXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qgd2l0aCBzY2FsZVggYW5kIHNjYWxlWSBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ2V0T2JqZWN0U2NhbGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBpZiB0aGUgb2JqZWN0IGlzIGEgdG9wIGxldmVsIG9uZSwgb24gdGhlIGNhbnZhcywgd2UgZ28gZm9yIHNpbXBsZSBhcml0bWV0aWNcbiAgICAgIC8vIG90aGVyd2lzZSB0aGUgY29tcGxleCBtZXRob2Qgd2l0aCBhbmdsZXMgd2lsbCByZXR1cm4gYXBwcm94aW1hdGlvbnMgYW5kIGRlY2ltYWxzXG4gICAgICAvLyBhbmQgd2lsbCBsaWtlbHkga2lsbCB0aGUgY2FjaGUgd2hlbiBub3QgbmVlZGVkXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFicmljanMvZmFicmljLmpzL2lzc3Vlcy83MTU3XG4gICAgICBpZiAoIXRoaXMuZ3JvdXApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzY2FsZVg6IHRoaXMuc2NhbGVYLFxuICAgICAgICAgIHNjYWxlWTogdGhpcy5zY2FsZVksXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICAvLyBpZiB3ZSBhcmUgaW5zaWRlIGEgZ3JvdXAgdG90YWwgem9vbSBjYWxjdWxhdGlvbiBpcyBjb21wbGV4LCB3ZSBkZWZlciB0byBnZW5lcmljIG1hdHJpY2VzXG4gICAgICB2YXIgb3B0aW9ucyA9IGZhYnJpYy51dGlsLnFyRGVjb21wb3NlKHRoaXMuY2FsY1RyYW5zZm9ybU1hdHJpeCgpKTtcbiAgICAgIHJldHVybiB7IHNjYWxlWDogTWF0aC5hYnMob3B0aW9ucy5zY2FsZVgpLCBzY2FsZVk6IE1hdGguYWJzKG9wdGlvbnMuc2NhbGVZKSB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG9iamVjdCBzY2FsZSBmYWN0b3IgY291bnRpbmcgYWxzbyB0aGUgZ3JvdXAgc2NhbGluZywgem9vbSBhbmQgcmV0aW5hXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3Qgd2l0aCBzY2FsZVggYW5kIHNjYWxlWSBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ2V0VG90YWxPYmplY3RTY2FsaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzY2FsZSA9IHRoaXMuZ2V0T2JqZWN0U2NhbGluZygpLCBzY2FsZVggPSBzY2FsZS5zY2FsZVgsIHNjYWxlWSA9IHNjYWxlLnNjYWxlWTtcbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB2YXIgem9vbSA9IHRoaXMuY2FudmFzLmdldFpvb20oKTtcbiAgICAgICAgdmFyIHJldGluYSA9IHRoaXMuY2FudmFzLmdldFJldGluYVNjYWxpbmcoKTtcbiAgICAgICAgc2NhbGVYICo9IHpvb20gKiByZXRpbmE7XG4gICAgICAgIHNjYWxlWSAqPSB6b29tICogcmV0aW5hO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgc2NhbGVYOiBzY2FsZVgsIHNjYWxlWTogc2NhbGVZIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgb2JqZWN0IG9wYWNpdHkgY291bnRpbmcgYWxzbyB0aGUgZ3JvdXAgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZ2V0T2JqZWN0T3BhY2l0eTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcbiAgICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICAgIG9wYWNpdHkgKj0gdGhpcy5ncm91cC5nZXRPYmplY3RPcGFjaXR5KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3BhY2l0eTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBfc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgc2hvdWxkQ29uc3RyYWluVmFsdWUgPSAoa2V5ID09PSAnc2NhbGVYJyB8fCBrZXkgPT09ICdzY2FsZVknKSxcbiAgICAgICAgICBpc0NoYW5nZWQgPSB0aGlzW2tleV0gIT09IHZhbHVlLCBncm91cE5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgIGlmIChzaG91bGRDb25zdHJhaW5WYWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuX2NvbnN0cmFpblNjYWxlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09ICdzY2FsZVgnICYmIHZhbHVlIDwgMCkge1xuICAgICAgICB0aGlzLmZsaXBYID0gIXRoaXMuZmxpcFg7XG4gICAgICAgIHZhbHVlICo9IC0xO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoa2V5ID09PSAnc2NhbGVZJyAmJiB2YWx1ZSA8IDApIHtcbiAgICAgICAgdGhpcy5mbGlwWSA9ICF0aGlzLmZsaXBZO1xuICAgICAgICB2YWx1ZSAqPSAtMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3NoYWRvdycgJiYgdmFsdWUgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIGZhYnJpYy5TaGFkb3cpKSB7XG4gICAgICAgIHZhbHVlID0gbmV3IGZhYnJpYy5TaGFkb3codmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoa2V5ID09PSAnZGlydHknICYmIHRoaXMuZ3JvdXApIHtcbiAgICAgICAgdGhpcy5ncm91cC5zZXQoJ2RpcnR5JywgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcblxuICAgICAgaWYgKGlzQ2hhbmdlZCkge1xuICAgICAgICBncm91cE5lZWRzVXBkYXRlID0gdGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwLmlzT25BQ2FjaGUoKTtcbiAgICAgICAgaWYgKHRoaXMuY2FjaGVQcm9wZXJ0aWVzLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgZ3JvdXBOZWVkc1VwZGF0ZSAmJiB0aGlzLmdyb3VwLnNldCgnZGlydHknLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChncm91cE5lZWRzVXBkYXRlICYmIHRoaXMuc3RhdGVQcm9wZXJ0aWVzLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgICAgdGhpcy5ncm91cC5zZXQoJ2RpcnR5JywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSB0aGUgcGFyZW50IGdyb3VwIG9mIGFuIG9iamVjdCBldmVyeVxuICAgICAqIHRpbWUgYSBub24tZGVsZWdhdGVkIHByb3BlcnR5IGNoYW5nZXMgb24gdGhlIGdyb3VwLiBJdCBpcyBwYXNzZWQgdGhlIGtleVxuICAgICAqIGFuZCB2YWx1ZSBhcyBwYXJhbWV0ZXJzLiBOb3QgYWRkaW5nIGluIHRoaXMgZnVuY3Rpb24ncyBzaWduYXR1cmUgdG8gYXZvaWRcbiAgICAgKiBUcmF2aXMgYnVpbGQgZXJyb3IgYWJvdXQgdW51c2VkIHZhcmlhYmxlcy5cbiAgICAgKi9cbiAgICBzZXRPbkdyb3VwOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGltcGxlbWVudGVkIGJ5IHN1Yi1jbGFzc2VzLCBhcyBuZWVkZWQuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB2aWV3cG9ydFRyYW5zZm9ybSBmcm9tIE9iamVjdCdzIGNhbnZhcyBpZiBwb3NzaWJsZVxuICAgICAqIEBtZXRob2QgZ2V0Vmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRWaWV3cG9ydFRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhYnJpYy5pTWF0cml4LmNvbmNhdCgpO1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogcmV0dXJuIGlmIHRoZSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpbiByZW5kZXJpbmdcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzTm90VmlzaWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcGFjaXR5ID09PSAwIHx8XG4gICAgICAgICghdGhpcy53aWR0aCAmJiAhdGhpcy5oZWlnaHQgJiYgdGhpcy5zdHJva2VXaWR0aCA9PT0gMCkgfHxcbiAgICAgICAgIXRoaXMudmlzaWJsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhbiBvYmplY3Qgb24gYSBzcGVjaWZpZWQgY29udGV4dFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgLy8gZG8gbm90IHJlbmRlciBpZiB3aWR0aC9oZWlnaHQgYXJlIHplcm9zIG9yIG9iamVjdCBpcyBub3QgdmlzaWJsZVxuICAgICAgaWYgKHRoaXMuaXNOb3RWaXNpYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnNraXBPZmZzY3JlZW4gJiYgIXRoaXMuZ3JvdXAgJiYgIXRoaXMuaXNPblNjcmVlbigpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0aGlzLl9zZXR1cENvbXBvc2l0ZU9wZXJhdGlvbihjdHgpO1xuICAgICAgdGhpcy5kcmF3U2VsZWN0aW9uQmFja2dyb3VuZChjdHgpO1xuICAgICAgdGhpcy50cmFuc2Zvcm0oY3R4KTtcbiAgICAgIHRoaXMuX3NldE9wYWNpdHkoY3R4KTtcbiAgICAgIHRoaXMuX3NldFNoYWRvdyhjdHgsIHRoaXMpO1xuICAgICAgaWYgKHRoaXMuc2hvdWxkQ2FjaGUoKSkge1xuICAgICAgICB0aGlzLnJlbmRlckNhY2hlKCk7XG4gICAgICAgIHRoaXMuZHJhd0NhY2hlT25DYW52YXMoY3R4KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9yZW1vdmVDYWNoZUNhbnZhcygpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZHJhd09iamVjdChjdHgpO1xuICAgICAgICBpZiAodGhpcy5vYmplY3RDYWNoaW5nICYmIHRoaXMuc3RhdGVmdWxsQ2FjaGUpIHtcbiAgICAgICAgICB0aGlzLnNhdmVTdGF0ZSh7IHByb3BlcnR5U2V0OiAnY2FjaGVQcm9wZXJ0aWVzJyB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyQ2FjaGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgaWYgKCF0aGlzLl9jYWNoZUNhbnZhcyB8fCAhdGhpcy5fY2FjaGVDb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUNhY2hlQ2FudmFzKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc0NhY2hlRGlydHkoKSkge1xuICAgICAgICB0aGlzLnN0YXRlZnVsbENhY2hlICYmIHRoaXMuc2F2ZVN0YXRlKHsgcHJvcGVydHlTZXQ6ICdjYWNoZVByb3BlcnRpZXMnIH0pO1xuICAgICAgICB0aGlzLmRyYXdPYmplY3QodGhpcy5fY2FjaGVDb250ZXh0LCBvcHRpb25zLmZvckNsaXBwaW5nKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgY2FjaGVDYW52YXMgYW5kIGl0cyBkaW1lbnNpb25zIGZyb20gdGhlIG9iamVjdHNcbiAgICAgKi9cbiAgICBfcmVtb3ZlQ2FjaGVDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY2FjaGVDYW52YXMgPSBudWxsO1xuICAgICAgdGhpcy5fY2FjaGVDb250ZXh0ID0gbnVsbDtcbiAgICAgIHRoaXMuY2FjaGVXaWR0aCA9IDA7XG4gICAgICB0aGlzLmNhY2hlSGVpZ2h0ID0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRydWUgaWYgdGhlIG9iamVjdCB3aWxsIGRyYXcgYSBzdHJva2VcbiAgICAgKiBEb2VzIG5vdCBjb25zaWRlciB0ZXh0IHN0eWxlcy4gVGhpcyBpcyBqdXN0IGEgc2hvcnRjdXQgdXNlZCBhdCByZW5kZXJpbmcgdGltZVxuICAgICAqIFdlIHdhbnQgaXQgdG8gYmUgYW4gYXBwcm94aW1hdGlvbiBhbmQgYmUgZmFzdC5cbiAgICAgKiB3cm90ZSB0byBhdm9pZCBleHRyYSBjYWNoaW5nLCBpdCBoYXMgdG8gcmV0dXJuIHRydWUgd2hlbiBzdHJva2UgaGFwcGVucyxcbiAgICAgKiBjYW4gZ3Vlc3Mgd2hlbiBpdCB3aWxsIG5vdCBoYXBwZW4gYXQgMTAwJSBjaGFuY2UsIGRvZXMgbm90IG1hdHRlciBpZiBpdCBtaXNzZXNcbiAgICAgKiBzb21lIHVzZSBjYXNlIHdoZXJlIHRoZSBzdHJva2UgaXMgaW52aXNpYmxlLlxuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEByZXR1cm5zIEJvb2xlYW5cbiAgICAgKi9cbiAgICBoYXNTdHJva2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3Ryb2tlICYmIHRoaXMuc3Ryb2tlICE9PSAndHJhbnNwYXJlbnQnICYmIHRoaXMuc3Ryb2tlV2lkdGggIT09IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0cnVlIGlmIHRoZSBvYmplY3Qgd2lsbCBkcmF3IGEgZmlsbFxuICAgICAqIERvZXMgbm90IGNvbnNpZGVyIHRleHQgc3R5bGVzLiBUaGlzIGlzIGp1c3QgYSBzaG9ydGN1dCB1c2VkIGF0IHJlbmRlcmluZyB0aW1lXG4gICAgICogV2Ugd2FudCBpdCB0byBiZSBhbiBhcHByb3hpbWF0aW9uIGFuZCBiZSBmYXN0LlxuICAgICAqIHdyb3RlIHRvIGF2b2lkIGV4dHJhIGNhY2hpbmcsIGl0IGhhcyB0byByZXR1cm4gdHJ1ZSB3aGVuIGZpbGwgaGFwcGVucyxcbiAgICAgKiBjYW4gZ3Vlc3Mgd2hlbiBpdCB3aWxsIG5vdCBoYXBwZW4gYXQgMTAwJSBjaGFuY2UsIGRvZXMgbm90IG1hdHRlciBpZiBpdCBtaXNzZXNcbiAgICAgKiBzb21lIHVzZSBjYXNlIHdoZXJlIHRoZSBmaWxsIGlzIGludmlzaWJsZS5cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAcmV0dXJucyBCb29sZWFuXG4gICAgICovXG4gICAgaGFzRmlsbDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWxsICYmIHRoaXMuZmlsbCAhPT0gJ3RyYW5zcGFyZW50JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzZXQgdG8gYHRydWVgLCBmb3JjZSB0aGUgb2JqZWN0IHRvIGhhdmUgaXRzIG93biBjYWNoZSwgZXZlbiBpZiBpdCBpcyBpbnNpZGUgYSBncm91cFxuICAgICAqIGl0IG1heSBiZSBuZWVkZWQgd2hlbiB5b3VyIG9iamVjdCBiZWhhdmUgaW4gYSBwYXJ0aWN1bGFyIHdheSBvbiB0aGUgY2FjaGUgYW5kIGFsd2F5cyBuZWVkc1xuICAgICAqIGl0cyBvd24gaXNvbGF0ZWQgY2FudmFzIHRvIHJlbmRlciBjb3JyZWN0bHkuXG4gICAgICogQ3JlYXRlZCB0byBiZSBvdmVycmlkZGVuXG4gICAgICogc2luY2UgMS43LjEyXG4gICAgICogQHJldHVybnMgQm9vbGVhblxuICAgICAqL1xuICAgIG5lZWRzSXRzT3duQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucGFpbnRGaXJzdCA9PT0gJ3N0cm9rZScgJiZcbiAgICAgICAgdGhpcy5oYXNGaWxsKCkgJiYgdGhpcy5oYXNTdHJva2UoKSAmJiB0eXBlb2YgdGhpcy5zaGFkb3cgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2xpcFBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY2lkZSBpZiB0aGUgb2JqZWN0IHNob3VsZCBjYWNoZSBvciBub3QuIENyZWF0ZSBpdHMgb3duIGNhY2hlIGxldmVsXG4gICAgICogb2JqZWN0Q2FjaGluZyBpcyBhIGdsb2JhbCBmbGFnLCB3aW5zIG92ZXIgZXZlcnl0aGluZ1xuICAgICAqIG5lZWRzSXRzT3duQ2FjaGUgc2hvdWxkIGJlIHVzZWQgd2hlbiB0aGUgb2JqZWN0IGRyYXdpbmcgbWV0aG9kIHJlcXVpcmVzXG4gICAgICogYSBjYWNoZSBzdGVwLiBOb25lIG9mIHRoZSBmYWJyaWMgY2xhc3NlcyByZXF1aXJlcyBpdC5cbiAgICAgKiBHZW5lcmFsbHkgeW91IGRvIG5vdCBjYWNoZSBvYmplY3RzIGluIGdyb3VwcyBiZWNhdXNlIHRoZSBncm91cCBvdXRzaWRlIGlzIGNhY2hlZC5cbiAgICAgKiBSZWFkIGFzOiBjYWNoZSBpZiBpcyBuZWVkZWQsIG9yIGlmIHRoZSBmZWF0dXJlIGlzIGVuYWJsZWQgYnV0IHdlIGFyZSBub3QgYWxyZWFkeSBjYWNoaW5nLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2hvdWxkQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5vd25DYWNoaW5nID0gdGhpcy5uZWVkc0l0c093bkNhY2hlKCkgfHwgKFxuICAgICAgICB0aGlzLm9iamVjdENhY2hpbmcgJiZcbiAgICAgICAgKCF0aGlzLmdyb3VwIHx8ICF0aGlzLmdyb3VwLmlzT25BQ2FjaGUoKSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gdGhpcy5vd25DYWNoaW5nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIG9iamVjdCBvciBhIGNoaWxkIG9iamVjdCB3aWxsIGNhc3QgYSBzaGFkb3dcbiAgICAgKiB1c2VkIGJ5IEdyb3VwLnNob3VsZENhY2hlIHRvIGtub3cgaWYgY2hpbGQgaGFzIGEgc2hhZG93IHJlY3Vyc2l2ZWx5XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB3aWxsRHJhd1NoYWRvdzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gISF0aGlzLnNoYWRvdyAmJiAodGhpcy5zaGFkb3cub2Zmc2V0WCAhPT0gMCB8fCB0aGlzLnNoYWRvdy5vZmZzZXRZICE9PSAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSB0aGUgZHJhd2luZyBvcGVyYXRpb24gZm9yIGFuIG9iamVjdCBjbGlwUGF0aFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGNsaXBQYXRoXG4gICAgICovXG4gICAgZHJhd0NsaXBQYXRoT25DYWNoZTogZnVuY3Rpb24oY3R4LCBjbGlwUGF0aCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIC8vIERFQlVHOiB1bmNvbW1lbnQgdGhpcyBsaW5lLCBjb21tZW50IHRoZSBmb2xsb3dpbmdcbiAgICAgIC8vIGN0eC5nbG9iYWxBbHBoYSA9IDAuNFxuICAgICAgaWYgKGNsaXBQYXRoLmludmVydGVkKSB7XG4gICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLWluJztcbiAgICAgIH1cbiAgICAgIC8vY3R4LnNjYWxlKDEgLyAyLCAxIC8gMik7XG4gICAgICBpZiAoY2xpcFBhdGguYWJzb2x1dGVQb3NpdGlvbmVkKSB7XG4gICAgICAgIHZhciBtID0gZmFicmljLnV0aWwuaW52ZXJ0VHJhbnNmb3JtKHRoaXMuY2FsY1RyYW5zZm9ybU1hdHJpeCgpKTtcbiAgICAgICAgY3R4LnRyYW5zZm9ybShtWzBdLCBtWzFdLCBtWzJdLCBtWzNdLCBtWzRdLCBtWzVdKTtcbiAgICAgIH1cbiAgICAgIGNsaXBQYXRoLnRyYW5zZm9ybShjdHgpO1xuICAgICAgY3R4LnNjYWxlKDEgLyBjbGlwUGF0aC56b29tWCwgMSAvIGNsaXBQYXRoLnpvb21ZKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoY2xpcFBhdGguX2NhY2hlQ2FudmFzLCAtY2xpcFBhdGguY2FjaGVUcmFuc2xhdGlvblgsIC1jbGlwUGF0aC5jYWNoZVRyYW5zbGF0aW9uWSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIHRoZSBkcmF3aW5nIG9wZXJhdGlvbiBmb3IgYW4gb2JqZWN0IG9uIGEgc3BlY2lmaWVkIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgZHJhd09iamVjdDogZnVuY3Rpb24oY3R4LCBmb3JDbGlwcGluZykge1xuICAgICAgdmFyIG9yaWdpbmFsRmlsbCA9IHRoaXMuZmlsbCwgb3JpZ2luYWxTdHJva2UgPSB0aGlzLnN0cm9rZTtcbiAgICAgIGlmIChmb3JDbGlwcGluZykge1xuICAgICAgICB0aGlzLmZpbGwgPSAnYmxhY2snO1xuICAgICAgICB0aGlzLnN0cm9rZSA9ICcnO1xuICAgICAgICB0aGlzLl9zZXRDbGlwcGluZ1Byb3BlcnRpZXMoY3R4KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9yZW5kZXJCYWNrZ3JvdW5kKGN0eCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZW5kZXIoY3R4KTtcbiAgICAgIHRoaXMuX2RyYXdDbGlwUGF0aChjdHgsIHRoaXMuY2xpcFBhdGgpO1xuICAgICAgdGhpcy5maWxsID0gb3JpZ2luYWxGaWxsO1xuICAgICAgdGhpcy5zdHJva2UgPSBvcmlnaW5hbFN0cm9rZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZSBjbGlwUGF0aCBzdGF0ZSBhbmQgY2FjaGUgYW5kIGRyYXcgaXQgb24gaW5zdGFuY2UncyBjYWNoZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IGNsaXBQYXRoXG4gICAgICovXG4gICAgX2RyYXdDbGlwUGF0aDogZnVuY3Rpb24gKGN0eCwgY2xpcFBhdGgpIHtcbiAgICAgIGlmICghY2xpcFBhdGgpIHsgcmV0dXJuOyB9XG4gICAgICAvLyBuZWVkZWQgdG8gc2V0dXAgYSBjb3VwbGUgb2YgdmFyaWFibGVzXG4gICAgICAvLyBwYXRoIGNhbnZhcyBnZXRzIG92ZXJyaWRkZW4gd2l0aCB0aGlzIG9uZS5cbiAgICAgIC8vIFRPRE8gZmluZCBhIGJldHRlciBzb2x1dGlvbj9cbiAgICAgIGNsaXBQYXRoLmNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgY2xpcFBhdGguc2hvdWxkQ2FjaGUoKTtcbiAgICAgIGNsaXBQYXRoLl90cmFuc2Zvcm1Eb25lID0gdHJ1ZTtcbiAgICAgIGNsaXBQYXRoLnJlbmRlckNhY2hlKHsgZm9yQ2xpcHBpbmc6IHRydWUgfSk7XG4gICAgICB0aGlzLmRyYXdDbGlwUGF0aE9uQ2FjaGUoY3R4LCBjbGlwUGF0aCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhaW50IHRoZSBjYWNoZWQgY29weSBvZiB0aGUgb2JqZWN0IG9uIHRoZSB0YXJnZXQgY29udGV4dC5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgZHJhd0NhY2hlT25DYW52YXM6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgY3R4LnNjYWxlKDEgLyB0aGlzLnpvb21YLCAxIC8gdGhpcy56b29tWSk7XG4gICAgICBjdHguZHJhd0ltYWdlKHRoaXMuX2NhY2hlQ2FudmFzLCAtdGhpcy5jYWNoZVRyYW5zbGF0aW9uWCwgLXRoaXMuY2FjaGVUcmFuc2xhdGlvblkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBjYWNoZSBpcyBkaXJ0eVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcENhbnZhcyBza2lwIGNhbnZhcyBjaGVja3MgYmVjYXVzZSB0aGlzIG9iamVjdCBpcyBwYWludGVkXG4gICAgICogb24gcGFyZW50IGNhbnZhcy5cbiAgICAgKi9cbiAgICBpc0NhY2hlRGlydHk6IGZ1bmN0aW9uKHNraXBDYW52YXMpIHtcbiAgICAgIGlmICh0aGlzLmlzTm90VmlzaWJsZSgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9jYWNoZUNhbnZhcyAmJiB0aGlzLl9jYWNoZUNvbnRleHQgJiYgIXNraXBDYW52YXMgJiYgdGhpcy5fdXBkYXRlQ2FjaGVDYW52YXMoKSkge1xuICAgICAgICAvLyBpbiB0aGlzIGNhc2UgdGhlIGNvbnRleHQgaXMgYWxyZWFkeSBjbGVhcmVkLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSB8fFxuICAgICAgICAgICh0aGlzLmNsaXBQYXRoICYmIHRoaXMuY2xpcFBhdGguYWJzb2x1dGVQb3NpdGlvbmVkKSB8fFxuICAgICAgICAgICh0aGlzLnN0YXRlZnVsbENhY2hlICYmIHRoaXMuaGFzU3RhdGVDaGFuZ2VkKCdjYWNoZVByb3BlcnRpZXMnKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2NhY2hlQ2FudmFzICYmIHRoaXMuX2NhY2hlQ29udGV4dCAmJiAhc2tpcENhbnZhcykge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5jYWNoZVdpZHRoIC8gdGhpcy56b29tWDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmNhY2hlSGVpZ2h0IC8gdGhpcy56b29tWTtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlQ29udGV4dC5jbGVhclJlY3QoLXdpZHRoIC8gMiwgLWhlaWdodCAvIDIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIGJhY2tncm91bmQgZm9yIHRoZSBvYmplY3QgYmlnIGFzIGl0cyB1bnRyYW5zZm9ybWVkIGRpbWVuc2lvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyQmFja2dyb3VuZDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBkaW0gPSB0aGlzLl9nZXROb25UcmFuc2Zvcm1lZERpbWVuc2lvbnMoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmJhY2tncm91bmRDb2xvcjtcblxuICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAtZGltLnggLyAyLFxuICAgICAgICAtZGltLnkgLyAyLFxuICAgICAgICBkaW0ueCxcbiAgICAgICAgZGltLnlcbiAgICAgICk7XG4gICAgICAvLyBpZiB0aGVyZSBpcyBiYWNrZ3JvdW5kIGNvbG9yIG5vIG90aGVyIHNoYWRvd3NcbiAgICAgIC8vIHNob3VsZCBiZSBjYXN0ZWRcbiAgICAgIHRoaXMuX3JlbW92ZVNoYWRvdyhjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfc2V0T3BhY2l0eTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAodGhpcy5ncm91cCAmJiAhdGhpcy5ncm91cC5fdHJhbnNmb3JtRG9uZSkge1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmdldE9iamVjdE9wYWNpdHkoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgKj0gdGhpcy5vcGFjaXR5O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfc2V0U3Ryb2tlU3R5bGVzOiBmdW5jdGlvbihjdHgsIGRlY2wpIHtcbiAgICAgIHZhciBzdHJva2UgPSBkZWNsLnN0cm9rZTtcbiAgICAgIGlmIChzdHJva2UpIHtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGRlY2wuc3Ryb2tlV2lkdGg7XG4gICAgICAgIGN0eC5saW5lQ2FwID0gZGVjbC5zdHJva2VMaW5lQ2FwO1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBkZWNsLnN0cm9rZURhc2hPZmZzZXQ7XG4gICAgICAgIGN0eC5saW5lSm9pbiA9IGRlY2wuc3Ryb2tlTGluZUpvaW47XG4gICAgICAgIGN0eC5taXRlckxpbWl0ID0gZGVjbC5zdHJva2VNaXRlckxpbWl0O1xuICAgICAgICBpZiAoc3Ryb2tlLnRvTGl2ZSkge1xuICAgICAgICAgIGlmIChzdHJva2UuZ3JhZGllbnRVbml0cyA9PT0gJ3BlcmNlbnRhZ2UnIHx8IHN0cm9rZS5ncmFkaWVudFRyYW5zZm9ybSB8fCBzdHJva2UucGF0dGVyblRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLy8gbmVlZCB0byB0cmFuc2Zvcm0gZ3JhZGllbnQgaW4gYSBwYXR0ZXJuLlxuICAgICAgICAgICAgLy8gdGhpcyBpcyBhIHNsb3cgcHJvY2Vzcy4gSWYgeW91IGFyZSBoaXR0aW5nIHRoaXMgY29kZXBhdGgsIGFuZCB0aGUgb2JqZWN0XG4gICAgICAgICAgICAvLyBpcyBub3QgdXNpbmcgY2FjaGluZywgeW91IHNob3VsZCBjb25zaWRlciBzd2l0Y2hpbmcgaXQgb24uXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIGEgY2FudmFzIGFzIGJpZyBhcyB0aGUgY3VycmVudCBvYmplY3QgY2FjaGluZyBjYW52YXMuXG4gICAgICAgICAgICB0aGlzLl9hcHBseVBhdHRlcm5Gb3JUcmFuc2Zvcm1lZEdyYWRpZW50KGN0eCwgc3Ryb2tlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpcyBhIHNpbXBsZSBncmFkaWVudCBvciBwYXR0ZXJuXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2UudG9MaXZlKGN0eCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9hcHBseVBhdHRlcm5HcmFkaWVudFRyYW5zZm9ybShjdHgsIHN0cm9rZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIGlzIGEgY29sb3JcbiAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBkZWNsLnN0cm9rZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBfc2V0RmlsbFN0eWxlczogZnVuY3Rpb24oY3R4LCBkZWNsKSB7XG4gICAgICB2YXIgZmlsbCA9IGRlY2wuZmlsbDtcbiAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgIGlmIChmaWxsLnRvTGl2ZSkge1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsLnRvTGl2ZShjdHgsIHRoaXMpO1xuICAgICAgICAgIHRoaXMuX2FwcGx5UGF0dGVybkdyYWRpZW50VHJhbnNmb3JtKGN0eCwgZGVjbC5maWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBfc2V0Q2xpcHBpbmdQcm9wZXJ0aWVzOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSAndHJhbnNwYXJlbnQnO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICcjMDAwMDAwJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBTZXRzIGxpbmUgZGFzaFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBzZXQgdGhlIGRhc2ggbGluZSBvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRhc2hBcnJheSBhcnJheSByZXByZXNlbnRpbmcgZGFzaGVzXG4gICAgICovXG4gICAgX3NldExpbmVEYXNoOiBmdW5jdGlvbihjdHgsIGRhc2hBcnJheSkge1xuICAgICAgaWYgKCFkYXNoQXJyYXkgfHwgZGFzaEFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBTcGVjIHJlcXVpcmVzIHRoZSBjb25jYXRlbmF0aW9uIG9mIHR3byBjb3BpZXMgdGhlIGRhc2ggbGlzdCB3aGVuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaXMgb2RkXG4gICAgICBpZiAoMSAmIGRhc2hBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgZGFzaEFycmF5LnB1c2guYXBwbHkoZGFzaEFycmF5LCBkYXNoQXJyYXkpO1xuICAgICAgfVxuICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hBcnJheSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgY29udHJvbHMgYW5kIGJvcmRlcnMgZm9yIHRoZSBvYmplY3RcbiAgICAgKiB0aGUgY29udGV4dCBoZXJlIGlzIG5vdCB0cmFuc2Zvcm1lZFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0eWxlT3ZlcnJpZGVdIHByb3BlcnRpZXMgdG8gb3ZlcnJpZGUgdGhlIG9iamVjdCBzdHlsZVxuICAgICAqL1xuICAgIF9yZW5kZXJDb250cm9sczogZnVuY3Rpb24oY3R4LCBzdHlsZU92ZXJyaWRlKSB7XG4gICAgICB2YXIgdnB0ID0gdGhpcy5nZXRWaWV3cG9ydFRyYW5zZm9ybSgpLFxuICAgICAgICAgIG1hdHJpeCA9IHRoaXMuY2FsY1RyYW5zZm9ybU1hdHJpeCgpLFxuICAgICAgICAgIG9wdGlvbnMsIGRyYXdCb3JkZXJzLCBkcmF3Q29udHJvbHM7XG4gICAgICBzdHlsZU92ZXJyaWRlID0gc3R5bGVPdmVycmlkZSB8fCB7IH07XG4gICAgICBkcmF3Qm9yZGVycyA9IHR5cGVvZiBzdHlsZU92ZXJyaWRlLmhhc0JvcmRlcnMgIT09ICd1bmRlZmluZWQnID8gc3R5bGVPdmVycmlkZS5oYXNCb3JkZXJzIDogdGhpcy5oYXNCb3JkZXJzO1xuICAgICAgZHJhd0NvbnRyb2xzID0gdHlwZW9mIHN0eWxlT3ZlcnJpZGUuaGFzQ29udHJvbHMgIT09ICd1bmRlZmluZWQnID8gc3R5bGVPdmVycmlkZS5oYXNDb250cm9scyA6IHRoaXMuaGFzQ29udHJvbHM7XG4gICAgICBtYXRyaXggPSBmYWJyaWMudXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzKHZwdCwgbWF0cml4KTtcbiAgICAgIG9wdGlvbnMgPSBmYWJyaWMudXRpbC5xckRlY29tcG9zZShtYXRyaXgpO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUob3B0aW9ucy50cmFuc2xhdGVYLCBvcHRpb25zLnRyYW5zbGF0ZVkpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IDEgKiB0aGlzLmJvcmRlclNjYWxlRmFjdG9yO1xuICAgICAgaWYgKCF0aGlzLmdyb3VwKSB7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuaXNNb3ZpbmcgPyB0aGlzLmJvcmRlck9wYWNpdHlXaGVuTW92aW5nIDogMTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmZsaXBYKSB7XG4gICAgICAgIG9wdGlvbnMuYW5nbGUgLT0gMTgwO1xuICAgICAgfVxuICAgICAgY3R4LnJvdGF0ZShkZWdyZWVzVG9SYWRpYW5zKHRoaXMuZ3JvdXAgPyBvcHRpb25zLmFuZ2xlIDogdGhpcy5hbmdsZSkpO1xuICAgICAgaWYgKHN0eWxlT3ZlcnJpZGUuZm9yQWN0aXZlU2VsZWN0aW9uIHx8IHRoaXMuZ3JvdXApIHtcbiAgICAgICAgZHJhd0JvcmRlcnMgJiYgdGhpcy5kcmF3Qm9yZGVyc0luR3JvdXAoY3R4LCBvcHRpb25zLCBzdHlsZU92ZXJyaWRlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBkcmF3Qm9yZGVycyAmJiB0aGlzLmRyYXdCb3JkZXJzKGN0eCwgc3R5bGVPdmVycmlkZSk7XG4gICAgICB9XG4gICAgICBkcmF3Q29udHJvbHMgJiYgdGhpcy5kcmF3Q29udHJvbHMoY3R4LCBzdHlsZU92ZXJyaWRlKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9zZXRTaGFkb3c6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLnNoYWRvdykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzaGFkb3cgPSB0aGlzLnNoYWRvdywgY2FudmFzID0gdGhpcy5jYW52YXMsIHNjYWxpbmcsXG4gICAgICAgICAgbXVsdFggPSAoY2FudmFzICYmIGNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybVswXSkgfHwgMSxcbiAgICAgICAgICBtdWx0WSA9IChjYW52YXMgJiYgY2FudmFzLnZpZXdwb3J0VHJhbnNmb3JtWzNdKSB8fCAxO1xuICAgICAgaWYgKHNoYWRvdy5ub25TY2FsaW5nKSB7XG4gICAgICAgIHNjYWxpbmcgPSB7IHNjYWxlWDogMSwgc2NhbGVZOiAxIH07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2NhbGluZyA9IHRoaXMuZ2V0T2JqZWN0U2NhbGluZygpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbnZhcyAmJiBjYW52YXMuX2lzUmV0aW5hU2NhbGluZygpKSB7XG4gICAgICAgIG11bHRYICo9IGZhYnJpYy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICBtdWx0WSAqPSBmYWJyaWMuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgIH1cbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHNoYWRvdy5jb2xvcjtcbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gc2hhZG93LmJsdXIgKiBmYWJyaWMuYnJvd3NlclNoYWRvd0JsdXJDb25zdGFudCAqXG4gICAgICAgIChtdWx0WCArIG11bHRZKSAqIChzY2FsaW5nLnNjYWxlWCArIHNjYWxpbmcuc2NhbGVZKSAvIDQ7XG4gICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IHNoYWRvdy5vZmZzZXRYICogbXVsdFggKiBzY2FsaW5nLnNjYWxlWDtcbiAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gc2hhZG93Lm9mZnNldFkgKiBtdWx0WSAqIHNjYWxpbmcuc2NhbGVZO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVtb3ZlU2hhZG93OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5zaGFkb3cpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjdHguc2hhZG93Q29sb3IgPSAnJztcbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gY3R4LnNoYWRvd09mZnNldFggPSBjdHguc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmaWxsZXIgZmFicmljLlBhdHRlcm4gb3IgZmFicmljLkdyYWRpZW50XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvZmZzZXQub2Zmc2V0WCBvZmZzZXQgZm9yIHRleHQgcmVuZGVyaW5nXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvZmZzZXQub2Zmc2V0WSBvZmZzZXQgZm9yIHRleHQgcmVuZGVyaW5nXG4gICAgICovXG4gICAgX2FwcGx5UGF0dGVybkdyYWRpZW50VHJhbnNmb3JtOiBmdW5jdGlvbihjdHgsIGZpbGxlcikge1xuICAgICAgaWYgKCFmaWxsZXIgfHwgIWZpbGxlci50b0xpdmUpIHtcbiAgICAgICAgcmV0dXJuIHsgb2Zmc2V0WDogMCwgb2Zmc2V0WTogMCB9O1xuICAgICAgfVxuICAgICAgdmFyIHQgPSBmaWxsZXIuZ3JhZGllbnRUcmFuc2Zvcm0gfHwgZmlsbGVyLnBhdHRlcm5UcmFuc2Zvcm07XG4gICAgICB2YXIgb2Zmc2V0WCA9IC10aGlzLndpZHRoIC8gMiArIGZpbGxlci5vZmZzZXRYIHx8IDAsXG4gICAgICAgICAgb2Zmc2V0WSA9IC10aGlzLmhlaWdodCAvIDIgKyBmaWxsZXIub2Zmc2V0WSB8fCAwO1xuXG4gICAgICBpZiAoZmlsbGVyLmdyYWRpZW50VW5pdHMgPT09ICdwZXJjZW50YWdlJykge1xuICAgICAgICBjdHgudHJhbnNmb3JtKHRoaXMud2lkdGgsIDAsIDAsIHRoaXMuaGVpZ2h0LCBvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjdHgudHJhbnNmb3JtKDEsIDAsIDAsIDEsIG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgfVxuICAgICAgaWYgKHQpIHtcbiAgICAgICAgY3R4LnRyYW5zZm9ybSh0WzBdLCB0WzFdLCB0WzJdLCB0WzNdLCB0WzRdLCB0WzVdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG9mZnNldFg6IG9mZnNldFgsIG9mZnNldFk6IG9mZnNldFkgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlclBhaW50SW5PcmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAodGhpcy5wYWludEZpcnN0ID09PSAnc3Ryb2tlJykge1xuICAgICAgICB0aGlzLl9yZW5kZXJTdHJva2UoY3R4KTtcbiAgICAgICAgdGhpcy5fcmVuZGVyRmlsbChjdHgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlbmRlckZpbGwoY3R4KTtcbiAgICAgICAgdGhpcy5fcmVuZGVyU3Ryb2tlKGN0eCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogZnVuY3Rpb24gdGhhdCBhY3R1YWxseSByZW5kZXIgc29tZXRoaW5nIG9uIHRoZSBjb250ZXh0LlxuICAgICAqIGVtcHR5IGhlcmUgdG8gYWxsb3cgT2JlY3RzIHRvIHdvcmsgb24gdGVzdHMgdG8gYmVuY2htYXJrIGZhYnJpYyBmdW5jdGlvbmFsaXRlc1xuICAgICAqIG5vdCByZWxhdGVkIHRvIHJlbmRlcmluZ1xuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbigvKiBjdHggKi8pIHtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyRmlsbDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuZmlsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0aGlzLl9zZXRGaWxsU3R5bGVzKGN0eCwgdGhpcyk7XG4gICAgICBpZiAodGhpcy5maWxsUnVsZSA9PT0gJ2V2ZW5vZGQnKSB7XG4gICAgICAgIGN0eC5maWxsKCdldmVub2RkJyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJTdHJva2U6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKCF0aGlzLnN0cm9rZSB8fCB0aGlzLnN0cm9rZVdpZHRoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2hhZG93ICYmICF0aGlzLnNoYWRvdy5hZmZlY3RTdHJva2UpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlU2hhZG93KGN0eCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBpZiAodGhpcy5zdHJva2VVbmlmb3JtICYmIHRoaXMuZ3JvdXApIHtcbiAgICAgICAgdmFyIHNjYWxpbmcgPSB0aGlzLmdldE9iamVjdFNjYWxpbmcoKTtcbiAgICAgICAgY3R4LnNjYWxlKDEgLyBzY2FsaW5nLnNjYWxlWCwgMSAvIHNjYWxpbmcuc2NhbGVZKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMuc3Ryb2tlVW5pZm9ybSkge1xuICAgICAgICBjdHguc2NhbGUoMSAvIHRoaXMuc2NhbGVYLCAxIC8gdGhpcy5zY2FsZVkpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0TGluZURhc2goY3R4LCB0aGlzLnN0cm9rZURhc2hBcnJheSk7XG4gICAgICB0aGlzLl9zZXRTdHJva2VTdHlsZXMoY3R4LCB0aGlzKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gdHJ5IHRvIHBhdGNoIHRoZSBtaXNzaW5nIGdyYWRpZW50VHJhbnNmb3JtIG9uIGNhbnZhcyBncmFkaWVudHMuXG4gICAgICogdHJhbnNmb3JtaW5nIGEgY29udGV4dCB0byB0cmFuc2Zvcm0gdGhlIGdyYWRpZW50LCBpcyBnb2luZyB0byB0cmFuc2Zvcm0gdGhlIHN0cm9rZSB0b28uXG4gICAgICogd2Ugd2FudCB0byB0cmFuc2Zvcm0gdGhlIGdyYWRpZW50IGJ1dCBub3QgdGhlIHN0cm9rZSBvcGVyYXRpb24sIHNvIHdlIGNyZWF0ZVxuICAgICAqIGEgdHJhbnNmb3JtZWQgZ3JhZGllbnQgb24gYSBwYXR0ZXJuIGFuZCB0aGVuIHdlIHVzZSB0aGUgcGF0dGVybiBpbnN0ZWFkIG9mIHRoZSBncmFkaWVudC5cbiAgICAgKiB0aGlzIG1ldGhvZCBoYXMgZHJ3YWJhY2tzOiBpcyBzbG93LCBpcyBpbiBsb3cgcmVzb2x1dGlvbiwgbmVlZHMgYSBwYXRjaCBmb3Igd2hlbiB0aGUgc2l6ZVxuICAgICAqIGlzIGxpbWl0ZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtmYWJyaWMuR3JhZGllbnR9IGZpbGxlciBhIGZhYnJpYyBncmFkaWVudCBpbnN0YW5jZVxuICAgICAqL1xuICAgIF9hcHBseVBhdHRlcm5Gb3JUcmFuc2Zvcm1lZEdyYWRpZW50OiBmdW5jdGlvbihjdHgsIGZpbGxlcikge1xuICAgICAgdmFyIGRpbXMgPSB0aGlzLl9saW1pdENhY2hlU2l6ZSh0aGlzLl9nZXRDYWNoZUNhbnZhc0RpbWVuc2lvbnMoKSksXG4gICAgICAgICAgcENhbnZhcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKSwgcEN0eCwgcmV0aW5hU2NhbGluZyA9IHRoaXMuY2FudmFzLmdldFJldGluYVNjYWxpbmcoKSxcbiAgICAgICAgICB3aWR0aCA9IGRpbXMueCAvIHRoaXMuc2NhbGVYIC8gcmV0aW5hU2NhbGluZywgaGVpZ2h0ID0gZGltcy55IC8gdGhpcy5zY2FsZVkgLyByZXRpbmFTY2FsaW5nO1xuICAgICAgcENhbnZhcy53aWR0aCA9IE1hdGguY2VpbCh3aWR0aCk7XG4gICAgICBwQ2FudmFzLmhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQpO1xuICAgICAgcEN0eCA9IHBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIHBDdHguYmVnaW5QYXRoKCk7IHBDdHgubW92ZVRvKDAsIDApOyBwQ3R4LmxpbmVUbyh3aWR0aCwgMCk7IHBDdHgubGluZVRvKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgcEN0eC5saW5lVG8oMCwgaGVpZ2h0KTsgcEN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIHBDdHgudHJhbnNsYXRlKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gICAgICBwQ3R4LnNjYWxlKFxuICAgICAgICBkaW1zLnpvb21YIC8gdGhpcy5zY2FsZVggLyByZXRpbmFTY2FsaW5nLFxuICAgICAgICBkaW1zLnpvb21ZIC8gdGhpcy5zY2FsZVkgLyByZXRpbmFTY2FsaW5nXG4gICAgICApO1xuICAgICAgdGhpcy5fYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm0ocEN0eCwgZmlsbGVyKTtcbiAgICAgIHBDdHguZmlsbFN0eWxlID0gZmlsbGVyLnRvTGl2ZShjdHgpO1xuICAgICAgcEN0eC5maWxsKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKC10aGlzLndpZHRoIC8gMiAtIHRoaXMuc3Ryb2tlV2lkdGggLyAyLCAtdGhpcy5oZWlnaHQgLyAyIC0gdGhpcy5zdHJva2VXaWR0aCAvIDIpO1xuICAgICAgY3R4LnNjYWxlKFxuICAgICAgICByZXRpbmFTY2FsaW5nICogdGhpcy5zY2FsZVggLyBkaW1zLnpvb21YLFxuICAgICAgICByZXRpbmFTY2FsaW5nICogdGhpcy5zY2FsZVkgLyBkaW1zLnpvb21ZXG4gICAgICApO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gcEN0eC5jcmVhdGVQYXR0ZXJuKHBDYW52YXMsICduby1yZXBlYXQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBhbiBoZWxwZXIgZm9yIHN2ZyBpbXBvcnQuIGl0IHJldHVybnMgdGhlIGNlbnRlciBvZiB0aGUgb2JqZWN0IGluIHRoZSBzdmdcbiAgICAgKiB1bnRyYW5zZm9ybWVkIGNvb3JkaW5hdGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGNlbnRlciBwb2ludCBmcm9tIGVsZW1lbnQgY29vcmRpbmF0ZXNcbiAgICAgKi9cbiAgICBfZmluZENlbnRlckZyb21FbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7IHg6IHRoaXMubGVmdCArIHRoaXMud2lkdGggLyAyLCB5OiB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0IC8gMiB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGFuIGhlbHBlciBmb3Igc3ZnIGltcG9ydC4gaXQgZGVjb21wb3NlIHRoZSB0cmFuc2Zvcm1NYXRyaXhcbiAgICAgKiBhbmQgYXNzaWduIHByb3BlcnRpZXMgdG8gb2JqZWN0LlxuICAgICAqIHVudHJhbnNmb3JtZWQgY29vcmRpbmF0ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBfYXNzaWduVHJhbnNmb3JtTWF0cml4UHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMudHJhbnNmb3JtTWF0cml4KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gZmFicmljLnV0aWwucXJEZWNvbXBvc2UodGhpcy50cmFuc2Zvcm1NYXRyaXgpO1xuICAgICAgICB0aGlzLmZsaXBYID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZmxpcFkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZXQoJ3NjYWxlWCcsIG9wdGlvbnMuc2NhbGVYKTtcbiAgICAgICAgdGhpcy5zZXQoJ3NjYWxlWScsIG9wdGlvbnMuc2NhbGVZKTtcbiAgICAgICAgdGhpcy5hbmdsZSA9IG9wdGlvbnMuYW5nbGU7XG4gICAgICAgIHRoaXMuc2tld1ggPSBvcHRpb25zLnNrZXdYO1xuICAgICAgICB0aGlzLnNrZXdZID0gMDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBhbiBoZWxwZXIgZm9yIHN2ZyBpbXBvcnQuIGl0IHJlbW92ZXMgdGhlIHRyYW5zZm9ybSBtYXRyaXhcbiAgICAgKiBhbmQgc2V0IHRvIG9iamVjdCBwcm9wZXJ0aWVzIHRoYXQgZmFicmljanMgY2FuIGhhbmRsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zXG4gICAgICogQHJldHVybiB7dGhpc0FyZ31cbiAgICAgKi9cbiAgICBfcmVtb3ZlVHJhbnNmb3JtTWF0cml4OiBmdW5jdGlvbihwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucykge1xuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuX2ZpbmRDZW50ZXJGcm9tRWxlbWVudCgpO1xuICAgICAgaWYgKHRoaXMudHJhbnNmb3JtTWF0cml4KSB7XG4gICAgICAgIHRoaXMuX2Fzc2lnblRyYW5zZm9ybU1hdHJpeFByb3BzKCk7XG4gICAgICAgIGNlbnRlciA9IGZhYnJpYy51dGlsLnRyYW5zZm9ybVBvaW50KGNlbnRlciwgdGhpcy50cmFuc2Zvcm1NYXRyaXgpO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFuc2Zvcm1NYXRyaXggPSBudWxsO1xuICAgICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc2NhbGVYICo9IHByZXNlcnZlQXNwZWN0UmF0aW9PcHRpb25zLnNjYWxlWDtcbiAgICAgICAgdGhpcy5zY2FsZVkgKj0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMuc2NhbGVZO1xuICAgICAgICB0aGlzLmNyb3BYID0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMuY3JvcFg7XG4gICAgICAgIHRoaXMuY3JvcFkgPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvT3B0aW9ucy5jcm9wWTtcbiAgICAgICAgY2VudGVyLnggKz0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMub2Zmc2V0TGVmdDtcbiAgICAgICAgY2VudGVyLnkgKz0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMub2Zmc2V0VG9wO1xuICAgICAgICB0aGlzLndpZHRoID0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMud2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gcHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMuaGVpZ2h0O1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRQb3NpdGlvbkJ5T3JpZ2luKGNlbnRlciwgJ2NlbnRlcicsICdjZW50ZXInKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xvbmVzIGFuIGluc3RhbmNlLCB1c2luZyBhIGNhbGxiYWNrIG1ldGhvZCB3aWxsIHdvcmsgZm9yIGV2ZXJ5IG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBpcyBpbnZva2VkIHdpdGggYSBjbG9uZSBhcyBhIGZpcnN0IGFyZ3VtZW50XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbihjYWxsYmFjaywgcHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG9iamVjdEZvcm0gPSB0aGlzLnRvT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuZnJvbU9iamVjdCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLmZyb21PYmplY3Qob2JqZWN0Rm9ybSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ09iamVjdCcsIG9iamVjdEZvcm0sIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2Ugb3V0IG9mIGFuIG9iamVjdFxuICAgICAqIG1ha2VzIHVzZSBvZiB0b0NhbnZhc0VsZW1lbnQuXG4gICAgICogT25jZSB0aGlzIG1ldGhvZCB3YXMgYmFzZWQgb24gdG9EYXRhVXJsIGFuZCBsb2FkSW1hZ2UsIHNvIGl0IGFsc28gaGFkIGEgcXVhbGl0eVxuICAgICAqIGFuZCBmb3JtYXQgb3B0aW9uLiB0b0NhbnZhc0VsZW1lbnQgaXMgZmFzdGVyIGFuZCBwcm9kdWNlIG5vIGxvc3Mgb2YgcXVhbGl0eS5cbiAgICAgKiBJZiB5b3UgbmVlZCB0byBnZXQgYSByZWFsIEpwZWcgb3IgUG5nIGZyb20gYW4gb2JqZWN0LCB1c2luZyB0b0RhdGFVUkwgaXMgdGhlIHJpZ2h0IHdheSB0byBkbyBpdC5cbiAgICAgKiB0b0NhbnZhc0VsZW1lbnQgYW5kIHRoZW4gdG9CbG9iIGZyb20gdGhlIG9idGFpbmVkIGNhbnZhcyBpcyBhbHNvIGEgZ29vZCBvcHRpb24uXG4gICAgICogVGhpcyBtZXRob2QgaXMgc3luYyBub3csIGJ1dCBzdGlsbCBzdXBwb3J0IHRoZSBjYWxsYmFjayBiZWNhdXNlIHdlIGRpZCBub3Qgd2FudCB0byBicmVhay5cbiAgICAgKiBXaGVuIGZhYnJpY0pTIDUuMCB3aWxsIGJlIHBsYW5uZWQsIHRoaXMgd2lsbCBwcm9iYWJseSBiZSBjaGFuZ2VkIHRvIG5vdCBoYXZlIGEgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2ssIGludm9rZWQgd2l0aCBhbiBpbnN0YW5jZSBhcyBhIGZpcnN0IGFyZ3VtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBmb3IgY2xvbmUgYXMgaW1hZ2UsIHBhc3NlZCB0byB0b0RhdGFVUkxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubXVsdGlwbGllcj0xXSBNdWx0aXBsaWVyIHRvIHNjYWxlIGJ5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxlZnRdIENyb3BwaW5nIGxlZnQgb2Zmc2V0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudG9wXSBDcm9wcGluZyB0b3Agb2Zmc2V0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud2lkdGhdIENyb3BwaW5nIHdpZHRoLiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVpZ2h0XSBDcm9wcGluZyBoZWlnaHQuIEludHJvZHVjZWQgaW4gdjEuMi4xNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZW5hYmxlUmV0aW5hU2NhbGluZ10gRW5hYmxlIHJldGluYSBzY2FsaW5nIGZvciBjbG9uZSBpbWFnZS4gSW50cm9kdWNlIGluIDEuNi40XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53aXRob3V0VHJhbnNmb3JtXSBSZW1vdmUgY3VycmVudCBvYmplY3QgdHJhbnNmb3JtICggbm8gc2NhbGUgLCBubyBhbmdsZSwgbm8gZmxpcCwgbm8gc2tldyApLiBJbnRyb2R1Y2VkIGluIDIuMy40XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy53aXRob3V0U2hhZG93XSBSZW1vdmUgY3VycmVudCBvYmplY3Qgc2hhZG93LiBJbnRyb2R1Y2VkIGluIDIuNC4yXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGNsb25lQXNJbWFnZTogZnVuY3Rpb24oY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIHZhciBjYW52YXNFbCA9IHRoaXMudG9DYW52YXNFbGVtZW50KG9wdGlvbnMpO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKG5ldyBmYWJyaWMuSW1hZ2UoY2FudmFzRWwpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIEhUTUxDYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm11bHRpcGxpZXI9MV0gTXVsdGlwbGllciB0byBzY2FsZSBieVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sZWZ0XSBDcm9wcGluZyBsZWZ0IG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRvcF0gQ3JvcHBpbmcgdG9wIG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoXSBDcm9wcGluZyB3aWR0aC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gQ3JvcHBpbmcgaGVpZ2h0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZVJldGluYVNjYWxpbmddIEVuYWJsZSByZXRpbmEgc2NhbGluZyBmb3IgY2xvbmUgaW1hZ2UuIEludHJvZHVjZSBpbiAxLjYuNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2l0aG91dFRyYW5zZm9ybV0gUmVtb3ZlIGN1cnJlbnQgb2JqZWN0IHRyYW5zZm9ybSAoIG5vIHNjYWxlICwgbm8gYW5nbGUsIG5vIGZsaXAsIG5vIHNrZXcgKS4gSW50cm9kdWNlZCBpbiAyLjMuNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2l0aG91dFNoYWRvd10gUmVtb3ZlIGN1cnJlbnQgb2JqZWN0IHNoYWRvdy4gSW50cm9kdWNlZCBpbiAyLjQuMlxuICAgICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBSZXR1cm5zIERPTSBlbGVtZW50IDxjYW52YXM+IHdpdGggdGhlIGZhYnJpYy5PYmplY3RcbiAgICAgKi9cbiAgICB0b0NhbnZhc0VsZW1lbnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7IH0pO1xuXG4gICAgICB2YXIgdXRpbHMgPSBmYWJyaWMudXRpbCwgb3JpZ1BhcmFtcyA9IHV0aWxzLnNhdmVPYmplY3RUcmFuc2Zvcm0odGhpcyksXG4gICAgICAgICAgb3JpZ2luYWxHcm91cCA9IHRoaXMuZ3JvdXAsXG4gICAgICAgICAgb3JpZ2luYWxTaGFkb3cgPSB0aGlzLnNoYWRvdywgYWJzID0gTWF0aC5hYnMsXG4gICAgICAgICAgbXVsdGlwbGllciA9IChvcHRpb25zLm11bHRpcGxpZXIgfHwgMSkgKiAob3B0aW9ucy5lbmFibGVSZXRpbmFTY2FsaW5nID8gZmFicmljLmRldmljZVBpeGVsUmF0aW8gOiAxKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmdyb3VwO1xuICAgICAgaWYgKG9wdGlvbnMud2l0aG91dFRyYW5zZm9ybSkge1xuICAgICAgICB1dGlscy5yZXNldE9iamVjdFRyYW5zZm9ybSh0aGlzKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLndpdGhvdXRTaGFkb3cpIHtcbiAgICAgICAgdGhpcy5zaGFkb3cgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWwgPSBmYWJyaWMudXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCksXG4gICAgICAgICAgLy8gc2tpcCBjYW52YXMgem9vbSBhbmQgY2FsY3VsYXRlIHdpdGggc2V0Q29vcmRzIG5vdy5cbiAgICAgICAgICBib3VuZGluZ1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCh0cnVlLCB0cnVlKSxcbiAgICAgICAgICBzaGFkb3cgPSB0aGlzLnNoYWRvdywgc2NhbGluZyxcbiAgICAgICAgICBzaGFkb3dPZmZzZXQgPSB7IHg6IDAsIHk6IDAgfSwgc2hhZG93Qmx1cixcbiAgICAgICAgICB3aWR0aCwgaGVpZ2h0O1xuXG4gICAgICBpZiAoc2hhZG93KSB7XG4gICAgICAgIHNoYWRvd0JsdXIgPSBzaGFkb3cuYmx1cjtcbiAgICAgICAgaWYgKHNoYWRvdy5ub25TY2FsaW5nKSB7XG4gICAgICAgICAgc2NhbGluZyA9IHsgc2NhbGVYOiAxLCBzY2FsZVk6IDEgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzY2FsaW5nID0gdGhpcy5nZXRPYmplY3RTY2FsaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc2lkZXIgbm9uIHNjYWxpbmcgc2hhZG93LlxuICAgICAgICBzaGFkb3dPZmZzZXQueCA9IDIgKiBNYXRoLnJvdW5kKGFicyhzaGFkb3cub2Zmc2V0WCkgKyBzaGFkb3dCbHVyKSAqIChhYnMoc2NhbGluZy5zY2FsZVgpKTtcbiAgICAgICAgc2hhZG93T2Zmc2V0LnkgPSAyICogTWF0aC5yb3VuZChhYnMoc2hhZG93Lm9mZnNldFkpICsgc2hhZG93Qmx1cikgKiAoYWJzKHNjYWxpbmcuc2NhbGVZKSk7XG4gICAgICB9XG4gICAgICB3aWR0aCA9IGJvdW5kaW5nUmVjdC53aWR0aCArIHNoYWRvd09mZnNldC54O1xuICAgICAgaGVpZ2h0ID0gYm91bmRpbmdSZWN0LmhlaWdodCArIHNoYWRvd09mZnNldC55O1xuICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgd2lkdGgvaGVpZ2h0IGlzIG5vdCBhbiBpbnRlZ2VyXG4gICAgICAvLyB3ZSBuZWVkIHRvIG1ha2UgaXQgc28uXG4gICAgICBlbC53aWR0aCA9IE1hdGguY2VpbCh3aWR0aCk7XG4gICAgICBlbC5oZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0KTtcbiAgICAgIHZhciBjYW52YXMgPSBuZXcgZmFicmljLlN0YXRpY0NhbnZhcyhlbCwge1xuICAgICAgICBlbmFibGVSZXRpbmFTY2FsaW5nOiBmYWxzZSxcbiAgICAgICAgcmVuZGVyT25BZGRSZW1vdmU6IGZhbHNlLFxuICAgICAgICBza2lwT2Zmc2NyZWVuOiBmYWxzZSxcbiAgICAgIH0pO1xuICAgICAgaWYgKG9wdGlvbnMuZm9ybWF0ID09PSAnanBlZycpIHtcbiAgICAgICAgY2FudmFzLmJhY2tncm91bmRDb2xvciA9ICcjZmZmJztcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0UG9zaXRpb25CeU9yaWdpbihuZXcgZmFicmljLlBvaW50KGNhbnZhcy53aWR0aCAvIDIsIGNhbnZhcy5oZWlnaHQgLyAyKSwgJ2NlbnRlcicsICdjZW50ZXInKTtcblxuICAgICAgdmFyIG9yaWdpbmFsQ2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICBjYW52YXMuYWRkKHRoaXMpO1xuICAgICAgdmFyIGNhbnZhc0VsID0gY2FudmFzLnRvQ2FudmFzRWxlbWVudChtdWx0aXBsaWVyIHx8IDEsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5zaGFkb3cgPSBvcmlnaW5hbFNoYWRvdztcbiAgICAgIHRoaXMuc2V0KCdjYW52YXMnLCBvcmlnaW5hbENhbnZhcyk7XG4gICAgICBpZiAob3JpZ2luYWxHcm91cCkge1xuICAgICAgICB0aGlzLmdyb3VwID0gb3JpZ2luYWxHcm91cDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0KG9yaWdQYXJhbXMpLnNldENvb3JkcygpO1xuICAgICAgLy8gY2FudmFzLmRpc3Bvc2Ugd2lsbCBjYWxsIGltYWdlLmRpc3Bvc2UgdGhhdCB3aWxsIG51bGxpZnkgdGhlIGVsZW1lbnRzXG4gICAgICAvLyBzaW5jZSB0aGlzIGNhbnZhcyBpcyBhIHNpbXBsZSBlbGVtZW50IGZvciB0aGUgcHJvY2Vzcywgd2UgcmVtb3ZlIHJlZmVyZW5jZXNcbiAgICAgIC8vIHRvIG9iamVjdHMgaW4gdGhpcyB3YXkgaW4gb3JkZXIgdG8gYXZvaWQgb2JqZWN0IHRyYXNoaW5nLlxuICAgICAgY2FudmFzLl9vYmplY3RzID0gW107XG4gICAgICBjYW52YXMuZGlzcG9zZSgpO1xuICAgICAgY2FudmFzID0gbnVsbDtcblxuICAgICAgcmV0dXJuIGNhbnZhc0VsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhIGRhdGEtdXJsLWxpa2Ugc3RyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZm9ybWF0PXBuZ10gVGhlIGZvcm1hdCBvZiB0aGUgb3V0cHV0IGltYWdlLiBFaXRoZXIgXCJqcGVnXCIgb3IgXCJwbmdcIlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5xdWFsaXR5PTFdIFF1YWxpdHkgbGV2ZWwgKDAuLjEpLiBPbmx5IHVzZWQgZm9yIGpwZWcuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm11bHRpcGxpZXI9MV0gTXVsdGlwbGllciB0byBzY2FsZSBieVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5sZWZ0XSBDcm9wcGluZyBsZWZ0IG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRvcF0gQ3JvcHBpbmcgdG9wIG9mZnNldC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoXSBDcm9wcGluZyB3aWR0aC4gSW50cm9kdWNlZCBpbiB2MS4yLjE0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodF0gQ3JvcHBpbmcgaGVpZ2h0LiBJbnRyb2R1Y2VkIGluIHYxLjIuMTRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZVJldGluYVNjYWxpbmddIEVuYWJsZSByZXRpbmEgc2NhbGluZyBmb3IgY2xvbmUgaW1hZ2UuIEludHJvZHVjZSBpbiAxLjYuNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2l0aG91dFRyYW5zZm9ybV0gUmVtb3ZlIGN1cnJlbnQgb2JqZWN0IHRyYW5zZm9ybSAoIG5vIHNjYWxlICwgbm8gYW5nbGUsIG5vIGZsaXAsIG5vIHNrZXcgKS4gSW50cm9kdWNlZCBpbiAyLjMuNFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2l0aG91dFNoYWRvd10gUmVtb3ZlIGN1cnJlbnQgb2JqZWN0IHNoYWRvdy4gSW50cm9kdWNlZCBpbiAyLjQuMlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gUmV0dXJucyBhIGRhdGE6IFVSTCBjb250YWluaW5nIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdCBpbiB0aGUgZm9ybWF0IHNwZWNpZmllZCBieSBvcHRpb25zLmZvcm1hdFxuICAgICAqL1xuICAgIHRvRGF0YVVSTDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwudG9EYXRhVVJMKHRoaXMudG9DYW52YXNFbGVtZW50KG9wdGlvbnMpLCBvcHRpb25zLmZvcm1hdCB8fCAncG5nJywgb3B0aW9ucy5xdWFsaXR5IHx8IDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgc3BlY2lmaWVkIHR5cGUgaXMgaWRlbnRpY2FsIHRvIHRoZSB0eXBlIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVHlwZSB0byBjaGVjayBhZ2FpbnN0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1R5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMSA/IEFycmF5LmZyb20oYXJndW1lbnRzKS5pbmNsdWRlcyh0aGlzLnR5cGUpIDogdGhpcy50eXBlID09PSB0eXBlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbXBsZXhpdHkgb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBsZXhpdHkgb2YgdGhpcyBpbnN0YW5jZSAoaXMgMSB1bmxlc3Mgc3ViY2xhc3NlZClcbiAgICAgKi9cbiAgICBjb21wbGV4aXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEpTT05cbiAgICAgKi9cbiAgICB0b0pTT046IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIC8vIGRlbGVnYXRlLCBub3QgYWxpYXNcbiAgICAgIHJldHVybiB0aGlzLnRvT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIFwiYW5nbGVcIiBvZiBhbiBpbnN0YW5jZSB3aXRoIGNlbnRlcmVkIHJvdGF0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIEFuZ2xlIHZhbHVlIChpbiBkZWdyZWVzKVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcm90YXRlOiBmdW5jdGlvbihhbmdsZSkge1xuICAgICAgdmFyIHNob3VsZENlbnRlck9yaWdpbiA9ICh0aGlzLm9yaWdpblggIT09ICdjZW50ZXInIHx8IHRoaXMub3JpZ2luWSAhPT0gJ2NlbnRlcicpICYmIHRoaXMuY2VudGVyZWRSb3RhdGlvbjtcblxuICAgICAgaWYgKHNob3VsZENlbnRlck9yaWdpbikge1xuICAgICAgICB0aGlzLl9zZXRPcmlnaW5Ub0NlbnRlcigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldCgnYW5nbGUnLCBhbmdsZSk7XG5cbiAgICAgIGlmIChzaG91bGRDZW50ZXJPcmlnaW4pIHtcbiAgICAgICAgdGhpcy5fcmVzZXRPcmlnaW4oKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IGhvcml6b250YWxseSBvbiBjYW52YXMgdG8gd2hpY2ggaXQgd2FzIGFkZGVkIGxhc3QuXG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgc2V0Q29vcmRzYCBvbiBhbiBvYmplY3QgYWZ0ZXIgY2VudGVyaW5nLCB0byB1cGRhdGUgY29udHJvbHMgYXJlYS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNlbnRlckg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmNlbnRlck9iamVjdEgodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2VudGVycyBvYmplY3QgaG9yaXpvbnRhbGx5IG9uIGN1cnJlbnQgdmlld3BvcnQgb2YgY2FudmFzIHRvIHdoaWNoIGl0IHdhcyBhZGRlZCBsYXN0LlxuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYHNldENvb3Jkc2Agb24gYW4gb2JqZWN0IGFmdGVyIGNlbnRlcmluZywgdG8gdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB2aWV3cG9ydENlbnRlckg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnZpZXdwb3J0Q2VudGVyT2JqZWN0SCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCB2ZXJ0aWNhbGx5IG9uIGNhbnZhcyB0byB3aGljaCBpdCB3YXMgYWRkZWQgbGFzdC5cbiAgICAgKiBZb3UgbWlnaHQgbmVlZCB0byBjYWxsIGBzZXRDb29yZHNgIG9uIGFuIG9iamVjdCBhZnRlciBjZW50ZXJpbmcsIHRvIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgY2VudGVyVjogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuY2VudGVyT2JqZWN0Vih0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCB2ZXJ0aWNhbGx5IG9uIGN1cnJlbnQgdmlld3BvcnQgb2YgY2FudmFzIHRvIHdoaWNoIGl0IHdhcyBhZGRlZCBsYXN0LlxuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYHNldENvb3Jkc2Agb24gYW4gb2JqZWN0IGFmdGVyIGNlbnRlcmluZywgdG8gdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB2aWV3cG9ydENlbnRlclY6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnZpZXdwb3J0Q2VudGVyT2JqZWN0Vih0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDZW50ZXJzIG9iamVjdCB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHkgb24gY2FudmFzIHRvIHdoaWNoIGlzIHdhcyBhZGRlZCBsYXN0XG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgc2V0Q29vcmRzYCBvbiBhbiBvYmplY3QgYWZ0ZXIgY2VudGVyaW5nLCB0byB1cGRhdGUgY29udHJvbHMgYXJlYS5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGNlbnRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuY2VudGVyT2JqZWN0KHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgb2JqZWN0IG9uIGN1cnJlbnQgdmlld3BvcnQgb2YgY2FudmFzIHRvIHdoaWNoIGl0IHdhcyBhZGRlZCBsYXN0LlxuICAgICAqIFlvdSBtaWdodCBuZWVkIHRvIGNhbGwgYHNldENvb3Jkc2Agb24gYW4gb2JqZWN0IGFmdGVyIGNlbnRlcmluZywgdG8gdXBkYXRlIGNvbnRyb2xzIGFyZWEuXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB2aWV3cG9ydENlbnRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMudmlld3BvcnRDZW50ZXJPYmplY3QodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb29yZGluYXRlcyBvZiBhIHBvaW50ZXIgcmVsYXRpdmUgdG8gYW4gb2JqZWN0XG4gICAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCB0byBvcGVyYXRlIHVwb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BvaW50ZXJdIFBvaW50ZXIgdG8gb3BlcmF0ZSB1cG9uIChpbnN0ZWFkIG9mIGV2ZW50KVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ29vcmRpbmF0ZXMgb2YgYSBwb2ludGVyICh4LCB5KVxuICAgICAqL1xuICAgIGdldExvY2FsUG9pbnRlcjogZnVuY3Rpb24oZSwgcG9pbnRlcikge1xuICAgICAgcG9pbnRlciA9IHBvaW50ZXIgfHwgdGhpcy5jYW52YXMuZ2V0UG9pbnRlcihlKTtcbiAgICAgIHZhciBwQ2xpY2tlZCA9IG5ldyBmYWJyaWMuUG9pbnQocG9pbnRlci54LCBwb2ludGVyLnkpLFxuICAgICAgICAgIG9iamVjdExlZnRUb3AgPSB0aGlzLl9nZXRMZWZ0VG9wQ29vcmRzKCk7XG4gICAgICBpZiAodGhpcy5hbmdsZSkge1xuICAgICAgICBwQ2xpY2tlZCA9IGZhYnJpYy51dGlsLnJvdGF0ZVBvaW50KFxuICAgICAgICAgIHBDbGlja2VkLCBvYmplY3RMZWZ0VG9wLCBkZWdyZWVzVG9SYWRpYW5zKC10aGlzLmFuZ2xlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBwQ2xpY2tlZC54IC0gb2JqZWN0TGVmdFRvcC54LFxuICAgICAgICB5OiBwQ2xpY2tlZC55IC0gb2JqZWN0TGVmdFRvcC55XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGNhbnZhcyBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gZm9yIHNwZWNpZmljIG9iamVjdFxuICAgICAqIGN1c3RvbSBjb21wb3NpdGlvbiBvcGVyYXRpb24gZm9yIHRoZSBwYXJ0aWN1bGFyIG9iamVjdCBjYW4gYmUgc3BlY2lmaWVkIHVzaW5nIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggUmVuZGVyaW5nIGNhbnZhcyBjb250ZXh0XG4gICAgICovXG4gICAgX3NldHVwQ29tcG9zaXRlT3BlcmF0aW9uOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICBpZiAodGhpcy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24pIHtcbiAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHRoaXMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYW5jZWwgaW5zdGFuY2UncyBydW5uaW5nIGFuaW1hdGlvbnNcbiAgICAgKiBvdmVycmlkZSBpZiBuZWNlc3NhcnkgdG8gZGlzcG9zZSBhcnRpZmFjdHMgc3VjaCBhcyBgY2xpcFBhdGhgXG4gICAgICovXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGZhYnJpYy5ydW5uaW5nQW5pbWF0aW9ucykge1xuICAgICAgICBmYWJyaWMucnVubmluZ0FuaW1hdGlvbnMuY2FuY2VsQnlUYXJnZXQodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBmYWJyaWMudXRpbC5jcmVhdGVBY2Nlc3NvcnMgJiYgZmFicmljLnV0aWwuY3JlYXRlQWNjZXNzb3JzKGZhYnJpYy5PYmplY3QpO1xuXG4gIGV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgZmFicmljLk9ic2VydmFibGUpO1xuXG4gIC8qKlxuICAgKiBEZWZpbmVzIHRoZSBudW1iZXIgb2YgZnJhY3Rpb24gZGlnaXRzIHRvIHVzZSB3aGVuIHNlcmlhbGl6aW5nIG9iamVjdCB2YWx1ZXMuXG4gICAqIFlvdSBjYW4gdXNlIGl0IHRvIGluY3JlYXNlL2RlY3JlYXNlIHByZWNpc2lvbiBvZiBzdWNoIHZhbHVlcyBsaWtlIGxlZnQsIHRvcCwgc2NhbGVYLCBzY2FsZVksIGV0Yy5cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdFxuICAgKiBAY29uc3RhbnRcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqL1xuICBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFMgPSAyO1xuXG4gIC8qKlxuICAgKiBEZWZpbmVzIHdoaWNoIHByb3BlcnRpZXMgc2hvdWxkIGJlIGVubGl2ZW5lZCBmcm9tIHRoZSBvYmplY3QgcGFzc2VkIHRvIHtAbGluayBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0fVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuT2JqZWN0XG4gICAqIEBjb25zdGFudFxuICAgKiBAdHlwZSBzdHJpbmdbXVxuICAgKi9cbiAgZmFicmljLk9iamVjdC5FTkxJVkVOX1BST1BTID0gWydjbGlwUGF0aCddO1xuXG4gIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QgPSBmdW5jdGlvbihjbGFzc05hbWUsIG9iamVjdCwgY2FsbGJhY2ssIGV4dHJhUGFyYW0pIHtcbiAgICB2YXIga2xhc3MgPSBmYWJyaWNbY2xhc3NOYW1lXTtcbiAgICBvYmplY3QgPSBjbG9uZShvYmplY3QsIHRydWUpO1xuICAgIGZhYnJpYy51dGlsLmVubGl2ZW5QYXR0ZXJucyhbb2JqZWN0LmZpbGwsIG9iamVjdC5zdHJva2VdLCBmdW5jdGlvbihwYXR0ZXJucykge1xuICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJuc1swXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb2JqZWN0LmZpbGwgPSBwYXR0ZXJuc1swXTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcGF0dGVybnNbMV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9iamVjdC5zdHJva2UgPSBwYXR0ZXJuc1sxXTtcbiAgICAgIH1cbiAgICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RFbmxpdmFibGVzKG9iamVjdCwgb2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGV4dHJhUGFyYW0gPyBuZXcga2xhc3Mob2JqZWN0W2V4dHJhUGFyYW1dLCBvYmplY3QpIDogbmV3IGtsYXNzKG9iamVjdCk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGluc3RhbmNlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVbmlxdWUgaWQgdXNlZCBpbnRlcm5hbGx5IHdoZW4gY3JlYXRpbmcgU1ZHIGVsZW1lbnRzXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5PYmplY3RcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqL1xuICBmYWJyaWMuT2JqZWN0Ll9fdWlkID0gMDtcbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGRlZ3JlZXNUb1JhZGlhbnMgPSBmYWJyaWMudXRpbC5kZWdyZWVzVG9SYWRpYW5zLFxuICAgICAgb3JpZ2luWE9mZnNldCA9IHtcbiAgICAgICAgbGVmdDogLTAuNSxcbiAgICAgICAgY2VudGVyOiAwLFxuICAgICAgICByaWdodDogMC41XG4gICAgICB9LFxuICAgICAgb3JpZ2luWU9mZnNldCA9IHtcbiAgICAgICAgdG9wOiAtMC41LFxuICAgICAgICBjZW50ZXI6IDAsXG4gICAgICAgIGJvdHRvbTogMC41XG4gICAgICB9O1xuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLk9iamVjdC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyB0aGUgY29vcmRpbmF0ZXMgZnJvbSBhIHNldCBvZiBvcmlnaW4gdG8gYW5vdGhlciAoYmFzZWQgb24gdGhlIG9iamVjdCdzIGRpbWVuc2lvbnMpXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFRoZSBwb2ludCB3aGljaCBjb3JyZXNwb25kcyB0byB0aGUgb3JpZ2luWCBhbmQgb3JpZ2luWSBwYXJhbXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZnJvbU9yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmcm9tT3JpZ2luWSBWZXJ0aWNhbCBvcmlnaW46ICd0b3AnLCAnY2VudGVyJyBvciAnYm90dG9tJ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0b09yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0b09yaWdpblkgVmVydGljYWwgb3JpZ2luOiAndG9wJywgJ2NlbnRlcicgb3IgJ2JvdHRvbSdcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgdHJhbnNsYXRlVG9HaXZlbk9yaWdpbjogZnVuY3Rpb24ocG9pbnQsIGZyb21PcmlnaW5YLCBmcm9tT3JpZ2luWSwgdG9PcmlnaW5YLCB0b09yaWdpblkpIHtcbiAgICAgIHZhciB4ID0gcG9pbnQueCxcbiAgICAgICAgICB5ID0gcG9pbnQueSxcbiAgICAgICAgICBvZmZzZXRYLCBvZmZzZXRZLCBkaW07XG5cbiAgICAgIGlmICh0eXBlb2YgZnJvbU9yaWdpblggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZyb21PcmlnaW5YID0gb3JpZ2luWE9mZnNldFtmcm9tT3JpZ2luWF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZnJvbU9yaWdpblggLT0gMC41O1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRvT3JpZ2luWCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdG9PcmlnaW5YID0gb3JpZ2luWE9mZnNldFt0b09yaWdpblhdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRvT3JpZ2luWCAtPSAwLjU7XG4gICAgICB9XG5cbiAgICAgIG9mZnNldFggPSB0b09yaWdpblggLSBmcm9tT3JpZ2luWDtcblxuICAgICAgaWYgKHR5cGVvZiBmcm9tT3JpZ2luWSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZnJvbU9yaWdpblkgPSBvcmlnaW5ZT2Zmc2V0W2Zyb21PcmlnaW5ZXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmcm9tT3JpZ2luWSAtPSAwLjU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdG9PcmlnaW5ZID09PSAnc3RyaW5nJykge1xuICAgICAgICB0b09yaWdpblkgPSBvcmlnaW5ZT2Zmc2V0W3RvT3JpZ2luWV07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdG9PcmlnaW5ZIC09IDAuNTtcbiAgICAgIH1cblxuICAgICAgb2Zmc2V0WSA9IHRvT3JpZ2luWSAtIGZyb21PcmlnaW5ZO1xuXG4gICAgICBpZiAob2Zmc2V0WCB8fCBvZmZzZXRZKSB7XG4gICAgICAgIGRpbSA9IHRoaXMuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpO1xuICAgICAgICB4ID0gcG9pbnQueCArIG9mZnNldFggKiBkaW0ueDtcbiAgICAgICAgeSA9IHBvaW50LnkgKyBvZmZzZXRZICogZGltLnk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgZmFicmljLlBvaW50KHgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIHRoZSBjb29yZGluYXRlcyBmcm9tIG9yaWdpbiB0byBjZW50ZXIgY29vcmRpbmF0ZXMgKGJhc2VkIG9uIHRoZSBvYmplY3QncyBkaW1lbnNpb25zKVxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCBUaGUgcG9pbnQgd2hpY2ggY29ycmVzcG9uZHMgdG8gdGhlIG9yaWdpblggYW5kIG9yaWdpblkgcGFyYW1zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIHRyYW5zbGF0ZVRvQ2VudGVyUG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCBvcmlnaW5YLCBvcmlnaW5ZKSB7XG4gICAgICB2YXIgcCA9IHRoaXMudHJhbnNsYXRlVG9HaXZlbk9yaWdpbihwb2ludCwgb3JpZ2luWCwgb3JpZ2luWSwgJ2NlbnRlcicsICdjZW50ZXInKTtcbiAgICAgIGlmICh0aGlzLmFuZ2xlKSB7XG4gICAgICAgIHJldHVybiBmYWJyaWMudXRpbC5yb3RhdGVQb2ludChwLCBwb2ludCwgZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyB0aGUgY29vcmRpbmF0ZXMgZnJvbSBjZW50ZXIgdG8gb3JpZ2luIGNvb3JkaW5hdGVzIChiYXNlZCBvbiB0aGUgb2JqZWN0J3MgZGltZW5zaW9ucylcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gY2VudGVyIFRoZSBwb2ludCB3aGljaCBjb3JyZXNwb25kcyB0byBjZW50ZXIgb2YgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5YIEhvcml6b250YWwgb3JpZ2luOiAnbGVmdCcsICdjZW50ZXInIG9yICdyaWdodCdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JpZ2luWSBWZXJ0aWNhbCBvcmlnaW46ICd0b3AnLCAnY2VudGVyJyBvciAnYm90dG9tJ1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Qb2ludH1cbiAgICAgKi9cbiAgICB0cmFuc2xhdGVUb09yaWdpblBvaW50OiBmdW5jdGlvbihjZW50ZXIsIG9yaWdpblgsIG9yaWdpblkpIHtcbiAgICAgIHZhciBwID0gdGhpcy50cmFuc2xhdGVUb0dpdmVuT3JpZ2luKGNlbnRlciwgJ2NlbnRlcicsICdjZW50ZXInLCBvcmlnaW5YLCBvcmlnaW5ZKTtcbiAgICAgIGlmICh0aGlzLmFuZ2xlKSB7XG4gICAgICAgIHJldHVybiBmYWJyaWMudXRpbC5yb3RhdGVQb2ludChwLCBjZW50ZXIsIGRlZ3JlZXNUb1JhZGlhbnModGhpcy5hbmdsZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJlYWwgY2VudGVyIGNvb3JkaW5hdGVzIG9mIHRoZSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgZ2V0Q2VudGVyUG9pbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxlZnRUb3AgPSBuZXcgZmFicmljLlBvaW50KHRoaXMubGVmdCwgdGhpcy50b3ApO1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlVG9DZW50ZXJQb2ludChsZWZ0VG9wLCB0aGlzLm9yaWdpblgsIHRoaXMub3JpZ2luWSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBvYmplY3QgYmFzZWQgb24gY2VudGVyIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFRoZSBwb2ludCB3aGljaCBjb3JyZXNwb25kcyB0byB0aGUgb3JpZ2luWCBhbmQgb3JpZ2luWSBwYXJhbXNcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuUG9pbnR9XG4gICAgICovXG4gICAgLy8gZ2V0T3JpZ2luUG9pbnQ6IGZ1bmN0aW9uKGNlbnRlcikge1xuICAgIC8vICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlVG9PcmlnaW5Qb2ludChjZW50ZXIsIHRoaXMub3JpZ2luWCwgdGhpcy5vcmlnaW5ZKTtcbiAgICAvLyB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBhcyBpZiBpdCBoYXMgYSBkaWZmZXJlbnQgb3JpZ2luXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIGdldFBvaW50QnlPcmlnaW46IGZ1bmN0aW9uKG9yaWdpblgsIG9yaWdpblkpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlclBvaW50KCk7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVUb09yaWdpblBvaW50KGNlbnRlciwgb3JpZ2luWCwgb3JpZ2luWSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvaW50IGluIGxvY2FsIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtmYWJyaWMuUG9pbnR9IHBvaW50IFRoZSBwb2ludCByZWxhdGl2ZSB0byB0aGUgZ2xvYmFsIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIHRvTG9jYWxQb2ludDogZnVuY3Rpb24ocG9pbnQsIG9yaWdpblgsIG9yaWdpblkpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlclBvaW50KCksXG4gICAgICAgICAgcCwgcDI7XG5cbiAgICAgIGlmICh0eXBlb2Ygb3JpZ2luWCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG9yaWdpblkgIT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICBwID0gdGhpcy50cmFuc2xhdGVUb0dpdmVuT3JpZ2luKGNlbnRlciwgJ2NlbnRlcicsICdjZW50ZXInLCBvcmlnaW5YLCBvcmlnaW5ZKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwID0gbmV3IGZhYnJpYy5Qb2ludCh0aGlzLmxlZnQsIHRoaXMudG9wKTtcbiAgICAgIH1cblxuICAgICAgcDIgPSBuZXcgZmFicmljLlBvaW50KHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgaWYgKHRoaXMuYW5nbGUpIHtcbiAgICAgICAgcDIgPSBmYWJyaWMudXRpbC5yb3RhdGVQb2ludChwMiwgY2VudGVyLCAtZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcDIuc3VidHJhY3RFcXVhbHMocCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvaW50IGluIGdsb2JhbCBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBUaGUgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgICogQHJldHVybiB7ZmFicmljLlBvaW50fVxuICAgICAqL1xuICAgIC8vIHRvR2xvYmFsUG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgLy8gICByZXR1cm4gZmFicmljLnV0aWwucm90YXRlUG9pbnQocG9pbnQsIHRoaXMuZ2V0Q2VudGVyUG9pbnQoKSwgZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSkuYWRkRXF1YWxzKG5ldyBmYWJyaWMuUG9pbnQodGhpcy5sZWZ0LCB0aGlzLnRvcCkpO1xuICAgIC8vIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgb2JqZWN0IHRha2luZyBpbnRvIGNvbnNpZGVyYXRpb24gdGhlIG9iamVjdCdzIG9yaWdpblxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb3MgVGhlIG5ldyBwb3NpdGlvbiBvZiB0aGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9yaWdpblggSG9yaXpvbnRhbCBvcmlnaW46ICdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcmlnaW5ZIFZlcnRpY2FsIG9yaWdpbjogJ3RvcCcsICdjZW50ZXInIG9yICdib3R0b20nXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBzZXRQb3NpdGlvbkJ5T3JpZ2luOiBmdW5jdGlvbihwb3MsIG9yaWdpblgsIG9yaWdpblkpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLnRyYW5zbGF0ZVRvQ2VudGVyUG9pbnQocG9zLCBvcmlnaW5YLCBvcmlnaW5ZKSxcbiAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMudHJhbnNsYXRlVG9PcmlnaW5Qb2ludChjZW50ZXIsIHRoaXMub3JpZ2luWCwgdGhpcy5vcmlnaW5ZKTtcbiAgICAgIHRoaXMuc2V0KCdsZWZ0JywgcG9zaXRpb24ueCk7XG4gICAgICB0aGlzLnNldCgndG9wJywgcG9zaXRpb24ueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0byBPbmUgb2YgJ2xlZnQnLCAnY2VudGVyJywgJ3JpZ2h0J1xuICAgICAqL1xuICAgIGFkanVzdFBvc2l0aW9uOiBmdW5jdGlvbih0bykge1xuICAgICAgdmFyIGFuZ2xlID0gZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSxcbiAgICAgICAgICBoeXBvdEZ1bGwgPSB0aGlzLmdldFNjYWxlZFdpZHRoKCksXG4gICAgICAgICAgeEZ1bGwgPSBmYWJyaWMudXRpbC5jb3MoYW5nbGUpICogaHlwb3RGdWxsLFxuICAgICAgICAgIHlGdWxsID0gZmFicmljLnV0aWwuc2luKGFuZ2xlKSAqIGh5cG90RnVsbCxcbiAgICAgICAgICBvZmZzZXRGcm9tLCBvZmZzZXRUbztcblxuICAgICAgLy9UT0RPOiB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IGNvbnNpZGVyIG1peGVkIHNpdHVhdGlvbiBsaWtlIHRvcCwgY2VudGVyLlxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9yaWdpblggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9mZnNldEZyb20gPSBvcmlnaW5YT2Zmc2V0W3RoaXMub3JpZ2luWF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgb2Zmc2V0RnJvbSA9IHRoaXMub3JpZ2luWCAtIDAuNTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9mZnNldFRvID0gb3JpZ2luWE9mZnNldFt0b107XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgb2Zmc2V0VG8gPSB0byAtIDAuNTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGVmdCArPSB4RnVsbCAqIChvZmZzZXRUbyAtIG9mZnNldEZyb20pO1xuICAgICAgdGhpcy50b3AgKz0geUZ1bGwgKiAob2Zmc2V0VG8gLSBvZmZzZXRGcm9tKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLm9yaWdpblggPSB0bztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgb3JpZ2luL3Bvc2l0aW9uIG9mIHRoZSBvYmplY3QgdG8gaXQncyBjZW50ZXIgcG9pbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgX3NldE9yaWdpblRvQ2VudGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX29yaWdpbmFsT3JpZ2luWCA9IHRoaXMub3JpZ2luWDtcbiAgICAgIHRoaXMuX29yaWdpbmFsT3JpZ2luWSA9IHRoaXMub3JpZ2luWTtcblxuICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKTtcblxuICAgICAgdGhpcy5vcmlnaW5YID0gJ2NlbnRlcic7XG4gICAgICB0aGlzLm9yaWdpblkgPSAnY2VudGVyJztcblxuICAgICAgdGhpcy5sZWZ0ID0gY2VudGVyLng7XG4gICAgICB0aGlzLnRvcCA9IGNlbnRlci55O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIG9yaWdpbi9wb3NpdGlvbiBvZiB0aGUgb2JqZWN0IHRvIGl0J3Mgb3JpZ2luYWwgb3JpZ2luXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIF9yZXNldE9yaWdpbjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3JpZ2luUG9pbnQgPSB0aGlzLnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQoXG4gICAgICAgIHRoaXMuZ2V0Q2VudGVyUG9pbnQoKSxcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxPcmlnaW5YLFxuICAgICAgICB0aGlzLl9vcmlnaW5hbE9yaWdpblkpO1xuXG4gICAgICB0aGlzLm9yaWdpblggPSB0aGlzLl9vcmlnaW5hbE9yaWdpblg7XG4gICAgICB0aGlzLm9yaWdpblkgPSB0aGlzLl9vcmlnaW5hbE9yaWdpblk7XG5cbiAgICAgIHRoaXMubGVmdCA9IG9yaWdpblBvaW50Lng7XG4gICAgICB0aGlzLnRvcCA9IG9yaWdpblBvaW50Lnk7XG5cbiAgICAgIHRoaXMuX29yaWdpbmFsT3JpZ2luWCA9IG51bGw7XG4gICAgICB0aGlzLl9vcmlnaW5hbE9yaWdpblkgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRMZWZ0VG9wQ29vcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQodGhpcy5nZXRDZW50ZXJQb2ludCgpLCAnbGVmdCcsICd0b3AnKTtcbiAgICB9LFxuICB9KTtcblxufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgZnVuY3Rpb24gYXJyYXlGcm9tQ29vcmRzKGNvb3Jkcykge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgZmFicmljLlBvaW50KGNvb3Jkcy50bC54LCBjb29yZHMudGwueSksXG4gICAgICBuZXcgZmFicmljLlBvaW50KGNvb3Jkcy50ci54LCBjb29yZHMudHIueSksXG4gICAgICBuZXcgZmFicmljLlBvaW50KGNvb3Jkcy5ici54LCBjb29yZHMuYnIueSksXG4gICAgICBuZXcgZmFicmljLlBvaW50KGNvb3Jkcy5ibC54LCBjb29yZHMuYmwueSlcbiAgICBdO1xuICB9XG5cbiAgdmFyIHV0aWwgPSBmYWJyaWMudXRpbCxcbiAgICAgIGRlZ3JlZXNUb1JhZGlhbnMgPSB1dGlsLmRlZ3JlZXNUb1JhZGlhbnMsXG4gICAgICBtdWx0aXBseU1hdHJpY2VzID0gdXRpbC5tdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzLFxuICAgICAgdHJhbnNmb3JtUG9pbnQgPSB1dGlsLnRyYW5zZm9ybVBvaW50O1xuXG4gIHV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSBvYmplY3QncyBjb3JuZXIgcG9zaXRpb24gaW4gY2FudmFzIGVsZW1lbnQgY29vcmRpbmF0ZXMuXG4gICAgICogcHJvcGVydGllcyBhcmUgZGVwZW5kaW5nIG9uIGNvbnRyb2wga2V5cyBhbmQgcGFkZGluZyB0aGUgbWFpbiBjb250cm9scy5cbiAgICAgKiBlYWNoIHByb3BlcnR5IGlzIGFuIG9iamVjdCB3aXRoIHgsIHkgYW5kIGNvcm5lci5cbiAgICAgKiBUaGUgYGNvcm5lcmAgcHJvcGVydHkgY29udGFpbnMgaW4gYSBzaW1pbGFyIG1hbm5lciB0aGUgNCBwb2ludHMgb2YgdGhlXG4gICAgICogaW50ZXJhY3RpdmUgYXJlYSBvZiB0aGUgY29ybmVyLlxuICAgICAqIFRoZSBjb29yZGluYXRlcyBkZXBlbmRzIGZyb20gdGhlIGNvbnRyb2xzIHBvc2l0aW9uSGFuZGxlciBhbmQgYXJlIHVzZWRcbiAgICAgKiB0byBkcmF3IGFuZCBsb2NhdGUgY29udHJvbHNcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBvQ29vcmRzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmUgb2JqZWN0J3MgY29ybmVyIHBvc2l0aW9uIGluIGNhbnZhcyBvYmplY3QgYWJzb2x1dGUgY29vcmRpbmF0ZXNcbiAgICAgKiBwcm9wZXJ0aWVzIGFyZSB0bCx0cixibCxiciBhbmQgZGVzY3JpYmUgdGhlIGZvdXIgbWFpbiBjb3JuZXIuXG4gICAgICogZWFjaCBwcm9wZXJ0eSBpcyBhbiBvYmplY3Qgd2l0aCB4LCB5LCBpbnN0YW5jZSBvZiBGYWJyaWMuUG9pbnQuXG4gICAgICogVGhlIGNvb3JkaW5hdGVzIGRlcGVuZHMgZnJvbSB0aGlzIHByb3BlcnRpZXM6IHdpZHRoLCBoZWlnaHQsIHNjYWxlWCwgc2NhbGVZXG4gICAgICogc2tld1gsIHNrZXdZLCBhbmdsZSwgc3Ryb2tlV2lkdGgsIHRvcCwgbGVmdC5cbiAgICAgKiBUaG9zZSBjb29yZGluYXRlcyBhcmUgdXNlZnVsIHRvIHVuZGVyc3RhbmQgd2hlcmUgYW4gb2JqZWN0IGlzLiBUaGV5IGdldCB1cGRhdGVkXG4gICAgICogd2l0aCBvQ29vcmRzIGJ1dCB0aGV5IGRvIG5vdCBuZWVkIHRvIGJlIHVwZGF0ZWQgd2hlbiB6b29tIG9yIHBhbm5pbmcgY2hhbmdlLlxuICAgICAqIFRoZSBjb29yZGluYXRlcyBnZXQgdXBkYXRlZCB3aXRoIEBtZXRob2Qgc2V0Q29vcmRzLlxuICAgICAqIFlvdSBjYW4gY2FsY3VsYXRlIHRoZW0gd2l0aG91dCB1cGRhdGluZyB3aXRoIEBtZXRob2QgY2FsY0FDb29yZHMoKTtcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBhQ29vcmRzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmUgb2JqZWN0J3MgY29ybmVyIHBvc2l0aW9uIGluIGNhbnZhcyBlbGVtZW50IGNvb3JkaW5hdGVzLlxuICAgICAqIGluY2x1ZGVzIHBhZGRpbmcuIFVzZWQgb2Ygb2JqZWN0IGRldGVjdGlvbi5cbiAgICAgKiBzZXQgYW5kIHJlZnJlc2hlZCB3aXRoIHNldENvb3Jkcy5cbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLk9iamVjdC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBsaW5lQ29vcmRzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogc3RvcmFnZSBmb3Igb2JqZWN0IHRyYW5zZm9ybSBtYXRyaXhcbiAgICAgKi9cbiAgICBvd25NYXRyaXhDYWNoZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIHN0b3JhZ2UgZm9yIG9iamVjdCBmdWxsIHRyYW5zZm9ybSBtYXRyaXhcbiAgICAgKi9cbiAgICBtYXRyaXhDYWNoZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGN1c3RvbSBjb250cm9scyBpbnRlcmZhY2VcbiAgICAgKiBjb250cm9scyBhcmUgYWRkZWQgYnkgZGVmYXVsdF9jb250cm9scy5qc1xuICAgICAqL1xuICAgIGNvbnRyb2xzOiB7IH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gY29ycmVjdCBzZXQgb2YgY29vcmRpbmF0ZXMgZm9yIGludGVyc2VjdGlvblxuICAgICAqIHRoaXMgd2lsbCByZXR1cm4gZWl0aGVyIGFDb29yZHMgb3IgbGluZUNvb3Jkcy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFic29sdXRlIHdpbGwgcmV0dXJuIGFDb29yZHMgaWYgdHJ1ZSBvciBsaW5lQ29vcmRzXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB7dGwsIHRyLCBiciwgYmx9IHBvaW50c1xuICAgICAqL1xuICAgIF9nZXRDb29yZHM6IGZ1bmN0aW9uKGFic29sdXRlLCBjYWxjdWxhdGUpIHtcbiAgICAgIGlmIChjYWxjdWxhdGUpIHtcbiAgICAgICAgcmV0dXJuIChhYnNvbHV0ZSA/IHRoaXMuY2FsY0FDb29yZHMoKSA6IHRoaXMuY2FsY0xpbmVDb29yZHMoKSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuYUNvb3JkcyB8fCAhdGhpcy5saW5lQ29vcmRzKSB7XG4gICAgICAgIHRoaXMuc2V0Q29vcmRzKHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChhYnNvbHV0ZSA/IHRoaXMuYUNvb3JkcyA6IHRoaXMubGluZUNvb3Jkcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiBjb3JyZWN0IHNldCBvZiBjb29yZGluYXRlcyBmb3IgaW50ZXJzZWN0aW9uXG4gICAgICogdGhpcyB3aWxsIHJldHVybiBlaXRoZXIgYUNvb3JkcyBvciBsaW5lQ29vcmRzLlxuICAgICAqIFRoZSBjb29yZHMgYXJlIHJldHVybmVkIGluIGFuIGFycmF5LlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBbdGwsIHRyLCBiciwgYmxdIG9mIHBvaW50c1xuICAgICAqL1xuICAgIGdldENvb3JkczogZnVuY3Rpb24oYWJzb2x1dGUsIGNhbGN1bGF0ZSkge1xuICAgICAgcmV0dXJuIGFycmF5RnJvbUNvb3Jkcyh0aGlzLl9nZXRDb29yZHMoYWJzb2x1dGUsIGNhbGN1bGF0ZSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgb2JqZWN0IGludGVyc2VjdHMgd2l0aCBhbiBhcmVhIGZvcm1lZCBieSAyIHBvaW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludFRMIHRvcC1sZWZ0IHBvaW50IG9mIGFyZWFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRCUiBib3R0b20tcmlnaHQgcG9pbnQgb2YgYXJlYVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Fic29sdXRlXSB1c2UgY29vcmRpbmF0ZXMgd2l0aG91dCB2aWV3cG9ydFRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NhbGN1bGF0ZV0gdXNlIGNvb3JkaW5hdGVzIG9mIGN1cnJlbnQgcG9zaXRpb24gaW5zdGVhZCBvZiAub0Nvb3Jkc1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgb2JqZWN0IGludGVyc2VjdHMgd2l0aCBhbiBhcmVhIGZvcm1lZCBieSAyIHBvaW50c1xuICAgICAqL1xuICAgIGludGVyc2VjdHNXaXRoUmVjdDogZnVuY3Rpb24ocG9pbnRUTCwgcG9pbnRCUiwgYWJzb2x1dGUsIGNhbGN1bGF0ZSkge1xuICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuZ2V0Q29vcmRzKGFic29sdXRlLCBjYWxjdWxhdGUpLFxuICAgICAgICAgIGludGVyc2VjdGlvbiA9IGZhYnJpYy5JbnRlcnNlY3Rpb24uaW50ZXJzZWN0UG9seWdvblJlY3RhbmdsZShcbiAgICAgICAgICAgIGNvb3JkcyxcbiAgICAgICAgICAgIHBvaW50VEwsXG4gICAgICAgICAgICBwb2ludEJSXG4gICAgICAgICAgKTtcbiAgICAgIHJldHVybiBpbnRlcnNlY3Rpb24uc3RhdHVzID09PSAnSW50ZXJzZWN0aW9uJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIG9iamVjdCBpbnRlcnNlY3RzIHdpdGggYW5vdGhlciBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgT2JqZWN0IHRvIHRlc3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthYnNvbHV0ZV0gdXNlIGNvb3JkaW5hdGVzIHdpdGhvdXQgdmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYWxjdWxhdGVdIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLm9Db29yZHNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIG9iamVjdCBpbnRlcnNlY3RzIHdpdGggYW5vdGhlciBvYmplY3RcbiAgICAgKi9cbiAgICBpbnRlcnNlY3RzV2l0aE9iamVjdDogZnVuY3Rpb24ob3RoZXIsIGFic29sdXRlLCBjYWxjdWxhdGUpIHtcbiAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBmYWJyaWMuSW50ZXJzZWN0aW9uLmludGVyc2VjdFBvbHlnb25Qb2x5Z29uKFxuICAgICAgICB0aGlzLmdldENvb3JkcyhhYnNvbHV0ZSwgY2FsY3VsYXRlKSxcbiAgICAgICAgb3RoZXIuZ2V0Q29vcmRzKGFic29sdXRlLCBjYWxjdWxhdGUpXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gaW50ZXJzZWN0aW9uLnN0YXR1cyA9PT0gJ0ludGVyc2VjdGlvbidcbiAgICAgICAgfHwgb3RoZXIuaXNDb250YWluZWRXaXRoaW5PYmplY3QodGhpcywgYWJzb2x1dGUsIGNhbGN1bGF0ZSlcbiAgICAgICAgfHwgdGhpcy5pc0NvbnRhaW5lZFdpdGhpbk9iamVjdChvdGhlciwgYWJzb2x1dGUsIGNhbGN1bGF0ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBvYmplY3QgaXMgZnVsbHkgY29udGFpbmVkIHdpdGhpbiBhcmVhIG9mIGFub3RoZXIgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIE9iamVjdCB0byB0ZXN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYWJzb2x1dGVdIHVzZSBjb29yZGluYXRlcyB3aXRob3V0IHZpZXdwb3J0VHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY2FsY3VsYXRlXSB1c2UgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb3NpdGlvbiBpbnN0ZWFkIG9mIC5vQ29vcmRzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvYmplY3QgaXMgZnVsbHkgY29udGFpbmVkIHdpdGhpbiBhcmVhIG9mIGFub3RoZXIgb2JqZWN0XG4gICAgICovXG4gICAgaXNDb250YWluZWRXaXRoaW5PYmplY3Q6IGZ1bmN0aW9uKG90aGVyLCBhYnNvbHV0ZSwgY2FsY3VsYXRlKSB7XG4gICAgICB2YXIgcG9pbnRzID0gdGhpcy5nZXRDb29yZHMoYWJzb2x1dGUsIGNhbGN1bGF0ZSksXG4gICAgICAgICAgb3RoZXJDb29yZHMgPSBhYnNvbHV0ZSA/IG90aGVyLmFDb29yZHMgOiBvdGhlci5saW5lQ29vcmRzLFxuICAgICAgICAgIGkgPSAwLCBsaW5lcyA9IG90aGVyLl9nZXRJbWFnZUxpbmVzKG90aGVyQ29vcmRzKTtcbiAgICAgIGZvciAoOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIGlmICghb3RoZXIuY29udGFpbnNQb2ludChwb2ludHNbaV0sIGxpbmVzKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBvYmplY3QgaXMgZnVsbHkgY29udGFpbmVkIHdpdGhpbiBhcmVhIGZvcm1lZCBieSAyIHBvaW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludFRMIHRvcC1sZWZ0IHBvaW50IG9mIGFyZWFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRCUiBib3R0b20tcmlnaHQgcG9pbnQgb2YgYXJlYVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Fic29sdXRlXSB1c2UgY29vcmRpbmF0ZXMgd2l0aG91dCB2aWV3cG9ydFRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NhbGN1bGF0ZV0gdXNlIGNvb3JkaW5hdGVzIG9mIGN1cnJlbnQgcG9zaXRpb24gaW5zdGVhZCBvZiAub0Nvb3Jkc1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgb2JqZWN0IGlzIGZ1bGx5IGNvbnRhaW5lZCB3aXRoaW4gYXJlYSBmb3JtZWQgYnkgMiBwb2ludHNcbiAgICAgKi9cbiAgICBpc0NvbnRhaW5lZFdpdGhpblJlY3Q6IGZ1bmN0aW9uKHBvaW50VEwsIHBvaW50QlIsIGFic29sdXRlLCBjYWxjdWxhdGUpIHtcbiAgICAgIHZhciBib3VuZGluZ1JlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdChhYnNvbHV0ZSwgY2FsY3VsYXRlKTtcblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgYm91bmRpbmdSZWN0LmxlZnQgPj0gcG9pbnRUTC54ICYmXG4gICAgICAgIGJvdW5kaW5nUmVjdC5sZWZ0ICsgYm91bmRpbmdSZWN0LndpZHRoIDw9IHBvaW50QlIueCAmJlxuICAgICAgICBib3VuZGluZ1JlY3QudG9wID49IHBvaW50VEwueSAmJlxuICAgICAgICBib3VuZGluZ1JlY3QudG9wICsgYm91bmRpbmdSZWN0LmhlaWdodCA8PSBwb2ludEJSLnlcbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBwb2ludCBpcyBpbnNpZGUgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7ZmFicmljLlBvaW50fSBwb2ludCBQb2ludCB0byBjaGVjayBhZ2FpbnN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtsaW5lc10gb2JqZWN0IHJldHVybmVkIGZyb20gQG1ldGhvZCBfZ2V0SW1hZ2VMaW5lc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Fic29sdXRlXSB1c2UgY29vcmRpbmF0ZXMgd2l0aG91dCB2aWV3cG9ydFRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NhbGN1bGF0ZV0gdXNlIGNvb3JkaW5hdGVzIG9mIGN1cnJlbnQgcG9zaXRpb24gaW5zdGVhZCBvZiAub0Nvb3Jkc1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgcG9pbnQgaXMgaW5zaWRlIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBjb250YWluc1BvaW50OiBmdW5jdGlvbihwb2ludCwgbGluZXMsIGFic29sdXRlLCBjYWxjdWxhdGUpIHtcbiAgICAgIHZhciBjb29yZHMgPSB0aGlzLl9nZXRDb29yZHMoYWJzb2x1dGUsIGNhbGN1bGF0ZSksXG4gICAgICAgICAgbGluZXMgPSBsaW5lcyB8fCB0aGlzLl9nZXRJbWFnZUxpbmVzKGNvb3JkcyksXG4gICAgICAgICAgeFBvaW50cyA9IHRoaXMuX2ZpbmRDcm9zc1BvaW50cyhwb2ludCwgbGluZXMpO1xuICAgICAgLy8gaWYgeFBvaW50cyBpcyBvZGQgdGhlbiBwb2ludCBpcyBpbnNpZGUgdGhlIG9iamVjdFxuICAgICAgcmV0dXJuICh4UG9pbnRzICE9PSAwICYmIHhQb2ludHMgJSAyID09PSAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIG9iamVjdCBpcyBjb250YWluZWQgd2l0aGluIHRoZSBjYW52YXMgd2l0aCBjdXJyZW50IHZpZXdwb3J0VHJhbnNmb3JtXG4gICAgICogdGhlIGNoZWNrIGlzIGRvbmUgc3RvcHBpbmcgYXQgZmlyc3QgcG9pbnQgdGhhdCBhcHBlYXJzIG9uIHNjcmVlblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NhbGN1bGF0ZV0gdXNlIGNvb3JkaW5hdGVzIG9mIGN1cnJlbnQgcG9zaXRpb24gaW5zdGVhZCBvZiAuYUNvb3Jkc1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgb2JqZWN0IGlzIGZ1bGx5IG9yIHBhcnRpYWxseSBjb250YWluZWQgd2l0aGluIGNhbnZhc1xuICAgICAqL1xuICAgIGlzT25TY3JlZW46IGZ1bmN0aW9uKGNhbGN1bGF0ZSkge1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcG9pbnRUTCA9IHRoaXMuY2FudmFzLnZwdENvb3Jkcy50bCwgcG9pbnRCUiA9IHRoaXMuY2FudmFzLnZwdENvb3Jkcy5icjtcbiAgICAgIHZhciBwb2ludHMgPSB0aGlzLmdldENvb3Jkcyh0cnVlLCBjYWxjdWxhdGUpO1xuICAgICAgLy8gaWYgc29tZSBwb2ludCBpcyBvbiBzY3JlZW4sIHRoZSBvYmplY3QgaXMgb24gc2NyZWVuLlxuICAgICAgaWYgKHBvaW50cy5zb21lKGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHJldHVybiBwb2ludC54IDw9IHBvaW50QlIueCAmJiBwb2ludC54ID49IHBvaW50VEwueCAmJlxuICAgICAgICBwb2ludC55IDw9IHBvaW50QlIueSAmJiBwb2ludC55ID49IHBvaW50VEwueTtcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gbm8gcG9pbnRzIG9uIHNjcmVlbiwgY2hlY2sgaW50ZXJzZWN0aW9uIHdpdGggYWJzb2x1dGUgY29vcmRpbmF0ZXNcbiAgICAgIGlmICh0aGlzLmludGVyc2VjdHNXaXRoUmVjdChwb2ludFRMLCBwb2ludEJSLCB0cnVlLCBjYWxjdWxhdGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5zQ2VudGVyT2ZDYW52YXMocG9pbnRUTCwgcG9pbnRCUiwgY2FsY3VsYXRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBvYmplY3QgY29udGFpbnMgdGhlIG1pZHBvaW50IGJldHdlZW4gY2FudmFzIGV4dHJlbWl0aWVzXG4gICAgICogRG9lcyBub3QgbWFrZSBzZW5zZSBvdXRzaWRlIHRoZSBjb250ZXh0IG9mIGlzT25TY3JlZW4gYW5kIGlzUGFydGlhbGx5T25TY3JlZW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RmFicmljLlBvaW50fSBwb2ludFRMIFRvcCBMZWZ0IHBvaW50XG4gICAgICogQHBhcmFtIHtGYWJyaWMuUG9pbnR9IHBvaW50QlIgVG9wIFJpZ2h0IHBvaW50XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjYWxjdWxhdGUgdXNlIGNvb3JkaW5hdGVzIG9mIGN1cnJlbnQgcG9zaXRpb24gaW5zdGVhZCBvZiAub0Nvb3Jkc1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIG9iamVjdCBjb250YWlucyB0aGUgcG9pbnRcbiAgICAgKi9cbiAgICBfY29udGFpbnNDZW50ZXJPZkNhbnZhczogZnVuY3Rpb24ocG9pbnRUTCwgcG9pbnRCUiwgY2FsY3VsYXRlKSB7XG4gICAgICAvLyB3b3JzdCBjYXNlIHNjZW5hcmlvIHRoZSBvYmplY3QgaXMgc28gYmlnIHRoYXQgY29udGFpbnMgdGhlIHNjcmVlblxuICAgICAgdmFyIGNlbnRlclBvaW50ID0geyB4OiAocG9pbnRUTC54ICsgcG9pbnRCUi54KSAvIDIsIHk6IChwb2ludFRMLnkgKyBwb2ludEJSLnkpIC8gMiB9O1xuICAgICAgaWYgKHRoaXMuY29udGFpbnNQb2ludChjZW50ZXJQb2ludCwgbnVsbCwgdHJ1ZSwgY2FsY3VsYXRlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIG9iamVjdCBpcyBwYXJ0aWFsbHkgY29udGFpbmVkIHdpdGhpbiB0aGUgY2FudmFzIHdpdGggY3VycmVudCB2aWV3cG9ydFRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NhbGN1bGF0ZV0gdXNlIGNvb3JkaW5hdGVzIG9mIGN1cnJlbnQgcG9zaXRpb24gaW5zdGVhZCBvZiAub0Nvb3Jkc1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgb2JqZWN0IGlzIHBhcnRpYWxseSBjb250YWluZWQgd2l0aGluIGNhbnZhc1xuICAgICAqL1xuICAgIGlzUGFydGlhbGx5T25TY3JlZW46IGZ1bmN0aW9uKGNhbGN1bGF0ZSkge1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcG9pbnRUTCA9IHRoaXMuY2FudmFzLnZwdENvb3Jkcy50bCwgcG9pbnRCUiA9IHRoaXMuY2FudmFzLnZwdENvb3Jkcy5icjtcbiAgICAgIGlmICh0aGlzLmludGVyc2VjdHNXaXRoUmVjdChwb2ludFRMLCBwb2ludEJSLCB0cnVlLCBjYWxjdWxhdGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIGFsbFBvaW50c0FyZU91dHNpZGUgPSB0aGlzLmdldENvb3Jkcyh0cnVlLCBjYWxjdWxhdGUpLmV2ZXJ5KGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHJldHVybiAocG9pbnQueCA+PSBwb2ludEJSLnggfHwgcG9pbnQueCA8PSBwb2ludFRMLngpICYmXG4gICAgICAgIChwb2ludC55ID49IHBvaW50QlIueSB8fCBwb2ludC55IDw9IHBvaW50VEwueSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhbGxQb2ludHNBcmVPdXRzaWRlICYmIHRoaXMuX2NvbnRhaW5zQ2VudGVyT2ZDYW52YXMocG9pbnRUTCwgcG9pbnRCUiwgY2FsY3VsYXRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgb2JqZWN0IGVkZ2VzIGluIGl0LCBnaXZlbiB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGNvcm5lcnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvQ29vcmRzIENvb3JkaW5hdGVzIG9mIHRoZSBvYmplY3QgY29ybmVyc1xuICAgICAqL1xuICAgIF9nZXRJbWFnZUxpbmVzOiBmdW5jdGlvbihvQ29vcmRzKSB7XG5cbiAgICAgIHZhciBsaW5lcyA9IHtcbiAgICAgICAgdG9wbGluZToge1xuICAgICAgICAgIG86IG9Db29yZHMudGwsXG4gICAgICAgICAgZDogb0Nvb3Jkcy50clxuICAgICAgICB9LFxuICAgICAgICByaWdodGxpbmU6IHtcbiAgICAgICAgICBvOiBvQ29vcmRzLnRyLFxuICAgICAgICAgIGQ6IG9Db29yZHMuYnJcbiAgICAgICAgfSxcbiAgICAgICAgYm90dG9tbGluZToge1xuICAgICAgICAgIG86IG9Db29yZHMuYnIsXG4gICAgICAgICAgZDogb0Nvb3Jkcy5ibFxuICAgICAgICB9LFxuICAgICAgICBsZWZ0bGluZToge1xuICAgICAgICAgIG86IG9Db29yZHMuYmwsXG4gICAgICAgICAgZDogb0Nvb3Jkcy50bFxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyAvLyBkZWJ1Z2dpbmdcbiAgICAgIC8vIGlmICh0aGlzLmNhbnZhcy5jb250ZXh0VG9wKSB7XG4gICAgICAvLyAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMuYm90dG9tbGluZS5kLngsIGxpbmVzLmJvdHRvbWxpbmUuZC55LCAyLCAyKTtcbiAgICAgIC8vICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5ib3R0b21saW5lLm8ueCwgbGluZXMuYm90dG9tbGluZS5vLnksIDIsIDIpO1xuICAgICAgLy9cbiAgICAgIC8vICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5sZWZ0bGluZS5kLngsIGxpbmVzLmxlZnRsaW5lLmQueSwgMiwgMik7XG4gICAgICAvLyAgIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMubGVmdGxpbmUuby54LCBsaW5lcy5sZWZ0bGluZS5vLnksIDIsIDIpO1xuICAgICAgLy9cbiAgICAgIC8vICAgdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy50b3BsaW5lLmQueCwgbGluZXMudG9wbGluZS5kLnksIDIsIDIpO1xuICAgICAgLy8gICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLnRvcGxpbmUuby54LCBsaW5lcy50b3BsaW5lLm8ueSwgMiwgMik7XG4gICAgICAvL1xuICAgICAgLy8gICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLnJpZ2h0bGluZS5kLngsIGxpbmVzLnJpZ2h0bGluZS5kLnksIDIsIDIpO1xuICAgICAgLy8gICB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLnJpZ2h0bGluZS5vLngsIGxpbmVzLnJpZ2h0bGluZS5vLnksIDIsIDIpO1xuICAgICAgLy8gfVxuXG4gICAgICByZXR1cm4gbGluZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gZGV0ZXJtaW5lIGhvdyBtYW55IGNyb3NzIHBvaW50cyBhcmUgYmV0d2VlbiB0aGUgNCBvYmplY3QgZWRnZXNcbiAgICAgKiBhbmQgdGhlIGhvcml6b250YWwgbGluZSBkZXRlcm1pbmVkIGJ5IGEgcG9pbnQgb24gY2FudmFzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gcG9pbnQgUG9pbnQgdG8gY2hlY2tcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbGluZXMgQ29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCBiZWluZyBldmFsdWF0ZWRcbiAgICAgKi9cbiAgICAvLyByZW1vdmUgeWksIG5vdCB1c2VkIGJ1dCBsZWZ0IGNvZGUgaGVyZSBqdXN0IGluIGNhc2UuXG4gICAgX2ZpbmRDcm9zc1BvaW50czogZnVuY3Rpb24ocG9pbnQsIGxpbmVzKSB7XG4gICAgICB2YXIgYjEsIGIyLCBhMSwgYTIsIHhpLCAvLyB5aSxcbiAgICAgICAgICB4Y291bnQgPSAwLFxuICAgICAgICAgIGlMaW5lO1xuXG4gICAgICBmb3IgKHZhciBsaW5lS2V5IGluIGxpbmVzKSB7XG4gICAgICAgIGlMaW5lID0gbGluZXNbbGluZUtleV07XG4gICAgICAgIC8vIG9wdGltaXNhdGlvbiAxOiBsaW5lIGJlbG93IHBvaW50LiBubyBjcm9zc1xuICAgICAgICBpZiAoKGlMaW5lLm8ueSA8IHBvaW50LnkpICYmIChpTGluZS5kLnkgPCBwb2ludC55KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9wdGltaXNhdGlvbiAyOiBsaW5lIGFib3ZlIHBvaW50LiBubyBjcm9zc1xuICAgICAgICBpZiAoKGlMaW5lLm8ueSA+PSBwb2ludC55KSAmJiAoaUxpbmUuZC55ID49IHBvaW50LnkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3B0aW1pc2F0aW9uIDM6IHZlcnRpY2FsIGxpbmUgY2FzZVxuICAgICAgICBpZiAoKGlMaW5lLm8ueCA9PT0gaUxpbmUuZC54KSAmJiAoaUxpbmUuby54ID49IHBvaW50LngpKSB7XG4gICAgICAgICAgeGkgPSBpTGluZS5vLng7XG4gICAgICAgICAgLy8geWkgPSBwb2ludC55O1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgaW50ZXJzZWN0aW9uIHBvaW50XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGIxID0gMDtcbiAgICAgICAgICBiMiA9IChpTGluZS5kLnkgLSBpTGluZS5vLnkpIC8gKGlMaW5lLmQueCAtIGlMaW5lLm8ueCk7XG4gICAgICAgICAgYTEgPSBwb2ludC55IC0gYjEgKiBwb2ludC54O1xuICAgICAgICAgIGEyID0gaUxpbmUuby55IC0gYjIgKiBpTGluZS5vLng7XG5cbiAgICAgICAgICB4aSA9IC0oYTEgLSBhMikgLyAoYjEgLSBiMik7XG4gICAgICAgICAgLy8geWkgPSBhMSArIGIxICogeGk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9udCBjb3VudCB4aSA8IHBvaW50LnggY2FzZXNcbiAgICAgICAgaWYgKHhpID49IHBvaW50LngpIHtcbiAgICAgICAgICB4Y291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvcHRpbWlzYXRpb24gNDogc3BlY2lmaWMgZm9yIHNxdWFyZSBpbWFnZXNcbiAgICAgICAgaWYgKHhjb3VudCA9PT0gMikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geGNvdW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvb3JkaW5hdGVzIG9mIG9iamVjdCdzIGJvdW5kaW5nIHJlY3RhbmdsZSAobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KVxuICAgICAqIHRoZSBib3ggaXMgaW50ZW5kZWQgYXMgYWxpZ25lZCB0byBheGlzIG9mIGNhbnZhcy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthYnNvbHV0ZV0gdXNlIGNvb3JkaW5hdGVzIHdpdGhvdXQgdmlld3BvcnRUcmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYWxjdWxhdGVdIHVzZSBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvc2l0aW9uIGluc3RlYWQgb2YgLm9Db29yZHMgLyAuYUNvb3Jkc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHdpdGggbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uKGFic29sdXRlLCBjYWxjdWxhdGUpIHtcbiAgICAgIHZhciBjb29yZHMgPSB0aGlzLmdldENvb3JkcyhhYnNvbHV0ZSwgY2FsY3VsYXRlKTtcbiAgICAgIHJldHVybiB1dGlsLm1ha2VCb3VuZGluZ0JveEZyb21Qb2ludHMoY29vcmRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aWR0aCBvZiBhbiBvYmplY3QncyBib3VuZGluZyBib3ggY291bnRpbmcgdHJhbnNmb3JtYXRpb25zXG4gICAgICogYmVmb3JlIDIuMCBpdCB3YXMgbmFtZWQgZ2V0V2lkdGgoKTtcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHdpZHRoIHZhbHVlXG4gICAgICovXG4gICAgZ2V0U2NhbGVkV2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpLng7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaGVpZ2h0IG9mIGFuIG9iamVjdCBib3VuZGluZyBib3ggY291bnRpbmcgdHJhbnNmb3JtYXRpb25zXG4gICAgICogYmVmb3JlIDIuMCBpdCB3YXMgbmFtZWQgZ2V0SGVpZ2h0KCk7XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBoZWlnaHQgdmFsdWVcbiAgICAgKi9cbiAgICBnZXRTY2FsZWRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpLnk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2VzIHN1cmUgdGhlIHNjYWxlIGlzIHZhbGlkIGFuZCBtb2RpZmllcyBpdCBpZiBuZWNlc3NhcnlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBfY29uc3RyYWluU2NhbGU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoTWF0aC5hYnModmFsdWUpIDwgdGhpcy5taW5TY2FsZUxpbWl0KSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgICByZXR1cm4gLXRoaXMubWluU2NhbGVMaW1pdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5taW5TY2FsZUxpbWl0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMC4wMDAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZXMgYW4gb2JqZWN0IChlcXVhbGx5IGJ5IHggYW5kIHkpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFNjYWxlIGZhY3RvclxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2NhbGU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB0aGlzLl9zZXQoJ3NjYWxlWCcsIHZhbHVlKTtcbiAgICAgIHRoaXMuX3NldCgnc2NhbGVZJywgdmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlcyBhbiBvYmplY3QgdG8gYSBnaXZlbiB3aWR0aCwgd2l0aCByZXNwZWN0IHRvIGJvdW5kaW5nIGJveCAoc2NhbGluZyBieSB4L3kgZXF1YWxseSlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgTmV3IHdpZHRoIHZhbHVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhYnNvbHV0ZSBpZ25vcmUgdmlld3BvcnRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNjYWxlVG9XaWR0aDogZnVuY3Rpb24odmFsdWUsIGFic29sdXRlKSB7XG4gICAgICAvLyBhZGp1c3QgdG8gYm91bmRpbmcgcmVjdCBmYWN0b3Igc28gdGhhdCByb3RhdGVkIHNoYXBlcyB3b3VsZCBmaXQgYXMgd2VsbFxuICAgICAgdmFyIGJvdW5kaW5nUmVjdEZhY3RvciA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KGFic29sdXRlKS53aWR0aCAvIHRoaXMuZ2V0U2NhbGVkV2lkdGgoKTtcbiAgICAgIHJldHVybiB0aGlzLnNjYWxlKHZhbHVlIC8gdGhpcy53aWR0aCAvIGJvdW5kaW5nUmVjdEZhY3Rvcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlcyBhbiBvYmplY3QgdG8gYSBnaXZlbiBoZWlnaHQsIHdpdGggcmVzcGVjdCB0byBib3VuZGluZyBib3ggKHNjYWxpbmcgYnkgeC95IGVxdWFsbHkpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIE5ldyBoZWlnaHQgdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFic29sdXRlIGlnbm9yZSB2aWV3cG9ydFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2NhbGVUb0hlaWdodDogZnVuY3Rpb24odmFsdWUsIGFic29sdXRlKSB7XG4gICAgICAvLyBhZGp1c3QgdG8gYm91bmRpbmcgcmVjdCBmYWN0b3Igc28gdGhhdCByb3RhdGVkIHNoYXBlcyB3b3VsZCBmaXQgYXMgd2VsbFxuICAgICAgdmFyIGJvdW5kaW5nUmVjdEZhY3RvciA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KGFic29sdXRlKS5oZWlnaHQgLyB0aGlzLmdldFNjYWxlZEhlaWdodCgpO1xuICAgICAgcmV0dXJuIHRoaXMuc2NhbGUodmFsdWUgLyB0aGlzLmhlaWdodCAvIGJvdW5kaW5nUmVjdEZhY3Rvcik7XG4gICAgfSxcblxuICAgIGNhbGNMaW5lQ29vcmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2cHQgPSB0aGlzLmdldFZpZXdwb3J0VHJhbnNmb3JtKCksXG4gICAgICAgICAgcGFkZGluZyA9IHRoaXMucGFkZGluZywgYW5nbGUgPSBkZWdyZWVzVG9SYWRpYW5zKHRoaXMuYW5nbGUpLFxuICAgICAgICAgIGNvcyA9IHV0aWwuY29zKGFuZ2xlKSwgc2luID0gdXRpbC5zaW4oYW5nbGUpLFxuICAgICAgICAgIGNvc1AgPSBjb3MgKiBwYWRkaW5nLCBzaW5QID0gc2luICogcGFkZGluZywgY29zUFNpblAgPSBjb3NQICsgc2luUCxcbiAgICAgICAgICBjb3NQTWludXNTaW5QID0gY29zUCAtIHNpblAsIGFDb29yZHMgPSB0aGlzLmNhbGNBQ29vcmRzKCk7XG5cbiAgICAgIHZhciBsaW5lQ29vcmRzID0ge1xuICAgICAgICB0bDogdHJhbnNmb3JtUG9pbnQoYUNvb3Jkcy50bCwgdnB0KSxcbiAgICAgICAgdHI6IHRyYW5zZm9ybVBvaW50KGFDb29yZHMudHIsIHZwdCksXG4gICAgICAgIGJsOiB0cmFuc2Zvcm1Qb2ludChhQ29vcmRzLmJsLCB2cHQpLFxuICAgICAgICBicjogdHJhbnNmb3JtUG9pbnQoYUNvb3Jkcy5iciwgdnB0KSxcbiAgICAgIH07XG5cbiAgICAgIGlmIChwYWRkaW5nKSB7XG4gICAgICAgIGxpbmVDb29yZHMudGwueCAtPSBjb3NQTWludXNTaW5QO1xuICAgICAgICBsaW5lQ29vcmRzLnRsLnkgLT0gY29zUFNpblA7XG4gICAgICAgIGxpbmVDb29yZHMudHIueCArPSBjb3NQU2luUDtcbiAgICAgICAgbGluZUNvb3Jkcy50ci55IC09IGNvc1BNaW51c1NpblA7XG4gICAgICAgIGxpbmVDb29yZHMuYmwueCAtPSBjb3NQU2luUDtcbiAgICAgICAgbGluZUNvb3Jkcy5ibC55ICs9IGNvc1BNaW51c1NpblA7XG4gICAgICAgIGxpbmVDb29yZHMuYnIueCArPSBjb3NQTWludXNTaW5QO1xuICAgICAgICBsaW5lQ29vcmRzLmJyLnkgKz0gY29zUFNpblA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsaW5lQ29vcmRzO1xuICAgIH0sXG5cbiAgICBjYWxjT0Nvb3JkczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcm90YXRlTWF0cml4ID0gdGhpcy5fY2FsY1JvdGF0ZU1hdHJpeCgpLFxuICAgICAgICAgIHRyYW5zbGF0ZU1hdHJpeCA9IHRoaXMuX2NhbGNUcmFuc2xhdGVNYXRyaXgoKSxcbiAgICAgICAgICB2cHQgPSB0aGlzLmdldFZpZXdwb3J0VHJhbnNmb3JtKCksXG4gICAgICAgICAgc3RhcnRNYXRyaXggPSBtdWx0aXBseU1hdHJpY2VzKHZwdCwgdHJhbnNsYXRlTWF0cml4KSxcbiAgICAgICAgICBmaW5hbE1hdHJpeCA9IG11bHRpcGx5TWF0cmljZXMoc3RhcnRNYXRyaXgsIHJvdGF0ZU1hdHJpeCksXG4gICAgICAgICAgZmluYWxNYXRyaXggPSBtdWx0aXBseU1hdHJpY2VzKGZpbmFsTWF0cml4LCBbMSAvIHZwdFswXSwgMCwgMCwgMSAvIHZwdFszXSwgMCwgMF0pLFxuICAgICAgICAgIGRpbSA9IHRoaXMuX2NhbGN1bGF0ZUN1cnJlbnREaW1lbnNpb25zKCksXG4gICAgICAgICAgY29vcmRzID0ge307XG4gICAgICB0aGlzLmZvckVhY2hDb250cm9sKGZ1bmN0aW9uKGNvbnRyb2wsIGtleSwgZmFicmljT2JqZWN0KSB7XG4gICAgICAgIGNvb3Jkc1trZXldID0gY29udHJvbC5wb3NpdGlvbkhhbmRsZXIoZGltLCBmaW5hbE1hdHJpeCwgZmFicmljT2JqZWN0KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBkZWJ1ZyBjb2RlXG4gICAgICAvLyB2YXIgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICAvLyBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgLy8gICBjYW52YXMuY29udGV4dFRvcC5jbGVhclJlY3QoMCwgMCwgNzAwLCA3MDApO1xuICAgICAgLy8gICBjYW52YXMuY29udGV4dFRvcC5maWxsU3R5bGUgPSAnZ3JlZW4nO1xuICAgICAgLy8gICBPYmplY3Qua2V5cyhjb29yZHMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAvLyAgICAgdmFyIGNvbnRyb2wgPSBjb29yZHNba2V5XTtcbiAgICAgIC8vICAgICBjYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChjb250cm9sLngsIGNvbnRyb2wueSwgMywgMyk7XG4gICAgICAvLyAgIH0pO1xuICAgICAgLy8gfSwgNTApO1xuICAgICAgcmV0dXJuIGNvb3JkcztcbiAgICB9LFxuXG4gICAgY2FsY0FDb29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJvdGF0ZU1hdHJpeCA9IHRoaXMuX2NhbGNSb3RhdGVNYXRyaXgoKSxcbiAgICAgICAgICB0cmFuc2xhdGVNYXRyaXggPSB0aGlzLl9jYWxjVHJhbnNsYXRlTWF0cml4KCksXG4gICAgICAgICAgZmluYWxNYXRyaXggPSBtdWx0aXBseU1hdHJpY2VzKHRyYW5zbGF0ZU1hdHJpeCwgcm90YXRlTWF0cml4KSxcbiAgICAgICAgICBkaW0gPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZERpbWVuc2lvbnMoKSxcbiAgICAgICAgICB3ID0gZGltLnggLyAyLCBoID0gZGltLnkgLyAyO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLy8gY29ybmVyc1xuICAgICAgICB0bDogdHJhbnNmb3JtUG9pbnQoeyB4OiAtdywgeTogLWggfSwgZmluYWxNYXRyaXgpLFxuICAgICAgICB0cjogdHJhbnNmb3JtUG9pbnQoeyB4OiB3LCB5OiAtaCB9LCBmaW5hbE1hdHJpeCksXG4gICAgICAgIGJsOiB0cmFuc2Zvcm1Qb2ludCh7IHg6IC13LCB5OiBoIH0sIGZpbmFsTWF0cml4KSxcbiAgICAgICAgYnI6IHRyYW5zZm9ybVBvaW50KHsgeDogdywgeTogaCB9LCBmaW5hbE1hdHJpeClcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgY29ybmVyIGFuZCBjb250cm9scyBwb3NpdGlvbiBjb29yZGluYXRlcyBiYXNlZCBvbiBjdXJyZW50IGFuZ2xlLCB3aWR0aCBhbmQgaGVpZ2h0LCBsZWZ0IGFuZCB0b3AuXG4gICAgICogb0Nvb3JkcyBhcmUgdXNlZCB0byBmaW5kIHRoZSBjb3JuZXJzXG4gICAgICogYUNvb3JkcyBhcmUgdXNlZCB0byBxdWlja2x5IGZpbmQgYW4gb2JqZWN0IG9uIHRoZSBjYW52YXNcbiAgICAgKiBsaW5lQ29vcmRzIGFyZSB1c2VkIHRvIHF1aWNrbHkgZmluZCBvYmplY3QgZHVyaW5nIHBvaW50ZXIgZXZlbnRzLlxuICAgICAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2ZhYnJpY2pzL2ZhYnJpYy5qcy93aWtpL1doZW4tdG8tY2FsbC1zZXRDb29yZHN9IGFuZCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtZ290Y2hhc31cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBDb3JuZXJzXSBza2lwIGNhbGN1bGF0aW9uIG9mIG9Db29yZHMuXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRDb29yZHM6IGZ1bmN0aW9uKHNraXBDb3JuZXJzKSB7XG4gICAgICB0aGlzLmFDb29yZHMgPSB0aGlzLmNhbGNBQ29vcmRzKCk7XG4gICAgICAvLyBpbiBjYXNlIHdlIGFyZSBpbiBhIGdyb3VwLCBmb3IgaG93IHRoZSBpbm5lciBncm91cCB0YXJnZXQgY2hlY2sgd29ya3MsXG4gICAgICAvLyBsaW5lQ29vcmRzIGFyZSBleGFjdGx5IGFDb29yZHMuIFNpbmNlIHRoZSB2cHQgZ2V0cyBhYnNvcmJlZCBieSB0aGUgbm9ybWFsaXplZCBwb2ludGVyLlxuICAgICAgdGhpcy5saW5lQ29vcmRzID0gdGhpcy5ncm91cCA/IHRoaXMuYUNvb3JkcyA6IHRoaXMuY2FsY0xpbmVDb29yZHMoKTtcbiAgICAgIGlmIChza2lwQ29ybmVycykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIC8vIHNldCBjb29yZGluYXRlcyBvZiB0aGUgZHJhZ2dhYmxlIGJveGVzIGluIHRoZSBjb3JuZXJzIHVzZWQgdG8gc2NhbGUvcm90YXRlIHRoZSBpbWFnZVxuICAgICAgdGhpcy5vQ29vcmRzID0gdGhpcy5jYWxjT0Nvb3JkcygpO1xuICAgICAgdGhpcy5fc2V0Q29ybmVyQ29vcmRzICYmIHRoaXMuX3NldENvcm5lckNvb3JkcygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSByb3RhdGlvbiBtYXRyaXggb2YgYW4gb2JqZWN0XG4gICAgICogQHJldHVybiB7QXJyYXl9IHJvdGF0aW9uIG1hdHJpeCBmb3IgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIF9jYWxjUm90YXRlTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB1dGlsLmNhbGNSb3RhdGVNYXRyaXgodGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZSB0aGUgdHJhbnNsYXRpb24gbWF0cml4IGZvciBhbiBvYmplY3QgdHJhbnNmb3JtXG4gICAgICogQHJldHVybiB7QXJyYXl9IHJvdGF0aW9uIG1hdHJpeCBmb3IgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIF9jYWxjVHJhbnNsYXRlTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlclBvaW50KCk7XG4gICAgICByZXR1cm4gWzEsIDAsIDAsIDEsIGNlbnRlci54LCBjZW50ZXIueV07XG4gICAgfSxcblxuICAgIHRyYW5zZm9ybU1hdHJpeEtleTogZnVuY3Rpb24oc2tpcEdyb3VwKSB7XG4gICAgICB2YXIgc2VwID0gJ18nLCBwcmVmaXggPSAnJztcbiAgICAgIGlmICghc2tpcEdyb3VwICYmIHRoaXMuZ3JvdXApIHtcbiAgICAgICAgcHJlZml4ID0gdGhpcy5ncm91cC50cmFuc2Zvcm1NYXRyaXhLZXkoc2tpcEdyb3VwKSArIHNlcDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcHJlZml4ICsgdGhpcy50b3AgKyBzZXAgKyB0aGlzLmxlZnQgKyBzZXAgKyB0aGlzLnNjYWxlWCArIHNlcCArIHRoaXMuc2NhbGVZICtcbiAgICAgICAgc2VwICsgdGhpcy5za2V3WCArIHNlcCArIHRoaXMuc2tld1kgKyBzZXAgKyB0aGlzLmFuZ2xlICsgc2VwICsgdGhpcy5vcmlnaW5YICsgc2VwICsgdGhpcy5vcmlnaW5ZICtcbiAgICAgICAgc2VwICsgdGhpcy53aWR0aCArIHNlcCArIHRoaXMuaGVpZ2h0ICsgc2VwICsgdGhpcy5zdHJva2VXaWR0aCArIHRoaXMuZmxpcFggKyB0aGlzLmZsaXBZO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGUgdHJhbnNmb3JtIG1hdHJpeCB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb25zIGZyb20gdGhlXG4gICAgICogb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtza2lwR3JvdXBdIHJldHVybiB0cmFuc2Zvcm0gbWF0cml4IGZvciBvYmplY3Qgbm90IGNvdW50aW5nIHBhcmVudCB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgKiBUaGVyZSBhcmUgc29tZSBzaXR1YXRpb24gaW4gd2hpY2ggdGhpcyBpcyB1c2VmdWwgdG8gYXZvaWQgdGhlIGZha2Ugcm90YXRpb24uXG4gICAgICogQHJldHVybiB7QXJyYXl9IHRyYW5zZm9ybSBtYXRyaXggZm9yIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBjYWxjVHJhbnNmb3JtTWF0cml4OiBmdW5jdGlvbihza2lwR3JvdXApIHtcbiAgICAgIHZhciBtYXRyaXggPSB0aGlzLmNhbGNPd25NYXRyaXgoKTtcbiAgICAgIGlmIChza2lwR3JvdXAgfHwgIXRoaXMuZ3JvdXApIHtcbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB0aGlzLnRyYW5zZm9ybU1hdHJpeEtleShza2lwR3JvdXApLCBjYWNoZSA9IHRoaXMubWF0cml4Q2FjaGUgfHwgKHRoaXMubWF0cml4Q2FjaGUgPSB7fSk7XG4gICAgICBpZiAoY2FjaGUua2V5ID09PSBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlLnZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZ3JvdXApIHtcbiAgICAgICAgbWF0cml4ID0gbXVsdGlwbHlNYXRyaWNlcyh0aGlzLmdyb3VwLmNhbGNUcmFuc2Zvcm1NYXRyaXgoZmFsc2UpLCBtYXRyaXgpO1xuICAgICAgfVxuICAgICAgY2FjaGUua2V5ID0ga2V5O1xuICAgICAgY2FjaGUudmFsdWUgPSBtYXRyaXg7XG4gICAgICByZXR1cm4gbWF0cml4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGUgdHJhbnNmb3JtIG1hdHJpeCB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb25zIGZyb20gdGhlXG4gICAgICogb2JqZWN0J3MgcHJvcGVydGllcywgdGhpcyBtYXRyaXggZG9lcyBub3QgaW5jbHVkZSB0aGUgZ3JvdXAgdHJhbnNmb3JtYXRpb25cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gdHJhbnNmb3JtIG1hdHJpeCBmb3IgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIGNhbGNPd25NYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGtleSA9IHRoaXMudHJhbnNmb3JtTWF0cml4S2V5KHRydWUpLCBjYWNoZSA9IHRoaXMub3duTWF0cml4Q2FjaGUgfHwgKHRoaXMub3duTWF0cml4Q2FjaGUgPSB7fSk7XG4gICAgICBpZiAoY2FjaGUua2V5ID09PSBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlLnZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIHRNYXRyaXggPSB0aGlzLl9jYWxjVHJhbnNsYXRlTWF0cml4KCksXG4gICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGFuZ2xlOiB0aGlzLmFuZ2xlLFxuICAgICAgICAgICAgdHJhbnNsYXRlWDogdE1hdHJpeFs0XSxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVk6IHRNYXRyaXhbNV0sXG4gICAgICAgICAgICBzY2FsZVg6IHRoaXMuc2NhbGVYLFxuICAgICAgICAgICAgc2NhbGVZOiB0aGlzLnNjYWxlWSxcbiAgICAgICAgICAgIHNrZXdYOiB0aGlzLnNrZXdYLFxuICAgICAgICAgICAgc2tld1k6IHRoaXMuc2tld1ksXG4gICAgICAgICAgICBmbGlwWDogdGhpcy5mbGlwWCxcbiAgICAgICAgICAgIGZsaXBZOiB0aGlzLmZsaXBZLFxuICAgICAgICAgIH07XG4gICAgICBjYWNoZS5rZXkgPSBrZXk7XG4gICAgICBjYWNoZS52YWx1ZSA9IHV0aWwuY29tcG9zZU1hdHJpeChvcHRpb25zKTtcbiAgICAgIHJldHVybiBjYWNoZS52YWx1ZTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBDYWxjdWxhdGUgb2JqZWN0IGRpbWVuc2lvbnMgZnJvbSBpdHMgcHJvcGVydGllc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAueCB3aWR0aCBkaW1lbnNpb25cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IC55IGhlaWdodCBkaW1lbnNpb25cbiAgICAgKi9cbiAgICBfZ2V0Tm9uVHJhbnNmb3JtZWREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdHJva2VXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgdyA9IHRoaXMud2lkdGggKyBzdHJva2VXaWR0aCxcbiAgICAgICAgICBoID0gdGhpcy5oZWlnaHQgKyBzdHJva2VXaWR0aDtcbiAgICAgIHJldHVybiB7IHg6IHcsIHk6IGggfTtcbiAgICB9LFxuXG4gICAgLypcbiAgICAgKiBDYWxjdWxhdGUgb2JqZWN0IGJvdW5kaW5nIGJveCBkaW1lbnNpb25zIGZyb20gaXRzIHByb3BlcnRpZXMgc2NhbGUsIHNrZXcuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNrZXdYLCBhIHZhbHVlIHRvIG92ZXJyaWRlIGN1cnJlbnQgc2tld1hcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2tld1ksIGEgdmFsdWUgdG8gb3ZlcnJpZGUgY3VycmVudCBza2V3WVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAueCB3aWR0aCBkaW1lbnNpb25cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IC55IGhlaWdodCBkaW1lbnNpb25cbiAgICAgKi9cbiAgICBfZ2V0VHJhbnNmb3JtZWREaW1lbnNpb25zOiBmdW5jdGlvbihza2V3WCwgc2tld1kpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2tld1ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNrZXdYID0gdGhpcy5za2V3WDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc2tld1kgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNrZXdZID0gdGhpcy5za2V3WTtcbiAgICAgIH1cbiAgICAgIHZhciBkaW1lbnNpb25zLCBkaW1YLCBkaW1ZLFxuICAgICAgICAgIG5vU2tldyA9IHNrZXdYID09PSAwICYmIHNrZXdZID09PSAwO1xuXG4gICAgICBpZiAodGhpcy5zdHJva2VVbmlmb3JtKSB7XG4gICAgICAgIGRpbVggPSB0aGlzLndpZHRoO1xuICAgICAgICBkaW1ZID0gdGhpcy5oZWlnaHQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZGltZW5zaW9ucyA9IHRoaXMuX2dldE5vblRyYW5zZm9ybWVkRGltZW5zaW9ucygpO1xuICAgICAgICBkaW1YID0gZGltZW5zaW9ucy54O1xuICAgICAgICBkaW1ZID0gZGltZW5zaW9ucy55O1xuICAgICAgfVxuICAgICAgaWYgKG5vU2tldykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVEaW1lbnNpb25zKGRpbVggKiB0aGlzLnNjYWxlWCwgZGltWSAqIHRoaXMuc2NhbGVZKTtcbiAgICAgIH1cbiAgICAgIHZhciBiYm94ID0gdXRpbC5zaXplQWZ0ZXJUcmFuc2Zvcm0oZGltWCwgZGltWSwge1xuICAgICAgICBzY2FsZVg6IHRoaXMuc2NhbGVYLFxuICAgICAgICBzY2FsZVk6IHRoaXMuc2NhbGVZLFxuICAgICAgICBza2V3WDogc2tld1gsXG4gICAgICAgIHNrZXdZOiBza2V3WSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplRGltZW5zaW9ucyhiYm94LngsIGJib3gueSk7XG4gICAgfSxcblxuICAgIC8qXG4gICAgICogQ2FsY3VsYXRlIG9iamVjdCBib3VuZGluZyBib3ggZGltZW5zaW9ucyBmcm9tIGl0cyBwcm9wZXJ0aWVzIHNjYWxlLCBza2V3LlxuICAgICAqIEBwYXJhbSBOdW1iZXIgd2lkdGggd2lkdGggb2YgdGhlIGJib3hcbiAgICAgKiBAcGFyYW0gTnVtYmVyIGhlaWdodCBoZWlnaHQgb2YgdGhlIGJib3hcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gLnggZmluYWxpemVkIHdpZHRoIGRpbWVuc2lvblxuICAgICAqIEByZXR1cm4ge09iamVjdH0gLnkgZmluYWxpemVkIGhlaWdodCBkaW1lbnNpb25cbiAgICAgKi9cbiAgICBfZmluYWxpemVEaW1lbnNpb25zOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJva2VVbmlmb3JtID9cbiAgICAgICAgeyB4OiB3aWR0aCArIHRoaXMuc3Ryb2tlV2lkdGgsIHk6IGhlaWdodCArIHRoaXMuc3Ryb2tlV2lkdGggfVxuICAgICAgICA6XG4gICAgICAgIHsgeDogd2lkdGgsIHk6IGhlaWdodCB9O1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIENhbGN1bGF0ZSBvYmplY3QgZGltZW5zaW9ucyBmb3IgY29udHJvbHMgYm94LCBpbmNsdWRpbmcgcGFkZGluZyBhbmQgY2FudmFzIHpvb20uXG4gICAgICogYW5kIGFjdGl2ZSBzZWxlY3Rpb25cbiAgICAgKiBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZUN1cnJlbnREaW1lbnNpb25zOiBmdW5jdGlvbigpICB7XG4gICAgICB2YXIgdnB0ID0gdGhpcy5nZXRWaWV3cG9ydFRyYW5zZm9ybSgpLFxuICAgICAgICAgIGRpbSA9IHRoaXMuX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucygpLFxuICAgICAgICAgIHAgPSB0cmFuc2Zvcm1Qb2ludChkaW0sIHZwdCwgdHJ1ZSk7XG4gICAgICByZXR1cm4gcC5zY2FsYXJBZGQoMiAqIHRoaXMucGFkZGluZyk7XG4gICAgfSxcbiAgfSk7XG59KSgpO1xuXG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLk9iamVjdC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBNb3ZlcyBhbiBvYmplY3QgdG8gdGhlIGJvdHRvbSBvZiB0aGUgc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHNlbmRUb0JhY2s6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5zZW5kVG9CYWNrLmNhbGwodGhpcy5ncm91cCwgdGhpcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICB0aGlzLmNhbnZhcy5zZW5kVG9CYWNrKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgYW4gb2JqZWN0IHRvIHRoZSB0b3Agb2YgdGhlIHN0YWNrIG9mIGRyYXduIG9iamVjdHNcbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmdyb3VwKSB7XG4gICAgICBmYWJyaWMuU3RhdGljQ2FudmFzLnByb3RvdHlwZS5icmluZ1RvRnJvbnQuY2FsbCh0aGlzLmdyb3VwLCB0aGlzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzLmJyaW5nVG9Gcm9udCh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGFuIG9iamVjdCBkb3duIGluIHN0YWNrIG9mIGRyYXduIG9iamVjdHNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbaW50ZXJzZWN0aW5nXSBJZiBgdHJ1ZWAsIHNlbmQgb2JqZWN0IGJlaGluZCBuZXh0IGxvd2VyIGludGVyc2VjdGluZyBvYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuICBzZW5kQmFja3dhcmRzOiBmdW5jdGlvbihpbnRlcnNlY3RpbmcpIHtcbiAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuc2VuZEJhY2t3YXJkcy5jYWxsKHRoaXMuZ3JvdXAsIHRoaXMsIGludGVyc2VjdGluZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICB0aGlzLmNhbnZhcy5zZW5kQmFja3dhcmRzKHRoaXMsIGludGVyc2VjdGluZyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBhbiBvYmplY3QgdXAgaW4gc3RhY2sgb2YgZHJhd24gb2JqZWN0c1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbnRlcnNlY3RpbmddIElmIGB0cnVlYCwgc2VuZCBvYmplY3QgaW4gZnJvbnQgb2YgbmV4dCB1cHBlciBpbnRlcnNlY3Rpbmcgb2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgYnJpbmdGb3J3YXJkOiBmdW5jdGlvbihpbnRlcnNlY3RpbmcpIHtcbiAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUuYnJpbmdGb3J3YXJkLmNhbGwodGhpcy5ncm91cCwgdGhpcywgaW50ZXJzZWN0aW5nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzLmJyaW5nRm9yd2FyZCh0aGlzLCBpbnRlcnNlY3RpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgYW4gb2JqZWN0IHRvIHNwZWNpZmllZCBsZXZlbCBpbiBzdGFjayBvZiBkcmF3biBvYmplY3RzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBOZXcgcG9zaXRpb24gb2Ygb2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICogQGNoYWluYWJsZVxuICAgKi9cbiAgbW92ZVRvOiBmdW5jdGlvbihpbmRleCkge1xuICAgIGlmICh0aGlzLmdyb3VwICYmIHRoaXMuZ3JvdXAudHlwZSAhPT0gJ2FjdGl2ZVNlbGVjdGlvbicpIHtcbiAgICAgIGZhYnJpYy5TdGF0aWNDYW52YXMucHJvdG90eXBlLm1vdmVUby5jYWxsKHRoaXMuZ3JvdXAsIHRoaXMsIGluZGV4KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzLm1vdmVUbyh0aGlzLCBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTtcblxuXG4vKiBfVE9fU1ZHX1NUQVJUXyAqL1xuKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBnZXRTdmdDb2xvclN0cmluZyhwcm9wLCB2YWx1ZSkge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiBwcm9wICsgJzogbm9uZTsgJztcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUudG9MaXZlKSB7XG4gICAgICByZXR1cm4gcHJvcCArICc6IHVybCgjU1ZHSURfJyArIHZhbHVlLmlkICsgJyk7ICc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIGNvbG9yID0gbmV3IGZhYnJpYy5Db2xvcih2YWx1ZSksXG4gICAgICAgICAgc3RyID0gcHJvcCArICc6ICcgKyBjb2xvci50b1JnYigpICsgJzsgJyxcbiAgICAgICAgICBvcGFjaXR5ID0gY29sb3IuZ2V0QWxwaGEoKTtcbiAgICAgIGlmIChvcGFjaXR5ICE9PSAxKSB7XG4gICAgICAgIC8vY2hhbmdlIHRoZSBjb2xvciBpbiByZ2IgKyBvcGFjaXR5XG4gICAgICAgIHN0ciArPSBwcm9wICsgJy1vcGFjaXR5OiAnICsgb3BhY2l0eS50b1N0cmluZygpICsgJzsgJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkO1xuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLk9iamVjdC5wcm90b3R5cGUgKi8ge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3R5bGVzLXN0cmluZyBmb3Igc3ZnLWV4cG9ydFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcFNoYWRvdyBhIGJvb2xlYW4gdG8gc2tpcCBzaGFkb3cgZmlsdGVyIG91dHB1dFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdmdTdHlsZXM6IGZ1bmN0aW9uKHNraXBTaGFkb3cpIHtcblxuICAgICAgdmFyIGZpbGxSdWxlID0gdGhpcy5maWxsUnVsZSA/IHRoaXMuZmlsbFJ1bGUgOiAnbm9uemVybycsXG4gICAgICAgICAgc3Ryb2tlV2lkdGggPSB0aGlzLnN0cm9rZVdpZHRoID8gdGhpcy5zdHJva2VXaWR0aCA6ICcwJyxcbiAgICAgICAgICBzdHJva2VEYXNoQXJyYXkgPSB0aGlzLnN0cm9rZURhc2hBcnJheSA/IHRoaXMuc3Ryb2tlRGFzaEFycmF5LmpvaW4oJyAnKSA6ICdub25lJyxcbiAgICAgICAgICBzdHJva2VEYXNoT2Zmc2V0ID0gdGhpcy5zdHJva2VEYXNoT2Zmc2V0ID8gdGhpcy5zdHJva2VEYXNoT2Zmc2V0IDogJzAnLFxuICAgICAgICAgIHN0cm9rZUxpbmVDYXAgPSB0aGlzLnN0cm9rZUxpbmVDYXAgPyB0aGlzLnN0cm9rZUxpbmVDYXAgOiAnYnV0dCcsXG4gICAgICAgICAgc3Ryb2tlTGluZUpvaW4gPSB0aGlzLnN0cm9rZUxpbmVKb2luID8gdGhpcy5zdHJva2VMaW5lSm9pbiA6ICdtaXRlcicsXG4gICAgICAgICAgc3Ryb2tlTWl0ZXJMaW1pdCA9IHRoaXMuc3Ryb2tlTWl0ZXJMaW1pdCA/IHRoaXMuc3Ryb2tlTWl0ZXJMaW1pdCA6ICc0JyxcbiAgICAgICAgICBvcGFjaXR5ID0gdHlwZW9mIHRoaXMub3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCcgPyB0aGlzLm9wYWNpdHkgOiAnMScsXG4gICAgICAgICAgdmlzaWJpbGl0eSA9IHRoaXMudmlzaWJsZSA/ICcnIDogJyB2aXNpYmlsaXR5OiBoaWRkZW47JyxcbiAgICAgICAgICBmaWx0ZXIgPSBza2lwU2hhZG93ID8gJycgOiB0aGlzLmdldFN2Z0ZpbHRlcigpLFxuICAgICAgICAgIGZpbGwgPSBnZXRTdmdDb2xvclN0cmluZygnZmlsbCcsIHRoaXMuZmlsbCksXG4gICAgICAgICAgc3Ryb2tlID0gZ2V0U3ZnQ29sb3JTdHJpbmcoJ3N0cm9rZScsIHRoaXMuc3Ryb2tlKTtcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgc3Ryb2tlLFxuICAgICAgICAnc3Ryb2tlLXdpZHRoOiAnLCBzdHJva2VXaWR0aCwgJzsgJyxcbiAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXk6ICcsIHN0cm9rZURhc2hBcnJheSwgJzsgJyxcbiAgICAgICAgJ3N0cm9rZS1saW5lY2FwOiAnLCBzdHJva2VMaW5lQ2FwLCAnOyAnLFxuICAgICAgICAnc3Ryb2tlLWRhc2hvZmZzZXQ6ICcsIHN0cm9rZURhc2hPZmZzZXQsICc7ICcsXG4gICAgICAgICdzdHJva2UtbGluZWpvaW46ICcsIHN0cm9rZUxpbmVKb2luLCAnOyAnLFxuICAgICAgICAnc3Ryb2tlLW1pdGVybGltaXQ6ICcsIHN0cm9rZU1pdGVyTGltaXQsICc7ICcsXG4gICAgICAgIGZpbGwsXG4gICAgICAgICdmaWxsLXJ1bGU6ICcsIGZpbGxSdWxlLCAnOyAnLFxuICAgICAgICAnb3BhY2l0eTogJywgb3BhY2l0eSwgJzsnLFxuICAgICAgICBmaWx0ZXIsXG4gICAgICAgIHZpc2liaWxpdHlcbiAgICAgIF0uam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3R5bGVzLXN0cmluZyBmb3Igc3ZnLWV4cG9ydFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZSB0aGUgb2JqZWN0IGZyb20gd2hpY2ggdG8gcmV0cmlldmUgc3R5bGUgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlV2hpdGVTcGFjZSBhIGJvb2xlYW4gdG8gaW5jbHVkZSBhbiBhZGRpdGlvbmFsIGF0dHJpYnV0ZSBpbiB0aGUgc3R5bGUuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN2Z1NwYW5TdHlsZXM6IGZ1bmN0aW9uKHN0eWxlLCB1c2VXaGl0ZVNwYWNlKSB7XG4gICAgICB2YXIgdGVybSA9ICc7ICc7XG4gICAgICB2YXIgZm9udEZhbWlseSA9IHN0eWxlLmZvbnRGYW1pbHkgP1xuICAgICAgICAnZm9udC1mYW1pbHk6ICcgKyAoKChzdHlsZS5mb250RmFtaWx5LmluZGV4T2YoJ1xcJycpID09PSAtMSAmJiBzdHlsZS5mb250RmFtaWx5LmluZGV4T2YoJ1wiJykgPT09IC0xKSA/XG4gICAgICAgICAgJ1xcJycgKyBzdHlsZS5mb250RmFtaWx5ICArICdcXCcnIDogc3R5bGUuZm9udEZhbWlseSkpICsgdGVybSA6ICcnO1xuICAgICAgdmFyIHN0cm9rZVdpZHRoID0gc3R5bGUuc3Ryb2tlV2lkdGggPyAnc3Ryb2tlLXdpZHRoOiAnICsgc3R5bGUuc3Ryb2tlV2lkdGggKyB0ZXJtIDogJycsXG4gICAgICAgICAgZm9udEZhbWlseSA9IGZvbnRGYW1pbHksXG4gICAgICAgICAgZm9udFNpemUgPSBzdHlsZS5mb250U2l6ZSA/ICdmb250LXNpemU6ICcgKyBzdHlsZS5mb250U2l6ZSArICdweCcgKyB0ZXJtIDogJycsXG4gICAgICAgICAgZm9udFN0eWxlID0gc3R5bGUuZm9udFN0eWxlID8gJ2ZvbnQtc3R5bGU6ICcgKyBzdHlsZS5mb250U3R5bGUgKyB0ZXJtIDogJycsXG4gICAgICAgICAgZm9udFdlaWdodCA9IHN0eWxlLmZvbnRXZWlnaHQgPyAnZm9udC13ZWlnaHQ6ICcgKyBzdHlsZS5mb250V2VpZ2h0ICsgdGVybSA6ICcnLFxuICAgICAgICAgIGZpbGwgPSBzdHlsZS5maWxsID8gZ2V0U3ZnQ29sb3JTdHJpbmcoJ2ZpbGwnLCBzdHlsZS5maWxsKSA6ICcnLFxuICAgICAgICAgIHN0cm9rZSA9IHN0eWxlLnN0cm9rZSA/IGdldFN2Z0NvbG9yU3RyaW5nKCdzdHJva2UnLCBzdHlsZS5zdHJva2UpIDogJycsXG4gICAgICAgICAgdGV4dERlY29yYXRpb24gPSB0aGlzLmdldFN2Z1RleHREZWNvcmF0aW9uKHN0eWxlKSxcbiAgICAgICAgICBkZWx0YVkgPSBzdHlsZS5kZWx0YVkgPyAnYmFzZWxpbmUtc2hpZnQ6ICcgKyAoLXN0eWxlLmRlbHRhWSkgKyAnOyAnIDogJyc7XG4gICAgICBpZiAodGV4dERlY29yYXRpb24pIHtcbiAgICAgICAgdGV4dERlY29yYXRpb24gPSAndGV4dC1kZWNvcmF0aW9uOiAnICsgdGV4dERlY29yYXRpb24gKyB0ZXJtO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBzdHJva2UsXG4gICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICBmb250RmFtaWx5LFxuICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgZm9udFN0eWxlLFxuICAgICAgICBmb250V2VpZ2h0LFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbixcbiAgICAgICAgZmlsbCxcbiAgICAgICAgZGVsdGFZLFxuICAgICAgICB1c2VXaGl0ZVNwYWNlID8gJ3doaXRlLXNwYWNlOiBwcmU7ICcgOiAnJ1xuICAgICAgXS5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0ZXh0LWRlY29yYXRpb24gcHJvcGVydHkgZm9yIHN2Zy1leHBvcnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGUgdGhlIG9iamVjdCBmcm9tIHdoaWNoIHRvIHJldHJpZXZlIHN0eWxlIHByb3BlcnRpZXNcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnVGV4dERlY29yYXRpb246IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICByZXR1cm4gWydvdmVybGluZScsICd1bmRlcmxpbmUnLCAnbGluZS10aHJvdWdoJ10uZmlsdGVyKGZ1bmN0aW9uKGRlY29yYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlW2RlY29yYXRpb24ucmVwbGFjZSgnLScsICcnKV07XG4gICAgICB9KS5qb2luKCcgJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZmlsdGVyIGZvciBzdmcgc2hhZG93XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN2Z0ZpbHRlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaGFkb3cgPyAnZmlsdGVyOiB1cmwoI1NWR0lEXycgKyB0aGlzLnNoYWRvdy5pZCArICcpOycgOiAnJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZCBhdHRyaWJ1dGUgZm9yIHN2ZyBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnQ29tbW9uczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB0aGlzLmlkID8gJ2lkPVwiJyArIHRoaXMuaWQgKyAnXCIgJyA6ICcnLFxuICAgICAgICB0aGlzLmNsaXBQYXRoID8gJ2NsaXAtcGF0aD1cInVybCgjJyArIHRoaXMuY2xpcFBhdGguY2xpcFBhdGhJZCArICcpXCIgJyA6ICcnLFxuICAgICAgXS5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cmFuc2Zvcm0tc3RyaW5nIGZvciBzdmctZXhwb3J0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSB1c2UgdGhlIGZ1bGwgdHJhbnNmb3JtIG9yIHRoZSBzaW5nbGUgb2JqZWN0IG9uZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0U3ZnVHJhbnNmb3JtOiBmdW5jdGlvbihmdWxsLCBhZGRpdGlvbmFsVHJhbnNmb3JtKSB7XG4gICAgICB2YXIgdHJhbnNmb3JtID0gZnVsbCA/IHRoaXMuY2FsY1RyYW5zZm9ybU1hdHJpeCgpIDogdGhpcy5jYWxjT3duTWF0cml4KCksXG4gICAgICAgICAgc3ZnVHJhbnNmb3JtID0gJ3RyYW5zZm9ybT1cIicgKyBmYWJyaWMudXRpbC5tYXRyaXhUb1NWRyh0cmFuc2Zvcm0pO1xuICAgICAgcmV0dXJuIHN2Z1RyYW5zZm9ybSArXG4gICAgICAgIChhZGRpdGlvbmFsVHJhbnNmb3JtIHx8ICcnKSArICdcIiAnO1xuICAgIH0sXG5cbiAgICBfc2V0U1ZHQmc6IGZ1bmN0aW9uKHRleHRCZ1JlY3RzKSB7XG4gICAgICBpZiAodGhpcy5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgdmFyIE5VTV9GUkFDVElPTl9ESUdJVFMgPSBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFM7XG4gICAgICAgIHRleHRCZ1JlY3RzLnB1c2goXG4gICAgICAgICAgJ1xcdFxcdDxyZWN0ICcsXG4gICAgICAgICAgdGhpcy5fZ2V0RmlsbEF0dHJpYnV0ZXModGhpcy5iYWNrZ3JvdW5kQ29sb3IpLFxuICAgICAgICAgICcgeD1cIicsXG4gICAgICAgICAgdG9GaXhlZCgtdGhpcy53aWR0aCAvIDIsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICdcIiB5PVwiJyxcbiAgICAgICAgICB0b0ZpeGVkKC10aGlzLmhlaWdodCAvIDIsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAgICdcIiB3aWR0aD1cIicsXG4gICAgICAgICAgdG9GaXhlZCh0aGlzLndpZHRoLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAnXCIgaGVpZ2h0PVwiJyxcbiAgICAgICAgICB0b0ZpeGVkKHRoaXMuaGVpZ2h0LCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgICAnXCI+PC9yZWN0PlxcbicpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUJhc2VTVkdNYXJrdXAodGhpcy5fdG9TVkcocmV2aXZlciksIHsgcmV2aXZlcjogcmV2aXZlciB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgY2xpcFBhdGggcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9DbGlwUGF0aFNWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgcmV0dXJuICdcXHQnICsgdGhpcy5fY3JlYXRlQmFzZUNsaXBQYXRoU1ZHTWFya3VwKHRoaXMuX3RvU1ZHKHJldml2ZXIpLCB7IHJldml2ZXI6IHJldml2ZXIgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZUJhc2VDbGlwUGF0aFNWR01hcmt1cDogZnVuY3Rpb24ob2JqZWN0TWFya3VwLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciByZXZpdmVyID0gb3B0aW9ucy5yZXZpdmVyLFxuICAgICAgICAgIGFkZGl0aW9uYWxUcmFuc2Zvcm0gPSBvcHRpb25zLmFkZGl0aW9uYWxUcmFuc2Zvcm0gfHwgJycsXG4gICAgICAgICAgY29tbW9uUGllY2VzID0gW1xuICAgICAgICAgICAgdGhpcy5nZXRTdmdUcmFuc2Zvcm0odHJ1ZSwgYWRkaXRpb25hbFRyYW5zZm9ybSksXG4gICAgICAgICAgICB0aGlzLmdldFN2Z0NvbW1vbnMoKSxcbiAgICAgICAgICBdLmpvaW4oJycpLFxuICAgICAgICAgIC8vIGluc2VydCBjb21tb25zIGluIHRoZSBtYXJrdXAsIHN0eWxlIGFuZCBzdmdDb21tb25zXG4gICAgICAgICAgaW5kZXggPSBvYmplY3RNYXJrdXAuaW5kZXhPZignQ09NTU9OX1BBUlRTJyk7XG4gICAgICBvYmplY3RNYXJrdXBbaW5kZXhdID0gY29tbW9uUGllY2VzO1xuICAgICAgcmV0dXJuIHJldml2ZXIgPyByZXZpdmVyKG9iamVjdE1hcmt1cC5qb2luKCcnKSkgOiBvYmplY3RNYXJrdXAuam9pbignJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZUJhc2VTVkdNYXJrdXA6IGZ1bmN0aW9uKG9iamVjdE1hcmt1cCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB2YXIgbm9TdHlsZSA9IG9wdGlvbnMubm9TdHlsZSxcbiAgICAgICAgICByZXZpdmVyID0gb3B0aW9ucy5yZXZpdmVyLFxuICAgICAgICAgIHN0eWxlSW5mbyA9IG5vU3R5bGUgPyAnJyA6ICdzdHlsZT1cIicgKyB0aGlzLmdldFN2Z1N0eWxlcygpICsgJ1wiICcsXG4gICAgICAgICAgc2hhZG93SW5mbyA9IG9wdGlvbnMud2l0aFNoYWRvdyA/ICdzdHlsZT1cIicgKyB0aGlzLmdldFN2Z0ZpbHRlcigpICsgJ1wiICcgOiAnJyxcbiAgICAgICAgICBjbGlwUGF0aCA9IHRoaXMuY2xpcFBhdGgsXG4gICAgICAgICAgdmVjdG9yRWZmZWN0ID0gdGhpcy5zdHJva2VVbmlmb3JtID8gJ3ZlY3Rvci1lZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIiAnIDogJycsXG4gICAgICAgICAgYWJzb2x1dGVDbGlwUGF0aCA9IGNsaXBQYXRoICYmIGNsaXBQYXRoLmFic29sdXRlUG9zaXRpb25lZCxcbiAgICAgICAgICBzdHJva2UgPSB0aGlzLnN0cm9rZSwgZmlsbCA9IHRoaXMuZmlsbCwgc2hhZG93ID0gdGhpcy5zaGFkb3csXG4gICAgICAgICAgY29tbW9uUGllY2VzLCBtYXJrdXAgPSBbXSwgY2xpcFBhdGhNYXJrdXAsXG4gICAgICAgICAgLy8gaW5zZXJ0IGNvbW1vbnMgaW4gdGhlIG1hcmt1cCwgc3R5bGUgYW5kIHN2Z0NvbW1vbnNcbiAgICAgICAgICBpbmRleCA9IG9iamVjdE1hcmt1cC5pbmRleE9mKCdDT01NT05fUEFSVFMnKSxcbiAgICAgICAgICBhZGRpdGlvbmFsVHJhbnNmb3JtID0gb3B0aW9ucy5hZGRpdGlvbmFsVHJhbnNmb3JtO1xuICAgICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICAgIGNsaXBQYXRoLmNsaXBQYXRoSWQgPSAnQ0xJUFBBVEhfJyArIGZhYnJpYy5PYmplY3QuX191aWQrKztcbiAgICAgICAgY2xpcFBhdGhNYXJrdXAgPSAnPGNsaXBQYXRoIGlkPVwiJyArIGNsaXBQYXRoLmNsaXBQYXRoSWQgKyAnXCIgPlxcbicgK1xuICAgICAgICAgIGNsaXBQYXRoLnRvQ2xpcFBhdGhTVkcocmV2aXZlcikgK1xuICAgICAgICAgICc8L2NsaXBQYXRoPlxcbic7XG4gICAgICB9XG4gICAgICBpZiAoYWJzb2x1dGVDbGlwUGF0aCkge1xuICAgICAgICBtYXJrdXAucHVzaChcbiAgICAgICAgICAnPGcgJywgc2hhZG93SW5mbywgdGhpcy5nZXRTdmdDb21tb25zKCksICcgPlxcbidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG1hcmt1cC5wdXNoKFxuICAgICAgICAnPGcgJyxcbiAgICAgICAgdGhpcy5nZXRTdmdUcmFuc2Zvcm0oZmFsc2UpLFxuICAgICAgICAhYWJzb2x1dGVDbGlwUGF0aCA/IHNoYWRvd0luZm8gKyB0aGlzLmdldFN2Z0NvbW1vbnMoKSA6ICcnLFxuICAgICAgICAnID5cXG4nXG4gICAgICApO1xuICAgICAgY29tbW9uUGllY2VzID0gW1xuICAgICAgICBzdHlsZUluZm8sXG4gICAgICAgIHZlY3RvckVmZmVjdCxcbiAgICAgICAgbm9TdHlsZSA/ICcnIDogdGhpcy5hZGRQYWludE9yZGVyKCksICcgJyxcbiAgICAgICAgYWRkaXRpb25hbFRyYW5zZm9ybSA/ICd0cmFuc2Zvcm09XCInICsgYWRkaXRpb25hbFRyYW5zZm9ybSArICdcIiAnIDogJycsXG4gICAgICBdLmpvaW4oJycpO1xuICAgICAgb2JqZWN0TWFya3VwW2luZGV4XSA9IGNvbW1vblBpZWNlcztcbiAgICAgIGlmIChmaWxsICYmIGZpbGwudG9MaXZlKSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKGZpbGwudG9TVkcodGhpcykpO1xuICAgICAgfVxuICAgICAgaWYgKHN0cm9rZSAmJiBzdHJva2UudG9MaXZlKSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKHN0cm9rZS50b1NWRyh0aGlzKSk7XG4gICAgICB9XG4gICAgICBpZiAoc2hhZG93KSB7XG4gICAgICAgIG1hcmt1cC5wdXNoKHNoYWRvdy50b1NWRyh0aGlzKSk7XG4gICAgICB9XG4gICAgICBpZiAoY2xpcFBhdGgpIHtcbiAgICAgICAgbWFya3VwLnB1c2goY2xpcFBhdGhNYXJrdXApO1xuICAgICAgfVxuICAgICAgbWFya3VwLnB1c2gob2JqZWN0TWFya3VwLmpvaW4oJycpKTtcbiAgICAgIG1hcmt1cC5wdXNoKCc8L2c+XFxuJyk7XG4gICAgICBhYnNvbHV0ZUNsaXBQYXRoICYmIG1hcmt1cC5wdXNoKCc8L2c+XFxuJyk7XG4gICAgICByZXR1cm4gcmV2aXZlciA/IHJldml2ZXIobWFya3VwLmpvaW4oJycpKSA6IG1hcmt1cC5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgYWRkUGFpbnRPcmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYWludEZpcnN0ICE9PSAnZmlsbCcgPyAnIHBhaW50LW9yZGVyPVwiJyArIHRoaXMucGFpbnRGaXJzdCArICdcIiAnIDogJyc7XG4gICAgfVxuICB9KTtcbn0pKCk7XG4vKiBfVE9fU1ZHX0VORF8gKi9cblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBvcmlnaW5hbFNldCA9ICdzdGF0ZVByb3BlcnRpZXMnO1xuXG4gIC8qXG4gICAgRGVwZW5kcyBvbiBgc3RhdGVQcm9wZXJ0aWVzYFxuICAqL1xuICBmdW5jdGlvbiBzYXZlUHJvcHMob3JpZ2luLCBkZXN0aW5hdGlvbiwgcHJvcHMpIHtcbiAgICB2YXIgdG1wT2JqID0geyB9LCBkZWVwID0gdHJ1ZTtcbiAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgIHRtcE9ialtwcm9wXSA9IG9yaWdpbltwcm9wXTtcbiAgICB9KTtcblxuICAgIGV4dGVuZChvcmlnaW5bZGVzdGluYXRpb25dLCB0bXBPYmosIGRlZXApO1xuICB9XG5cbiAgZnVuY3Rpb24gX2lzRXF1YWwob3JpZ1ZhbHVlLCBjdXJyZW50VmFsdWUsIGZpcnN0UGFzcykge1xuICAgIGlmIChvcmlnVmFsdWUgPT09IGN1cnJlbnRWYWx1ZSkge1xuICAgICAgLy8gaWYgdGhlIG9iamVjdHMgYXJlIGlkZW50aWNhbCwgcmV0dXJuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvcmlnVmFsdWUpKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY3VycmVudFZhbHVlKSB8fCBvcmlnVmFsdWUubGVuZ3RoICE9PSBjdXJyZW50VmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvcmlnVmFsdWUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKCFfaXNFcXVhbChvcmlnVmFsdWVbaV0sIGN1cnJlbnRWYWx1ZVtpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcmlnVmFsdWUgJiYgdHlwZW9mIG9yaWdWYWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob3JpZ1ZhbHVlKSwga2V5O1xuICAgICAgaWYgKCFjdXJyZW50VmFsdWUgfHxcbiAgICAgICAgICB0eXBlb2YgY3VycmVudFZhbHVlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICghZmlyc3RQYXNzICYmIGtleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhjdXJyZW50VmFsdWUpLmxlbmd0aClcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAvLyBzaW5jZSBjbGlwUGF0aCBpcyBpbiB0aGUgc3RhdGVmdWxsIGNhY2hlIGxpc3QgYW5kIHRoZSBjbGlwUGF0aCBvYmplY3RzXG4gICAgICAgIC8vIHdvdWxkIGJlIGl0ZXJhdGVkIGFzIGFuIG9iamVjdCwgdGhpcyB3b3VsZCBsZWFkIHRvIHBvc3NpYmxlIGluZmluaXRlIHJlY3Vyc2lvblxuICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBjb21wYXJlIHRob3NlLlxuICAgICAgICBpZiAoa2V5ID09PSAnY2FudmFzJyB8fCBrZXkgPT09ICdncm91cCcpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9pc0VxdWFsKG9yaWdWYWx1ZVtrZXldLCBjdXJyZW50VmFsdWVba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IHN0YXRlIChvbmUgb2YgaXRzIHN0YXRlIHByb3BlcnRpZXMpIHdhcyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0eVNldF0gb3B0aW9uYWwgbmFtZSBmb3IgdGhlIHNldCBvZiBwcm9wZXJ0eSB3ZSB3YW50IHRvIHNhdmVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGluc3RhbmNlJyBzdGF0ZSBoYXMgY2hhbmdlZCBzaW5jZSBge0BsaW5rIGZhYnJpYy5PYmplY3Qjc2F2ZVN0YXRlfWAgd2FzIGNhbGxlZFxuICAgICAqL1xuICAgIGhhc1N0YXRlQ2hhbmdlZDogZnVuY3Rpb24ocHJvcGVydHlTZXQpIHtcbiAgICAgIHByb3BlcnR5U2V0ID0gcHJvcGVydHlTZXQgfHwgb3JpZ2luYWxTZXQ7XG4gICAgICB2YXIgZGFzaGVkUHJvcGVydHlTZXQgPSAnXycgKyBwcm9wZXJ0eVNldDtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzW2Rhc2hlZFByb3BlcnR5U2V0XSkubGVuZ3RoIDwgdGhpc1twcm9wZXJ0eVNldF0ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuICFfaXNFcXVhbCh0aGlzW2Rhc2hlZFByb3BlcnR5U2V0XSwgdGhpcywgdHJ1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNhdmVzIHN0YXRlIG9mIGFuIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT2JqZWN0IHdpdGggYWRkaXRpb25hbCBgc3RhdGVQcm9wZXJ0aWVzYCBhcnJheSB0byBpbmNsdWRlIHdoZW4gc2F2aW5nIHN0YXRlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIHNhdmVTdGF0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIHByb3BlcnR5U2V0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnByb3BlcnR5U2V0IHx8IG9yaWdpbmFsU2V0LFxuICAgICAgICAgIGRlc3RpbmF0aW9uID0gJ18nICsgcHJvcGVydHlTZXQ7XG4gICAgICBpZiAoIXRoaXNbZGVzdGluYXRpb25dKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldHVwU3RhdGUob3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBzYXZlUHJvcHModGhpcywgZGVzdGluYXRpb24sIHRoaXNbcHJvcGVydHlTZXRdKTtcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc3RhdGVQcm9wZXJ0aWVzKSB7XG4gICAgICAgIHNhdmVQcm9wcyh0aGlzLCBkZXN0aW5hdGlvbiwgb3B0aW9ucy5zdGF0ZVByb3BlcnRpZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHVwcyBzdGF0ZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9iamVjdCB3aXRoIGFkZGl0aW9uYWwgYHN0YXRlUHJvcGVydGllc2AgYXJyYXkgdG8gaW5jbHVkZSB3aGVuIHNhdmluZyBzdGF0ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBzZXR1cFN0YXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IH07XG4gICAgICB2YXIgcHJvcGVydHlTZXQgPSBvcHRpb25zLnByb3BlcnR5U2V0IHx8IG9yaWdpbmFsU2V0O1xuICAgICAgb3B0aW9ucy5wcm9wZXJ0eVNldCA9IHByb3BlcnR5U2V0O1xuICAgICAgdGhpc1snXycgKyBwcm9wZXJ0eVNldF0gPSB7IH07XG4gICAgICB0aGlzLnNhdmVTdGF0ZShvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnM7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGljaCBjb3JuZXIgaGFzIGJlZW4gY2xpY2tlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXIgVGhlIHBvaW50ZXIgaW5kaWNhdGluZyB0aGUgbW91c2UgcG9zaXRpb25cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd8Qm9vbGVhbn0gY29ybmVyIGNvZGUgKHRsLCB0ciwgYmwsIGJyLCBldGMuKSwgb3IgZmFsc2UgaWYgbm90aGluZyBpcyBmb3VuZFxuICAgICAqL1xuICAgIF9maW5kVGFyZ2V0Q29ybmVyOiBmdW5jdGlvbihwb2ludGVyLCBmb3JUb3VjaCkge1xuICAgICAgLy8gb2JqZWN0cyBpbiBncm91cCwgYW55a2luZCwgYXJlIG5vdCBzZWxmIG1vZGlmaWNhYmxlLFxuICAgICAgLy8gbXVzdCBub3QgcmV0dXJuIGFuIGhvdmVyZWQgY29ybmVyLlxuICAgICAgaWYgKCF0aGlzLmhhc0NvbnRyb2xzIHx8IHRoaXMuZ3JvdXAgfHwgKCF0aGlzLmNhbnZhcyB8fCB0aGlzLmNhbnZhcy5fYWN0aXZlT2JqZWN0ICE9PSB0aGlzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBleCA9IHBvaW50ZXIueCxcbiAgICAgICAgICBleSA9IHBvaW50ZXIueSxcbiAgICAgICAgICB4UG9pbnRzLFxuICAgICAgICAgIGxpbmVzLCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5vQ29vcmRzKSxcbiAgICAgICAgICBqID0ga2V5cy5sZW5ndGggLSAxLCBpO1xuICAgICAgdGhpcy5fX2Nvcm5lciA9IDA7XG5cbiAgICAgIC8vIGN5Y2xlIGluIHJldmVyc2Ugb3JkZXIgc28gd2UgcGljayBmaXJzdCB0aGUgb25lIG9uIHRvcFxuICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIGkgPSBrZXlzW2pdO1xuICAgICAgICBpZiAoIXRoaXMuaXNDb250cm9sVmlzaWJsZShpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluZXMgPSB0aGlzLl9nZXRJbWFnZUxpbmVzKGZvclRvdWNoID8gdGhpcy5vQ29vcmRzW2ldLnRvdWNoQ29ybmVyIDogdGhpcy5vQ29vcmRzW2ldLmNvcm5lcik7XG4gICAgICAgIC8vIC8vIGRlYnVnZ2luZ1xuICAgICAgICAvL1xuICAgICAgICAvLyB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLmJvdHRvbWxpbmUuZC54LCBsaW5lcy5ib3R0b21saW5lLmQueSwgMiwgMik7XG4gICAgICAgIC8vIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMuYm90dG9tbGluZS5vLngsIGxpbmVzLmJvdHRvbWxpbmUuby55LCAyLCAyKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5sZWZ0bGluZS5kLngsIGxpbmVzLmxlZnRsaW5lLmQueSwgMiwgMik7XG4gICAgICAgIC8vIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMubGVmdGxpbmUuby54LCBsaW5lcy5sZWZ0bGluZS5vLnksIDIsIDIpO1xuICAgICAgICAvL1xuICAgICAgICAvLyB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLmZpbGxSZWN0KGxpbmVzLnRvcGxpbmUuZC54LCBsaW5lcy50b3BsaW5lLmQueSwgMiwgMik7XG4gICAgICAgIC8vIHRoaXMuY2FudmFzLmNvbnRleHRUb3AuZmlsbFJlY3QobGluZXMudG9wbGluZS5vLngsIGxpbmVzLnRvcGxpbmUuby55LCAyLCAyKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5yaWdodGxpbmUuZC54LCBsaW5lcy5yaWdodGxpbmUuZC55LCAyLCAyKTtcbiAgICAgICAgLy8gdGhpcy5jYW52YXMuY29udGV4dFRvcC5maWxsUmVjdChsaW5lcy5yaWdodGxpbmUuby54LCBsaW5lcy5yaWdodGxpbmUuby55LCAyLCAyKTtcblxuICAgICAgICB4UG9pbnRzID0gdGhpcy5fZmluZENyb3NzUG9pbnRzKHsgeDogZXgsIHk6IGV5IH0sIGxpbmVzKTtcbiAgICAgICAgaWYgKHhQb2ludHMgIT09IDAgJiYgeFBvaW50cyAlIDIgPT09IDEpIHtcbiAgICAgICAgICB0aGlzLl9fY29ybmVyID0gaTtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxscyBhIGZ1bmN0aW9uIGZvciBlYWNoIGNvbnRyb2wuIFRoZSBmdW5jdGlvbiBnZXRzIGNhbGxlZCxcbiAgICAgKiB3aXRoIHRoZSBjb250cm9sLCB0aGUgb2JqZWN0IHRoYXQgaXMgY2FsbGluZyB0aGUgaXRlcmF0b3IgYW5kIHRoZSBjb250cm9sJ3Mga2V5XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIHRoZSBjb250cm9scyBvdmVyXG4gICAgICovXG4gICAgZm9yRWFjaENvbnRyb2w6IGZ1bmN0aW9uKGZuKSB7XG4gICAgICBmb3IgKHZhciBpIGluIHRoaXMuY29udHJvbHMpIHtcbiAgICAgICAgZm4odGhpcy5jb250cm9sc1tpXSwgaSwgdGhpcyk7XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgZHJhZ2dhYmxlIGJveGVzIGluIHRoZSBjb3JuZXJzIG9mXG4gICAgICogdGhlIGltYWdlIHVzZWQgdG8gc2NhbGUvcm90YXRlIGl0LlxuICAgICAqIG5vdGU6IGlmIHdlIHdvdWxkIHN3aXRjaCB0byBST1VORCBjb3JuZXIgYXJlYSwgYWxsIG9mIHRoaXMgd291bGQgZGlzYXBwZWFyLlxuICAgICAqIGV2ZXJ5dGhpbmcgd291bGQgcmVzb2x2ZSB0byBhIHNpbmdsZSBwb2ludCBhbmQgYSBweXRoYWdvcmVhbiB0aGVvcmVtIGZvciB0aGUgZGlzdGFuY2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRDb3JuZXJDb29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvb3JkcyA9IHRoaXMub0Nvb3JkcztcblxuICAgICAgZm9yICh2YXIgY29udHJvbCBpbiBjb29yZHMpIHtcbiAgICAgICAgdmFyIGNvbnRyb2xPYmplY3QgPSB0aGlzLmNvbnRyb2xzW2NvbnRyb2xdO1xuICAgICAgICBjb29yZHNbY29udHJvbF0uY29ybmVyID0gY29udHJvbE9iamVjdC5jYWxjQ29ybmVyQ29vcmRzKFxuICAgICAgICAgIHRoaXMuYW5nbGUsIHRoaXMuY29ybmVyU2l6ZSwgY29vcmRzW2NvbnRyb2xdLngsIGNvb3Jkc1tjb250cm9sXS55LCBmYWxzZSk7XG4gICAgICAgIGNvb3Jkc1tjb250cm9sXS50b3VjaENvcm5lciA9IGNvbnRyb2xPYmplY3QuY2FsY0Nvcm5lckNvb3JkcyhcbiAgICAgICAgICB0aGlzLmFuZ2xlLCB0aGlzLnRvdWNoQ29ybmVyU2l6ZSwgY29vcmRzW2NvbnRyb2xdLngsIGNvb3Jkc1tjb250cm9sXS55LCB0cnVlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgYSBjb2xvcmVkIGxheWVyIGJlaGluZCB0aGUgb2JqZWN0LCBpbnNpZGUgaXRzIHNlbGVjdGlvbiBib3JkZXJzLlxuICAgICAqIFJlcXVpcmVzIHB1YmxpYyBvcHRpb25zOiBwYWRkaW5nLCBzZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3JcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIHRoZSBjb250ZXh0IGlzIHRyYW5zZm9ybWVkXG4gICAgICogaGFzIGNoZWNrcyB0byBiZSBza2lwcGVkIHdoZW4gdGhlIG9iamVjdCBpcyBvbiBhIHN0YXRpY0NhbnZhc1xuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBkcmF3IG9uXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkcmF3U2VsZWN0aW9uQmFja2dyb3VuZDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uQmFja2dyb3VuZENvbG9yIHx8XG4gICAgICAgICh0aGlzLmNhbnZhcyAmJiAhdGhpcy5jYW52YXMuaW50ZXJhY3RpdmUpIHx8XG4gICAgICAgICh0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5fYWN0aXZlT2JqZWN0ICE9PSB0aGlzKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlclBvaW50KCksIHdoID0gdGhpcy5fY2FsY3VsYXRlQ3VycmVudERpbWVuc2lvbnMoKSxcbiAgICAgICAgICB2cHQgPSB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybTtcbiAgICAgIGN0eC50cmFuc2xhdGUoY2VudGVyLngsIGNlbnRlci55KTtcbiAgICAgIGN0eC5zY2FsZSgxIC8gdnB0WzBdLCAxIC8gdnB0WzNdKTtcbiAgICAgIGN0eC5yb3RhdGUoZGVncmVlc1RvUmFkaWFucyh0aGlzLmFuZ2xlKSk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5zZWxlY3Rpb25CYWNrZ3JvdW5kQ29sb3I7XG4gICAgICBjdHguZmlsbFJlY3QoLXdoLnggLyAyLCAtd2gueSAvIDIsIHdoLngsIHdoLnkpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyBib3JkZXJzIG9mIGFuIG9iamVjdCdzIGJvdW5kaW5nIGJveC5cbiAgICAgKiBSZXF1aXJlcyBwdWJsaWMgcHJvcGVydGllczogd2lkdGgsIGhlaWdodFxuICAgICAqIFJlcXVpcmVzIHB1YmxpYyBvcHRpb25zOiBwYWRkaW5nLCBib3JkZXJDb2xvclxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byBkcmF3IG9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlT3ZlcnJpZGUgb2JqZWN0IHRvIG92ZXJyaWRlIHRoZSBvYmplY3Qgc3R5bGVcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRyYXdCb3JkZXJzOiBmdW5jdGlvbihjdHgsIHN0eWxlT3ZlcnJpZGUpIHtcbiAgICAgIHN0eWxlT3ZlcnJpZGUgPSBzdHlsZU92ZXJyaWRlIHx8IHt9O1xuICAgICAgdmFyIHdoID0gdGhpcy5fY2FsY3VsYXRlQ3VycmVudERpbWVuc2lvbnMoKSxcbiAgICAgICAgICBzdHJva2VXaWR0aCA9IHRoaXMuYm9yZGVyU2NhbGVGYWN0b3IsXG4gICAgICAgICAgd2lkdGggPSB3aC54ICsgc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gd2gueSArIHN0cm9rZVdpZHRoLFxuICAgICAgICAgIGhhc0NvbnRyb2xzID0gdHlwZW9mIHN0eWxlT3ZlcnJpZGUuaGFzQ29udHJvbHMgIT09ICd1bmRlZmluZWQnID9cbiAgICAgICAgICAgIHN0eWxlT3ZlcnJpZGUuaGFzQ29udHJvbHMgOiB0aGlzLmhhc0NvbnRyb2xzLFxuICAgICAgICAgIHNob3VsZFN0cm9rZSA9IGZhbHNlO1xuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGVPdmVycmlkZS5ib3JkZXJDb2xvciB8fCB0aGlzLmJvcmRlckNvbG9yO1xuICAgICAgdGhpcy5fc2V0TGluZURhc2goY3R4LCBzdHlsZU92ZXJyaWRlLmJvcmRlckRhc2hBcnJheSB8fCB0aGlzLmJvcmRlckRhc2hBcnJheSk7XG5cbiAgICAgIGN0eC5zdHJva2VSZWN0KFxuICAgICAgICAtd2lkdGggLyAyLFxuICAgICAgICAtaGVpZ2h0IC8gMixcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgKTtcblxuICAgICAgaWYgKGhhc0NvbnRyb2xzKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5mb3JFYWNoQ29udHJvbChmdW5jdGlvbihjb250cm9sLCBrZXksIGZhYnJpY09iamVjdCkge1xuICAgICAgICAgIC8vIGluIHRoaXMgbW9tZW50LCB0aGUgY3R4IGlzIGNlbnRlcmVkIG9uIHRoZSBvYmplY3QuXG4gICAgICAgICAgLy8gd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgYWJvdmUgZnVuY3Rpb24gYXJlIHRoZSBzaXplIG9mIHRoZSBiYm94LlxuICAgICAgICAgIGlmIChjb250cm9sLndpdGhDb25uZWN0aW9uICYmIGNvbnRyb2wuZ2V0VmlzaWJpbGl0eShmYWJyaWNPYmplY3QsIGtleSkpIHtcbiAgICAgICAgICAgIC8vIHJlc2V0IG1vdmVtZW50IGZvciBlYWNoIGNvbnRyb2xcbiAgICAgICAgICAgIHNob3VsZFN0cm9rZSA9IHRydWU7XG4gICAgICAgICAgICBjdHgubW92ZVRvKGNvbnRyb2wueCAqIHdpZHRoLCBjb250cm9sLnkgKiBoZWlnaHQpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhcbiAgICAgICAgICAgICAgY29udHJvbC54ICogd2lkdGggKyBjb250cm9sLm9mZnNldFgsXG4gICAgICAgICAgICAgIGNvbnRyb2wueSAqIGhlaWdodCArIGNvbnRyb2wub2Zmc2V0WVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc2hvdWxkU3Ryb2tlKSB7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGJvcmRlcnMgb2YgYW4gb2JqZWN0J3MgYm91bmRpbmcgYm94IHdoZW4gaXQgaXMgaW5zaWRlIGEgZ3JvdXAuXG4gICAgICogUmVxdWlyZXMgcHVibGljIHByb3BlcnRpZXM6IHdpZHRoLCBoZWlnaHRcbiAgICAgKiBSZXF1aXJlcyBwdWJsaWMgb3B0aW9uczogcGFkZGluZywgYm9yZGVyQ29sb3JcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gZHJhdyBvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIG9iamVjdCByZXByZXNlbnRpbmcgY3VycmVudCBvYmplY3QgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZU92ZXJyaWRlIG9iamVjdCB0byBvdmVycmlkZSB0aGUgb2JqZWN0IHN0eWxlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkcmF3Qm9yZGVyc0luR3JvdXA6IGZ1bmN0aW9uKGN0eCwgb3B0aW9ucywgc3R5bGVPdmVycmlkZSkge1xuICAgICAgc3R5bGVPdmVycmlkZSA9IHN0eWxlT3ZlcnJpZGUgfHwge307XG4gICAgICB2YXIgYmJveCA9IGZhYnJpYy51dGlsLnNpemVBZnRlclRyYW5zZm9ybSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgb3B0aW9ucyksXG4gICAgICAgICAgc3Ryb2tlV2lkdGggPSB0aGlzLnN0cm9rZVdpZHRoLFxuICAgICAgICAgIHN0cm9rZVVuaWZvcm0gPSB0aGlzLnN0cm9rZVVuaWZvcm0sXG4gICAgICAgICAgYm9yZGVyU2NhbGVGYWN0b3IgPSB0aGlzLmJvcmRlclNjYWxlRmFjdG9yLFxuICAgICAgICAgIHdpZHRoID1cbiAgICAgICAgICAgIGJib3gueCArIHN0cm9rZVdpZHRoICogKHN0cm9rZVVuaWZvcm0gPyB0aGlzLmNhbnZhcy5nZXRab29tKCkgOiBvcHRpb25zLnNjYWxlWCkgKyBib3JkZXJTY2FsZUZhY3RvcixcbiAgICAgICAgICBoZWlnaHQgPVxuICAgICAgICAgICAgYmJveC55ICsgc3Ryb2tlV2lkdGggKiAoc3Ryb2tlVW5pZm9ybSA/IHRoaXMuY2FudmFzLmdldFpvb20oKSA6IG9wdGlvbnMuc2NhbGVZKSArIGJvcmRlclNjYWxlRmFjdG9yO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuX3NldExpbmVEYXNoKGN0eCwgc3R5bGVPdmVycmlkZS5ib3JkZXJEYXNoQXJyYXkgfHwgdGhpcy5ib3JkZXJEYXNoQXJyYXkpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGVPdmVycmlkZS5ib3JkZXJDb2xvciB8fCB0aGlzLmJvcmRlckNvbG9yO1xuICAgICAgY3R4LnN0cm9rZVJlY3QoXG4gICAgICAgIC13aWR0aCAvIDIsXG4gICAgICAgIC1oZWlnaHQgLyAyLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICApO1xuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERyYXdzIGNvcm5lcnMgb2YgYW4gb2JqZWN0J3MgYm91bmRpbmcgYm94LlxuICAgICAqIFJlcXVpcmVzIHB1YmxpYyBwcm9wZXJ0aWVzOiB3aWR0aCwgaGVpZ2h0XG4gICAgICogUmVxdWlyZXMgcHVibGljIG9wdGlvbnM6IGNvcm5lclNpemUsIHBhZGRpbmdcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gZHJhdyBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZU92ZXJyaWRlIG9iamVjdCB0byBvdmVycmlkZSB0aGUgb2JqZWN0IHN0eWxlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBkcmF3Q29udHJvbHM6IGZ1bmN0aW9uKGN0eCwgc3R5bGVPdmVycmlkZSkge1xuICAgICAgc3R5bGVPdmVycmlkZSA9IHN0eWxlT3ZlcnJpZGUgfHwge307XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdmFyIHJldGluYVNjYWxpbmcgPSAxLCBtYXRyaXgsIHA7XG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgcmV0aW5hU2NhbGluZyA9IHRoaXMuY2FudmFzLmdldFJldGluYVNjYWxpbmcoKTtcbiAgICAgIH1cbiAgICAgIGN0eC5zZXRUcmFuc2Zvcm0ocmV0aW5hU2NhbGluZywgMCwgMCwgcmV0aW5hU2NhbGluZywgMCwgMCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlID0gc3R5bGVPdmVycmlkZS5jb3JuZXJDb2xvciB8fCB0aGlzLmNvcm5lckNvbG9yO1xuICAgICAgaWYgKCF0aGlzLnRyYW5zcGFyZW50Q29ybmVycykge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZU92ZXJyaWRlLmNvcm5lclN0cm9rZUNvbG9yIHx8IHRoaXMuY29ybmVyU3Ryb2tlQ29sb3I7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRMaW5lRGFzaChjdHgsIHN0eWxlT3ZlcnJpZGUuY29ybmVyRGFzaEFycmF5IHx8IHRoaXMuY29ybmVyRGFzaEFycmF5KTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICBpZiAodGhpcy5ncm91cCkge1xuICAgICAgICAvLyBmYWJyaWNKUyBkb2VzIG5vdCByZWFsbHkgc3VwcG9ydCBkcmF3aW5nIGNvbnRyb2xzIGluc2lkZSBncm91cHMsXG4gICAgICAgIC8vIHRoaXMgcGllY2Ugb2YgY29kZSBoZXJlIGhlbHBzIGhhdmluZyBhdCBsZWFzdCB0aGUgY29udHJvbCBpbiBwbGFjZXMuXG4gICAgICAgIC8vIElmIGFuIGFwcGxpY2F0aW9uIG5lZWRzIHRvIHNob3cgc29tZSBvYmplY3RzIGFzIHNlbGVjdGVkIGJlY2F1c2Ugb2Ygc29tZSBVSSBzdGF0ZVxuICAgICAgICAvLyBjYW4gc3RpbGwgY2FsbCBPYmplY3QuX3JlbmRlckNvbnRyb2xzKCkgb24gYW55IG9iamVjdCB0aGV5IGRlc2lyZSwgaW5kZXBlbmRlbnRseSBvZiBncm91cHMuXG4gICAgICAgIC8vIHVzaW5nIG5vIHBhZGRpbmcsIGNpcmN1bGFyIGNvbnRyb2xzIGFuZCBoaWRpbmcgdGhlIHJvdGF0aW5nIGN1cnNvciBpcyBoaWdseSBzdWdnZXN0ZWQsXG4gICAgICAgIG1hdHJpeCA9IHRoaXMuZ3JvdXAuY2FsY1RyYW5zZm9ybU1hdHJpeCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5mb3JFYWNoQ29udHJvbChmdW5jdGlvbihjb250cm9sLCBrZXksIGZhYnJpY09iamVjdCkge1xuICAgICAgICBwID0gZmFicmljT2JqZWN0Lm9Db29yZHNba2V5XTtcbiAgICAgICAgaWYgKGNvbnRyb2wuZ2V0VmlzaWJpbGl0eShmYWJyaWNPYmplY3QsIGtleSkpIHtcbiAgICAgICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgICAgICBwID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQocCwgbWF0cml4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udHJvbC5yZW5kZXIoY3R4LCBwLngsIHAueSwgc3R5bGVPdmVycmlkZSwgZmFicmljT2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgY29udHJvbCBpcyB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbnRyb2xLZXkgVGhlIGtleSBvZiB0aGUgY29udHJvbC4gUG9zc2libGUgdmFsdWVzIGFyZSAndGwnLCAndHInLCAnYnInLCAnYmwnLCAnbWwnLCAnbXQnLCAnbXInLCAnbWInLCAnbXRyJy5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIGNvbnRyb2wgaXMgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgaXNDb250cm9sVmlzaWJsZTogZnVuY3Rpb24oY29udHJvbEtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udHJvbHNbY29udHJvbEtleV0gJiYgdGhpcy5jb250cm9sc1tjb250cm9sS2V5XS5nZXRWaXNpYmlsaXR5KHRoaXMsIGNvbnRyb2xLZXkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBzcGVjaWZpZWQgY29udHJvbC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29udHJvbEtleSBUaGUga2V5IG9mIHRoZSBjb250cm9sLiBQb3NzaWJsZSB2YWx1ZXMgYXJlICd0bCcsICd0cicsICdicicsICdibCcsICdtbCcsICdtdCcsICdtcicsICdtYicsICdtdHInLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJsZSB0cnVlIHRvIHNldCB0aGUgc3BlY2lmaWVkIGNvbnRyb2wgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRDb250cm9sVmlzaWJsZTogZnVuY3Rpb24oY29udHJvbEtleSwgdmlzaWJsZSkge1xuICAgICAgaWYgKCF0aGlzLl9jb250cm9sc1Zpc2liaWxpdHkpIHtcbiAgICAgICAgdGhpcy5fY29udHJvbHNWaXNpYmlsaXR5ID0ge307XG4gICAgICB9XG4gICAgICB0aGlzLl9jb250cm9sc1Zpc2liaWxpdHlbY29udHJvbEtleV0gPSB2aXNpYmxlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZpc2liaWxpdHkgc3RhdGUgb2Ygb2JqZWN0IGNvbnRyb2xzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJsXSB0cnVlIHRvIGVuYWJsZSB0aGUgYm90dG9tLWxlZnQgY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYnJdIHRydWUgdG8gZW5hYmxlIHRoZSBib3R0b20tcmlnaHQgY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWJdIHRydWUgdG8gZW5hYmxlIHRoZSBtaWRkbGUtYm90dG9tIGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1sXSB0cnVlIHRvIGVuYWJsZSB0aGUgbWlkZGxlLWxlZnQgY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubXJdIHRydWUgdG8gZW5hYmxlIHRoZSBtaWRkbGUtcmlnaHQgY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubXRdIHRydWUgdG8gZW5hYmxlIHRoZSBtaWRkbGUtdG9wIGNvbnRyb2wsIGZhbHNlIHRvIGRpc2FibGUgaXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRsXSB0cnVlIHRvIGVuYWJsZSB0aGUgdG9wLWxlZnQgY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJdIHRydWUgdG8gZW5hYmxlIHRoZSB0b3AtcmlnaHQgY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubXRyXSB0cnVlIHRvIGVuYWJsZSB0aGUgbWlkZGxlLXRvcC1yb3RhdGUgY29udHJvbCwgZmFsc2UgdG8gZGlzYWJsZSBpdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0Q29udHJvbHNWaXNpYmlsaXR5OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgZm9yICh2YXIgcCBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc2V0Q29udHJvbFZpc2libGUocCwgb3B0aW9uc1twXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCBldmVyeSB0aW1lIF9kaXNjYXJkQWN0aXZlT2JqZWN0IG9yIF9zZXRBY3RpdmVPYmplY3RcbiAgICAgKiB0cnkgdG8gdG8gZGVzZWxlY3QgdGhpcyBvYmplY3QuIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUsIHRoZSBwcm9jZXNzIGlzIGNhbmNlbGxlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9ucyBzZW50IGZyb20gdGhlIHVwcGVyIGZ1bmN0aW9uc1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IFtvcHRpb25zLmVdIGV2ZW50IGlmIHRoZSBwcm9jZXNzIGlzIGdlbmVyYXRlZCBieSBhbiBldmVudFxuICAgICAqL1xuICAgIG9uRGVzZWxlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gaW1wbGVtZW50ZWQgYnkgc3ViLWNsYXNzZXMsIGFzIG5lZWRlZC5cbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCBldmVyeSB0aW1lIF9kaXNjYXJkQWN0aXZlT2JqZWN0IG9yIF9zZXRBY3RpdmVPYmplY3RcbiAgICAgKiB0cnkgdG8gdG8gc2VsZWN0IHRoaXMgb2JqZWN0LiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlLCB0aGUgcHJvY2VzcyBpcyBjYW5jZWxsZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbnMgc2VudCBmcm9tIHRoZSB1cHBlciBmdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBbb3B0aW9ucy5lXSBldmVudCBpZiB0aGUgcHJvY2VzcyBpcyBnZW5lcmF0ZWQgYnkgYW4gZXZlbnRcbiAgICAgKi9cbiAgICBvblNlbGVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBpbXBsZW1lbnRlZCBieSBzdWItY2xhc3NlcywgYXMgbmVlZGVkLlxuICAgIH1cbiAgfSk7XG59KSgpO1xuXG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBBbmltYXRpb24gZHVyYXRpb24gKGluIG1zKSBmb3IgZngqIG1ldGhvZHNcbiAgICogQHR5cGUgTnVtYmVyXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBGWF9EVVJBVElPTjogNTAwLFxuXG4gIC8qKlxuICAgKiBDZW50ZXJzIG9iamVjdCBob3Jpem9udGFsbHkgd2l0aCBhbmltYXRpb24uXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjZW50ZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjYWxsYmFja3NdIENhbGxiYWNrcyBvYmplY3Qgd2l0aCBvcHRpb25hbCBcIm9uQ29tcGxldGVcIiBhbmQvb3IgXCJvbkNoYW5nZVwiIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5vbkNvbXBsZXRlXSBJbnZva2VkIG9uIGNvbXBsZXRpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrcy5vbkNoYW5nZV0gSW52b2tlZCBvbiBldmVyeSBzdGVwIG9mIGFuaW1hdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQW5pbWF0aW9uQ29udGV4dH0gY29udGV4dFxuICAgKi9cbiAgZnhDZW50ZXJPYmplY3RIOiBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3MgfHwgeyB9O1xuXG4gICAgdmFyIGVtcHR5ID0gZnVuY3Rpb24oKSB7IH0sXG4gICAgICAgIG9uQ29tcGxldGUgPSBjYWxsYmFja3Mub25Db21wbGV0ZSB8fCBlbXB0eSxcbiAgICAgICAgb25DaGFuZ2UgPSBjYWxsYmFja3Mub25DaGFuZ2UgfHwgZW1wdHksXG4gICAgICAgIF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBmYWJyaWMudXRpbC5hbmltYXRlKHtcbiAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgIHN0YXJ0VmFsdWU6IG9iamVjdC5sZWZ0LFxuICAgICAgZW5kVmFsdWU6IHRoaXMuZ2V0Q2VudGVyUG9pbnQoKS54LFxuICAgICAgZHVyYXRpb246IHRoaXMuRlhfRFVSQVRJT04sXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgb2JqZWN0LnNldCgnbGVmdCcsIHZhbHVlKTtcbiAgICAgICAgX3RoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgICBvbkNoYW5nZSgpO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBvYmplY3Quc2V0Q29vcmRzKCk7XG4gICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQ2VudGVycyBvYmplY3QgdmVydGljYWxseSB3aXRoIGFuaW1hdGlvbi5cbiAgICogQHBhcmFtIHtmYWJyaWMuT2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNlbnRlclxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NhbGxiYWNrc10gQ2FsbGJhY2tzIG9iamVjdCB3aXRoIG9wdGlvbmFsIFwib25Db21wbGV0ZVwiIGFuZC9vciBcIm9uQ2hhbmdlXCIgcHJvcGVydGllc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLm9uQ29tcGxldGVdIEludm9rZWQgb24gY29tcGxldGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tzLm9uQ2hhbmdlXSBJbnZva2VkIG9uIGV2ZXJ5IHN0ZXAgb2YgYW5pbWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5BbmltYXRpb25Db250ZXh0fSBjb250ZXh0XG4gICAqL1xuICBmeENlbnRlck9iamVjdFY6IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcyB8fCB7IH07XG5cbiAgICB2YXIgZW1wdHkgPSBmdW5jdGlvbigpIHsgfSxcbiAgICAgICAgb25Db21wbGV0ZSA9IGNhbGxiYWNrcy5vbkNvbXBsZXRlIHx8IGVtcHR5LFxuICAgICAgICBvbkNoYW5nZSA9IGNhbGxiYWNrcy5vbkNoYW5nZSB8fCBlbXB0eSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIGZhYnJpYy51dGlsLmFuaW1hdGUoe1xuICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgc3RhcnRWYWx1ZTogb2JqZWN0LnRvcCxcbiAgICAgIGVuZFZhbHVlOiB0aGlzLmdldENlbnRlclBvaW50KCkueSxcbiAgICAgIGR1cmF0aW9uOiB0aGlzLkZYX0RVUkFUSU9OLFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIG9iamVjdC5zZXQoJ3RvcCcsIHZhbHVlKTtcbiAgICAgICAgX3RoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgICAgICBvbkNoYW5nZSgpO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBvYmplY3Quc2V0Q29vcmRzKCk7XG4gICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogU2FtZSBhcyBgZmFicmljLkNhbnZhcyNyZW1vdmVgIGJ1dCBhbmltYXRlZFxuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gcmVtb3ZlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY2FsbGJhY2tzXSBDYWxsYmFja3Mgb2JqZWN0IHdpdGggb3B0aW9uYWwgXCJvbkNvbXBsZXRlXCIgYW5kL29yIFwib25DaGFuZ2VcIiBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25Db21wbGV0ZV0gSW52b2tlZCBvbiBjb21wbGV0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25DaGFuZ2VdIEludm9rZWQgb24gZXZlcnkgc3RlcCBvZiBhbmltYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkFuaW1hdGlvbkNvbnRleHR9IGNvbnRleHRcbiAgICovXG4gIGZ4UmVtb3ZlOiBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3MgfHwgeyB9O1xuXG4gICAgdmFyIGVtcHR5ID0gZnVuY3Rpb24oKSB7IH0sXG4gICAgICAgIG9uQ29tcGxldGUgPSBjYWxsYmFja3Mub25Db21wbGV0ZSB8fCBlbXB0eSxcbiAgICAgICAgb25DaGFuZ2UgPSBjYWxsYmFja3Mub25DaGFuZ2UgfHwgZW1wdHksXG4gICAgICAgIF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBmYWJyaWMudXRpbC5hbmltYXRlKHtcbiAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgIHN0YXJ0VmFsdWU6IG9iamVjdC5vcGFjaXR5LFxuICAgICAgZW5kVmFsdWU6IDAsXG4gICAgICBkdXJhdGlvbjogdGhpcy5GWF9EVVJBVElPTixcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBvYmplY3Quc2V0KCdvcGFjaXR5JywgdmFsdWUpO1xuICAgICAgICBfdGhpcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICAgIG9uQ2hhbmdlKCk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5yZW1vdmUob2JqZWN0KTtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59KTtcblxuZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZSAqLyB7XG4gIC8qKlxuICAgKiBBbmltYXRlcyBvYmplY3QncyBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gcHJvcGVydHkgUHJvcGVydHkgdG8gYW5pbWF0ZSAoaWYgc3RyaW5nKSBvciBwcm9wZXJ0aWVzIHRvIGFuaW1hdGUgKGlmIG9iamVjdClcbiAgICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSB2YWx1ZSBWYWx1ZSB0byBhbmltYXRlIHByb3BlcnR5IHRvIChpZiBzdHJpbmcgd2FzIGdpdmVuIGZpcnN0KSBvciBvcHRpb25zIG9iamVjdFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0yI2FuaW1hdGlvbn1cbiAgICogQHJldHVybiB7ZmFicmljLkFuaW1hdGlvbkNvbnRleHQgfCBmYWJyaWMuQW5pbWF0aW9uQ29udGV4dFtdfSBhbmltYXRpb24gY29udGV4dCAob3IgYW4gYXJyYXkgaWYgcGFzc2VkIG11bHRpcGxlIHByb3BlcnRpZXMpXG4gICAqXG4gICAqIEFzIG9iamVjdCDigJQgbXVsdGlwbGUgcHJvcGVydGllc1xuICAgKlxuICAgKiBvYmplY3QuYW5pbWF0ZSh7IGxlZnQ6IC4uLiwgdG9wOiAuLi4gfSk7XG4gICAqIG9iamVjdC5hbmltYXRlKHsgbGVmdDogLi4uLCB0b3A6IC4uLiB9LCB7IGR1cmF0aW9uOiAuLi4gfSk7XG4gICAqXG4gICAqIEFzIHN0cmluZyDigJQgb25lIHByb3BlcnR5XG4gICAqXG4gICAqIG9iamVjdC5hbmltYXRlKCdsZWZ0JywgLi4uKTtcbiAgICogb2JqZWN0LmFuaW1hdGUoJ2xlZnQnLCB7IGR1cmF0aW9uOiAuLi4gfSk7XG4gICAqXG4gICAqL1xuICBhbmltYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSAmJiB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIHByb3BzVG9BbmltYXRlID0gW10sIHByb3AsIHNraXBDYWxsYmFja3MsIG91dCA9IFtdO1xuICAgICAgZm9yIChwcm9wIGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICBwcm9wc1RvQW5pbWF0ZS5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb3BzVG9BbmltYXRlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHByb3AgPSBwcm9wc1RvQW5pbWF0ZVtpXTtcbiAgICAgICAgc2tpcENhbGxiYWNrcyA9IGkgIT09IGxlbiAtIDE7XG4gICAgICAgIG91dC5wdXNoKHRoaXMuX2FuaW1hdGUocHJvcCwgYXJndW1lbnRzWzBdW3Byb3BdLCBhcmd1bWVudHNbMV0sIHNraXBDYWxsYmFja3MpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2FuaW1hdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0byBhbmltYXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0byBWYWx1ZSB0byBhbmltYXRlIHRvXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbc2tpcENhbGxiYWNrc10gV2hlbiB0cnVlLCBjYWxsYmFja3MgbGlrZSBvbmNoYW5nZSBhbmQgb25jb21wbGV0ZSBhcmUgbm90IGludm9rZWRcbiAgICovXG4gIF9hbmltYXRlOiBmdW5jdGlvbihwcm9wZXJ0eSwgdG8sIG9wdGlvbnMsIHNraXBDYWxsYmFja3MpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzLCBwcm9wUGFpcjtcblxuICAgIHRvID0gdG8udG9TdHJpbmcoKTtcblxuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHsgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBvcHRpb25zID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmICh+cHJvcGVydHkuaW5kZXhPZignLicpKSB7XG4gICAgICBwcm9wUGFpciA9IHByb3BlcnR5LnNwbGl0KCcuJyk7XG4gICAgfVxuXG4gICAgdmFyIHByb3BJc0NvbG9yID1cbiAgICAgIF90aGlzLmNvbG9yUHJvcGVydGllcy5pbmRleE9mKHByb3BlcnR5KSA+IC0xIHx8XG4gICAgICAocHJvcFBhaXIgJiYgX3RoaXMuY29sb3JQcm9wZXJ0aWVzLmluZGV4T2YocHJvcFBhaXJbMV0pID4gLTEpO1xuXG4gICAgdmFyIGN1cnJlbnRWYWx1ZSA9IHByb3BQYWlyXG4gICAgICA/IHRoaXMuZ2V0KHByb3BQYWlyWzBdKVtwcm9wUGFpclsxXV1cbiAgICAgIDogdGhpcy5nZXQocHJvcGVydHkpO1xuXG4gICAgaWYgKCEoJ2Zyb20nIGluIG9wdGlvbnMpKSB7XG4gICAgICBvcHRpb25zLmZyb20gPSBjdXJyZW50VmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKCFwcm9wSXNDb2xvcikge1xuICAgICAgaWYgKH50by5pbmRleE9mKCc9JykpIHtcbiAgICAgICAgdG8gPSBjdXJyZW50VmFsdWUgKyBwYXJzZUZsb2F0KHRvLnJlcGxhY2UoJz0nLCAnJykpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRvID0gcGFyc2VGbG9hdCh0byk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIF9vcHRpb25zID0ge1xuICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgc3RhcnRWYWx1ZTogb3B0aW9ucy5mcm9tLFxuICAgICAgZW5kVmFsdWU6IHRvLFxuICAgICAgYnlWYWx1ZTogb3B0aW9ucy5ieSxcbiAgICAgIGVhc2luZzogb3B0aW9ucy5lYXNpbmcsXG4gICAgICBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcbiAgICAgIGFib3J0OiBvcHRpb25zLmFib3J0ICYmIGZ1bmN0aW9uKHZhbHVlLCB2YWx1ZVByb2dyZXNzLCB0aW1lUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuYWJvcnQuY2FsbChfdGhpcywgdmFsdWUsIHZhbHVlUHJvZ3Jlc3MsIHRpbWVQcm9ncmVzcyk7XG4gICAgICB9LFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uICh2YWx1ZSwgdmFsdWVQcm9ncmVzcywgdGltZVByb2dyZXNzKSB7XG4gICAgICAgIGlmIChwcm9wUGFpcikge1xuICAgICAgICAgIF90aGlzW3Byb3BQYWlyWzBdXVtwcm9wUGFpclsxXV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5zZXQocHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2tpcENhbGxiYWNrcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLm9uQ2hhbmdlICYmIG9wdGlvbnMub25DaGFuZ2UodmFsdWUsIHZhbHVlUHJvZ3Jlc3MsIHRpbWVQcm9ncmVzcyk7XG4gICAgICB9LFxuICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gKHZhbHVlLCB2YWx1ZVByb2dyZXNzLCB0aW1lUHJvZ3Jlc3MpIHtcbiAgICAgICAgaWYgKHNraXBDYWxsYmFja3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgICAgb3B0aW9ucy5vbkNvbXBsZXRlICYmIG9wdGlvbnMub25Db21wbGV0ZSh2YWx1ZSwgdmFsdWVQcm9ncmVzcywgdGltZVByb2dyZXNzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHByb3BJc0NvbG9yKSB7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwuYW5pbWF0ZUNvbG9yKF9vcHRpb25zLnN0YXJ0VmFsdWUsIF9vcHRpb25zLmVuZFZhbHVlLCBfb3B0aW9ucy5kdXJhdGlvbiwgX29wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBmYWJyaWMudXRpbC5hbmltYXRlKF9vcHRpb25zKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGNsb25lID0gZmFicmljLnV0aWwub2JqZWN0LmNsb25lLFxuICAgICAgY29vcmRQcm9wcyA9IHsgeDE6IDEsIHgyOiAxLCB5MTogMSwgeTI6IDEgfTtcblxuICBpZiAoZmFicmljLkxpbmUpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLkxpbmUgaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIExpbmUgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5MaW5lXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkxpbmUjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5MaW5lID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuTGluZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdsaW5lJyxcblxuICAgIC8qKlxuICAgICAqIHggdmFsdWUgb3IgZmlyc3QgbGluZSBlZGdlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB4MTogMCxcblxuICAgIC8qKlxuICAgICAqIHkgdmFsdWUgb3IgZmlyc3QgbGluZSBlZGdlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB5MTogMCxcblxuICAgIC8qKlxuICAgICAqIHggdmFsdWUgb3Igc2Vjb25kIGxpbmUgZWRnZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgeDI6IDAsXG5cbiAgICAvKipcbiAgICAgKiB5IHZhbHVlIG9yIHNlY29uZCBsaW5lIGVkZ2VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHkyOiAwLFxuXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5jYWNoZVByb3BlcnRpZXMuY29uY2F0KCd4MScsICd4MicsICd5MScsICd5MicpLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcG9pbnRzXSBBcnJheSBvZiBwb2ludHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkxpbmV9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihwb2ludHMsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghcG9pbnRzKSB7XG4gICAgICAgIHBvaW50cyA9IFswLCAwLCAwLCAwXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcblxuICAgICAgdGhpcy5zZXQoJ3gxJywgcG9pbnRzWzBdKTtcbiAgICAgIHRoaXMuc2V0KCd5MScsIHBvaW50c1sxXSk7XG4gICAgICB0aGlzLnNldCgneDInLCBwb2ludHNbMl0pO1xuICAgICAgdGhpcy5zZXQoJ3kyJywgcG9pbnRzWzNdKTtcblxuICAgICAgdGhpcy5fc2V0V2lkdGhIZWlnaHQob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zXG4gICAgICovXG4gICAgX3NldFdpZHRoSGVpZ2h0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgdGhpcy53aWR0aCA9IE1hdGguYWJzKHRoaXMueDIgLSB0aGlzLngxKTtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5hYnModGhpcy55MiAtIHRoaXMueTEpO1xuXG4gICAgICB0aGlzLmxlZnQgPSAnbGVmdCcgaW4gb3B0aW9uc1xuICAgICAgICA/IG9wdGlvbnMubGVmdFxuICAgICAgICA6IHRoaXMuX2dldExlZnRUb09yaWdpblgoKTtcblxuICAgICAgdGhpcy50b3AgPSAndG9wJyBpbiBvcHRpb25zXG4gICAgICAgID8gb3B0aW9ucy50b3BcbiAgICAgICAgOiB0aGlzLl9nZXRUb3BUb09yaWdpblkoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqL1xuICAgIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfc2V0Jywga2V5LCB2YWx1ZSk7XG4gICAgICBpZiAodHlwZW9mIGNvb3JkUHJvcHNba2V5XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5fc2V0V2lkdGhIZWlnaHQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gbGVmdFRvT3JpZ2luWCBEaXN0YW5jZSBmcm9tIGxlZnQgZWRnZSBvZiBjYW52YXMgdG8gb3JpZ2luWCBvZiBMaW5lLlxuICAgICAqL1xuICAgIF9nZXRMZWZ0VG9PcmlnaW5YOiBtYWtlRWRnZVRvT3JpZ2luR2V0dGVyKFxuICAgICAgeyAvLyBwcm9wZXJ0eSBuYW1lc1xuICAgICAgICBvcmlnaW46ICdvcmlnaW5YJyxcbiAgICAgICAgYXhpczE6ICd4MScsXG4gICAgICAgIGF4aXMyOiAneDInLFxuICAgICAgICBkaW1lbnNpb246ICd3aWR0aCdcbiAgICAgIH0sXG4gICAgICB7IC8vIHBvc3NpYmxlIHZhbHVlcyBvZiBvcmlnaW5cbiAgICAgICAgbmVhcmVzdDogJ2xlZnQnLFxuICAgICAgICBjZW50ZXI6ICdjZW50ZXInLFxuICAgICAgICBmYXJ0aGVzdDogJ3JpZ2h0J1xuICAgICAgfVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gdG9wVG9PcmlnaW5ZIERpc3RhbmNlIGZyb20gdG9wIGVkZ2Ugb2YgY2FudmFzIHRvIG9yaWdpblkgb2YgTGluZS5cbiAgICAgKi9cbiAgICBfZ2V0VG9wVG9PcmlnaW5ZOiBtYWtlRWRnZVRvT3JpZ2luR2V0dGVyKFxuICAgICAgeyAvLyBwcm9wZXJ0eSBuYW1lc1xuICAgICAgICBvcmlnaW46ICdvcmlnaW5ZJyxcbiAgICAgICAgYXhpczE6ICd5MScsXG4gICAgICAgIGF4aXMyOiAneTInLFxuICAgICAgICBkaW1lbnNpb246ICdoZWlnaHQnXG4gICAgICB9LFxuICAgICAgeyAvLyBwb3NzaWJsZSB2YWx1ZXMgb2Ygb3JpZ2luXG4gICAgICAgIG5lYXJlc3Q6ICd0b3AnLFxuICAgICAgICBjZW50ZXI6ICdjZW50ZXInLFxuICAgICAgICBmYXJ0aGVzdDogJ2JvdHRvbSdcbiAgICAgIH1cbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG5cblxuICAgICAgdmFyIHAgPSB0aGlzLmNhbGNMaW5lUG9pbnRzKCk7XG4gICAgICBjdHgubW92ZVRvKHAueDEsIHAueTEpO1xuICAgICAgY3R4LmxpbmVUbyhwLngyLCBwLnkyKTtcblxuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGg7XG5cbiAgICAgIC8vIFRPRE86IHRlc3QgdGhpc1xuICAgICAgLy8gbWFrZSBzdXJlIHNldHRpbmcgXCJmaWxsXCIgY2hhbmdlcyBjb2xvciBvZiBhIGxpbmVcbiAgICAgIC8vIChieSBjb3B5aW5nIGZpbGxTdHlsZSB0byBzdHJva2VTdHlsZSwgc2luY2UgbGluZSBpcyBzdHJva2VkLCBub3QgZmlsbGVkKVxuICAgICAgdmFyIG9yaWdTdHJva2VTdHlsZSA9IGN0eC5zdHJva2VTdHlsZTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc3Ryb2tlIHx8IGN0eC5maWxsU3R5bGU7XG4gICAgICB0aGlzLnN0cm9rZSAmJiB0aGlzLl9yZW5kZXJTdHJva2UoY3R4KTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9yaWdTdHJva2VTdHlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBhbiBoZWxwZXIgZm9yIHN2ZyBpbXBvcnQuIGl0IHJldHVybnMgdGhlIGNlbnRlciBvZiB0aGUgb2JqZWN0IGluIHRoZSBzdmdcbiAgICAgKiB1bnRyYW5zZm9ybWVkIGNvb3JkaW5hdGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGNlbnRlciBwb2ludCBmcm9tIGVsZW1lbnQgY29vcmRpbmF0ZXNcbiAgICAgKi9cbiAgICBfZmluZENlbnRlckZyb21FbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6ICh0aGlzLngxICsgdGhpcy54MikgLyAyLFxuICAgICAgICB5OiAodGhpcy55MSArIHRoaXMueTIpIC8gMixcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQG1ldGhvZCB0b09iamVjdFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIHByb3BlcnRpZXNUb0luY2x1ZGUpLCB0aGlzLmNhbGNMaW5lUG9pbnRzKCkpO1xuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIENhbGN1bGF0ZSBvYmplY3QgZGltZW5zaW9ucyBmcm9tIGl0cyBwcm9wZXJ0aWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Tm9uVHJhbnNmb3JtZWREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkaW0gPSB0aGlzLmNhbGxTdXBlcignX2dldE5vblRyYW5zZm9ybWVkRGltZW5zaW9ucycpO1xuICAgICAgaWYgKHRoaXMuc3Ryb2tlTGluZUNhcCA9PT0gJ2J1dHQnKSB7XG4gICAgICAgIGlmICh0aGlzLndpZHRoID09PSAwKSB7XG4gICAgICAgICAgZGltLnkgLT0gdGhpcy5zdHJva2VXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICBkaW0ueCAtPSB0aGlzLnN0cm9rZVdpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGltO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWNhbGN1bGF0ZXMgbGluZSBwb2ludHMgZ2l2ZW4gd2lkdGggYW5kIGhlaWdodFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY2FsY0xpbmVQb2ludHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHhNdWx0ID0gdGhpcy54MSA8PSB0aGlzLngyID8gLTEgOiAxLFxuICAgICAgICAgIHlNdWx0ID0gdGhpcy55MSA8PSB0aGlzLnkyID8gLTEgOiAxLFxuICAgICAgICAgIHgxID0gKHhNdWx0ICogdGhpcy53aWR0aCAqIDAuNSksXG4gICAgICAgICAgeTEgPSAoeU11bHQgKiB0aGlzLmhlaWdodCAqIDAuNSksXG4gICAgICAgICAgeDIgPSAoeE11bHQgKiB0aGlzLndpZHRoICogLTAuNSksXG4gICAgICAgICAgeTIgPSAoeU11bHQgKiB0aGlzLmhlaWdodCAqIC0wLjUpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogeDEsXG4gICAgICAgIHgyOiB4MixcbiAgICAgICAgeTE6IHkxLFxuICAgICAgICB5MjogeTJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYW4gYXJyYXkgb2Ygc3RyaW5ncyB3aXRoIHRoZSBzcGVjaWZpYyBzdmcgcmVwcmVzZW50YXRpb25cbiAgICAgKiBvZiB0aGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfdG9TVkc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHAgPSB0aGlzLmNhbGNMaW5lUG9pbnRzKCk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAnPGxpbmUgJywgJ0NPTU1PTl9QQVJUUycsXG4gICAgICAgICd4MT1cIicsIHAueDEsXG4gICAgICAgICdcIiB5MT1cIicsIHAueTEsXG4gICAgICAgICdcIiB4Mj1cIicsIHAueDIsXG4gICAgICAgICdcIiB5Mj1cIicsIHAueTIsXG4gICAgICAgICdcIiAvPlxcbidcbiAgICAgIF07XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cbiAgfSk7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IHtAbGluayBmYWJyaWMuTGluZS5mcm9tRWxlbWVudH0pXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5MaW5lXG4gICAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI0xpbmVFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuTGluZS5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KCd4MSB5MSB4MiB5Micuc3BsaXQoJyAnKSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLkxpbmUgaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuTGluZVxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBhZnRlciBwYXJzaW5nXG4gICAqL1xuICBmYWJyaWMuTGluZS5mcm9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB9O1xuICAgIHZhciBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuTGluZS5BVFRSSUJVVEVfTkFNRVMpLFxuICAgICAgICBwb2ludHMgPSBbXG4gICAgICAgICAgcGFyc2VkQXR0cmlidXRlcy54MSB8fCAwLFxuICAgICAgICAgIHBhcnNlZEF0dHJpYnV0ZXMueTEgfHwgMCxcbiAgICAgICAgICBwYXJzZWRBdHRyaWJ1dGVzLngyIHx8IDAsXG4gICAgICAgICAgcGFyc2VkQXR0cmlidXRlcy55MiB8fCAwXG4gICAgICAgIF07XG4gICAgY2FsbGJhY2sobmV3IGZhYnJpYy5MaW5lKHBvaW50cywgZXh0ZW5kKHBhcnNlZEF0dHJpYnV0ZXMsIG9wdGlvbnMpKSk7XG4gIH07XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLkxpbmUgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkxpbmVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBpbnZva2VkIHdpdGggbmV3IGluc3RhbmNlIGFzIGZpcnN0IGFyZ3VtZW50XG4gICAqL1xuICBmYWJyaWMuTGluZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIGZ1bmN0aW9uIF9jYWxsYmFjayhpbnN0YW5jZSkge1xuICAgICAgZGVsZXRlIGluc3RhbmNlLnBvaW50cztcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGluc3RhbmNlKTtcbiAgICB9O1xuICAgIHZhciBvcHRpb25zID0gY2xvbmUob2JqZWN0LCB0cnVlKTtcbiAgICBvcHRpb25zLnBvaW50cyA9IFtvYmplY3QueDEsIG9iamVjdC55MSwgb2JqZWN0LngyLCBvYmplY3QueTJdO1xuICAgIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ0xpbmUnLCBvcHRpb25zLCBfY2FsbGJhY2ssICdwb2ludHMnKTtcbiAgfTtcblxuICAvKipcbiAgICogUHJvZHVjZXMgYSBmdW5jdGlvbiB0aGF0IGNhbGN1bGF0ZXMgZGlzdGFuY2UgZnJvbSBjYW52YXMgZWRnZSB0byBMaW5lIG9yaWdpbi5cbiAgICovXG4gIGZ1bmN0aW9uIG1ha2VFZGdlVG9PcmlnaW5HZXR0ZXIocHJvcGVydHlOYW1lcywgb3JpZ2luVmFsdWVzKSB7XG4gICAgdmFyIG9yaWdpbiA9IHByb3BlcnR5TmFtZXMub3JpZ2luLFxuICAgICAgICBheGlzMSA9IHByb3BlcnR5TmFtZXMuYXhpczEsXG4gICAgICAgIGF4aXMyID0gcHJvcGVydHlOYW1lcy5heGlzMixcbiAgICAgICAgZGltZW5zaW9uID0gcHJvcGVydHlOYW1lcy5kaW1lbnNpb24sXG4gICAgICAgIG5lYXJlc3QgPSBvcmlnaW5WYWx1ZXMubmVhcmVzdCxcbiAgICAgICAgY2VudGVyID0gb3JpZ2luVmFsdWVzLmNlbnRlcixcbiAgICAgICAgZmFydGhlc3QgPSBvcmlnaW5WYWx1ZXMuZmFydGhlc3Q7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuZ2V0KG9yaWdpbikpIHtcbiAgICAgICAgY2FzZSBuZWFyZXN0OlxuICAgICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmdldChheGlzMSksIHRoaXMuZ2V0KGF4aXMyKSk7XG4gICAgICAgIGNhc2UgY2VudGVyOlxuICAgICAgICAgIHJldHVybiBNYXRoLm1pbih0aGlzLmdldChheGlzMSksIHRoaXMuZ2V0KGF4aXMyKSkgKyAoMC41ICogdGhpcy5nZXQoZGltZW5zaW9uKSk7XG4gICAgICAgIGNhc2UgZmFydGhlc3Q6XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuZ2V0KGF4aXMxKSwgdGhpcy5nZXQoYXhpczIpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIH1cblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZGVncmVlc1RvUmFkaWFucyA9IGZhYnJpYy51dGlsLmRlZ3JlZXNUb1JhZGlhbnM7XG5cbiAgaWYgKGZhYnJpYy5DaXJjbGUpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLkNpcmNsZSBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIENpcmNsZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkNpcmNsZVxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5DaXJjbGUjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5DaXJjbGUgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5DaXJjbGUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnY2lyY2xlJyxcblxuICAgIC8qKlxuICAgICAqIFJhZGl1cyBvZiB0aGlzIGNpcmNsZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcmFkaXVzOiAwLFxuXG4gICAgLyoqXG4gICAgICogZGVncmVlcyBvZiBzdGFydCBvZiB0aGUgY2lyY2xlLlxuICAgICAqIHByb2JhYmx5IHdpbGwgY2hhbmdlIHRvIGRlZ3JlZXMgaW4gbmV4dCBtYWpvciB2ZXJzaW9uXG4gICAgICogQHR5cGUgTnVtYmVyIDAgLSAzNTlcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgc3RhcnRBbmdsZTogMCxcblxuICAgIC8qKlxuICAgICAqIEVuZCBhbmdsZSBvZiB0aGUgY2lyY2xlXG4gICAgICogcHJvYmFibHkgd2lsbCBjaGFuZ2UgdG8gZGVncmVlcyBpbiBuZXh0IG1ham9yIHZlcnNpb25cbiAgICAgKiBAdHlwZSBOdW1iZXIgMSAtIDM2MFxuICAgICAqIEBkZWZhdWx0IDM2MFxuICAgICAqL1xuICAgIGVuZEFuZ2xlOiAzNjAsXG5cbiAgICBjYWNoZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNhY2hlUHJvcGVydGllcy5jb25jYXQoJ3JhZGl1cycsICdzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJyksXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7ZmFicmljLkNpcmNsZX0gdGhpc0FyZ1xuICAgICAqL1xuICAgIF9zZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdfc2V0Jywga2V5LCB2YWx1ZSk7XG5cbiAgICAgIGlmIChrZXkgPT09ICdyYWRpdXMnKSB7XG4gICAgICAgIHRoaXMuc2V0UmFkaXVzKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBbJ3JhZGl1cycsICdzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJ10uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpKTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IG9mIHN0cmluZ3Mgd2l0aCB0aGUgc3BlY2lmaWMgc3ZnIHJlcHJlc2VudGF0aW9uXG4gICAgICogb2YgdGhlIGluc3RhbmNlXG4gICAgICovXG4gICAgX3RvU1ZHOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdmdTdHJpbmcsIHggPSAwLCB5ID0gMCxcbiAgICAgICAgICBhbmdsZSA9ICh0aGlzLmVuZEFuZ2xlIC0gdGhpcy5zdGFydEFuZ2xlKSAlIDM2MDtcblxuICAgICAgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgICAgIHN2Z1N0cmluZyA9IFtcbiAgICAgICAgICAnPGNpcmNsZSAnLCAnQ09NTU9OX1BBUlRTJyxcbiAgICAgICAgICAnY3g9XCInICsgeCArICdcIiBjeT1cIicgKyB5ICsgJ1wiICcsXG4gICAgICAgICAgJ3I9XCInLCB0aGlzLnJhZGl1cyxcbiAgICAgICAgICAnXCIgLz5cXG4nXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gZGVncmVlc1RvUmFkaWFucyh0aGlzLnN0YXJ0QW5nbGUpLFxuICAgICAgICAgICAgZW5kID0gZGVncmVlc1RvUmFkaWFucyh0aGlzLmVuZEFuZ2xlKSxcbiAgICAgICAgICAgIHJhZGl1cyA9IHRoaXMucmFkaXVzLFxuICAgICAgICAgICAgc3RhcnRYID0gZmFicmljLnV0aWwuY29zKHN0YXJ0KSAqIHJhZGl1cyxcbiAgICAgICAgICAgIHN0YXJ0WSA9IGZhYnJpYy51dGlsLnNpbihzdGFydCkgKiByYWRpdXMsXG4gICAgICAgICAgICBlbmRYID0gZmFicmljLnV0aWwuY29zKGVuZCkgKiByYWRpdXMsXG4gICAgICAgICAgICBlbmRZID0gZmFicmljLnV0aWwuc2luKGVuZCkgKiByYWRpdXMsXG4gICAgICAgICAgICBsYXJnZUZsYWcgPSBhbmdsZSA+IDE4MCA/ICcxJyA6ICcwJztcbiAgICAgICAgc3ZnU3RyaW5nID0gW1xuICAgICAgICAgICc8cGF0aCBkPVwiTSAnICsgc3RhcnRYICsgJyAnICsgc3RhcnRZLFxuICAgICAgICAgICcgQSAnICsgcmFkaXVzICsgJyAnICsgcmFkaXVzLFxuICAgICAgICAgICcgMCAnLCArbGFyZ2VGbGFnICsgJyAxJywgJyAnICsgZW5kWCArICcgJyArIGVuZFksXG4gICAgICAgICAgJ1wiICcsICdDT01NT05fUEFSVFMnLCAnIC8+XFxuJ1xuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN2Z1N0cmluZztcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguYXJjKFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICB0aGlzLnJhZGl1cyxcbiAgICAgICAgZGVncmVlc1RvUmFkaWFucyh0aGlzLnN0YXJ0QW5nbGUpLFxuICAgICAgICBkZWdyZWVzVG9SYWRpYW5zKHRoaXMuZW5kQW5nbGUpLFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICAgIHRoaXMuX3JlbmRlclBhaW50SW5PcmRlcihjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGhvcml6b250YWwgcmFkaXVzIG9mIGFuIG9iamVjdCAoYWNjb3JkaW5nIHRvIGhvdyBhbiBvYmplY3QgaXMgc2NhbGVkKVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRSYWRpdXNYOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgncmFkaXVzJykgKiB0aGlzLmdldCgnc2NhbGVYJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdmVydGljYWwgcmFkaXVzIG9mIGFuIG9iamVjdCAoYWNjb3JkaW5nIHRvIGhvdyBhbiBvYmplY3QgaXMgc2NhbGVkKVxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRSYWRpdXNZOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgncmFkaXVzJykgKiB0aGlzLmdldCgnc2NhbGVZJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgcmFkaXVzIG9mIGFuIG9iamVjdCAoYW5kIHVwZGF0ZXMgd2lkdGggYWNjb3JkaW5nbHkpXG4gICAgICogQHJldHVybiB7ZmFicmljLkNpcmNsZX0gdGhpc0FyZ1xuICAgICAqL1xuICAgIHNldFJhZGl1czogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHRoaXMucmFkaXVzID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcy5zZXQoJ3dpZHRoJywgdmFsdWUgKiAyKS5zZXQoJ2hlaWdodCcsIHZhbHVlICogMik7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IHtAbGluayBmYWJyaWMuQ2lyY2xlLmZyb21FbGVtZW50fSlcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkNpcmNsZVxuICAgKiBAc2VlOiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc2hhcGVzLmh0bWwjQ2lyY2xlRWxlbWVudFxuICAgKi9cbiAgZmFicmljLkNpcmNsZS5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KCdjeCBjeSByJy5zcGxpdCgnICcpKTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLkNpcmNsZX0gaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuQ2lyY2xlXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gT3B0aW9ucyBjYWxsYmFjayBpbnZva2VkIGFmdGVyIHBhcnNpbmcgaXMgZmluaXNoZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdmFsdWUgb2YgYHJgIGF0dHJpYnV0ZSBpcyBtaXNzaW5nIG9yIGludmFsaWRcbiAgICovXG4gIGZhYnJpYy5DaXJjbGUuZnJvbUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaykge1xuICAgIHZhciBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuQ2lyY2xlLkFUVFJJQlVURV9OQU1FUyk7XG5cbiAgICBpZiAoIWlzVmFsaWRSYWRpdXMocGFyc2VkQXR0cmlidXRlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndmFsdWUgb2YgYHJgIGF0dHJpYnV0ZSBpcyByZXF1aXJlZCBhbmQgY2FuIG5vdCBiZSBuZWdhdGl2ZScpO1xuICAgIH1cblxuICAgIHBhcnNlZEF0dHJpYnV0ZXMubGVmdCA9IChwYXJzZWRBdHRyaWJ1dGVzLmxlZnQgfHwgMCkgLSBwYXJzZWRBdHRyaWJ1dGVzLnJhZGl1cztcbiAgICBwYXJzZWRBdHRyaWJ1dGVzLnRvcCA9IChwYXJzZWRBdHRyaWJ1dGVzLnRvcCB8fCAwKSAtIHBhcnNlZEF0dHJpYnV0ZXMucmFkaXVzO1xuICAgIGNhbGxiYWNrKG5ldyBmYWJyaWMuQ2lyY2xlKHBhcnNlZEF0dHJpYnV0ZXMpKTtcbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGlzVmFsaWRSYWRpdXMoYXR0cmlidXRlcykge1xuICAgIHJldHVybiAoKCdyYWRpdXMnIGluIGF0dHJpYnV0ZXMpICYmIChhdHRyaWJ1dGVzLnJhZGl1cyA+PSAwKSk7XG4gIH1cbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLkNpcmNsZX0gaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkNpcmNsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGludm9rZWQgd2l0aCBuZXcgaW5zdGFuY2UgYXMgZmlyc3QgYXJndW1lbnRcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIGZhYnJpYy5DaXJjbGUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdDaXJjbGUnLCBvYmplY3QsIGNhbGxiYWNrKTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pO1xuXG4gIGlmIChmYWJyaWMuVHJpYW5nbGUpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlRyaWFuZ2xlIGlzIGFscmVhZHkgZGVmaW5lZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlhbmdsZSBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlRyaWFuZ2xlXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLlRyaWFuZ2xlfSB0aGlzQXJnXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5UcmlhbmdsZSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlRyaWFuZ2xlID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuVHJpYW5nbGUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAndHJpYW5nbGUnLFxuXG4gICAgLyoqXG4gICAgICogV2lkdGggaXMgc2V0IHRvIDEwMCB0byBjb21wZW5zYXRlIHRoZSBvbGQgaW5pdGlhbGl6ZSBjb2RlIHRoYXQgd2FzIHNldHRpbmcgaXQgdG8gMTAwXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB3aWR0aDogMTAwLFxuXG4gICAgLyoqXG4gICAgICogSGVpZ2h0IGlzIHNldCB0byAxMDAgdG8gY29tcGVuc2F0ZSB0aGUgb2xkIGluaXRpYWxpemUgY29kZSB0aGF0IHdhcyBzZXR0aW5nIGl0IHRvIDEwMFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgaGVpZ2h0OiAxMDAsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHZhciB3aWR0aEJ5MiA9IHRoaXMud2lkdGggLyAyLFxuICAgICAgICAgIGhlaWdodEJ5MiA9IHRoaXMuaGVpZ2h0IC8gMjtcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbygtd2lkdGhCeTIsIGhlaWdodEJ5Mik7XG4gICAgICBjdHgubGluZVRvKDAsIC1oZWlnaHRCeTIpO1xuICAgICAgY3R4LmxpbmVUbyh3aWR0aEJ5MiwgaGVpZ2h0QnkyKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgICAgdGhpcy5fcmVuZGVyUGFpbnRJbk9yZGVyKGN0eCk7XG4gICAgfSxcblxuICAgIC8qIF9UT19TVkdfU1RBUlRfICovXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gYW4gYXJyYXkgb2Ygc3RyaW5ncyB3aXRoIHRoZSBzcGVjaWZpYyBzdmcgcmVwcmVzZW50YXRpb25cbiAgICAgKiBvZiB0aGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfdG9TVkc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHdpZHRoQnkyID0gdGhpcy53aWR0aCAvIDIsXG4gICAgICAgICAgaGVpZ2h0QnkyID0gdGhpcy5oZWlnaHQgLyAyLFxuICAgICAgICAgIHBvaW50cyA9IFtcbiAgICAgICAgICAgIC13aWR0aEJ5MiArICcgJyArIGhlaWdodEJ5MixcbiAgICAgICAgICAgICcwICcgKyAtaGVpZ2h0QnkyLFxuICAgICAgICAgICAgd2lkdGhCeTIgKyAnICcgKyBoZWlnaHRCeTJcbiAgICAgICAgICBdLmpvaW4oJywnKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgICc8cG9seWdvbiAnLCAnQ09NTU9OX1BBUlRTJyxcbiAgICAgICAgJ3BvaW50cz1cIicsIHBvaW50cyxcbiAgICAgICAgJ1wiIC8+J1xuICAgICAgXTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLlRyaWFuZ2xlfSBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuVHJpYW5nbGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBpbnZva2VkIHdpdGggbmV3IGluc3RhbmNlIGFzIGZpcnN0IGFyZ3VtZW50XG4gICAqL1xuICBmYWJyaWMuVHJpYW5nbGUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnVHJpYW5nbGUnLCBvYmplY3QsIGNhbGxiYWNrKTtcbiAgfTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgcGlCeTIgICA9IE1hdGguUEkgKiAyO1xuXG4gIGlmIChmYWJyaWMuRWxsaXBzZSkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuRWxsaXBzZSBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIEVsbGlwc2UgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5FbGxpcHNlXG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLkVsbGlwc2V9IHRoaXNBcmdcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkVsbGlwc2UjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5FbGxpcHNlID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuRWxsaXBzZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdlbGxpcHNlJyxcblxuICAgIC8qKlxuICAgICAqIEhvcml6b250YWwgcmFkaXVzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByeDogICAwLFxuXG4gICAgLyoqXG4gICAgICogVmVydGljYWwgcmFkaXVzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByeTogICAwLFxuXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5jYWNoZVByb3BlcnRpZXMuY29uY2F0KCdyeCcsICdyeScpLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLkVsbGlwc2V9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5zZXQoJ3J4Jywgb3B0aW9ucyAmJiBvcHRpb25zLnJ4IHx8IDApO1xuICAgICAgdGhpcy5zZXQoJ3J5Jywgb3B0aW9ucyAmJiBvcHRpb25zLnJ5IHx8IDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7ZmFicmljLkVsbGlwc2V9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBfc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignX3NldCcsIGtleSwgdmFsdWUpO1xuICAgICAgc3dpdGNoIChrZXkpIHtcblxuICAgICAgICBjYXNlICdyeCc6XG4gICAgICAgICAgdGhpcy5yeCA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuc2V0KCd3aWR0aCcsIHZhbHVlICogMik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncnknOlxuICAgICAgICAgIHRoaXMucnkgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLnNldCgnaGVpZ2h0JywgdmFsdWUgKiAyKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaG9yaXpvbnRhbCByYWRpdXMgb2YgYW4gb2JqZWN0IChhY2NvcmRpbmcgdG8gaG93IGFuIG9iamVjdCBpcyBzY2FsZWQpXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFJ4OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgncngnKSAqIHRoaXMuZ2V0KCdzY2FsZVgnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBWZXJ0aWNhbCByYWRpdXMgb2YgYW4gb2JqZWN0IChhY2NvcmRpbmcgdG8gaG93IGFuIG9iamVjdCBpcyBzY2FsZWQpXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFJ5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgncnknKSAqIHRoaXMuZ2V0KCdzY2FsZVknKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIFsncngnLCAncnknXS5jb25jYXQocHJvcGVydGllc1RvSW5jbHVkZSkpO1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IG9mIHN0cmluZ3Mgd2l0aCB0aGUgc3BlY2lmaWMgc3ZnIHJlcHJlc2VudGF0aW9uXG4gICAgICogb2YgdGhlIGluc3RhbmNlXG4gICAgICovXG4gICAgX3RvU1ZHOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgICc8ZWxsaXBzZSAnLCAnQ09NTU9OX1BBUlRTJyxcbiAgICAgICAgJ2N4PVwiMFwiIGN5PVwiMFwiICcsXG4gICAgICAgICdyeD1cIicsIHRoaXMucngsXG4gICAgICAgICdcIiByeT1cIicsIHRoaXMucnksXG4gICAgICAgICdcIiAvPlxcbidcbiAgICAgIF07XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBjb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0oMSwgMCwgMCwgdGhpcy5yeSAvIHRoaXMucngsIDAsIDApO1xuICAgICAgY3R4LmFyYyhcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgdGhpcy5yeCxcbiAgICAgICAgMCxcbiAgICAgICAgcGlCeTIsXG4gICAgICAgIGZhbHNlKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLl9yZW5kZXJQYWludEluT3JkZXIoY3R4KTtcbiAgICB9LFxuICB9KTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkge0BsaW5rIGZhYnJpYy5FbGxpcHNlLmZyb21FbGVtZW50fSlcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkVsbGlwc2VcbiAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc2hhcGVzLmh0bWwjRWxsaXBzZUVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5FbGxpcHNlLkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoJ2N4IGN5IHJ4IHJ5Jy5zcGxpdCgnICcpKTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLkVsbGlwc2V9IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkVsbGlwc2VcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBPcHRpb25zIGNhbGxiYWNrIGludm9rZWQgYWZ0ZXIgcGFyc2luZyBpcyBmaW5pc2hlZFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuRWxsaXBzZX1cbiAgICovXG4gIGZhYnJpYy5FbGxpcHNlLmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2spIHtcblxuICAgIHZhciBwYXJzZWRBdHRyaWJ1dGVzID0gZmFicmljLnBhcnNlQXR0cmlidXRlcyhlbGVtZW50LCBmYWJyaWMuRWxsaXBzZS5BVFRSSUJVVEVfTkFNRVMpO1xuXG4gICAgcGFyc2VkQXR0cmlidXRlcy5sZWZ0ID0gKHBhcnNlZEF0dHJpYnV0ZXMubGVmdCB8fCAwKSAtIHBhcnNlZEF0dHJpYnV0ZXMucng7XG4gICAgcGFyc2VkQXR0cmlidXRlcy50b3AgPSAocGFyc2VkQXR0cmlidXRlcy50b3AgfHwgMCkgLSBwYXJzZWRBdHRyaWJ1dGVzLnJ5O1xuICAgIGNhbGxiYWNrKG5ldyBmYWJyaWMuRWxsaXBzZShwYXJzZWRBdHRyaWJ1dGVzKSk7XG4gIH07XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5FbGxpcHNlfSBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuRWxsaXBzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGludm9rZWQgd2l0aCBuZXcgaW5zdGFuY2UgYXMgZmlyc3QgYXJndW1lbnRcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIGZhYnJpYy5FbGxpcHNlLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnRWxsaXBzZScsIG9iamVjdCwgY2FsbGJhY2spO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kO1xuXG4gIGlmIChmYWJyaWMuUmVjdCkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuUmVjdCBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogUmVjdGFuZ2xlIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUmVjdFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEByZXR1cm4ge2ZhYnJpYy5SZWN0fSB0aGlzQXJnXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5SZWN0I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuUmVjdCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLlJlY3QucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgcHJvcGVydGllcyB0byBjb25zaWRlciB3aGVuIGNoZWNraW5nIGlmIHN0YXRlIG9mIGFuIG9iamVjdCBpcyBjaGFuZ2VkICh7QGxpbmsgZmFicmljLk9iamVjdCNoYXNTdGF0ZUNoYW5nZWR9KVxuICAgICAqIGFzIHdlbGwgYXMgZm9yIGhpc3RvcnkgKHVuZG8vcmVkbykgcHVycG9zZXNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIHN0YXRlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuc3RhdGVQcm9wZXJ0aWVzLmNvbmNhdCgncngnLCAncnknKSxcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAncmVjdCcsXG5cbiAgICAvKipcbiAgICAgKiBIb3Jpem9udGFsIGJvcmRlciByYWRpdXNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHJ4OiAgIDAsXG5cbiAgICAvKipcbiAgICAgKiBWZXJ0aWNhbCBib3JkZXIgcmFkaXVzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByeTogICAwLFxuXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5jYWNoZVByb3BlcnRpZXMuY29uY2F0KCdyeCcsICdyeScpLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX2luaXRSeFJ5KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHJ4L3J5IGF0dHJpYnV0ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0UnhSeTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5yeCAmJiAhdGhpcy5yeSkge1xuICAgICAgICB0aGlzLnJ5ID0gdGhpcy5yeDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMucnkgJiYgIXRoaXMucngpIHtcbiAgICAgICAgdGhpcy5yeCA9IHRoaXMucnk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuXG4gICAgICAvLyAxeDEgY2FzZSAodXNlZCBpbiBzcHJheSBicnVzaCkgb3B0aW1pemF0aW9uIHdhcyByZW1vdmVkIGJlY2F1c2VcbiAgICAgIC8vIHdpdGggY2FjaGluZyBhbmQgaGlnaGVyIHpvb20gbGV2ZWwgdGhpcyBtYWtlcyBtb3JlIGRhbWFnZSB0aGFuIGhlbHBcblxuICAgICAgdmFyIHJ4ID0gdGhpcy5yeCA/IE1hdGgubWluKHRoaXMucngsIHRoaXMud2lkdGggLyAyKSA6IDAsXG4gICAgICAgICAgcnkgPSB0aGlzLnJ5ID8gTWF0aC5taW4odGhpcy5yeSwgdGhpcy5oZWlnaHQgLyAyKSA6IDAsXG4gICAgICAgICAgdyA9IHRoaXMud2lkdGgsXG4gICAgICAgICAgaCA9IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgIHggPSAtdGhpcy53aWR0aCAvIDIsXG4gICAgICAgICAgeSA9IC10aGlzLmhlaWdodCAvIDIsXG4gICAgICAgICAgaXNSb3VuZGVkID0gcnggIT09IDAgfHwgcnkgIT09IDAsXG4gICAgICAgICAgLyogXCJtYWdpYyBudW1iZXJcIiBmb3IgYmV6aWVyIGFwcHJveGltYXRpb25zIG9mIGFyY3MgKGh0dHA6Ly9pdGMua3R1Lmx0L2l0YzM1NC9SaXNrdXMzNTQucGRmKSAqL1xuICAgICAgICAgIGsgPSAxIC0gMC41NTIyODQ3NDk4O1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICBjdHgubW92ZVRvKHggKyByeCwgeSk7XG5cbiAgICAgIGN0eC5saW5lVG8oeCArIHcgLSByeCwgeSk7XG4gICAgICBpc1JvdW5kZWQgJiYgY3R4LmJlemllckN1cnZlVG8oeCArIHcgLSBrICogcngsIHksIHggKyB3LCB5ICsgayAqIHJ5LCB4ICsgdywgeSArIHJ5KTtcblxuICAgICAgY3R4LmxpbmVUbyh4ICsgdywgeSArIGggLSByeSk7XG4gICAgICBpc1JvdW5kZWQgJiYgY3R4LmJlemllckN1cnZlVG8oeCArIHcsIHkgKyBoIC0gayAqIHJ5LCB4ICsgdyAtIGsgKiByeCwgeSArIGgsIHggKyB3IC0gcngsIHkgKyBoKTtcblxuICAgICAgY3R4LmxpbmVUbyh4ICsgcngsIHkgKyBoKTtcbiAgICAgIGlzUm91bmRlZCAmJiBjdHguYmV6aWVyQ3VydmVUbyh4ICsgayAqIHJ4LCB5ICsgaCwgeCwgeSArIGggLSBrICogcnksIHgsIHkgKyBoIC0gcnkpO1xuXG4gICAgICBjdHgubGluZVRvKHgsIHkgKyByeSk7XG4gICAgICBpc1JvdW5kZWQgJiYgY3R4LmJlemllckN1cnZlVG8oeCwgeSArIGsgKiByeSwgeCArIGsgKiByeCwgeSwgeCArIHJ4LCB5KTtcblxuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgICB0aGlzLl9yZW5kZXJQYWludEluT3JkZXIoY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcsIFsncngnLCAncnknXS5jb25jYXQocHJvcGVydGllc1RvSW5jbHVkZSkpO1xuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IG9mIHN0cmluZ3Mgd2l0aCB0aGUgc3BlY2lmaWMgc3ZnIHJlcHJlc2VudGF0aW9uXG4gICAgICogb2YgdGhlIGluc3RhbmNlXG4gICAgICovXG4gICAgX3RvU1ZHOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB4ID0gLXRoaXMud2lkdGggLyAyLCB5ID0gLXRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIHJldHVybiBbXG4gICAgICAgICc8cmVjdCAnLCAnQ09NTU9OX1BBUlRTJyxcbiAgICAgICAgJ3g9XCInLCB4LCAnXCIgeT1cIicsIHksXG4gICAgICAgICdcIiByeD1cIicsIHRoaXMucngsICdcIiByeT1cIicsIHRoaXMucnksXG4gICAgICAgICdcIiB3aWR0aD1cIicsIHRoaXMud2lkdGgsICdcIiBoZWlnaHQ9XCInLCB0aGlzLmhlaWdodCxcbiAgICAgICAgJ1wiIC8+XFxuJ1xuICAgICAgXTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuICB9KTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkgYGZhYnJpYy5SZWN0LmZyb21FbGVtZW50YClcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlJlY3RcbiAgICogQHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI1JlY3RFbGVtZW50XG4gICAqL1xuICBmYWJyaWMuUmVjdC5BVFRSSUJVVEVfTkFNRVMgPSBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KCd4IHkgcnggcnkgd2lkdGggaGVpZ2h0Jy5zcGxpdCgnICcpKTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLlJlY3R9IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlJlY3RcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBhZnRlciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGZhYnJpYy5SZWN0LmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB9O1xuXG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5SZWN0LkFUVFJJQlVURV9OQU1FUyk7XG4gICAgcGFyc2VkQXR0cmlidXRlcy5sZWZ0ID0gcGFyc2VkQXR0cmlidXRlcy5sZWZ0IHx8IDA7XG4gICAgcGFyc2VkQXR0cmlidXRlcy50b3AgID0gcGFyc2VkQXR0cmlidXRlcy50b3AgIHx8IDA7XG4gICAgcGFyc2VkQXR0cmlidXRlcy5oZWlnaHQgID0gcGFyc2VkQXR0cmlidXRlcy5oZWlnaHQgfHwgMDtcbiAgICBwYXJzZWRBdHRyaWJ1dGVzLndpZHRoICA9IHBhcnNlZEF0dHJpYnV0ZXMud2lkdGggfHwgMDtcbiAgICB2YXIgcmVjdCA9IG5ldyBmYWJyaWMuUmVjdChleHRlbmQoKG9wdGlvbnMgPyBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUob3B0aW9ucykgOiB7IH0pLCBwYXJzZWRBdHRyaWJ1dGVzKSk7XG4gICAgcmVjdC52aXNpYmxlID0gcmVjdC52aXNpYmxlICYmIHJlY3Qud2lkdGggPiAwICYmIHJlY3QuaGVpZ2h0ID4gMDtcbiAgICBjYWxsYmFjayhyZWN0KTtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLlJlY3R9IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5SZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlJlY3QgaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLlJlY3QuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnUmVjdCcsIG9iamVjdCwgY2FsbGJhY2spO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgbWluID0gZmFicmljLnV0aWwuYXJyYXkubWluLFxuICAgICAgbWF4ID0gZmFicmljLnV0aWwuYXJyYXkubWF4LFxuICAgICAgdG9GaXhlZCA9IGZhYnJpYy51dGlsLnRvRml4ZWQsXG4gICAgICBwcm9qZWN0U3Ryb2tlT25Qb2ludHMgPSBmYWJyaWMudXRpbC5wcm9qZWN0U3Ryb2tlT25Qb2ludHM7XG5cbiAgaWYgKGZhYnJpYy5Qb2x5bGluZSkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuUG9seWxpbmUgaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvbHlsaW5lIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuUG9seWxpbmVcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuUG9seWxpbmUjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5Qb2x5bGluZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLlBvbHlsaW5lLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ3BvbHlsaW5lJyxcblxuICAgIC8qKlxuICAgICAqIFBvaW50cyBhcnJheVxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwb2ludHM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBXQVJOSU5HOiBGZWF0dXJlIGluIHByb2dyZXNzXG4gICAgICogQ2FsY3VsYXRlIHRoZSBleGFjdCBib3VuZGluZyBib3ggdGFraW5nIGluIGFjY291bnQgc3Ryb2tlV2lkdGggb24gYWN1dGUgYW5nbGVzXG4gICAgICogdGhpcyB3aWxsIGJlIHR1cm5lZCB0byB0cnVlIGJ5IGRlZmF1bHQgb24gZmFicmljIDYuMFxuICAgICAqIG1heWJlIHdpbGwgYmUgbGVmdCBpbiBhcyBhbiBvcHRpbWl6YXRpb24gc2luY2UgY2FsY3VsYXRpb25zIG1heSBiZSBzbG93XG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBleGFjdEJvdW5kaW5nQm94OiBmYWxzZSxcblxuICAgIGNhY2hlUHJvcGVydGllczogZmFicmljLk9iamVjdC5wcm90b3R5cGUuY2FjaGVQcm9wZXJ0aWVzLmNvbmNhdCgncG9pbnRzJyksXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyBBcnJheSBvZiBwb2ludHMgKHdoZXJlIGVhY2ggcG9pbnQgaXMgYW4gb2JqZWN0IHdpdGggeCBhbmQgeSlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7ZmFicmljLlBvbHlsaW5lfSB0aGlzQXJnXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgcG9seSA9IG5ldyBmYWJyaWMuUG9seWxpbmUoW1xuICAgICAqICAgICB7IHg6IDEwLCB5OiAxMCB9LFxuICAgICAqICAgICB7IHg6IDUwLCB5OiAzMCB9LFxuICAgICAqICAgICB7IHg6IDQwLCB5OiA3MCB9LFxuICAgICAqICAgICB7IHg6IDYwLCB5OiA1MCB9LFxuICAgICAqICAgICB7IHg6IDEwMCwgeTogMTUwIH0sXG4gICAgICogICAgIHsgeDogNDAsIHk6IDEwMCB9XG4gICAgICogICBdLCB7XG4gICAgICogICBzdHJva2U6ICdyZWQnLFxuICAgICAqICAgbGVmdDogMTAwLFxuICAgICAqICAgdG9wOiAxMDBcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihwb2ludHMsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgdGhpcy5wb2ludHMgPSBwb2ludHMgfHwgW107XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5fc2V0UG9zaXRpb25EaW1lbnNpb25zKG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wcm9qZWN0U3Ryb2tlT25Qb2ludHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBwcm9qZWN0U3Ryb2tlT25Qb2ludHModGhpcy5wb2ludHMsIHRoaXMsIHRydWUpO1xuICAgIH0sXG5cbiAgICBfc2V0UG9zaXRpb25EaW1lbnNpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgY2FsY0RpbSA9IHRoaXMuX2NhbGNEaW1lbnNpb25zKG9wdGlvbnMpLCBjb3JyZWN0TGVmdFRvcCxcbiAgICAgICAgICBjb3JyZWN0U2l6ZSA9IHRoaXMuZXhhY3RCb3VuZGluZ0JveCA/IHRoaXMuc3Ryb2tlV2lkdGggOiAwO1xuICAgICAgdGhpcy53aWR0aCA9IGNhbGNEaW0ud2lkdGggLSBjb3JyZWN0U2l6ZTtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gY2FsY0RpbS5oZWlnaHQgLSBjb3JyZWN0U2l6ZTtcbiAgICAgIGlmICghb3B0aW9ucy5mcm9tU1ZHKSB7XG4gICAgICAgIGNvcnJlY3RMZWZ0VG9wID0gdGhpcy50cmFuc2xhdGVUb0dpdmVuT3JpZ2luKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIHRoaXMgbG9va3MgYmFkLCBidXQgaXMgb25lIHdheSB0byBrZWVwIGl0IG9wdGlvbmFsIGZvciBub3cuXG4gICAgICAgICAgICB4OiBjYWxjRGltLmxlZnQgLSB0aGlzLnN0cm9rZVdpZHRoIC8gMiArIGNvcnJlY3RTaXplIC8gMixcbiAgICAgICAgICAgIHk6IGNhbGNEaW0udG9wIC0gdGhpcy5zdHJva2VXaWR0aCAvIDIgKyBjb3JyZWN0U2l6ZSAvIDJcbiAgICAgICAgICB9LFxuICAgICAgICAgICdsZWZ0JyxcbiAgICAgICAgICAndG9wJyxcbiAgICAgICAgICB0aGlzLm9yaWdpblgsXG4gICAgICAgICAgdGhpcy5vcmlnaW5ZXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMubGVmdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5sZWZ0ID0gb3B0aW9ucy5mcm9tU1ZHID8gY2FsY0RpbS5sZWZ0IDogY29ycmVjdExlZnRUb3AueDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b3AgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMudG9wID0gb3B0aW9ucy5mcm9tU1ZHID8gY2FsY0RpbS50b3AgOiBjb3JyZWN0TGVmdFRvcC55O1xuICAgICAgfVxuICAgICAgdGhpcy5wYXRoT2Zmc2V0ID0ge1xuICAgICAgICB4OiBjYWxjRGltLmxlZnQgKyB0aGlzLndpZHRoIC8gMiArIGNvcnJlY3RTaXplIC8gMixcbiAgICAgICAgeTogY2FsY0RpbS50b3AgKyB0aGlzLmhlaWdodCAvIDIgKyBjb3JyZWN0U2l6ZSAvIDJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgcG9seWdvbiBtaW4gYW5kIG1heCBwb2ludCBmcm9tIHBvaW50cyBhcnJheSxcbiAgICAgKiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IHRvIG1lYXN1cmUgdGhlXG4gICAgICogcG9seWdvbiBzaXplXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QubGVmdCBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvbHlnb24gbGVmdG1vc3QgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdC50b3AgWSBjb29yZGluYXRlIG9mIHRoZSBwb2x5Z29uIHRvcG1vc3QgcG9pbnRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdC53aWR0aCBkaXN0YW5jZSBiZXR3ZWVuIFggY29vcmRpbmF0ZXMgb2YgdGhlIHBvbHlnb24gbGVmdG1vc3QgYW5kIHJpZ2h0bW9zdCBwb2ludFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0LmhlaWdodCBkaXN0YW5jZSBiZXR3ZWVuIFkgY29vcmRpbmF0ZXMgb2YgdGhlIHBvbHlnb24gdG9wbW9zdCBhbmQgYm90dG9tbW9zdCBwb2ludFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGNEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIHBvaW50cyA9IHRoaXMuZXhhY3RCb3VuZGluZ0JveCA/IHRoaXMuX3Byb2plY3RTdHJva2VPblBvaW50cygpIDogdGhpcy5wb2ludHMsXG4gICAgICAgICAgbWluWCA9IG1pbihwb2ludHMsICd4JykgfHwgMCxcbiAgICAgICAgICBtaW5ZID0gbWluKHBvaW50cywgJ3knKSB8fCAwLFxuICAgICAgICAgIG1heFggPSBtYXgocG9pbnRzLCAneCcpIHx8IDAsXG4gICAgICAgICAgbWF4WSA9IG1heChwb2ludHMsICd5JykgfHwgMCxcbiAgICAgICAgICB3aWR0aCA9IChtYXhYIC0gbWluWCksXG4gICAgICAgICAgaGVpZ2h0ID0gKG1heFkgLSBtaW5ZKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogbWluWCxcbiAgICAgICAgdG9wOiBtaW5ZLFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcGVydGllc1RvSW5jbHVkZV0gQW55IHByb3BlcnRpZXMgdGhhdCB5b3UgbWlnaHQgd2FudCB0byBhZGRpdGlvbmFsbHkgaW5jbHVkZSBpbiB0aGUgb3V0cHV0XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKSwge1xuICAgICAgICBwb2ludHM6IHRoaXMucG9pbnRzLmNvbmNhdCgpXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSBvZiBzdHJpbmdzIHdpdGggdGhlIHNwZWNpZmljIHN2ZyByZXByZXNlbnRhdGlvblxuICAgICAqIG9mIHRoZSBpbnN0YW5jZVxuICAgICAqL1xuICAgIF90b1NWRzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9pbnRzID0gW10sIGRpZmZYID0gdGhpcy5wYXRoT2Zmc2V0LngsIGRpZmZZID0gdGhpcy5wYXRoT2Zmc2V0LnksXG4gICAgICAgICAgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUztcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMucG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHBvaW50cy5wdXNoKFxuICAgICAgICAgIHRvRml4ZWQodGhpcy5wb2ludHNbaV0ueCAtIGRpZmZYLCBOVU1fRlJBQ1RJT05fRElHSVRTKSwgJywnLFxuICAgICAgICAgIHRvRml4ZWQodGhpcy5wb2ludHNbaV0ueSAtIGRpZmZZLCBOVU1fRlJBQ1RJT05fRElHSVRTKSwgJyAnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW1xuICAgICAgICAnPCcgKyB0aGlzLnR5cGUgKyAnICcsICdDT01NT05fUEFSVFMnLFxuICAgICAgICAncG9pbnRzPVwiJywgcG9pbnRzLmpvaW4oJycpLFxuICAgICAgICAnXCIgLz5cXG4nXG4gICAgICBdO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIGNvbW1vblJlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB2YXIgcG9pbnQsIGxlbiA9IHRoaXMucG9pbnRzLmxlbmd0aCxcbiAgICAgICAgICB4ID0gdGhpcy5wYXRoT2Zmc2V0LngsXG4gICAgICAgICAgeSA9IHRoaXMucGF0aE9mZnNldC55O1xuXG4gICAgICBpZiAoIWxlbiB8fCBpc05hTih0aGlzLnBvaW50c1tsZW4gLSAxXS55KSkge1xuICAgICAgICAvLyBkbyBub3QgZHJhdyBpZiBubyBwb2ludHMgb3Igb2RkIHBvaW50c1xuICAgICAgICAvLyBOYU4gY29tZXMgZnJvbSBwYXJzZUZsb2F0IG9mIGEgZW1wdHkgc3RyaW5nIGluIHBhcnNlclxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHRoaXMucG9pbnRzWzBdLnggLSB4LCB0aGlzLnBvaW50c1swXS55IC0geSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHBvaW50ID0gdGhpcy5wb2ludHNbaV07XG4gICAgICAgIGN0eC5saW5lVG8ocG9pbnQueCAtIHgsIHBvaW50LnkgLSB5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5jb21tb25SZW5kZXIoY3R4KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9yZW5kZXJQYWludEluT3JkZXIoY3R4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb21wbGV4aXR5IG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBjb21wbGV4aXR5IG9mIHRoaXMgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb21wbGV4aXR5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldCgncG9pbnRzJykubGVuZ3RoO1xuICAgIH1cbiAgfSk7XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IHtAbGluayBmYWJyaWMuUG9seWxpbmUuZnJvbUVsZW1lbnR9KVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUG9seWxpbmVcbiAgICogQHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3NoYXBlcy5odG1sI1BvbHlsaW5lRWxlbWVudFxuICAgKi9cbiAgZmFicmljLlBvbHlsaW5lLkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoKTtcblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuUG9seWxpbmUgaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUG9seWxpbmVcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uIGludm9rZWQgYWZ0ZXIgcGFyc2luZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBmYWJyaWMuUG9seWxpbmUuZnJvbUVsZW1lbnRHZW5lcmF0b3IgPSBmdW5jdGlvbihfY2xhc3MpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICB9XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcblxuICAgICAgdmFyIHBvaW50cyA9IGZhYnJpYy5wYXJzZVBvaW50c0F0dHJpYnV0ZShlbGVtZW50LmdldEF0dHJpYnV0ZSgncG9pbnRzJykpLFxuICAgICAgICAgIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpY1tfY2xhc3NdLkFUVFJJQlVURV9OQU1FUyk7XG4gICAgICBwYXJzZWRBdHRyaWJ1dGVzLmZyb21TVkcgPSB0cnVlO1xuICAgICAgY2FsbGJhY2sobmV3IGZhYnJpY1tfY2xhc3NdKHBvaW50cywgZXh0ZW5kKHBhcnNlZEF0dHJpYnV0ZXMsIG9wdGlvbnMpKSk7XG4gICAgfTtcbiAgfTtcblxuICBmYWJyaWMuUG9seWxpbmUuZnJvbUVsZW1lbnQgPSBmYWJyaWMuUG9seWxpbmUuZnJvbUVsZW1lbnRHZW5lcmF0b3IoJ1BvbHlsaW5lJyk7XG5cbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuUG9seWxpbmUgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBvbHlsaW5lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlBhdGggaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLlBvbHlsaW5lLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ1BvbHlsaW5lJywgb2JqZWN0LCBjYWxsYmFjaywgJ3BvaW50cycpO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHt9KSxcbiAgICAgIHByb2plY3RTdHJva2VPblBvaW50cyA9IGZhYnJpYy51dGlsLnByb2plY3RTdHJva2VPblBvaW50cztcblxuICBpZiAoZmFicmljLlBvbHlnb24pIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlBvbHlnb24gaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvbHlnb24gY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5Qb2x5Z29uXG4gICAqIEBleHRlbmRzIGZhYnJpYy5Qb2x5bGluZVxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuUG9seWdvbiNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlBvbHlnb24gPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuUG9seWxpbmUsIC8qKiBAbGVuZHMgZmFicmljLlBvbHlnb24ucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAncG9seWdvbicsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wcm9qZWN0U3Ryb2tlT25Qb2ludHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBwcm9qZWN0U3Ryb2tlT25Qb2ludHModGhpcy5wb2ludHMsIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5jb21tb25SZW5kZXIoY3R4KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICB0aGlzLl9yZW5kZXJQYWludEluT3JkZXIoY3R4KTtcbiAgICB9LFxuXG4gIH0pO1xuXG4gIC8qIF9GUk9NX1NWR19TVEFSVF8gKi9cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXR0cmlidXRlIG5hbWVzIHRvIGFjY291bnQgZm9yIHdoZW4gcGFyc2luZyBTVkcgZWxlbWVudCAodXNlZCBieSBgZmFicmljLlBvbHlnb24uZnJvbUVsZW1lbnRgKVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUG9seWdvblxuICAgKiBAc2VlOiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc2hhcGVzLmh0bWwjUG9seWdvbkVsZW1lbnRcbiAgICovXG4gIGZhYnJpYy5Qb2x5Z29uLkFUVFJJQlVURV9OQU1FUyA9IGZhYnJpYy5TSEFSRURfQVRUUklCVVRFUy5jb25jYXQoKTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLlBvbHlnb259IGluc3RhbmNlIGZyb20gYW4gU1ZHIGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBvbHlnb25cbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24gaW52b2tlZCBhZnRlciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIGZhYnJpYy5Qb2x5Z29uLmZyb21FbGVtZW50ID0gZmFicmljLlBvbHlsaW5lLmZyb21FbGVtZW50R2VuZXJhdG9yKCdQb2x5Z29uJyk7XG4gIC8qIF9GUk9NX1NWR19FTkRfICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLlBvbHlnb24gaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBvbHlnb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBmYWJyaWMuUGF0aCBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBmYWJyaWMuUG9seWdvbi5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ1BvbHlnb24nLCBvYmplY3QsIGNhbGxiYWNrLCAncG9pbnRzJyk7XG4gIH07XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIG1pbiA9IGZhYnJpYy51dGlsLmFycmF5Lm1pbixcbiAgICAgIG1heCA9IGZhYnJpYy51dGlsLmFycmF5Lm1heCxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBjbG9uZSA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZSxcbiAgICAgIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkO1xuXG4gIGlmIChmYWJyaWMuUGF0aCkge1xuICAgIGZhYnJpYy53YXJuKCdmYWJyaWMuUGF0aCBpcyBhbHJlYWR5IGRlZmluZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogUGF0aCBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLlBhdGhcbiAgICogQGV4dGVuZHMgZmFicmljLk9iamVjdFxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMSNwYXRoX2FuZF9wYXRoZ3JvdXB9XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5QYXRoI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuUGF0aCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5PYmplY3QsIC8qKiBAbGVuZHMgZmFicmljLlBhdGgucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAncGF0aCcsXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBwYXRoIHBvaW50c1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwYXRoOiBudWxsLFxuXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5jYWNoZVByb3BlcnRpZXMuY29uY2F0KCdwYXRoJywgJ2ZpbGxSdWxlJyksXG5cbiAgICBzdGF0ZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnN0YXRlUHJvcGVydGllcy5jb25jYXQoJ3BhdGgnKSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IHBhdGggUGF0aCBkYXRhIChzZXF1ZW5jZSBvZiBjb29yZGluYXRlcyBhbmQgY29ycmVzcG9uZGluZyBcImNvbW1hbmRcIiB0b2tlbnMpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5QYXRofSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBjbG9uZShvcHRpb25zIHx8IHt9KTtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLnBhdGg7XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5fc2V0UGF0aChwYXRoIHx8IFtdLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgKiBAcHJpdmF0ZVxuICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IHBhdGggUGF0aCBkYXRhIChzZXF1ZW5jZSBvZiBjb29yZGluYXRlcyBhbmQgY29ycmVzcG9uZGluZyBcImNvbW1hbmRcIiB0b2tlbnMpXG4gICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgKi9cbiAgICBfc2V0UGF0aDogZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMucGF0aCA9IGZhYnJpYy51dGlsLm1ha2VQYXRoU2ltcGxlcihcbiAgICAgICAgQXJyYXkuaXNBcnJheShwYXRoKSA/IHBhdGggOiBmYWJyaWMudXRpbC5wYXJzZVBhdGgocGF0aClcbiAgICAgICk7XG5cbiAgICAgIGZhYnJpYy5Qb2x5bGluZS5wcm90b3R5cGUuX3NldFBvc2l0aW9uRGltZW5zaW9ucy5jYWxsKHRoaXMsIG9wdGlvbnMgfHwge30pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggY29udGV4dCB0byByZW5kZXIgcGF0aCBvblxuICAgICAqL1xuICAgIF9yZW5kZXJQYXRoQ29tbWFuZHM6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIGN1cnJlbnQsIC8vIGN1cnJlbnQgaW5zdHJ1Y3Rpb25cbiAgICAgICAgICBzdWJwYXRoU3RhcnRYID0gMCxcbiAgICAgICAgICBzdWJwYXRoU3RhcnRZID0gMCxcbiAgICAgICAgICB4ID0gMCwgLy8gY3VycmVudCB4XG4gICAgICAgICAgeSA9IDAsIC8vIGN1cnJlbnQgeVxuICAgICAgICAgIGNvbnRyb2xYID0gMCwgLy8gY3VycmVudCBjb250cm9sIHBvaW50IHhcbiAgICAgICAgICBjb250cm9sWSA9IDAsIC8vIGN1cnJlbnQgY29udHJvbCBwb2ludCB5XG4gICAgICAgICAgbCA9IC10aGlzLnBhdGhPZmZzZXQueCxcbiAgICAgICAgICB0ID0gLXRoaXMucGF0aE9mZnNldC55O1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnBhdGgubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblxuICAgICAgICBjdXJyZW50ID0gdGhpcy5wYXRoW2ldO1xuXG4gICAgICAgIHN3aXRjaCAoY3VycmVudFswXSkgeyAvLyBmaXJzdCBsZXR0ZXJcblxuICAgICAgICAgIGNhc2UgJ0wnOiAvLyBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdNJzogLy8gbW92ZVRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgICAgICB5ID0gY3VycmVudFsyXTtcbiAgICAgICAgICAgIHN1YnBhdGhTdGFydFggPSB4O1xuICAgICAgICAgICAgc3VicGF0aFN0YXJ0WSA9IHk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0MnOiAvLyBiZXppZXJDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgeCA9IGN1cnJlbnRbNV07XG4gICAgICAgICAgICB5ID0gY3VycmVudFs2XTtcbiAgICAgICAgICAgIGNvbnRyb2xYID0gY3VycmVudFszXTtcbiAgICAgICAgICAgIGNvbnRyb2xZID0gY3VycmVudFs0XTtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICBjdXJyZW50WzFdICsgbCxcbiAgICAgICAgICAgICAgY3VycmVudFsyXSArIHQsXG4gICAgICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgICAgICB4ICsgbCxcbiAgICAgICAgICAgICAgeSArIHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICAgIGN1cnJlbnRbMV0gKyBsLFxuICAgICAgICAgICAgICBjdXJyZW50WzJdICsgdCxcbiAgICAgICAgICAgICAgY3VycmVudFszXSArIGwsXG4gICAgICAgICAgICAgIGN1cnJlbnRbNF0gKyB0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCA9IGN1cnJlbnRbM107XG4gICAgICAgICAgICB5ID0gY3VycmVudFs0XTtcbiAgICAgICAgICAgIGNvbnRyb2xYID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIGNvbnRyb2xZID0gY3VycmVudFsyXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICB4ID0gc3VicGF0aFN0YXJ0WDtcbiAgICAgICAgICAgIHkgPSBzdWJwYXRoU3RhcnRZO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIHBhdGggb25cbiAgICAgKi9cbiAgICBfcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuX3JlbmRlclBhdGhDb21tYW5kcyhjdHgpO1xuICAgICAgdGhpcy5fcmVuZGVyUGFpbnRJbk9yZGVyKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJyM8ZmFicmljLlBhdGggKCcgKyB0aGlzLmNvbXBsZXhpdHkoKSArXG4gICAgICAgICcpOiB7IFwidG9wXCI6ICcgKyB0aGlzLnRvcCArICcsIFwibGVmdFwiOiAnICsgdGhpcy5sZWZ0ICsgJyB9Pic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JywgcHJvcGVydGllc1RvSW5jbHVkZSksIHtcbiAgICAgICAgcGF0aDogdGhpcy5wYXRoLm1hcChmdW5jdGlvbihpdGVtKSB7IHJldHVybiBpdGVtLnNsaWNlKCk7IH0pLFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZGF0YWxlc3Mgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9EYXRhbGVzc09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG8gPSB0aGlzLnRvT2JqZWN0KFsnc291cmNlUGF0aCddLmNvbmNhdChwcm9wZXJ0aWVzVG9JbmNsdWRlKSk7XG4gICAgICBpZiAoby5zb3VyY2VQYXRoKSB7XG4gICAgICAgIGRlbGV0ZSBvLnBhdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gbztcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSBvZiBzdHJpbmdzIHdpdGggdGhlIHNwZWNpZmljIHN2ZyByZXByZXNlbnRhdGlvblxuICAgICAqIG9mIHRoZSBpbnN0YW5jZVxuICAgICAqL1xuICAgIF90b1NWRzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGF0aCA9IGZhYnJpYy51dGlsLmpvaW5QYXRoKHRoaXMucGF0aCk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAnPHBhdGggJywgJ0NPTU1PTl9QQVJUUycsXG4gICAgICAgICdkPVwiJywgcGF0aCxcbiAgICAgICAgJ1wiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiAnLFxuICAgICAgICAnLz5cXG4nXG4gICAgICBdO1xuICAgIH0sXG5cbiAgICBfZ2V0T2Zmc2V0VHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkaWdpdHMgPSBmYWJyaWMuT2JqZWN0Lk5VTV9GUkFDVElPTl9ESUdJVFM7XG4gICAgICByZXR1cm4gJyB0cmFuc2xhdGUoJyArIHRvRml4ZWQoLXRoaXMucGF0aE9mZnNldC54LCBkaWdpdHMpICsgJywgJyArXG4gICAgICAgICAgdG9GaXhlZCgtdGhpcy5wYXRoT2Zmc2V0LnksIGRpZ2l0cykgKyAnKSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIGNsaXBQYXRoIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvQ2xpcFBhdGhTVkc6IGZ1bmN0aW9uKHJldml2ZXIpIHtcbiAgICAgIHZhciBhZGRpdGlvbmFsVHJhbnNmb3JtID0gdGhpcy5fZ2V0T2Zmc2V0VHJhbnNmb3JtKCk7XG4gICAgICByZXR1cm4gJ1xcdCcgKyB0aGlzLl9jcmVhdGVCYXNlQ2xpcFBhdGhTVkdNYXJrdXAoXG4gICAgICAgIHRoaXMuX3RvU1ZHKCksIHsgcmV2aXZlcjogcmV2aXZlciwgYWRkaXRpb25hbFRyYW5zZm9ybTogYWRkaXRpb25hbFRyYW5zZm9ybSB9XG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIGFkZGl0aW9uYWxUcmFuc2Zvcm0gPSB0aGlzLl9nZXRPZmZzZXRUcmFuc2Zvcm0oKTtcbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVCYXNlU1ZHTWFya3VwKHRoaXMuX3RvU1ZHKCksIHsgcmV2aXZlcjogcmV2aXZlciwgYWRkaXRpb25hbFRyYW5zZm9ybTogYWRkaXRpb25hbFRyYW5zZm9ybSAgfSk7XG4gICAgfSxcbiAgICAvKiBfVE9fU1ZHX0VORF8gKi9cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbnVtYmVyIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlIGNvbXBsZXhpdHlcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGNvbXBsZXhpdHkgb2YgdGhpcyBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbXBsZXhpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGF0aC5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGNEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGFYID0gW10sXG4gICAgICAgICAgYVkgPSBbXSxcbiAgICAgICAgICBjdXJyZW50LCAvLyBjdXJyZW50IGluc3RydWN0aW9uXG4gICAgICAgICAgc3VicGF0aFN0YXJ0WCA9IDAsXG4gICAgICAgICAgc3VicGF0aFN0YXJ0WSA9IDAsXG4gICAgICAgICAgeCA9IDAsIC8vIGN1cnJlbnQgeFxuICAgICAgICAgIHkgPSAwLCAvLyBjdXJyZW50IHlcbiAgICAgICAgICBib3VuZHM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnBhdGgubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblxuICAgICAgICBjdXJyZW50ID0gdGhpcy5wYXRoW2ldO1xuXG4gICAgICAgIHN3aXRjaCAoY3VycmVudFswXSkgeyAvLyBmaXJzdCBsZXR0ZXJcblxuICAgICAgICAgIGNhc2UgJ0wnOiAvLyBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgYm91bmRzID0gW107XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ00nOiAvLyBtb3ZlVG8sIGFic29sdXRlXG4gICAgICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICAgICAgc3VicGF0aFN0YXJ0WCA9IHg7XG4gICAgICAgICAgICBzdWJwYXRoU3RhcnRZID0geTtcbiAgICAgICAgICAgIGJvdW5kcyA9IFtdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdDJzogLy8gYmV6aWVyQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgICAgIGJvdW5kcyA9IGZhYnJpYy51dGlsLmdldEJvdW5kc09mQ3VydmUoeCwgeSxcbiAgICAgICAgICAgICAgY3VycmVudFsxXSxcbiAgICAgICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICAgICAgY3VycmVudFs0XSxcbiAgICAgICAgICAgICAgY3VycmVudFs1XSxcbiAgICAgICAgICAgICAgY3VycmVudFs2XVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHggPSBjdXJyZW50WzVdO1xuICAgICAgICAgICAgeSA9IGN1cnJlbnRbNl07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICAgICAgYm91bmRzID0gZmFicmljLnV0aWwuZ2V0Qm91bmRzT2ZDdXJ2ZSh4LCB5LFxuICAgICAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgICAgICBjdXJyZW50WzRdXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgeCA9IGN1cnJlbnRbM107XG4gICAgICAgICAgICB5ID0gY3VycmVudFs0XTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICB4ID0gc3VicGF0aFN0YXJ0WDtcbiAgICAgICAgICAgIHkgPSBzdWJwYXRoU3RhcnRZO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYm91bmRzLmZvckVhY2goZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgYVgucHVzaChwb2ludC54KTtcbiAgICAgICAgICBhWS5wdXNoKHBvaW50LnkpO1xuICAgICAgICB9KTtcbiAgICAgICAgYVgucHVzaCh4KTtcbiAgICAgICAgYVkucHVzaCh5KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1pblggPSBtaW4oYVgpIHx8IDAsXG4gICAgICAgICAgbWluWSA9IG1pbihhWSkgfHwgMCxcbiAgICAgICAgICBtYXhYID0gbWF4KGFYKSB8fCAwLFxuICAgICAgICAgIG1heFkgPSBtYXgoYVkpIHx8IDAsXG4gICAgICAgICAgZGVsdGFYID0gbWF4WCAtIG1pblgsXG4gICAgICAgICAgZGVsdGFZID0gbWF4WSAtIG1pblk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IG1pblgsXG4gICAgICAgIHRvcDogbWluWSxcbiAgICAgICAgd2lkdGg6IGRlbHRhWCxcbiAgICAgICAgaGVpZ2h0OiBkZWx0YVlcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBmYWJyaWMuUGF0aCBmcm9tIGFuIG9iamVjdFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuUGF0aFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYW4gZmFicmljLlBhdGggaW5zdGFuY2UgaXMgY3JlYXRlZFxuICAgKi9cbiAgZmFicmljLlBhdGguZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9iamVjdC5zb3VyY2VQYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIHBhdGhVcmwgPSBvYmplY3Quc291cmNlUGF0aDtcbiAgICAgIGZhYnJpYy5sb2FkU1ZHRnJvbVVSTChwYXRoVXJsLCBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIHBhdGggPSBlbGVtZW50c1swXTtcbiAgICAgICAgcGF0aC5zZXRPcHRpb25zKG9iamVjdCk7XG4gICAgICAgIGlmIChvYmplY3QuY2xpcFBhdGgpIHtcbiAgICAgICAgICBmYWJyaWMudXRpbC5lbmxpdmVuT2JqZWN0cyhbb2JqZWN0LmNsaXBQYXRoXSwgZnVuY3Rpb24oZWxpdmVuZWRPYmplY3RzKSB7XG4gICAgICAgICAgICBwYXRoLmNsaXBQYXRoID0gZWxpdmVuZWRPYmplY3RzWzBdO1xuICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socGF0aCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ1BhdGgnLCBvYmplY3QsIGNhbGxiYWNrLCAncGF0aCcpO1xuICAgIH1cbiAgfTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkgYGZhYnJpYy5QYXRoLmZyb21FbGVtZW50YClcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBhdGhcbiAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvcGF0aHMuaHRtbCNQYXRoRWxlbWVudFxuICAgKi9cbiAgZmFicmljLlBhdGguQVRUUklCVVRFX05BTUVTID0gZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdChbJ2QnXSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgZmFicmljLlBhdGggZnJvbSBhbiBTVkcgPHBhdGg+IGVsZW1lbnRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlBhdGhcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGZhYnJpYy5QYXRoIGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIE9wdGlvbnMgY2FsbGJhY2sgaW52b2tlZCBhZnRlciBwYXJzaW5nIGlzIGZpbmlzaGVkXG4gICAqL1xuICBmYWJyaWMuUGF0aC5mcm9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5QYXRoLkFUVFJJQlVURV9OQU1FUyk7XG4gICAgcGFyc2VkQXR0cmlidXRlcy5mcm9tU1ZHID0gdHJ1ZTtcbiAgICBjYWxsYmFjayhuZXcgZmFicmljLlBhdGgocGFyc2VkQXR0cmlidXRlcy5kLCBleHRlbmQocGFyc2VkQXR0cmlidXRlcywgb3B0aW9ucykpKTtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgbWluID0gZmFicmljLnV0aWwuYXJyYXkubWluLFxuICAgICAgbWF4ID0gZmFicmljLnV0aWwuYXJyYXkubWF4O1xuXG4gIGlmIChmYWJyaWMuR3JvdXApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogR3JvdXAgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5Hcm91cFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEBtaXhlcyBmYWJyaWMuQ29sbGVjdGlvblxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMyNncm91cHN9XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5Hcm91cCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLkdyb3VwID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgZmFicmljLkNvbGxlY3Rpb24sIC8qKiBAbGVuZHMgZmFicmljLkdyb3VwLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ2dyb3VwJyxcblxuICAgIC8qKlxuICAgICAqIFdpZHRoIG9mIHN0cm9rZVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlV2lkdGg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgY2xpY2ssIG1vdXNlb3ZlciwgbW91c2VvdXQgZXZlbnRzICYgaG92ZXJDdXJzb3Igc2hvdWxkIGFsc28gY2hlY2sgZm9yIHN1YnRhcmdldHNcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdWJUYXJnZXRDaGVjazogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBHcm91cHMgYXJlIGNvbnRhaW5lciwgZG8gbm90IHJlbmRlciBhbnl0aGluZyBvbiB0aGV5ciBvd24sIGVuY2Ugbm8gY2FjaGUgcHJvcGVydGllc1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjYWNoZVByb3BlcnRpZXM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogc2V0T25Hcm91cCBpcyBhIG1ldGhvZCB1c2VkIGZvciBUZXh0Qm94IHRoYXQgaXMgbm8gbW9yZSB1c2VkIHNpbmNlIDIuMC4wIFRoZSBiZWhhdmlvciBpcyBzdGlsbFxuICAgICAqIGF2YWlsYWJsZSBzZXR0aW5nIHRoaXMgYm9vbGVhbiB0byB0cnVlLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHVzZVNldE9uR3JvdXA6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0cyBHcm91cCBvYmplY3RzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzQWxyZWFkeUdyb3VwZWRdIGlmIHRydWUsIG9iamVjdHMgaGF2ZSBiZWVuIGdyb3VwZWQgYWxyZWFkeS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvYmplY3RzLCBvcHRpb25zLCBpc0FscmVhZHlHcm91cGVkKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHRoaXMuX29iamVjdHMgPSBbXTtcbiAgICAgIC8vIGlmIG9iamVjdHMgZW5jbG9zZWQgaW4gYSBncm91cCBoYXZlIGJlZW4gZ3JvdXBlZCBhbHJlYWR5LFxuICAgICAgLy8gd2UgY2Fubm90IGNoYW5nZSBwcm9wZXJ0aWVzIG9mIG9iamVjdHMuXG4gICAgICAvLyBUaHVzIHdlIG5lZWQgdG8gc2V0IG9wdGlvbnMgdG8gZ3JvdXAgd2l0aG91dCBvYmplY3RzLFxuICAgICAgaXNBbHJlYWR5R3JvdXBlZCAmJiB0aGlzLmNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5fb2JqZWN0cyA9IG9iamVjdHMgfHwgW107XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGktLTsgKSB7XG4gICAgICAgIHRoaXMuX29iamVjdHNbaV0uZ3JvdXAgPSB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzQWxyZWFkeUdyb3VwZWQpIHtcbiAgICAgICAgdmFyIGNlbnRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jZW50ZXJQb2ludDtcbiAgICAgICAgLy8gd2Ugd2FudCB0byBzZXQgb3JpZ2lucyBiZWZvcmUgY2FsY3VsYXRpbmcgdGhlIGJvdW5kaW5nIGJveC5cbiAgICAgICAgLy8gc28gdGhhdCB0aGUgdG9wbGVmdCBjYW4gYmUgc2V0IHdpdGggdGhhdCBpbiBtaW5kLlxuICAgICAgICAvLyBpZiBzcGVjaWZpYyB0b3AgYW5kIGxlZnQgYXJlIHBhc3NlZCwgYXJlIG92ZXJ3cml0dGVuIGxhdGVyXG4gICAgICAgIC8vIHdpdGggdGhlIGNhbGxTdXBlcignaW5pdGlhbGl6ZScsIG9wdGlvbnMpXG4gICAgICAgIGlmIChvcHRpb25zLm9yaWdpblggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMub3JpZ2luWCA9IG9wdGlvbnMub3JpZ2luWDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5vcmlnaW5ZICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLm9yaWdpblkgPSBvcHRpb25zLm9yaWdpblk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgY29taW5nIGZyb20gc3ZnIGkgZG8gbm90IHdhbnQgdG8gY2FsYyBib3VuZHMuXG4gICAgICAgIC8vIGkgYXNzdW1lIHdpZHRoIGFuZCBoZWlnaHQgYXJlIHBhc3NlZCBhbG9uZyBvcHRpb25zXG4gICAgICAgIGNlbnRlciB8fCB0aGlzLl9jYWxjQm91bmRzKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZU9iamVjdHNDb29yZHMoY2VudGVyKTtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuY2VudGVyUG9pbnQ7XG4gICAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlT2JqZWN0c0FDb29yZHMoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlT2JqZWN0c0FDb29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNraXBDb250cm9scyA9IHRydWU7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGktLTsgKXtcbiAgICAgICAgdGhpcy5fb2JqZWN0c1tpXS5zZXRDb29yZHMoc2tpcENvbnRyb2xzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtza2lwQ29vcmRzQ2hhbmdlXSBpZiB0cnVlLCBjb29yZGluYXRlcyBvZiBvYmplY3RzIGVuY2xvc2VkIGluIGEgZ3JvdXAgZG8gbm90IGNoYW5nZVxuICAgICAqL1xuICAgIF91cGRhdGVPYmplY3RzQ29vcmRzOiBmdW5jdGlvbihjZW50ZXIpIHtcbiAgICAgIHZhciBjZW50ZXIgPSBjZW50ZXIgfHwgdGhpcy5nZXRDZW50ZXJQb2ludCgpO1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpLS07ICl7XG4gICAgICAgIHRoaXMuX3VwZGF0ZU9iamVjdENvb3Jkcyh0aGlzLl9vYmplY3RzW2ldLCBjZW50ZXIpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge2ZhYnJpYy5Qb2ludH0gY2VudGVyLCBjdXJyZW50IGNlbnRlciBvZiBncm91cC5cbiAgICAgKi9cbiAgICBfdXBkYXRlT2JqZWN0Q29vcmRzOiBmdW5jdGlvbihvYmplY3QsIGNlbnRlcikge1xuICAgICAgdmFyIG9iamVjdExlZnQgPSBvYmplY3QubGVmdCxcbiAgICAgICAgICBvYmplY3RUb3AgPSBvYmplY3QudG9wLFxuICAgICAgICAgIHNraXBDb250cm9scyA9IHRydWU7XG5cbiAgICAgIG9iamVjdC5zZXQoe1xuICAgICAgICBsZWZ0OiBvYmplY3RMZWZ0IC0gY2VudGVyLngsXG4gICAgICAgIHRvcDogb2JqZWN0VG9wIC0gY2VudGVyLnlcbiAgICAgIH0pO1xuICAgICAgb2JqZWN0Lmdyb3VwID0gdGhpcztcbiAgICAgIG9iamVjdC5zZXRDb29yZHMoc2tpcENvbnRyb2xzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW5hdGlvbiBvZiBhIGdyb3VwXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnIzxmYWJyaWMuR3JvdXA6ICgnICsgdGhpcy5jb21wbGV4aXR5KCkgKyAnKT4nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIG9iamVjdCB0byBhIGdyb3VwOyBUaGVuIHJlY2FsY3VsYXRlcyBncm91cCdzIGRpbWVuc2lvbiwgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Hcm91cH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBhZGRXaXRoVXBkYXRlOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciBuZXN0ZWQgPSAhIXRoaXMuZ3JvdXA7XG4gICAgICB0aGlzLl9yZXN0b3JlT2JqZWN0c1N0YXRlKCk7XG4gICAgICBmYWJyaWMudXRpbC5yZXNldE9iamVjdFRyYW5zZm9ybSh0aGlzKTtcbiAgICAgIGlmIChvYmplY3QpIHtcbiAgICAgICAgaWYgKG5lc3RlZCkge1xuICAgICAgICAgIC8vIGlmIHRoaXMgZ3JvdXAgaXMgaW5zaWRlIGFub3RoZXIgZ3JvdXAsIHdlIG5lZWQgdG8gcHJlIHRyYW5zZm9ybSB0aGUgb2JqZWN0XG4gICAgICAgICAgZmFicmljLnV0aWwucmVtb3ZlVHJhbnNmb3JtRnJvbU9iamVjdChvYmplY3QsIHRoaXMuZ3JvdXAuY2FsY1RyYW5zZm9ybU1hdHJpeCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vYmplY3RzLnB1c2gob2JqZWN0KTtcbiAgICAgICAgb2JqZWN0Lmdyb3VwID0gdGhpcztcbiAgICAgICAgb2JqZWN0Ll9zZXQoJ2NhbnZhcycsIHRoaXMuY2FudmFzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhbGNCb3VuZHMoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZU9iamVjdHNDb29yZHMoKTtcbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgaWYgKG5lc3RlZCkge1xuICAgICAgICB0aGlzLmdyb3VwLmFkZFdpdGhVcGRhdGUoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gb2JqZWN0IGZyb20gYSBncm91cDsgVGhlbiByZWNhbGN1bGF0ZXMgZ3JvdXAncyBkaW1lbnNpb24sIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JvdXB9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgcmVtb3ZlV2l0aFVwZGF0ZTogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB0aGlzLl9yZXN0b3JlT2JqZWN0c1N0YXRlKCk7XG4gICAgICBmYWJyaWMudXRpbC5yZXNldE9iamVjdFRyYW5zZm9ybSh0aGlzKTtcblxuICAgICAgdGhpcy5yZW1vdmUob2JqZWN0KTtcbiAgICAgIHRoaXMuX2NhbGNCb3VuZHMoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZU9iamVjdHNDb29yZHMoKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbk9iamVjdEFkZGVkOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgb2JqZWN0Lmdyb3VwID0gdGhpcztcbiAgICAgIG9iamVjdC5fc2V0KCdjYW52YXMnLCB0aGlzLmNhbnZhcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uT2JqZWN0UmVtb3ZlZDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIGRlbGV0ZSBvYmplY3QuZ3JvdXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGkgPSB0aGlzLl9vYmplY3RzLmxlbmd0aDtcbiAgICAgIGlmICh0aGlzLnVzZVNldE9uR3JvdXApIHtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIHRoaXMuX29iamVjdHNbaV0uc2V0T25Hcm91cChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ2NhbnZhcycpIHtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIHRoaXMuX29iamVjdHNbaV0uX3NldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmFicmljLk9iamVjdC5wcm90b3R5cGUuX3NldC5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgX2luY2x1ZGVEZWZhdWx0VmFsdWVzID0gdGhpcy5pbmNsdWRlRGVmYXVsdFZhbHVlcztcbiAgICAgIHZhciBvYmpzVG9PYmplY3QgPSB0aGlzLl9vYmplY3RzXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgIHJldHVybiAhb2JqLmV4Y2x1ZGVGcm9tRXhwb3J0O1xuICAgICAgICB9KVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICB2YXIgb3JpZ2luYWxEZWZhdWx0cyA9IG9iai5pbmNsdWRlRGVmYXVsdFZhbHVlcztcbiAgICAgICAgICBvYmouaW5jbHVkZURlZmF1bHRWYWx1ZXMgPSBfaW5jbHVkZURlZmF1bHRWYWx1ZXM7XG4gICAgICAgICAgdmFyIF9vYmogPSBvYmoudG9PYmplY3QocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICAgICAgb2JqLmluY2x1ZGVEZWZhdWx0VmFsdWVzID0gb3JpZ2luYWxEZWZhdWx0cztcbiAgICAgICAgICByZXR1cm4gX29iajtcbiAgICAgICAgfSk7XG4gICAgICB2YXIgb2JqID0gZmFicmljLk9iamVjdC5wcm90b3R5cGUudG9PYmplY3QuY2FsbCh0aGlzLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIG9iai5vYmplY3RzID0gb2Jqc1RvT2JqZWN0O1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2UsIGluIGRhdGFsZXNzIG1vZGUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9EYXRhbGVzc09iamVjdDogZnVuY3Rpb24ocHJvcGVydGllc1RvSW5jbHVkZSkge1xuICAgICAgdmFyIG9ianNUb09iamVjdCwgc291cmNlUGF0aCA9IHRoaXMuc291cmNlUGF0aDtcbiAgICAgIGlmIChzb3VyY2VQYXRoKSB7XG4gICAgICAgIG9ianNUb09iamVjdCA9IHNvdXJjZVBhdGg7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIF9pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IHRoaXMuaW5jbHVkZURlZmF1bHRWYWx1ZXM7XG4gICAgICAgIG9ianNUb09iamVjdCA9IHRoaXMuX29iamVjdHMubWFwKGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgIHZhciBvcmlnaW5hbERlZmF1bHRzID0gb2JqLmluY2x1ZGVEZWZhdWx0VmFsdWVzO1xuICAgICAgICAgIG9iai5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IF9pbmNsdWRlRGVmYXVsdFZhbHVlcztcbiAgICAgICAgICB2YXIgX29iaiA9IG9iai50b0RhdGFsZXNzT2JqZWN0KHByb3BlcnRpZXNUb0luY2x1ZGUpO1xuICAgICAgICAgIG9iai5pbmNsdWRlRGVmYXVsdFZhbHVlcyA9IG9yaWdpbmFsRGVmYXVsdHM7XG4gICAgICAgICAgcmV0dXJuIF9vYmo7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdmFyIG9iaiA9IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnRvRGF0YWxlc3NPYmplY3QuY2FsbCh0aGlzLCBwcm9wZXJ0aWVzVG9JbmNsdWRlKTtcbiAgICAgIG9iai5vYmplY3RzID0gb2Jqc1RvT2JqZWN0O1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBpbnN0YW5jZSBvbiBhIGdpdmVuIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IGNvbnRleHQgdG8gcmVuZGVyIGluc3RhbmNlIG9uXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybURvbmUgPSB0cnVlO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ3JlbmRlcicsIGN0eCk7XG4gICAgICB0aGlzLl90cmFuc2Zvcm1Eb25lID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY2lkZSBpZiB0aGUgb2JqZWN0IHNob3VsZCBjYWNoZSBvciBub3QuIENyZWF0ZSBpdHMgb3duIGNhY2hlIGxldmVsXG4gICAgICogbmVlZHNJdHNPd25DYWNoZSBzaG91bGQgYmUgdXNlZCB3aGVuIHRoZSBvYmplY3QgZHJhd2luZyBtZXRob2QgcmVxdWlyZXNcbiAgICAgKiBhIGNhY2hlIHN0ZXAuIE5vbmUgb2YgdGhlIGZhYnJpYyBjbGFzc2VzIHJlcXVpcmVzIGl0LlxuICAgICAqIEdlbmVyYWxseSB5b3UgZG8gbm90IGNhY2hlIG9iamVjdHMgaW4gZ3JvdXBzIGJlY2F1c2UgdGhlIGdyb3VwIGlzIGFscmVhZHkgY2FjaGVkLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2hvdWxkQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG93bkNhY2hlID0gZmFicmljLk9iamVjdC5wcm90b3R5cGUuc2hvdWxkQ2FjaGUuY2FsbCh0aGlzKTtcbiAgICAgIGlmIChvd25DYWNoZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmICh0aGlzLl9vYmplY3RzW2ldLndpbGxEcmF3U2hhZG93KCkpIHtcbiAgICAgICAgICAgIHRoaXMub3duQ2FjaGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG93bkNhY2hlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIG9iamVjdCBvciBhIGNoaWxkIG9iamVjdCB3aWxsIGNhc3QgYSBzaGFkb3dcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHdpbGxEcmF3U2hhZG93OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS53aWxsRHJhd1NoYWRvdy5jYWxsKHRoaXMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuX29iamVjdHNbaV0ud2lsbERyYXdTaGFkb3coKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoaXMgZ3JvdXAgb3IgaXRzIHBhcmVudCBncm91cCBhcmUgY2FjaGluZywgcmVjdXJzaXZlbHkgdXBcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzT25BQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3duQ2FjaGluZyB8fCAodGhpcy5ncm91cCAmJiB0aGlzLmdyb3VwLmlzT25BQ2FjaGUoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgdGhlIGRyYXdpbmcgb3BlcmF0aW9uIGZvciBhbiBvYmplY3Qgb24gYSBzcGVjaWZpZWQgY29udGV4dFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBkcmF3T2JqZWN0OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuX29iamVjdHNbaV0ucmVuZGVyKGN0eCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9kcmF3Q2xpcFBhdGgoY3R4LCB0aGlzLmNsaXBQYXRoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgY2FjaGUgaXMgZGlydHlcbiAgICAgKi9cbiAgICBpc0NhY2hlRGlydHk6IGZ1bmN0aW9uKHNraXBDYW52YXMpIHtcbiAgICAgIGlmICh0aGlzLmNhbGxTdXBlcignaXNDYWNoZURpcnR5Jywgc2tpcENhbnZhcykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc3RhdGVmdWxsQ2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuX29iamVjdHNbaV0uaXNDYWNoZURpcnR5KHRydWUpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2NhY2hlQ2FudmFzKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGdyb3VwIGhhcyBub3QgYSBjYWNoZSBjYW52YXMgdGhlcmUgaXMgbm90aGluZyB0byBjbGVhblxuICAgICAgICAgICAgdmFyIHggPSB0aGlzLmNhY2hlV2lkdGggLyB0aGlzLnpvb21YLCB5ID0gdGhpcy5jYWNoZUhlaWdodCAvIHRoaXMuem9vbVk7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUNvbnRleHQuY2xlYXJSZWN0KC14IC8gMiwgLXkgLyAyLCB4LCB5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzdG9yZXMgb3JpZ2luYWwgc3RhdGUgb2YgZWFjaCBvZiBncm91cCBvYmplY3RzIChvcmlnaW5hbCBzdGF0ZSBpcyB0aGF0IHdoaWNoIHdhcyBiZWZvcmUgZ3JvdXAgd2FzIGNyZWF0ZWQpLlxuICAgICAqIGlmIHRoZSBuZXN0ZWQgYm9vbGVhbiBpcyB0cnVlLCB0aGUgb3JpZ2luYWwgc3RhdGUgd2lsbCBiZSByZXN0b3JlZCBqdXN0IGZvciB0aGVcbiAgICAgKiBmaXJzdCBncm91cCBhbmQgbm90IGZvciBhbGwgdGhlIGdyb3VwIGNoYWluXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG5lc3RlZCB0ZWxsIHRoZSBmdW5jdGlvbiB0byByZXN0b3JlIG9iamVjdCBzdGF0ZSB1cCB0byB0aGUgcGFyZW50IGdyb3VwIGFuZCBub3QgbW9yZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Hcm91cH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBfcmVzdG9yZU9iamVjdHNTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZ3JvdXBNYXRyaXggPSB0aGlzLmNhbGNPd25NYXRyaXgoKTtcbiAgICAgIHRoaXMuX29iamVjdHMuZm9yRWFjaChmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgLy8gaW5zdGVhZCBvZiB1c2luZyBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGZhYnJpYy51dGlsLmFkZFRyYW5zZm9ybVRvT2JqZWN0KG9iamVjdCwgZ3JvdXBNYXRyaXgpO1xuICAgICAgICBkZWxldGUgb2JqZWN0Lmdyb3VwO1xuICAgICAgICBvYmplY3Quc2V0Q29vcmRzKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyBhIGdyb3VwIChyZXN0b3Jpbmcgc3RhdGUgb2YgaXRzIG9iamVjdHMpXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gd2hlbiBncm91cCBpcyBkZXN0cm95ZWQgb2JqZWN0cyBuZWVkcyB0byBnZXQgYSByZXBhaW50IHRvIGJlIGV2ZW50dWFsbHlcbiAgICAgIC8vIGRpc3BsYXllZCBvbiBjYW52YXMuXG4gICAgICB0aGlzLl9vYmplY3RzLmZvckVhY2goZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIG9iamVjdC5zZXQoJ2RpcnR5JywgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLl9yZXN0b3JlT2JqZWN0c1N0YXRlKCk7XG4gICAgfSxcblxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdkaXNwb3NlJyk7XG4gICAgICB0aGlzLmZvckVhY2hPYmplY3QoZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICBvYmplY3QuZGlzcG9zZSAmJiBvYmplY3QuZGlzcG9zZSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9vYmplY3RzID0gW107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIG1ha2UgYSBncm91cCBhbiBhY3RpdmUgc2VsZWN0aW9uLCByZW1vdmUgdGhlIGdyb3VwIGZyb20gY2FudmFzXG4gICAgICogdGhlIGdyb3VwIGhhcyB0byBiZSBvbiBjYW52YXMgZm9yIHRoaXMgdG8gd29yay5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuQWN0aXZlU2VsZWN0aW9ufSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHRvQWN0aXZlU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLCBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgIHRoaXMuX29iamVjdHMgPSBbXTtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy50b09iamVjdCgpO1xuICAgICAgZGVsZXRlIG9wdGlvbnMub2JqZWN0cztcbiAgICAgIHZhciBhY3RpdmVTZWxlY3Rpb24gPSBuZXcgZmFicmljLkFjdGl2ZVNlbGVjdGlvbihbXSk7XG4gICAgICBhY3RpdmVTZWxlY3Rpb24uc2V0KG9wdGlvbnMpO1xuICAgICAgYWN0aXZlU2VsZWN0aW9uLnR5cGUgPSAnYWN0aXZlU2VsZWN0aW9uJztcbiAgICAgIGNhbnZhcy5yZW1vdmUodGhpcyk7XG4gICAgICBvYmplY3RzLmZvckVhY2goZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIG9iamVjdC5ncm91cCA9IGFjdGl2ZVNlbGVjdGlvbjtcbiAgICAgICAgb2JqZWN0LmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgY2FudmFzLmFkZChvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICBhY3RpdmVTZWxlY3Rpb24uY2FudmFzID0gY2FudmFzO1xuICAgICAgYWN0aXZlU2VsZWN0aW9uLl9vYmplY3RzID0gb2JqZWN0cztcbiAgICAgIGNhbnZhcy5fYWN0aXZlT2JqZWN0ID0gYWN0aXZlU2VsZWN0aW9uO1xuICAgICAgYWN0aXZlU2VsZWN0aW9uLnNldENvb3JkcygpO1xuICAgICAgcmV0dXJuIGFjdGl2ZVNlbGVjdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgYSBncm91cCAocmVzdG9yaW5nIHN0YXRlIG9mIGl0cyBvYmplY3RzKVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5Hcm91cH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICB1bmdyb3VwT25DYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jlc3RvcmVPYmplY3RzU3RhdGUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBjb29yZGluYXRlcyBvZiBhbGwgb2JqZWN0cyBpbnNpZGUgZ3JvdXBcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuR3JvdXB9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0T2JqZWN0c0Nvb3JkczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2tpcENvbnRyb2xzID0gdHJ1ZTtcbiAgICAgIHRoaXMuZm9yRWFjaE9iamVjdChmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgb2JqZWN0LnNldENvb3Jkcyhza2lwQ29udHJvbHMpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2FsY0JvdW5kczogZnVuY3Rpb24ob25seVdpZHRoSGVpZ2h0KSB7XG4gICAgICB2YXIgYVggPSBbXSxcbiAgICAgICAgICBhWSA9IFtdLFxuICAgICAgICAgIG8sIHByb3AsIGNvb3JkcyxcbiAgICAgICAgICBwcm9wcyA9IFsndHInLCAnYnInLCAnYmwnLCAndGwnXSxcbiAgICAgICAgICBpID0gMCwgaUxlbiA9IHRoaXMuX29iamVjdHMubGVuZ3RoLFxuICAgICAgICAgIGosIGpMZW4gPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIGZvciAoIDsgaSA8IGlMZW47ICsraSkge1xuICAgICAgICBvID0gdGhpcy5fb2JqZWN0c1tpXTtcbiAgICAgICAgY29vcmRzID0gby5jYWxjQUNvb3JkcygpO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaisrKSB7XG4gICAgICAgICAgcHJvcCA9IHByb3BzW2pdO1xuICAgICAgICAgIGFYLnB1c2goY29vcmRzW3Byb3BdLngpO1xuICAgICAgICAgIGFZLnB1c2goY29vcmRzW3Byb3BdLnkpO1xuICAgICAgICB9XG4gICAgICAgIG8uYUNvb3JkcyA9IGNvb3JkcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZ2V0Qm91bmRzKGFYLCBhWSwgb25seVdpZHRoSGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Qm91bmRzOiBmdW5jdGlvbihhWCwgYVksIG9ubHlXaWR0aEhlaWdodCkge1xuICAgICAgdmFyIG1pblhZID0gbmV3IGZhYnJpYy5Qb2ludChtaW4oYVgpLCBtaW4oYVkpKSxcbiAgICAgICAgICBtYXhYWSA9IG5ldyBmYWJyaWMuUG9pbnQobWF4KGFYKSwgbWF4KGFZKSksXG4gICAgICAgICAgdG9wID0gbWluWFkueSB8fCAwLCBsZWZ0ID0gbWluWFkueCB8fCAwLFxuICAgICAgICAgIHdpZHRoID0gKG1heFhZLnggLSBtaW5YWS54KSB8fCAwLFxuICAgICAgICAgIGhlaWdodCA9IChtYXhYWS55IC0gbWluWFkueSkgfHwgMDtcbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgaWYgKCFvbmx5V2lkdGhIZWlnaHQpIHtcbiAgICAgICAgLy8gdGhlIGJvdW5kaW5nIGJveCBhbHdheXMgZmluZHMgdGhlIHRvcGxlZnQgbW9zdCBjb3JuZXIuXG4gICAgICAgIC8vIHdoYXRldmVyIGlzIHRoZSBncm91cCBvcmlnaW4sIHdlIHNldCB1cCBoZXJlIHRoZSBsZWZ0L3RvcCBwb3NpdGlvbi5cbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbkJ5T3JpZ2luKHsgeDogbGVmdCwgeTogdG9wIH0sICdsZWZ0JywgJ3RvcCcpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiBfVE9fU1ZHX1NUQVJUXyAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jldml2ZXJdIE1ldGhvZCBmb3IgZnVydGhlciBwYXJzaW5nIG9mIHN2ZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIF90b1NWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIHN2Z1N0cmluZyA9IFsnPGcgJywgJ0NPTU1PTl9QQVJUUycsICcgPlxcbiddO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzdmdTdHJpbmcucHVzaCgnXFx0XFx0JywgdGhpcy5fb2JqZWN0c1tpXS50b1NWRyhyZXZpdmVyKSk7XG4gICAgICB9XG4gICAgICBzdmdTdHJpbmcucHVzaCgnPC9nPlxcbicpO1xuICAgICAgcmV0dXJuIHN2Z1N0cmluZztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHlsZXMtc3RyaW5nIGZvciBzdmctZXhwb3J0LCBzcGVjaWZpYyB2ZXJzaW9uIGZvciBncm91cFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTdmdTdHlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9wYWNpdHkgPSB0eXBlb2YgdGhpcy5vcGFjaXR5ICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzLm9wYWNpdHkgIT09IDEgP1xuICAgICAgICAgICAgJ29wYWNpdHk6ICcgKyB0aGlzLm9wYWNpdHkgKyAnOycgOiAnJyxcbiAgICAgICAgICB2aXNpYmlsaXR5ID0gdGhpcy52aXNpYmxlID8gJycgOiAnIHZpc2liaWxpdHk6IGhpZGRlbjsnO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgdGhpcy5nZXRTdmdGaWx0ZXIoKSxcbiAgICAgICAgdmlzaWJpbGl0eVxuICAgICAgXS5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgY2xpcFBhdGggcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9DbGlwUGF0aFNWRzogZnVuY3Rpb24ocmV2aXZlcikge1xuICAgICAgdmFyIHN2Z1N0cmluZyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzdmdTdHJpbmcucHVzaCgnXFx0JywgdGhpcy5fb2JqZWN0c1tpXS50b0NsaXBQYXRoU1ZHKHJldml2ZXIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUJhc2VDbGlwUGF0aFNWR01hcmt1cChzdmdTdHJpbmcsIHsgcmV2aXZlcjogcmV2aXZlciB9KTtcbiAgICB9LFxuICAgIC8qIF9UT19TVkdfRU5EXyAqL1xuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyB7QGxpbmsgZmFicmljLkdyb3VwfSBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuR3JvdXBcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGEgZ3JvdXAgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGdyb3VwIGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICovXG4gIGZhYnJpYy5Hcm91cC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHZhciBvYmplY3RzID0gb2JqZWN0Lm9iamVjdHMsXG4gICAgICAgIG9wdGlvbnMgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUob2JqZWN0LCB0cnVlKTtcbiAgICBkZWxldGUgb3B0aW9ucy5vYmplY3RzO1xuICAgIGlmICh0eXBlb2Ygb2JqZWN0cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGl0IGhhcyB0byBiZSBhbiB1cmwgb3Igc29tZXRoaW5nIHdlbnQgd3JvbmcuXG4gICAgICBmYWJyaWMubG9hZFNWR0Zyb21VUkwob2JqZWN0cywgZnVuY3Rpb24gKGVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBncm91cCA9IGZhYnJpYy51dGlsLmdyb3VwU1ZHRWxlbWVudHMoZWxlbWVudHMsIG9iamVjdCwgb2JqZWN0cyk7XG4gICAgICAgIHZhciBjbGlwUGF0aCA9IG9wdGlvbnMuY2xpcFBhdGg7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmNsaXBQYXRoO1xuICAgICAgICBncm91cC5zZXQob3B0aW9ucyk7XG4gICAgICAgIGlmIChjbGlwUGF0aCkge1xuICAgICAgICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RzKFtjbGlwUGF0aF0sIGZ1bmN0aW9uKGVsaXZlbmVkT2JqZWN0cykge1xuICAgICAgICAgICAgZ3JvdXAuY2xpcFBhdGggPSBlbGl2ZW5lZE9iamVjdHNbMF07XG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhncm91cCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZ3JvdXApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMob2JqZWN0cywgZnVuY3Rpb24gKGVubGl2ZW5lZE9iamVjdHMpIHtcbiAgICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RFbmxpdmFibGVzKG9iamVjdCwgb3B0aW9ucywgZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhuZXcgZmFicmljLkdyb3VwKGVubGl2ZW5lZE9iamVjdHMsIG9wdGlvbnMsIHRydWUpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pO1xuXG4gIGlmIChmYWJyaWMuQWN0aXZlU2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIEdyb3VwIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uXG4gICAqIEBleHRlbmRzIGZhYnJpYy5Hcm91cFxuICAgKiBAdHV0b3JpYWwge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vZmFicmljLWludHJvLXBhcnQtMyNncm91cHN9XG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5BY3RpdmVTZWxlY3Rpb24jaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5BY3RpdmVTZWxlY3Rpb24gPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuR3JvdXAsIC8qKiBAbGVuZHMgZmFicmljLkFjdGl2ZVNlbGVjdGlvbi5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdhY3RpdmVTZWxlY3Rpb24nLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0cyBBY3RpdmVTZWxlY3Rpb24gb2JqZWN0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvYmplY3RzLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHRoaXMuX29iamVjdHMgPSBvYmplY3RzIHx8IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX29iamVjdHMubGVuZ3RoOyBpLS07ICkge1xuICAgICAgICB0aGlzLl9vYmplY3RzW2ldLmdyb3VwID0gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMub3JpZ2luWCkge1xuICAgICAgICB0aGlzLm9yaWdpblggPSBvcHRpb25zLm9yaWdpblg7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5vcmlnaW5ZKSB7XG4gICAgICAgIHRoaXMub3JpZ2luWSA9IG9wdGlvbnMub3JpZ2luWTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhbGNCb3VuZHMoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZU9iamVjdHNDb29yZHMoKTtcbiAgICAgIGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoYW5nZSB0ZSBhY3RpdmVTZWxlY3Rpb24gdG8gYSBub3JtYWwgZ3JvdXAsXG4gICAgICogSGlnaCBsZXZlbCBmdW5jdGlvbiB0aGF0IGF1dG9tYXRpY2FsbHkgYWRkcyBpdCB0byBjYW52YXMgYXNcbiAgICAgKiBhY3RpdmUgb2JqZWN0LiBubyBldmVudHMgZmlyZWQuXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQHJldHVybiB7ZmFicmljLkdyb3VwfVxuICAgICAqL1xuICAgIHRvR3JvdXA6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLmNvbmNhdCgpO1xuICAgICAgdGhpcy5fb2JqZWN0cyA9IFtdO1xuICAgICAgdmFyIG9wdGlvbnMgPSBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS50b09iamVjdC5jYWxsKHRoaXMpO1xuICAgICAgdmFyIG5ld0dyb3VwID0gbmV3IGZhYnJpYy5Hcm91cChbXSk7XG4gICAgICBkZWxldGUgb3B0aW9ucy50eXBlO1xuICAgICAgbmV3R3JvdXAuc2V0KG9wdGlvbnMpO1xuICAgICAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBvYmplY3QuY2FudmFzLnJlbW92ZShvYmplY3QpO1xuICAgICAgICBvYmplY3QuZ3JvdXAgPSBuZXdHcm91cDtcbiAgICAgIH0pO1xuICAgICAgbmV3R3JvdXAuX29iamVjdHMgPSBvYmplY3RzO1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgICByZXR1cm4gbmV3R3JvdXA7XG4gICAgICB9XG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICBjYW52YXMuYWRkKG5ld0dyb3VwKTtcbiAgICAgIGNhbnZhcy5fYWN0aXZlT2JqZWN0ID0gbmV3R3JvdXA7XG4gICAgICBuZXdHcm91cC5zZXRDb29yZHMoKTtcbiAgICAgIHJldHVybiBuZXdHcm91cDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgcmV0dXJucyB0cnVlLCBkZXNlbGVjdGlvbiBpcyBjYW5jZWxsZWQuXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gW2NhbmNlbF1cbiAgICAgKi9cbiAgICBvbkRlc2VsZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGdyb3VwXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnIzxmYWJyaWMuQWN0aXZlU2VsZWN0aW9uOiAoJyArIHRoaXMuY29tcGxleGl0eSgpICsgJyk+JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVjaWRlIGlmIHRoZSBvYmplY3Qgc2hvdWxkIGNhY2hlIG9yIG5vdC4gQ3JlYXRlIGl0cyBvd24gY2FjaGUgbGV2ZWxcbiAgICAgKiBvYmplY3RDYWNoaW5nIGlzIGEgZ2xvYmFsIGZsYWcsIHdpbnMgb3ZlciBldmVyeXRoaW5nXG4gICAgICogbmVlZHNJdHNPd25DYWNoZSBzaG91bGQgYmUgdXNlZCB3aGVuIHRoZSBvYmplY3QgZHJhd2luZyBtZXRob2QgcmVxdWlyZXNcbiAgICAgKiBhIGNhY2hlIHN0ZXAuIE5vbmUgb2YgdGhlIGZhYnJpYyBjbGFzc2VzIHJlcXVpcmVzIGl0LlxuICAgICAqIEdlbmVyYWxseSB5b3UgZG8gbm90IGNhY2hlIG9iamVjdHMgaW4gZ3JvdXBzIGJlY2F1c2UgdGhlIGdyb3VwIG91dHNpZGUgaXMgY2FjaGVkLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc2hvdWxkQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIGdyb3VwIG9yIGl0cyBwYXJlbnQgZ3JvdXAgYXJlIGNhY2hpbmcsIHJlY3Vyc2l2ZWx5IHVwXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc09uQUNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBjb250cm9scyBhbmQgYm9yZGVycyBmb3IgdGhlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0eWxlT3ZlcnJpZGVdIHByb3BlcnRpZXMgdG8gb3ZlcnJpZGUgdGhlIG9iamVjdCBzdHlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY2hpbGRyZW5PdmVycmlkZV0gcHJvcGVydGllcyB0byBvdmVycmlkZSB0aGUgY2hpbGRyZW4gb3ZlcnJpZGVzXG4gICAgICovXG4gICAgX3JlbmRlckNvbnRyb2xzOiBmdW5jdGlvbihjdHgsIHN0eWxlT3ZlcnJpZGUsIGNoaWxkcmVuT3ZlcnJpZGUpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmlzTW92aW5nID8gdGhpcy5ib3JkZXJPcGFjaXR5V2hlbk1vdmluZyA6IDE7XG4gICAgICBjaGlsZHJlbk92ZXJyaWRlID0gY2hpbGRyZW5PdmVycmlkZSB8fCB7IH07XG4gICAgICBpZiAodHlwZW9mIGNoaWxkcmVuT3ZlcnJpZGUuaGFzQ29udHJvbHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNoaWxkcmVuT3ZlcnJpZGUuaGFzQ29udHJvbHMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuT3ZlcnJpZGUuZm9yQWN0aXZlU2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9vYmplY3RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuX29iamVjdHNbaV0uX3JlbmRlckNvbnRyb2xzKGN0eCwgY2hpbGRyZW5PdmVycmlkZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmNhbGxTdXBlcignX3JlbmRlckNvbnRyb2xzJywgY3R4LCBzdHlsZU92ZXJyaWRlKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5BY3RpdmVTZWxlY3Rpb259IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5BY3RpdmVTZWxlY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGEgZ3JvdXAgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIEFjdGl2ZVNlbGVjdGlvbiBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgZmFicmljLnV0aWwuZW5saXZlbk9iamVjdHMob2JqZWN0Lm9iamVjdHMsIGZ1bmN0aW9uKGVubGl2ZW5lZE9iamVjdHMpIHtcbiAgICAgIGRlbGV0ZSBvYmplY3Qub2JqZWN0cztcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG5ldyBmYWJyaWMuQWN0aXZlU2VsZWN0aW9uKGVubGl2ZW5lZE9iamVjdHMsIG9iamVjdCwgdHJ1ZSkpO1xuICAgIH0pO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZDtcblxuICBpZiAoIWdsb2JhbC5mYWJyaWMpIHtcbiAgICBnbG9iYWwuZmFicmljID0geyB9O1xuICB9XG5cbiAgaWYgKGdsb2JhbC5mYWJyaWMuSW1hZ2UpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLkltYWdlIGlzIGFscmVhZHkgZGVmaW5lZC4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogSW1hZ2UgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZVxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuT2JqZWN0XG4gICAqIEB0dXRvcmlhbCB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9mYWJyaWMtaW50cm8tcGFydC0xI2ltYWdlc31cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuT2JqZWN0LCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBhbiBvYmplY3RcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdpbWFnZScsXG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiBhIHN0cm9rZS5cbiAgICAgKiBGb3IgaW1hZ2UgcXVhbGl0eSBhIHN0cm9rZSBtdWx0aXBsZSBvZiAyIGdpdmVzIGJldHRlciByZXN1bHRzLlxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc3Ryb2tlV2lkdGg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGNhbGxpbmcge0BsaW5rIGZhYnJpYy5JbWFnZS5nZXRTcmN9LCByZXR1cm4gdmFsdWUgZnJvbSBlbGVtZW50IHNyYyB3aXRoIGBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3JjJylgLlxuICAgICAqIFRoaXMgYWxsb3dzIGZvciByZWxhdGl2ZSB1cmxzIGFzIGltYWdlIHNyYy5cbiAgICAgKiBAc2luY2UgMi43LjBcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzcmNGcm9tQXR0cmlidXRlOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIHByaXZhdGVcbiAgICAgKiBjb250YWlucyBsYXN0IHZhbHVlIG9mIHNjYWxlWCB0byBkZXRlY3RcbiAgICAgKiBpZiB0aGUgSW1hZ2UgZ290IHJlc2l6ZWQgYWZ0ZXIgdGhlIGxhc3QgUmVuZGVyXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgX2xhc3RTY2FsZVg6IDEsXG5cbiAgICAvKipcbiAgICAgKiBwcml2YXRlXG4gICAgICogY29udGFpbnMgbGFzdCB2YWx1ZSBvZiBzY2FsZVkgdG8gZGV0ZWN0XG4gICAgICogaWYgdGhlIEltYWdlIGdvdCByZXNpemVkIGFmdGVyIHRoZSBsYXN0IFJlbmRlclxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIF9sYXN0U2NhbGVZOiAxLFxuXG4gICAgLyoqXG4gICAgICogcHJpdmF0ZVxuICAgICAqIGNvbnRhaW5zIGxhc3QgdmFsdWUgb2Ygc2NhbGluZyBhcHBsaWVkIGJ5IHRoZSBhcHBseSBmaWx0ZXIgY2hhaW5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICBfZmlsdGVyU2NhbGluZ1g6IDEsXG5cbiAgICAvKipcbiAgICAgKiBwcml2YXRlXG4gICAgICogY29udGFpbnMgbGFzdCB2YWx1ZSBvZiBzY2FsaW5nIGFwcGxpZWQgYnkgdGhlIGFwcGx5IGZpbHRlciBjaGFpblxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIF9maWx0ZXJTY2FsaW5nWTogMSxcblxuICAgIC8qKlxuICAgICAqIG1pbmltdW0gc2NhbGUgZmFjdG9yIHVuZGVyIHdoaWNoIGFueSByZXNpemVGaWx0ZXIgaXMgdHJpZ2dlcmVkIHRvIHJlc2l6ZSB0aGUgaW1hZ2VcbiAgICAgKiAwIHdpbGwgZGlzYWJsZSB0aGUgYXV0b21hdGljIHJlc2l6ZS4gMSB3aWxsIHRyaWdnZXIgYXV0b21hdGljYWxseSBhbHdheXMuXG4gICAgICogbnVtYmVyIGJpZ2dlciB0aGFuIDEgYXJlIG5vdCBpbXBsZW1lbnRlZCB5ZXQuXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgbWluaW11bVNjYWxlVHJpZ2dlcjogMC41LFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBwcm9wZXJ0aWVzIHRvIGNvbnNpZGVyIHdoZW4gY2hlY2tpbmcgaWZcbiAgICAgKiBzdGF0ZSBvZiBhbiBvYmplY3QgaXMgY2hhbmdlZCAoe0BsaW5rIGZhYnJpYy5PYmplY3QjaGFzU3RhdGVDaGFuZ2VkfSlcbiAgICAgKiBhcyB3ZWxsIGFzIGZvciBoaXN0b3J5ICh1bmRvL3JlZG8pIHB1cnBvc2VzXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBzdGF0ZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLnN0YXRlUHJvcGVydGllcy5jb25jYXQoJ2Nyb3BYJywgJ2Nyb3BZJyksXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgd2hlbiBjaGVja2luZyBpZiBjYWNoZSBuZWVkcyByZWZyZXNoXG4gICAgICogVGhvc2UgcHJvcGVydGllcyBhcmUgY2hlY2tlZCBieSBzdGF0ZWZ1bGxDYWNoZSBPTiAoIG9yIGxhenkgbW9kZSBpZiB3ZSB3YW50ICkgb3IgZnJvbSBzaW5nbGVcbiAgICAgKiBjYWxscyB0byBPYmplY3Quc2V0KGtleSwgdmFsdWUpLiBJZiB0aGUga2V5IGlzIGluIHRoaXMgbGlzdCwgdGhlIG9iamVjdCBpcyBtYXJrZWQgYXMgZGlydHlcbiAgICAgKiBhbmQgcmVmcmVzaGVkIGF0IHRoZSBuZXh0IHJlbmRlclxuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgY2FjaGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5jYWNoZVByb3BlcnRpZXMuY29uY2F0KCdjcm9wWCcsICdjcm9wWScpLFxuXG4gICAgLyoqXG4gICAgICoga2V5IHVzZWQgdG8gcmV0cmlldmUgdGhlIHRleHR1cmUgcmVwcmVzZW50aW5nIHRoaXMgaW1hZ2VcbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNhY2hlS2V5OiAnJyxcblxuICAgIC8qKlxuICAgICAqIEltYWdlIGNyb3AgaW4gcGl4ZWxzIGZyb20gb3JpZ2luYWwgaW1hZ2Ugc2l6ZS5cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNyb3BYOiAwLFxuXG4gICAgLyoqXG4gICAgICogSW1hZ2UgY3JvcCBpbiBwaXhlbHMgZnJvbSBvcmlnaW5hbCBpbWFnZSBzaXplLlxuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY3JvcFk6IDAsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGNhbnZhcyB3aWxsIHVzZSBpbWFnZSBzbW9vdGhpbmcgd2hlbiBwYWludGluZyB0aGlzIGltYWdlLlxuICAgICAqIEFsc28gaW5mbHVlbmNlIGlmIHRoZSBjYWNoZUNhbnZhcyBmb3IgdGhpcyBpbWFnZSB1c2VzIGltYWdlU21vb3RoaW5nXG4gICAgICogQHNpbmNlIDQuMC4wLWJldGEuMTFcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBpbWFnZVNtb290aGluZzogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogSW1hZ2UgY2FuIGJlIGluaXRpYWxpemVkIHdpdGggYW55IGNhbnZhcyBkcmF3YWJsZSBvciBhIHN0cmluZy5cbiAgICAgKiBUaGUgc3RyaW5nIHNob3VsZCBiZSBhIHVybCBhbmQgd2lsbCBiZSBsb2FkZWQgYXMgYW4gaW1hZ2UuXG4gICAgICogQ2FudmFzIGFuZCBJbWFnZSBlbGVtZW50IHdvcmsgb3V0IG9mIHRoZSBib3gsIHdoaWxlIHZpZGVvcyByZXF1aXJlIGV4dHJhIGNvZGUgdG8gd29yay5cbiAgICAgKiBQbGVhc2UgY2hlY2sgdmlkZW8gZWxlbWVudCBldmVudHMgZm9yIHNlZWtpbmcuXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTENhbnZhc0VsZW1lbnQgfCBIVE1MVmlkZW9FbGVtZW50IHwgU3RyaW5nfSBlbGVtZW50IEltYWdlIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIGFmdGVyIGV2ZW50dWFsIGZpbHRlcnMgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2V9IHRoaXNBcmdcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0geyB9KTtcbiAgICAgIHRoaXMuZmlsdGVycyA9IFtdO1xuICAgICAgdGhpcy5jYWNoZUtleSA9ICd0ZXh0dXJlJyArIGZhYnJpYy5PYmplY3QuX191aWQrKztcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9pbml0RWxlbWVudChlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpbWFnZSBlbGVtZW50IHdoaWNoIHRoaXMgaW5zdGFuY2UgaWYgYmFzZWQgb25cbiAgICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSBJbWFnZSBlbGVtZW50XG4gICAgICovXG4gICAgZ2V0RWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudCB8fCB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBpbWFnZSBlbGVtZW50IGZvciB0aGlzIGluc3RhbmNlIHRvIGEgc3BlY2lmaWVkIG9uZS5cbiAgICAgKiBJZiBmaWx0ZXJzIGRlZmluZWQgdGhleSBhcmUgYXBwbGllZCB0byBuZXcgaW1hZ2UuXG4gICAgICogWW91IG1pZ2h0IG5lZWQgdG8gY2FsbCBgY2FudmFzLnJlbmRlckFsbGAgYW5kIGBvYmplY3Quc2V0Q29vcmRzYCBhZnRlciByZXBsYWNpbmcsIHRvIHJlbmRlciBuZXcgaW1hZ2UgYW5kIHVwZGF0ZSBjb250cm9scyBhcmVhLlxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2V9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0RWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgdGhpcy5yZW1vdmVUZXh0dXJlKHRoaXMuY2FjaGVLZXkpO1xuICAgICAgdGhpcy5yZW1vdmVUZXh0dXJlKHRoaXMuY2FjaGVLZXkgKyAnX2ZpbHRlcmVkJyk7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMuX29yaWdpbmFsRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLl9pbml0Q29uZmlnKG9wdGlvbnMpO1xuICAgICAgaWYgKHRoaXMuZmlsdGVycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgdGhpcy5hcHBseUZpbHRlcnMoKTtcbiAgICAgIH1cbiAgICAgIC8vIHJlc2l6ZUZpbHRlcnMgd29yayBvbiB0aGUgYWxyZWFkeSBmaWx0ZXJlZCBjb3B5LlxuICAgICAgLy8gd2UgbmVlZCB0byBhcHBseSByZXNpemVGaWx0ZXJzIEFGVEVSIG5vcm1hbCBmaWx0ZXJzLlxuICAgICAgLy8gYXBwbHlSZXNpemVGaWx0ZXJzIGlzIHJ1biBtb3JlIG9mdGVuIHRoYW4gbm9ybWFsIGZpbHRlcnNcbiAgICAgIC8vIGFuZCBpcyB0cmlnZ2VyZWQgYnkgdXNlciBpbnRlcmFjdGlvbnMgcmF0aGVyIHRoYW4gZGV2IGNvZGVcbiAgICAgIGlmICh0aGlzLnJlc2l6ZUZpbHRlcikge1xuICAgICAgICB0aGlzLmFwcGx5UmVzaXplRmlsdGVycygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHNpbmdsZSB0ZXh0dXJlIGlmIGluIHdlYmdsIG1vZGVcbiAgICAgKi9cbiAgICByZW1vdmVUZXh0dXJlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciBiYWNrZW5kID0gZmFicmljLmZpbHRlckJhY2tlbmQ7XG4gICAgICBpZiAoYmFja2VuZCAmJiBiYWNrZW5kLmV2aWN0Q2FjaGVzRm9yS2V5KSB7XG4gICAgICAgIGJhY2tlbmQuZXZpY3RDYWNoZXNGb3JLZXkoa2V5KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIHRleHR1cmVzLCByZWZlcmVuY2UgdG8gZWxlbWVudHMgYW5kIGV2ZW50dWFsbHkgSlNET00gY2xlYW51cFxuICAgICAqL1xuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdkaXNwb3NlJyk7XG4gICAgICB0aGlzLnJlbW92ZVRleHR1cmUodGhpcy5jYWNoZUtleSk7XG4gICAgICB0aGlzLnJlbW92ZVRleHR1cmUodGhpcy5jYWNoZUtleSArICdfZmlsdGVyZWQnKTtcbiAgICAgIHRoaXMuX2NhY2hlQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgIFsnX29yaWdpbmFsRWxlbWVudCcsICdfZWxlbWVudCcsICdfZmlsdGVyZWRFbCcsICdfY2FjaGVDYW52YXMnXS5mb3JFYWNoKChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIGZhYnJpYy51dGlsLmNsZWFuVXBKc2RvbU5vZGUodGhpc1tlbGVtZW50XSk7XG4gICAgICAgIHRoaXNbZWxlbWVudF0gPSB1bmRlZmluZWQ7XG4gICAgICB9KS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjcm9zc09yaWdpbiB2YWx1ZSAob2YgdGhlIGNvcnJlc3BvbmRpbmcgaW1hZ2UgZWxlbWVudClcbiAgICAgKi9cbiAgICBnZXRDcm9zc09yaWdpbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb3JpZ2luYWxFbGVtZW50ICYmICh0aGlzLl9vcmlnaW5hbEVsZW1lbnQuY3Jvc3NPcmlnaW4gfHwgbnVsbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb3JpZ2luYWwgc2l6ZSBvZiBhbiBpbWFnZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHdpdGggXCJ3aWR0aFwiIGFuZCBcImhlaWdodFwiIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBnZXRPcmlnaW5hbFNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBlbGVtZW50Lm5hdHVyYWxXaWR0aCB8fCBlbGVtZW50LndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGVsZW1lbnQubmF0dXJhbEhlaWdodCB8fCBlbGVtZW50LmhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3N0cm9rZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMuc3Ryb2tlIHx8IHRoaXMuc3Ryb2tlV2lkdGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHcgPSB0aGlzLndpZHRoIC8gMiwgaCA9IHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oLXcsIC1oKTtcbiAgICAgIGN0eC5saW5lVG8odywgLWgpO1xuICAgICAgY3R4LmxpbmVUbyh3LCBoKTtcbiAgICAgIGN0eC5saW5lVG8oLXcsIGgpO1xuICAgICAgY3R4LmxpbmVUbygtdywgLWgpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgZmlsdGVycyA9IFtdO1xuXG4gICAgICB0aGlzLmZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbihmaWx0ZXJPYmopIHtcbiAgICAgICAgaWYgKGZpbHRlck9iaikge1xuICAgICAgICAgIGZpbHRlcnMucHVzaChmaWx0ZXJPYmoudG9PYmplY3QoKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIG9iamVjdCA9IGV4dGVuZChcbiAgICAgICAgdGhpcy5jYWxsU3VwZXIoXG4gICAgICAgICAgJ3RvT2JqZWN0JyxcbiAgICAgICAgICBbJ2Nyb3BYJywgJ2Nyb3BZJ10uY29uY2F0KHByb3BlcnRpZXNUb0luY2x1ZGUpXG4gICAgICAgICksIHtcbiAgICAgICAgICBzcmM6IHRoaXMuZ2V0U3JjKCksXG4gICAgICAgICAgY3Jvc3NPcmlnaW46IHRoaXMuZ2V0Q3Jvc3NPcmlnaW4oKSxcbiAgICAgICAgICBmaWx0ZXJzOiBmaWx0ZXJzLFxuICAgICAgICB9KTtcbiAgICAgIGlmICh0aGlzLnJlc2l6ZUZpbHRlcikge1xuICAgICAgICBvYmplY3QucmVzaXplRmlsdGVyID0gdGhpcy5yZXNpemVGaWx0ZXIudG9PYmplY3QoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhbiBpbWFnZSBoYXMgY3JvcCBhcHBsaWVkLCBpbnNwZWN0aW5nIHZhbHVlcyBvZiBjcm9wWCxjcm9wWSx3aWR0aCxoZWlnaHQuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNDcm9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyb3BYIHx8IHRoaXMuY3JvcFkgfHwgdGhpcy53aWR0aCA8IHRoaXMuX2VsZW1lbnQud2lkdGggfHwgdGhpcy5oZWlnaHQgPCB0aGlzLl9lbGVtZW50LmhlaWdodDtcbiAgICB9LFxuXG4gICAgLyogX1RPX1NWR19TVEFSVF8gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHN2ZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSBvZiBzdHJpbmdzIHdpdGggdGhlIHNwZWNpZmljIHN2ZyByZXByZXNlbnRhdGlvblxuICAgICAqIG9mIHRoZSBpbnN0YW5jZVxuICAgICAqL1xuICAgIF90b1NWRzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3ZnU3RyaW5nID0gW10sIGltYWdlTWFya3VwID0gW10sIHN0cm9rZVN2ZywgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQsXG4gICAgICAgICAgeCA9IC10aGlzLndpZHRoIC8gMiwgeSA9IC10aGlzLmhlaWdodCAvIDIsIGNsaXBQYXRoID0gJycsIGltYWdlUmVuZGVyaW5nID0gJyc7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGFzQ3JvcCgpKSB7XG4gICAgICAgIHZhciBjbGlwUGF0aElkID0gZmFicmljLk9iamVjdC5fX3VpZCsrO1xuICAgICAgICBzdmdTdHJpbmcucHVzaChcbiAgICAgICAgICAnPGNsaXBQYXRoIGlkPVwiaW1hZ2VDcm9wXycgKyBjbGlwUGF0aElkICsgJ1wiPlxcbicsXG4gICAgICAgICAgJ1xcdDxyZWN0IHg9XCInICsgeCArICdcIiB5PVwiJyArIHkgKyAnXCIgd2lkdGg9XCInICsgdGhpcy53aWR0aCArICdcIiBoZWlnaHQ9XCInICsgdGhpcy5oZWlnaHQgKyAnXCIgLz5cXG4nLFxuICAgICAgICAgICc8L2NsaXBQYXRoPlxcbidcbiAgICAgICAgKTtcbiAgICAgICAgY2xpcFBhdGggPSAnIGNsaXAtcGF0aD1cInVybCgjaW1hZ2VDcm9wXycgKyBjbGlwUGF0aElkICsgJylcIiAnO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmltYWdlU21vb3RoaW5nKSB7XG4gICAgICAgIGltYWdlUmVuZGVyaW5nID0gJ1wiIGltYWdlLXJlbmRlcmluZz1cIm9wdGltaXplU3BlZWQnO1xuICAgICAgfVxuICAgICAgaW1hZ2VNYXJrdXAucHVzaCgnXFx0PGltYWdlICcsICdDT01NT05fUEFSVFMnLCAneGxpbms6aHJlZj1cIicsIHRoaXMuZ2V0U3ZnU3JjKHRydWUpLFxuICAgICAgICAnXCIgeD1cIicsIHggLSB0aGlzLmNyb3BYLCAnXCIgeT1cIicsIHkgLSB0aGlzLmNyb3BZLFxuICAgICAgICAvLyB3ZSdyZSBlc3NlbnRpYWxseSBtb3Zpbmcgb3JpZ2luIG9mIHRyYW5zZm9ybWF0aW9uIGZyb20gdG9wL2xlZnQgY29ybmVyIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHNoYXBlXG4gICAgICAgIC8vIGJ5IHdyYXBwaW5nIGl0IGluIGNvbnRhaW5lciA8Zz4gZWxlbWVudCB3aXRoIGFjdHVhbCB0cmFuc2Zvcm1hdGlvbiwgdGhlbiBvZmZzZXR0aW5nIG9iamVjdCB0byB0aGUgdG9wL2xlZnRcbiAgICAgICAgLy8gc28gdGhhdCBvYmplY3QncyBjZW50ZXIgYWxpZ25zIHdpdGggY29udGFpbmVyJ3MgbGVmdC90b3BcbiAgICAgICAgJ1wiIHdpZHRoPVwiJywgZWxlbWVudC53aWR0aCB8fCBlbGVtZW50Lm5hdHVyYWxXaWR0aCxcbiAgICAgICAgJ1wiIGhlaWdodD1cIicsIGVsZW1lbnQuaGVpZ2h0IHx8IGVsZW1lbnQuaGVpZ2h0LFxuICAgICAgICBpbWFnZVJlbmRlcmluZyxcbiAgICAgICAgJ1wiJywgY2xpcFBhdGgsXG4gICAgICAgICc+PC9pbWFnZT5cXG4nKTtcblxuICAgICAgaWYgKHRoaXMuc3Ryb2tlIHx8IHRoaXMuc3Ryb2tlRGFzaEFycmF5KSB7XG4gICAgICAgIHZhciBvcmlnRmlsbCA9IHRoaXMuZmlsbDtcbiAgICAgICAgdGhpcy5maWxsID0gbnVsbDtcbiAgICAgICAgc3Ryb2tlU3ZnID0gW1xuICAgICAgICAgICdcXHQ8cmVjdCAnLFxuICAgICAgICAgICd4PVwiJywgeCwgJ1wiIHk9XCInLCB5LFxuICAgICAgICAgICdcIiB3aWR0aD1cIicsIHRoaXMud2lkdGgsICdcIiBoZWlnaHQ9XCInLCB0aGlzLmhlaWdodCxcbiAgICAgICAgICAnXCIgc3R5bGU9XCInLCB0aGlzLmdldFN2Z1N0eWxlcygpLFxuICAgICAgICAgICdcIi8+XFxuJ1xuICAgICAgICBdO1xuICAgICAgICB0aGlzLmZpbGwgPSBvcmlnRmlsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBhaW50Rmlyc3QgIT09ICdmaWxsJykge1xuICAgICAgICBzdmdTdHJpbmcgPSBzdmdTdHJpbmcuY29uY2F0KHN0cm9rZVN2ZywgaW1hZ2VNYXJrdXApO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN2Z1N0cmluZyA9IHN2Z1N0cmluZy5jb25jYXQoaW1hZ2VNYXJrdXAsIHN0cm9rZVN2Zyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3ZnU3RyaW5nO1xuICAgIH0sXG4gICAgLyogX1RPX1NWR19FTkRfICovXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHNvdXJjZSBvZiBhbiBpbWFnZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmlsdGVyZWQgaW5kaWNhdGVzIGlmIHRoZSBzcmMgaXMgbmVlZGVkIGZvciBzdmdcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFNvdXJjZSBvZiBhbiBpbWFnZVxuICAgICAqL1xuICAgIGdldFNyYzogZnVuY3Rpb24oZmlsdGVyZWQpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gZmlsdGVyZWQgPyB0aGlzLl9lbGVtZW50IDogdGhpcy5fb3JpZ2luYWxFbGVtZW50O1xuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQudG9EYXRhVVJMKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQudG9EYXRhVVJMKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zcmNGcm9tQXR0cmlidXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudC5zcmM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5zcmMgfHwgJyc7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgc291cmNlIG9mIGFuIGltYWdlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNyYyBTb3VyY2Ugc3RyaW5nIChVUkwpXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayBpcyBpbnZva2VkIHdoZW4gaW1hZ2UgaGFzIGJlZW4gbG9hZGVkIChhbmQgYWxsIGZpbHRlcnMgaGF2ZSBiZWVuIGFwcGxpZWQpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jcm9zc09yaWdpbl0gY3Jvc3NPcmlnaW4gdmFsdWUgKG9uZSBvZiBcIlwiLCBcImFub255bW91c1wiLCBcInVzZS1jcmVkZW50aWFsc1wiKVxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9IVE1ML0NPUlNfc2V0dGluZ3NfYXR0cmlidXRlc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZX0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRTcmM6IGZ1bmN0aW9uKHNyYywgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgIGZhYnJpYy51dGlsLmxvYWRJbWFnZShzcmMsIGZ1bmN0aW9uKGltZywgaXNFcnJvcikge1xuICAgICAgICB0aGlzLnNldEVsZW1lbnQoaW1nLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fc2V0V2lkdGhIZWlnaHQoKTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sodGhpcywgaXNFcnJvcik7XG4gICAgICB9LCB0aGlzLCBvcHRpb25zICYmIG9wdGlvbnMuY3Jvc3NPcmlnaW4pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gJyM8ZmFicmljLkltYWdlOiB7IHNyYzogXCInICsgdGhpcy5nZXRTcmMoKSArICdcIiB9Pic7XG4gICAgfSxcblxuICAgIGFwcGx5UmVzaXplRmlsdGVyczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZmlsdGVyID0gdGhpcy5yZXNpemVGaWx0ZXIsXG4gICAgICAgICAgbWluaW11bVNjYWxlID0gdGhpcy5taW5pbXVtU2NhbGVUcmlnZ2VyLFxuICAgICAgICAgIG9iamVjdFNjYWxlID0gdGhpcy5nZXRUb3RhbE9iamVjdFNjYWxpbmcoKSxcbiAgICAgICAgICBzY2FsZVggPSBvYmplY3RTY2FsZS5zY2FsZVgsXG4gICAgICAgICAgc2NhbGVZID0gb2JqZWN0U2NhbGUuc2NhbGVZLFxuICAgICAgICAgIGVsZW1lbnRUb0ZpbHRlciA9IHRoaXMuX2ZpbHRlcmVkRWwgfHwgdGhpcy5fb3JpZ2luYWxFbGVtZW50O1xuICAgICAgaWYgKHRoaXMuZ3JvdXApIHtcbiAgICAgICAgdGhpcy5zZXQoJ2RpcnR5JywgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWZpbHRlciB8fCAoc2NhbGVYID4gbWluaW11bVNjYWxlICYmIHNjYWxlWSA+IG1pbmltdW1TY2FsZSkpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnRUb0ZpbHRlcjtcbiAgICAgICAgdGhpcy5fZmlsdGVyU2NhbGluZ1ggPSAxO1xuICAgICAgICB0aGlzLl9maWx0ZXJTY2FsaW5nWSA9IDE7XG4gICAgICAgIHRoaXMuX2xhc3RTY2FsZVggPSBzY2FsZVg7XG4gICAgICAgIHRoaXMuX2xhc3RTY2FsZVkgPSBzY2FsZVk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghZmFicmljLmZpbHRlckJhY2tlbmQpIHtcbiAgICAgICAgZmFicmljLmZpbHRlckJhY2tlbmQgPSBmYWJyaWMuaW5pdEZpbHRlckJhY2tlbmQoKTtcbiAgICAgIH1cbiAgICAgIHZhciBjYW52YXNFbCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKSxcbiAgICAgICAgICBjYWNoZUtleSA9IHRoaXMuX2ZpbHRlcmVkRWwgPyAodGhpcy5jYWNoZUtleSArICdfZmlsdGVyZWQnKSA6IHRoaXMuY2FjaGVLZXksXG4gICAgICAgICAgc291cmNlV2lkdGggPSBlbGVtZW50VG9GaWx0ZXIud2lkdGgsIHNvdXJjZUhlaWdodCA9IGVsZW1lbnRUb0ZpbHRlci5oZWlnaHQ7XG4gICAgICBjYW52YXNFbC53aWR0aCA9IHNvdXJjZVdpZHRoO1xuICAgICAgY2FudmFzRWwuaGVpZ2h0ID0gc291cmNlSGVpZ2h0O1xuICAgICAgdGhpcy5fZWxlbWVudCA9IGNhbnZhc0VsO1xuICAgICAgdGhpcy5fbGFzdFNjYWxlWCA9IGZpbHRlci5zY2FsZVggPSBzY2FsZVg7XG4gICAgICB0aGlzLl9sYXN0U2NhbGVZID0gZmlsdGVyLnNjYWxlWSA9IHNjYWxlWTtcbiAgICAgIGZhYnJpYy5maWx0ZXJCYWNrZW5kLmFwcGx5RmlsdGVycyhcbiAgICAgICAgW2ZpbHRlcl0sIGVsZW1lbnRUb0ZpbHRlciwgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCwgdGhpcy5fZWxlbWVudCwgY2FjaGVLZXkpO1xuICAgICAgdGhpcy5fZmlsdGVyU2NhbGluZ1ggPSBjYW52YXNFbC53aWR0aCAvIHRoaXMuX29yaWdpbmFsRWxlbWVudC53aWR0aDtcbiAgICAgIHRoaXMuX2ZpbHRlclNjYWxpbmdZID0gY2FudmFzRWwuaGVpZ2h0IC8gdGhpcy5fb3JpZ2luYWxFbGVtZW50LmhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBmaWx0ZXJzIGFzc2lnbmVkIHRvIHRoaXMgaW1hZ2UgKGZyb20gXCJmaWx0ZXJzXCIgYXJyYXkpIG9yIGZyb20gZmlsdGVyIHBhcmFtXG4gICAgICogQG1ldGhvZCBhcHBseUZpbHRlcnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXJzIHRvIGJlIGFwcGxpZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvclJlc2l6aW5nIHNwZWNpZnkgaWYgdGhlIGZpbHRlciBvcGVyYXRpb24gaXMgYSByZXNpemUgb3BlcmF0aW9uXG4gICAgICogQHJldHVybiB7dGhpc0FyZ30gcmV0dXJuIHRoZSBmYWJyaWMuSW1hZ2Ugb2JqZWN0XG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGFwcGx5RmlsdGVyczogZnVuY3Rpb24oZmlsdGVycykge1xuXG4gICAgICBmaWx0ZXJzID0gZmlsdGVycyB8fCB0aGlzLmZpbHRlcnMgfHwgW107XG4gICAgICBmaWx0ZXJzID0gZmlsdGVycy5maWx0ZXIoZnVuY3Rpb24oZmlsdGVyKSB7IHJldHVybiBmaWx0ZXIgJiYgIWZpbHRlci5pc05ldXRyYWxTdGF0ZSgpOyB9KTtcbiAgICAgIHRoaXMuc2V0KCdkaXJ0eScsIHRydWUpO1xuXG4gICAgICAvLyBuZWVkcyB0byBjbGVhciBvdXQgb3IgV0VCR0wgd2lsbCBub3QgcmVzaXplIGNvcnJlY3RseVxuICAgICAgdGhpcy5yZW1vdmVUZXh0dXJlKHRoaXMuY2FjaGVLZXkgKyAnX2ZpbHRlcmVkJyk7XG5cbiAgICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gdGhpcy5fb3JpZ2luYWxFbGVtZW50O1xuICAgICAgICB0aGlzLl9maWx0ZXJlZEVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZmlsdGVyU2NhbGluZ1ggPSAxO1xuICAgICAgICB0aGlzLl9maWx0ZXJTY2FsaW5nWSA9IDE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW1nRWxlbWVudCA9IHRoaXMuX29yaWdpbmFsRWxlbWVudCxcbiAgICAgICAgICBzb3VyY2VXaWR0aCA9IGltZ0VsZW1lbnQubmF0dXJhbFdpZHRoIHx8IGltZ0VsZW1lbnQud2lkdGgsXG4gICAgICAgICAgc291cmNlSGVpZ2h0ID0gaW1nRWxlbWVudC5uYXR1cmFsSGVpZ2h0IHx8IGltZ0VsZW1lbnQuaGVpZ2h0O1xuXG4gICAgICBpZiAodGhpcy5fZWxlbWVudCA9PT0gdGhpcy5fb3JpZ2luYWxFbGVtZW50KSB7XG4gICAgICAgIC8vIGlmIHRoZSBlbGVtZW50IGlzIHRoZSBzYW1lIHdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IGVsZW1lbnRcbiAgICAgICAgdmFyIGNhbnZhc0VsID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgICBjYW52YXNFbC53aWR0aCA9IHNvdXJjZVdpZHRoO1xuICAgICAgICBjYW52YXNFbC5oZWlnaHQgPSBzb3VyY2VIZWlnaHQ7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBjYW52YXNFbDtcbiAgICAgICAgdGhpcy5fZmlsdGVyZWRFbCA9IGNhbnZhc0VsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGNsZWFyIHRoZSBleGlzdGluZyBlbGVtZW50IHRvIGdldCBuZXcgZmlsdGVyIGRhdGFcbiAgICAgICAgLy8gYWxzbyBkZXJlZmVyZW5jZSB0aGUgZXZlbnR1YWwgcmVzaXplZCBfZWxlbWVudFxuICAgICAgICB0aGlzLl9lbGVtZW50ID0gdGhpcy5fZmlsdGVyZWRFbDtcbiAgICAgICAgdGhpcy5fZmlsdGVyZWRFbC5nZXRDb250ZXh0KCcyZCcpLmNsZWFyUmVjdCgwLCAwLCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0KTtcbiAgICAgICAgLy8gd2UgYWxzbyBuZWVkIHRvIHJlc2l6ZSBhZ2FpbiBhdCBuZXh0IHJlbmRlckFsbCwgc28gcmVtb3ZlIHNhdmVkIF9sYXN0U2NhbGVYL1lcbiAgICAgICAgdGhpcy5fbGFzdFNjYWxlWCA9IDE7XG4gICAgICAgIHRoaXMuX2xhc3RTY2FsZVkgPSAxO1xuICAgICAgfVxuICAgICAgaWYgKCFmYWJyaWMuZmlsdGVyQmFja2VuZCkge1xuICAgICAgICBmYWJyaWMuZmlsdGVyQmFja2VuZCA9IGZhYnJpYy5pbml0RmlsdGVyQmFja2VuZCgpO1xuICAgICAgfVxuICAgICAgZmFicmljLmZpbHRlckJhY2tlbmQuYXBwbHlGaWx0ZXJzKFxuICAgICAgICBmaWx0ZXJzLCB0aGlzLl9vcmlnaW5hbEVsZW1lbnQsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQsIHRoaXMuX2VsZW1lbnQsIHRoaXMuY2FjaGVLZXkpO1xuICAgICAgaWYgKHRoaXMuX29yaWdpbmFsRWxlbWVudC53aWR0aCAhPT0gdGhpcy5fZWxlbWVudC53aWR0aCB8fFxuICAgICAgICB0aGlzLl9vcmlnaW5hbEVsZW1lbnQuaGVpZ2h0ICE9PSB0aGlzLl9lbGVtZW50LmhlaWdodCkge1xuICAgICAgICB0aGlzLl9maWx0ZXJTY2FsaW5nWCA9IHRoaXMuX2VsZW1lbnQud2lkdGggLyB0aGlzLl9vcmlnaW5hbEVsZW1lbnQud2lkdGg7XG4gICAgICAgIHRoaXMuX2ZpbHRlclNjYWxpbmdZID0gdGhpcy5fZWxlbWVudC5oZWlnaHQgLyB0aGlzLl9vcmlnaW5hbEVsZW1lbnQuaGVpZ2h0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgZmFicmljLnV0aWwuc2V0SW1hZ2VTbW9vdGhpbmcoY3R4LCB0aGlzLmltYWdlU21vb3RoaW5nKTtcbiAgICAgIGlmICh0aGlzLmlzTW92aW5nICE9PSB0cnVlICYmIHRoaXMucmVzaXplRmlsdGVyICYmIHRoaXMuX25lZWRzUmVzaXplKCkpIHtcbiAgICAgICAgdGhpcy5hcHBseVJlc2l6ZUZpbHRlcnMoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0cm9rZShjdHgpO1xuICAgICAgdGhpcy5fcmVuZGVyUGFpbnRJbk9yZGVyKGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhaW50IHRoZSBjYWNoZWQgY29weSBvZiB0aGUgb2JqZWN0IG9uIHRoZSB0YXJnZXQgY29udGV4dC5cbiAgICAgKiBpdCB3aWxsIHNldCB0aGUgaW1hZ2VTbW9vdGhpbmcgZm9yIHRoZSBkcmF3IG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBkcmF3Q2FjaGVPbkNhbnZhczogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBmYWJyaWMudXRpbC5zZXRJbWFnZVNtb290aGluZyhjdHgsIHRoaXMuaW1hZ2VTbW9vdGhpbmcpO1xuICAgICAgZmFicmljLk9iamVjdC5wcm90b3R5cGUuZHJhd0NhY2hlT25DYW52YXMuY2FsbCh0aGlzLCBjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWNpZGUgaWYgdGhlIG9iamVjdCBzaG91bGQgY2FjaGUgb3Igbm90LiBDcmVhdGUgaXRzIG93biBjYWNoZSBsZXZlbFxuICAgICAqIG5lZWRzSXRzT3duQ2FjaGUgc2hvdWxkIGJlIHVzZWQgd2hlbiB0aGUgb2JqZWN0IGRyYXdpbmcgbWV0aG9kIHJlcXVpcmVzXG4gICAgICogYSBjYWNoZSBzdGVwLiBOb25lIG9mIHRoZSBmYWJyaWMgY2xhc3NlcyByZXF1aXJlcyBpdC5cbiAgICAgKiBHZW5lcmFsbHkgeW91IGRvIG5vdCBjYWNoZSBvYmplY3RzIGluIGdyb3VwcyBiZWNhdXNlIHRoZSBncm91cCBvdXRzaWRlIGlzIGNhY2hlZC5cbiAgICAgKiBUaGlzIGlzIHRoZSBzcGVjaWFsIGltYWdlIHZlcnNpb24gd2hlcmUgd2Ugd291bGQgbGlrZSB0byBhdm9pZCBjYWNoaW5nIHdoZXJlIHBvc3NpYmxlLlxuICAgICAqIEVzc2VudGlhbGx5IGltYWdlcyBkbyBub3QgYmVuZWZpdCBmcm9tIGNhY2hpbmcuIFRoZXkgbWF5IHJlcXVpcmUgY2FjaGluZywgYW5kIGluIHRoYXRcbiAgICAgKiBjYXNlIHdlIGRvIGl0LiBBbHNvIGNhY2hpbmcgYW4gaW1hZ2UgdXN1YWxseSBlbmRzIGluIGEgbG9zcyBvZiBkZXRhaWxzLlxuICAgICAqIEEgZnVsbCBwZXJmb3JtYW5jZSBhdWRpdCBzaG91bGQgYmUgZG9uZS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHNob3VsZENhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5lZWRzSXRzT3duQ2FjaGUoKTtcbiAgICB9LFxuXG4gICAgX3JlbmRlckZpbGw6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIGVsZW1lbnRUb0RyYXcgPSB0aGlzLl9lbGVtZW50O1xuICAgICAgaWYgKCFlbGVtZW50VG9EcmF3KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzY2FsZVggPSB0aGlzLl9maWx0ZXJTY2FsaW5nWCwgc2NhbGVZID0gdGhpcy5fZmlsdGVyU2NhbGluZ1ksXG4gICAgICAgICAgdyA9IHRoaXMud2lkdGgsIGggPSB0aGlzLmhlaWdodCwgbWluID0gTWF0aC5taW4sIG1heCA9IE1hdGgubWF4LFxuICAgICAgICAgIC8vIGNyb3AgdmFsdWVzIGNhbm5vdCBiZSBsZXNzZXIgdGhhbiAwLlxuICAgICAgICAgIGNyb3BYID0gbWF4KHRoaXMuY3JvcFgsIDApLCBjcm9wWSA9IG1heCh0aGlzLmNyb3BZLCAwKSxcbiAgICAgICAgICBlbFdpZHRoID0gZWxlbWVudFRvRHJhdy5uYXR1cmFsV2lkdGggfHwgZWxlbWVudFRvRHJhdy53aWR0aCxcbiAgICAgICAgICBlbEhlaWdodCA9IGVsZW1lbnRUb0RyYXcubmF0dXJhbEhlaWdodCB8fCBlbGVtZW50VG9EcmF3LmhlaWdodCxcbiAgICAgICAgICBzWCA9IGNyb3BYICogc2NhbGVYLFxuICAgICAgICAgIHNZID0gY3JvcFkgKiBzY2FsZVksXG4gICAgICAgICAgLy8gdGhlIHdpZHRoIGhlaWdodCBjYW5ub3QgZXhjZWVkIGVsZW1lbnQgd2lkdGgvaGVpZ2h0LCBzdGFydGluZyBmcm9tIHRoZSBjcm9wIG9mZnNldC5cbiAgICAgICAgICBzVyA9IG1pbih3ICogc2NhbGVYLCBlbFdpZHRoIC0gc1gpLFxuICAgICAgICAgIHNIID0gbWluKGggKiBzY2FsZVksIGVsSGVpZ2h0IC0gc1kpLFxuICAgICAgICAgIHggPSAtdyAvIDIsIHkgPSAtaCAvIDIsXG4gICAgICAgICAgbWF4RGVzdFcgPSBtaW4odywgZWxXaWR0aCAvIHNjYWxlWCAtIGNyb3BYKSxcbiAgICAgICAgICBtYXhEZXN0SCA9IG1pbihoLCBlbEhlaWdodCAvIHNjYWxlWSAtIGNyb3BZKTtcblxuICAgICAgZWxlbWVudFRvRHJhdyAmJiBjdHguZHJhd0ltYWdlKGVsZW1lbnRUb0RyYXcsIHNYLCBzWSwgc1csIHNILCB4LCB5LCBtYXhEZXN0VywgbWF4RGVzdEgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBuZWVkZWQgdG8gY2hlY2sgaWYgaW1hZ2UgbmVlZHMgcmVzaXplXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbmVlZHNSZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNjYWxlID0gdGhpcy5nZXRUb3RhbE9iamVjdFNjYWxpbmcoKTtcbiAgICAgIHJldHVybiAoc2NhbGUuc2NhbGVYICE9PSB0aGlzLl9sYXN0U2NhbGVYIHx8IHNjYWxlLnNjYWxlWSAhPT0gdGhpcy5fbGFzdFNjYWxlWSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc2V0V2lkdGhIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZXQodGhpcy5nZXRPcmlnaW5hbFNpemUoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBJbWFnZSBjbGFzcydzIGluaXRpYWxpemF0aW9uIG1ldGhvZC4gVGhpcyBtZXRob2QgaXMgYXV0b21hdGljYWxseVxuICAgICAqIGNhbGxlZCBieSB0aGUgY29uc3RydWN0b3IuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8U3RyaW5nfSBlbGVtZW50IFRoZSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgaW1hZ2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgX2luaXRFbGVtZW50OiBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICB0aGlzLnNldEVsZW1lbnQoZmFicmljLnV0aWwuZ2V0QnlJZChlbGVtZW50KSwgb3B0aW9ucyk7XG4gICAgICBmYWJyaWMudXRpbC5hZGRDbGFzcyh0aGlzLmdldEVsZW1lbnQoKSwgZmFicmljLkltYWdlLkNTU19DQU5WQVMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBfaW5pdENvbmZpZzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB0aGlzLl9zZXRXaWR0aEhlaWdodChvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXJzIHRvIGJlIGluaXRpYWxpemVkXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gYWxsIGZhYnJpYy5JbWFnZS5maWx0ZXJzIGluc3RhbmNlcyBhcmUgY3JlYXRlZFxuICAgICAqL1xuICAgIF9pbml0RmlsdGVyczogZnVuY3Rpb24oZmlsdGVycywgY2FsbGJhY2spIHtcbiAgICAgIGlmIChmaWx0ZXJzICYmIGZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RzKGZpbHRlcnMsIGZ1bmN0aW9uKGVubGl2ZW5lZE9iamVjdHMpIHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbmxpdmVuZWRPYmplY3RzKTtcbiAgICAgICAgfSwgJ2ZhYnJpYy5JbWFnZS5maWx0ZXJzJyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBTZXQgdGhlIHdpZHRoIGFuZCB0aGUgaGVpZ2h0IG9mIHRoZSBpbWFnZSBvYmplY3QsIHVzaW5nIHRoZSBlbGVtZW50IG9yIHRoZVxuICAgICAqIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPYmplY3Qgd2l0aCB3aWR0aC9oZWlnaHQgcHJvcGVydGllc1xuICAgICAqL1xuICAgIF9zZXRXaWR0aEhlaWdodDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHsgfSk7XG4gICAgICB2YXIgZWwgPSB0aGlzLmdldEVsZW1lbnQoKTtcbiAgICAgIHRoaXMud2lkdGggPSBvcHRpb25zLndpZHRoIHx8IGVsLm5hdHVyYWxXaWR0aCB8fCBlbC53aWR0aCB8fCAwO1xuICAgICAgdGhpcy5oZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCBlbC5uYXR1cmFsSGVpZ2h0IHx8IGVsLmhlaWdodCB8fCAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgb2Zmc2V0IGZvciBjZW50ZXIgYW5kIHNjYWxlIGZhY3RvciBmb3IgdGhlIGltYWdlIGluIG9yZGVyIHRvIHJlc3BlY3RcbiAgICAgKiB0aGUgcHJlc2VydmVBc3BlY3RSYXRpbyBhdHRyaWJ1dGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICBwYXJzZVByZXNlcnZlQXNwZWN0UmF0aW9BdHRyaWJ1dGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBBUiA9IGZhYnJpYy51dGlsLnBhcnNlUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZSh0aGlzLnByZXNlcnZlQXNwZWN0UmF0aW8gfHwgJycpLFxuICAgICAgICAgIHJXaWR0aCA9IHRoaXMuX2VsZW1lbnQud2lkdGgsIHJIZWlnaHQgPSB0aGlzLl9lbGVtZW50LmhlaWdodCxcbiAgICAgICAgICBzY2FsZVggPSAxLCBzY2FsZVkgPSAxLCBvZmZzZXRMZWZ0ID0gMCwgb2Zmc2V0VG9wID0gMCwgY3JvcFggPSAwLCBjcm9wWSA9IDAsXG4gICAgICAgICAgb2Zmc2V0LCBwV2lkdGggPSB0aGlzLndpZHRoLCBwSGVpZ2h0ID0gdGhpcy5oZWlnaHQsIHBhcnNlZEF0dHJpYnV0ZXMgPSB7IHdpZHRoOiBwV2lkdGgsIGhlaWdodDogcEhlaWdodCB9O1xuICAgICAgaWYgKHBBUiAmJiAocEFSLmFsaWduWCAhPT0gJ25vbmUnIHx8IHBBUi5hbGlnblkgIT09ICdub25lJykpIHtcbiAgICAgICAgaWYgKHBBUi5tZWV0T3JTbGljZSA9PT0gJ21lZXQnKSB7XG4gICAgICAgICAgc2NhbGVYID0gc2NhbGVZID0gZmFicmljLnV0aWwuZmluZFNjYWxlVG9GaXQodGhpcy5fZWxlbWVudCwgcGFyc2VkQXR0cmlidXRlcyk7XG4gICAgICAgICAgb2Zmc2V0ID0gKHBXaWR0aCAtIHJXaWR0aCAqIHNjYWxlWCkgLyAyO1xuICAgICAgICAgIGlmIChwQVIuYWxpZ25YID09PSAnTWluJykge1xuICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IC1vZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwQVIuYWxpZ25YID09PSAnTWF4Jykge1xuICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IG9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2Zmc2V0ID0gKHBIZWlnaHQgLSBySGVpZ2h0ICogc2NhbGVZKSAvIDI7XG4gICAgICAgICAgaWYgKHBBUi5hbGlnblkgPT09ICdNaW4nKSB7XG4gICAgICAgICAgICBvZmZzZXRUb3AgPSAtb2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocEFSLmFsaWduWSA9PT0gJ01heCcpIHtcbiAgICAgICAgICAgIG9mZnNldFRvcCA9IG9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBBUi5tZWV0T3JTbGljZSA9PT0gJ3NsaWNlJykge1xuICAgICAgICAgIHNjYWxlWCA9IHNjYWxlWSA9IGZhYnJpYy51dGlsLmZpbmRTY2FsZVRvQ292ZXIodGhpcy5fZWxlbWVudCwgcGFyc2VkQXR0cmlidXRlcyk7XG4gICAgICAgICAgb2Zmc2V0ID0gcldpZHRoIC0gcFdpZHRoIC8gc2NhbGVYO1xuICAgICAgICAgIGlmIChwQVIuYWxpZ25YID09PSAnTWlkJykge1xuICAgICAgICAgICAgY3JvcFggPSBvZmZzZXQgLyAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocEFSLmFsaWduWCA9PT0gJ01heCcpIHtcbiAgICAgICAgICAgIGNyb3BYID0gb2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBvZmZzZXQgPSBySGVpZ2h0IC0gcEhlaWdodCAvIHNjYWxlWTtcbiAgICAgICAgICBpZiAocEFSLmFsaWduWSA9PT0gJ01pZCcpIHtcbiAgICAgICAgICAgIGNyb3BZID0gb2Zmc2V0IC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBBUi5hbGlnblkgPT09ICdNYXgnKSB7XG4gICAgICAgICAgICBjcm9wWSA9IG9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcldpZHRoID0gcFdpZHRoIC8gc2NhbGVYO1xuICAgICAgICAgIHJIZWlnaHQgPSBwSGVpZ2h0IC8gc2NhbGVZO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2NhbGVYID0gcFdpZHRoIC8gcldpZHRoO1xuICAgICAgICBzY2FsZVkgPSBwSGVpZ2h0IC8gckhlaWdodDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiByV2lkdGgsXG4gICAgICAgIGhlaWdodDogckhlaWdodCxcbiAgICAgICAgc2NhbGVYOiBzY2FsZVgsXG4gICAgICAgIHNjYWxlWTogc2NhbGVZLFxuICAgICAgICBvZmZzZXRMZWZ0OiBvZmZzZXRMZWZ0LFxuICAgICAgICBvZmZzZXRUb3A6IG9mZnNldFRvcCxcbiAgICAgICAgY3JvcFg6IGNyb3BYLFxuICAgICAgICBjcm9wWTogY3JvcFlcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogRGVmYXVsdCBDU1MgY2xhc3MgbmFtZSBmb3IgY2FudmFzXG4gICAqIEBzdGF0aWNcbiAgICogQHR5cGUgU3RyaW5nXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuQ1NTX0NBTlZBUyA9ICdjYW52YXMtaW1nJztcblxuICAvKipcbiAgICogQWxpYXMgZm9yIGdldFNyY1xuICAgKiBAc3RhdGljXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UucHJvdG90eXBlLmdldFN2Z1NyYyA9IGZhYnJpYy5JbWFnZS5wcm90b3R5cGUuZ2V0U3JjO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZSBmcm9tIGl0cyBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBhbiBpbWFnZSBpbnN0YW5jZSBpcyBjcmVhdGVkXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKF9vYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9iamVjdCA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShfb2JqZWN0KTtcbiAgICBmYWJyaWMudXRpbC5sb2FkSW1hZ2Uob2JqZWN0LnNyYywgZnVuY3Rpb24oaW1nLCBpc0Vycm9yKSB7XG4gICAgICBpZiAoaXNFcnJvcikge1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhudWxsLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZmFicmljLkltYWdlLnByb3RvdHlwZS5faW5pdEZpbHRlcnMuY2FsbChvYmplY3QsIG9iamVjdC5maWx0ZXJzLCBmdW5jdGlvbihmaWx0ZXJzKSB7XG4gICAgICAgIG9iamVjdC5maWx0ZXJzID0gZmlsdGVycyB8fCBbXTtcbiAgICAgICAgZmFicmljLkltYWdlLnByb3RvdHlwZS5faW5pdEZpbHRlcnMuY2FsbChvYmplY3QsIFtvYmplY3QucmVzaXplRmlsdGVyXSwgZnVuY3Rpb24ocmVzaXplRmlsdGVycykge1xuICAgICAgICAgIG9iamVjdC5yZXNpemVGaWx0ZXIgPSByZXNpemVGaWx0ZXJzWzBdO1xuICAgICAgICAgIGZhYnJpYy51dGlsLmVubGl2ZW5PYmplY3RFbmxpdmFibGVzKG9iamVjdCwgb2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW1hZ2UgPSBuZXcgZmFicmljLkltYWdlKGltZywgb2JqZWN0KTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGltYWdlLCBmYWxzZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSwgbnVsbCwgb2JqZWN0LmNyb3NzT3JpZ2luKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UgZnJvbSBhbiBVUkwgc3RyaW5nXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBVUkwgdG8gY3JlYXRlIGFuIGltYWdlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsYmFjayB0byBpbnZva2Ugd2hlbiBpbWFnZSBpcyBjcmVhdGVkIChuZXdseSBjcmVhdGVkIGltYWdlIGlzIHBhc3NlZCBhcyBhIGZpcnN0IGFyZ3VtZW50KS4gU2Vjb25kIGFyZ3VtZW50IGlzIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGFuIGVycm9yIG9jY3VycmVkIG9yIG5vdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtpbWdPcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgZmFicmljLkltYWdlLmZyb21VUkwgPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrLCBpbWdPcHRpb25zKSB7XG4gICAgZmFicmljLnV0aWwubG9hZEltYWdlKHVybCwgZnVuY3Rpb24oaW1nLCBpc0Vycm9yKSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhuZXcgZmFicmljLkltYWdlKGltZywgaW1nT3B0aW9ucyksIGlzRXJyb3IpO1xuICAgIH0sIG51bGwsIGltZ09wdGlvbnMgJiYgaW1nT3B0aW9ucy5jcm9zc09yaWdpbik7XG4gIH07XG5cbiAgLyogX0ZST01fU1ZHX1NUQVJUXyAqL1xuICAvKipcbiAgICogTGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdG8gYWNjb3VudCBmb3Igd2hlbiBwYXJzaW5nIFNWRyBlbGVtZW50ICh1c2VkIGJ5IHtAbGluayBmYWJyaWMuSW1hZ2UuZnJvbUVsZW1lbnR9KVxuICAgKiBAc3RhdGljXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zdHJ1Y3QuaHRtbCNJbWFnZUVsZW1lbnR9XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuQVRUUklCVVRFX05BTUVTID1cbiAgICBmYWJyaWMuU0hBUkVEX0FUVFJJQlVURVMuY29uY2F0KFxuICAgICAgJ3ggeSB3aWR0aCBoZWlnaHQgcHJlc2VydmVBc3BlY3RSYXRpbyB4bGluazpocmVmIGNyb3NzT3JpZ2luIGltYWdlLXJlbmRlcmluZycuc3BsaXQoJyAnKVxuICAgICk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMge0BsaW5rIGZhYnJpYy5JbWFnZX0gaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIGZhYnJpYy5JbWFnZSBvYmplY3QgaXMgY3JlYXRlZFxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2V9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZyb21FbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICB2YXIgcGFyc2VkQXR0cmlidXRlcyA9IGZhYnJpYy5wYXJzZUF0dHJpYnV0ZXMoZWxlbWVudCwgZmFicmljLkltYWdlLkFUVFJJQlVURV9OQU1FUyk7XG4gICAgZmFicmljLkltYWdlLmZyb21VUkwocGFyc2VkQXR0cmlidXRlc1sneGxpbms6aHJlZiddLCBjYWxsYmFjayxcbiAgICAgIGV4dGVuZCgob3B0aW9ucyA/IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShvcHRpb25zKSA6IHsgfSksIHBhcnNlZEF0dHJpYnV0ZXMpKTtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLk9iamVjdC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLk9iamVjdC5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGFuZ2xlIHZhbHVlXG4gICAqL1xuICBfZ2V0QW5nbGVWYWx1ZUZvclN0cmFpZ2h0ZW46IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhbmdsZSA9IHRoaXMuYW5nbGUgJSAzNjA7XG4gICAgaWYgKGFuZ2xlID4gMCkge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQoKGFuZ2xlIC0gMSkgLyA5MCkgKiA5MDtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgucm91bmQoYW5nbGUgLyA5MCkgKiA5MDtcbiAgfSxcblxuICAvKipcbiAgICogU3RyYWlnaHRlbnMgYW4gb2JqZWN0IChyb3RhdGluZyBpdCBmcm9tIGN1cnJlbnQgYW5nbGUgdG8gb25lIG9mIDAsIDkwLCAxODAsIDI3MCwgZXRjLiBkZXBlbmRpbmcgb24gd2hpY2ggaXMgY2xvc2VyKVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuT2JqZWN0fSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHN0cmFpZ2h0ZW46IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJvdGF0ZSh0aGlzLl9nZXRBbmdsZVZhbHVlRm9yU3RyYWlnaHRlbigpKTtcbiAgfSxcblxuICAvKipcbiAgICogU2FtZSBhcyB7QGxpbmsgZmFicmljLk9iamVjdC5wcm90b3R5cGUuc3RyYWlnaHRlbn0gYnV0IHdpdGggYW5pbWF0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFja3MgT2JqZWN0IHdpdGggY2FsbGJhY2sgZnVuY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25Db21wbGV0ZV0gSW52b2tlZCBvbiBjb21wbGV0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja3Mub25DaGFuZ2VdIEludm9rZWQgb24gZXZlcnkgc3RlcCBvZiBhbmltYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLk9iamVjdH0gdGhpc0FyZ1xuICAgKi9cbiAgZnhTdHJhaWdodGVuOiBmdW5jdGlvbihjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3MgfHwgeyB9O1xuXG4gICAgdmFyIGVtcHR5ID0gZnVuY3Rpb24oKSB7IH0sXG4gICAgICAgIG9uQ29tcGxldGUgPSBjYWxsYmFja3Mub25Db21wbGV0ZSB8fCBlbXB0eSxcbiAgICAgICAgb25DaGFuZ2UgPSBjYWxsYmFja3Mub25DaGFuZ2UgfHwgZW1wdHksXG4gICAgICAgIF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBmYWJyaWMudXRpbC5hbmltYXRlKHtcbiAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgIHN0YXJ0VmFsdWU6IHRoaXMuZ2V0KCdhbmdsZScpLFxuICAgICAgZW5kVmFsdWU6IHRoaXMuX2dldEFuZ2xlVmFsdWVGb3JTdHJhaWdodGVuKCksXG4gICAgICBkdXJhdGlvbjogdGhpcy5GWF9EVVJBVElPTixcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBfdGhpcy5yb3RhdGUodmFsdWUpO1xuICAgICAgICBvbkNoYW5nZSgpO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBfdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxufSk7XG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLlN0YXRpY0NhbnZhcy5wcm90b3R5cGUgKi8ge1xuXG4gIC8qKlxuICAgKiBTdHJhaWdodGVucyBvYmplY3QsIHRoZW4gcmVyZW5kZXJzIGNhbnZhc1xuICAgKiBAcGFyYW0ge2ZhYnJpYy5PYmplY3R9IG9iamVjdCBPYmplY3QgdG8gc3RyYWlnaHRlblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuQ2FudmFzfSB0aGlzQXJnXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG4gIHN0cmFpZ2h0ZW5PYmplY3Q6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICBvYmplY3Quc3RyYWlnaHRlbigpO1xuICAgIHRoaXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIHtAbGluayBmYWJyaWMuQ2FudmFzLnByb3RvdHlwZS5zdHJhaWdodGVuT2JqZWN0fSwgYnV0IGFuaW1hdGVkXG4gICAqIEBwYXJhbSB7ZmFicmljLk9iamVjdH0gb2JqZWN0IE9iamVjdCB0byBzdHJhaWdodGVuXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5DYW52YXN9IHRoaXNBcmdcbiAgICovXG4gIGZ4U3RyYWlnaHRlbk9iamVjdDogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QuZnhTdHJhaWdodGVuKHtcbiAgICAgIG9uQ2hhbmdlOiB0aGlzLnJlcXVlc3RSZW5kZXJBbGxCb3VuZFxuICAgIH0pO1xuICB9XG59KTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBUZXN0cyBpZiB3ZWJnbCBzdXBwb3J0cyBjZXJ0YWluIHByZWNpc2lvblxuICAgKiBAcGFyYW0ge1dlYkdMfSBDYW52YXMgV2ViR0wgY29udGV4dCB0byB0ZXN0IG9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBQcmVjaXNpb24gdG8gdGVzdCBjYW4gYmUgYW55IG9mIGZvbGxvd2luZzogJ2xvd3AnLCAnbWVkaXVtcCcsICdoaWdocCdcbiAgICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHVzZXIncyBicm93c2VyIFdlYkdMIHN1cHBvcnRzIGdpdmVuIHByZWNpc2lvbi5cbiAgICovXG4gIGZ1bmN0aW9uIHRlc3RQcmVjaXNpb24oZ2wsIHByZWNpc2lvbil7XG4gICAgdmFyIGZyYWdtZW50U291cmNlID0gJ3ByZWNpc2lvbiAnICsgcHJlY2lzaW9uICsgJyBmbG9hdDtcXG52b2lkIG1haW4oKXt9JztcbiAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgICBnbC5zaGFkZXJTb3VyY2UoZnJhZ21lbnRTaGFkZXIsIGZyYWdtZW50U291cmNlKTtcbiAgICBnbC5jb21waWxlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcbiAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihmcmFnbWVudFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlIHdoZXRoZXIgdGhpcyBmaWx0ZXJpbmcgYmFja2VuZCBpcyBzdXBwb3J0ZWQgYnkgdGhlIHVzZXIncyBicm93c2VyLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGlsZVNpemUgY2hlY2sgaWYgdGhlIHRpbGVTaXplIGlzIHN1cHBvcnRlZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgdXNlcidzIGJyb3dzZXIgc3VwcG9ydHMgV2ViR0wuXG4gICAqL1xuICBmYWJyaWMuaXNXZWJnbFN1cHBvcnRlZCA9IGZ1bmN0aW9uKHRpbGVTaXplKSB7XG4gICAgaWYgKGZhYnJpYy5pc0xpa2VseU5vZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGlsZVNpemUgPSB0aWxlU2l6ZSB8fCBmYWJyaWMuV2ViZ2xGaWx0ZXJCYWNrZW5kLnByb3RvdHlwZS50aWxlU2l6ZTtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdmFyIGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJykgfHwgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcpO1xuICAgIHZhciBpc1N1cHBvcnRlZCA9IGZhbHNlO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGlmIChnbCkge1xuICAgICAgZmFicmljLm1heFRleHR1cmVTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX1NJWkUpO1xuICAgICAgaXNTdXBwb3J0ZWQgPSBmYWJyaWMubWF4VGV4dHVyZVNpemUgPj0gdGlsZVNpemU7XG4gICAgICB2YXIgcHJlY2lzaW9ucyA9IFsnaGlnaHAnLCAnbWVkaXVtcCcsICdsb3dwJ107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKyl7XG4gICAgICAgIGlmICh0ZXN0UHJlY2lzaW9uKGdsLCBwcmVjaXNpb25zW2ldKSl7XG4gICAgICAgICAgZmFicmljLndlYkdsUHJlY2lzaW9uID0gcHJlY2lzaW9uc1tpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5pc1N1cHBvcnRlZCA9IGlzU3VwcG9ydGVkO1xuICAgIHJldHVybiBpc1N1cHBvcnRlZDtcbiAgfTtcblxuICBmYWJyaWMuV2ViZ2xGaWx0ZXJCYWNrZW5kID0gV2ViZ2xGaWx0ZXJCYWNrZW5kO1xuXG4gIC8qKlxuICAgKiBXZWJHTCBmaWx0ZXIgYmFja2VuZC5cbiAgICovXG4gIGZ1bmN0aW9uIFdlYmdsRmlsdGVyQmFja2VuZChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50aWxlU2l6ZSkge1xuICAgICAgdGhpcy50aWxlU2l6ZSA9IG9wdGlvbnMudGlsZVNpemU7XG4gICAgfVxuICAgIHRoaXMuc2V0dXBHTENvbnRleHQodGhpcy50aWxlU2l6ZSwgdGhpcy50aWxlU2l6ZSk7XG4gICAgdGhpcy5jYXB0dXJlR1BVSW5mbygpO1xuICB9O1xuXG4gIFdlYmdsRmlsdGVyQmFja2VuZC5wcm90b3R5cGUgPSAvKiogQGxlbmRzIGZhYnJpYy5XZWJnbEZpbHRlckJhY2tlbmQucHJvdG90eXBlICovIHtcblxuICAgIHRpbGVTaXplOiAyMDQ4LFxuXG4gICAgLyoqXG4gICAgICogRXhwZXJpbWVudGFsLiBUaGlzIG9iamVjdCBpcyBhIHNvcnQgb2YgcmVwb3NpdG9yeSBvZiBoZWxwIGxheWVycyB1c2VkIHRvIGF2b2lkXG4gICAgICogb2YgcmVjcmVhdGluZyB0aGVtIGR1cmluZyBmcmVxdWVudCBmaWx0ZXJpbmcuIElmIHlvdSBhcmUgcHJldmlld2luZyBhIGZpbHRlciB3aXRoXG4gICAgICogYSBzbGlkZXIgeW91IHByb2JhYmx5IGRvIG5vdCB3YW50IHRvIGNyZWF0ZSBoZWxwIGxheWVycyBldmVyeSBmaWx0ZXIgc3RlcC5cbiAgICAgKiBpbiB0aGlzIG9iamVjdCB0aGVyZSB3aWxsIGJlIGFwcGVuZGVkIHNvbWUgY2FudmFzZXMsIGNyZWF0ZWQgb25jZSwgcmVzaXplZCBzb21ldGltZXNcbiAgICAgKiBjbGVhcmVkIG5ldmVyLiBDbGVhcmluZyBpcyBsZWZ0IHRvIHRoZSBkZXZlbG9wZXIuXG4gICAgICoqL1xuICAgIHJlc291cmNlczoge1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHVwIGEgV2ViR0wgY29udGV4dCBzdWl0YWJsZSBmb3IgZmlsdGVyaW5nLCBhbmQgYmluZCBhbnkgbmVlZGVkIGV2ZW50IGhhbmRsZXJzLlxuICAgICAqL1xuICAgIHNldHVwR0xDb250ZXh0OiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuY3JlYXRlV2ViR0xDYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIHRoaXMuYVBvc2l0aW9uID0gbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMCwgMSwgMSwgMCwgMSwgMV0pO1xuICAgICAgdGhpcy5jaG9vc2VGYXN0ZXN0Q29weUdMVG8yRE1ldGhvZCh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGljayBhIG1ldGhvZCB0byBjb3B5IGRhdGEgZnJvbSBHTCBjb250ZXh0IHRvIDJkIGNhbnZhcy4gIEluIHNvbWUgYnJvd3NlcnMgdXNpbmdcbiAgICAgKiBwdXRJbWFnZURhdGEgaXMgZmFzdGVyIHRoYW4gZHJhd0ltYWdlIGZvciB0aGF0IHNwZWNpZmljIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBjaG9vc2VGYXN0ZXN0Q29weUdMVG8yRE1ldGhvZDogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgdmFyIGNhbk1lYXN1cmVQZXJmID0gdHlwZW9mIHdpbmRvdy5wZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcsIGNhblVzZUltYWdlRGF0YTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBJbWFnZURhdGEoMSwgMSk7XG4gICAgICAgIGNhblVzZUltYWdlRGF0YSA9IHRydWU7XG4gICAgICB9XG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICBjYW5Vc2VJbWFnZURhdGEgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgdmFyIGNhblVzZUFycmF5QnVmZmVyID0gdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJztcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgdmFyIGNhblVzZVVpbnQ4Q2xhbXBlZCA9IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgICAgIGlmICghKGNhbk1lYXN1cmVQZXJmICYmIGNhblVzZUltYWdlRGF0YSAmJiBjYW5Vc2VBcnJheUJ1ZmZlciAmJiBjYW5Vc2VVaW50OENsYW1wZWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHRhcmdldENhbnZhcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgdmFyIGltYWdlQnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICBpZiAoZmFicmljLmZvcmNlR0xQdXRJbWFnZURhdGEpIHtcbiAgICAgICAgdGhpcy5pbWFnZUJ1ZmZlciA9IGltYWdlQnVmZmVyO1xuICAgICAgICB0aGlzLmNvcHlHTFRvMkQgPSBjb3B5R0xUbzJEUHV0SW1hZ2VEYXRhO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdGVzdENvbnRleHQgPSB7XG4gICAgICAgIGltYWdlQnVmZmVyOiBpbWFnZUJ1ZmZlcixcbiAgICAgICAgZGVzdGluYXRpb25XaWR0aDogd2lkdGgsXG4gICAgICAgIGRlc3RpbmF0aW9uSGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIHRhcmdldENhbnZhczogdGFyZ2V0Q2FudmFzXG4gICAgICB9O1xuICAgICAgdmFyIHN0YXJ0VGltZSwgZHJhd0ltYWdlVGltZSwgcHV0SW1hZ2VEYXRhVGltZTtcbiAgICAgIHRhcmdldENhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgdGFyZ2V0Q2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgc3RhcnRUaW1lID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29weUdMVG8yRERyYXdJbWFnZS5jYWxsKHRlc3RDb250ZXh0LCB0aGlzLmdsLCB0ZXN0Q29udGV4dCk7XG4gICAgICBkcmF3SW1hZ2VUaW1lID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuXG4gICAgICBzdGFydFRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb3B5R0xUbzJEUHV0SW1hZ2VEYXRhLmNhbGwodGVzdENvbnRleHQsIHRoaXMuZ2wsIHRlc3RDb250ZXh0KTtcbiAgICAgIHB1dEltYWdlRGF0YVRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWU7XG5cbiAgICAgIGlmIChkcmF3SW1hZ2VUaW1lID4gcHV0SW1hZ2VEYXRhVGltZSkge1xuICAgICAgICB0aGlzLmltYWdlQnVmZmVyID0gaW1hZ2VCdWZmZXI7XG4gICAgICAgIHRoaXMuY29weUdMVG8yRCA9IGNvcHlHTFRvMkRQdXRJbWFnZURhdGE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5jb3B5R0xUbzJEID0gY29weUdMVG8yRERyYXdJbWFnZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY2FudmFzIGVsZW1lbnQgYW5kIGFzc29jaWF0ZWQgV2ViR0wgY29udGV4dCBhbmQgYXR0YWNoZXMgdGhlbSBhc1xuICAgICAqIGNsYXNzIHByb3BlcnRpZXMgdG8gdGhlIEdMRmlsdGVyQmFja2VuZCBjbGFzcy5cbiAgICAgKi9cbiAgICBjcmVhdGVXZWJHTENhbnZhczogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgdmFyIGNhbnZhcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIHZhciBnbE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhbHBoYTogdHJ1ZSxcbiAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogZmFsc2UsXG4gICAgICAgICAgICBkZXB0aDogZmFsc2UsXG4gICAgICAgICAgICBzdGVuY2lsOiBmYWxzZSxcbiAgICAgICAgICAgIGFudGlhbGlhczogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgZ2xPcHRpb25zKTtcbiAgICAgIGlmICghZ2wpIHtcbiAgICAgICAgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgZ2xPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICghZ2wpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcbiAgICAgIC8vIHRoaXMgY2FudmFzIGNhbiBmaXJlIHdlYmdsY29udGV4dGxvc3QgYW5kIHdlYmdsY29udGV4dHJlc3RvcmVkXG4gICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gYXBwbHkgdGhlIHJlcXVlc3RlZCBmaWx0ZXJzIHRvIHRoZSBzb3VyY2UgcHJvdmlkZWQsIGRyYXdpbmcgdGhlIGZpbHRlcmVkIG91dHB1dFxuICAgICAqIHRvIHRoZSBwcm92aWRlZCB0YXJnZXQgY2FudmFzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gZmlsdGVycyBUaGUgZmlsdGVycyB0byBhcHBseS5cbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IHNvdXJjZSBUaGUgc291cmNlIHRvIGJlIGZpbHRlcmVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIHNvdXJjZSBpbnB1dC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIHNvdXJjZSBpbnB1dC5cbiAgICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSB0YXJnZXRDYW52YXMgVGhlIGRlc3RpbmF0aW9uIGZvciBmaWx0ZXJlZCBvdXRwdXQgdG8gYmUgZHJhd24uXG4gICAgICogQHBhcmFtIHtTdHJpbmd8dW5kZWZpbmVkfSBjYWNoZUtleSBBIGtleSB1c2VkIHRvIGNhY2hlIHJlc291cmNlcyByZWxhdGVkIHRvIHRoZSBzb3VyY2UuIElmXG4gICAgICogb21pdHRlZCwgY2FjaGluZyB3aWxsIGJlIHNraXBwZWQuXG4gICAgICovXG4gICAgYXBwbHlGaWx0ZXJzOiBmdW5jdGlvbihmaWx0ZXJzLCBzb3VyY2UsIHdpZHRoLCBoZWlnaHQsIHRhcmdldENhbnZhcywgY2FjaGVLZXkpIHtcbiAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICB2YXIgY2FjaGVkVGV4dHVyZTtcbiAgICAgIGlmIChjYWNoZUtleSkge1xuICAgICAgICBjYWNoZWRUZXh0dXJlID0gdGhpcy5nZXRDYWNoZWRUZXh0dXJlKGNhY2hlS2V5LCBzb3VyY2UpO1xuICAgICAgfVxuICAgICAgdmFyIHBpcGVsaW5lU3RhdGUgPSB7XG4gICAgICAgIG9yaWdpbmFsV2lkdGg6IHNvdXJjZS53aWR0aCB8fCBzb3VyY2Uub3JpZ2luYWxXaWR0aCxcbiAgICAgICAgb3JpZ2luYWxIZWlnaHQ6IHNvdXJjZS5oZWlnaHQgfHwgc291cmNlLm9yaWdpbmFsSGVpZ2h0LFxuICAgICAgICBzb3VyY2VXaWR0aDogd2lkdGgsXG4gICAgICAgIHNvdXJjZUhlaWdodDogaGVpZ2h0LFxuICAgICAgICBkZXN0aW5hdGlvbldpZHRoOiB3aWR0aCxcbiAgICAgICAgZGVzdGluYXRpb25IZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgY29udGV4dDogZ2wsXG4gICAgICAgIHNvdXJjZVRleHR1cmU6IHRoaXMuY3JlYXRlVGV4dHVyZShnbCwgd2lkdGgsIGhlaWdodCwgIWNhY2hlZFRleHR1cmUgJiYgc291cmNlKSxcbiAgICAgICAgdGFyZ2V0VGV4dHVyZTogdGhpcy5jcmVhdGVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0KSxcbiAgICAgICAgb3JpZ2luYWxUZXh0dXJlOiBjYWNoZWRUZXh0dXJlIHx8XG4gICAgICAgICAgdGhpcy5jcmVhdGVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0LCAhY2FjaGVkVGV4dHVyZSAmJiBzb3VyY2UpLFxuICAgICAgICBwYXNzZXM6IGZpbHRlcnMubGVuZ3RoLFxuICAgICAgICB3ZWJnbDogdHJ1ZSxcbiAgICAgICAgYVBvc2l0aW9uOiB0aGlzLmFQb3NpdGlvbixcbiAgICAgICAgcHJvZ3JhbUNhY2hlOiB0aGlzLnByb2dyYW1DYWNoZSxcbiAgICAgICAgcGFzczogMCxcbiAgICAgICAgZmlsdGVyQmFja2VuZDogdGhpcyxcbiAgICAgICAgdGFyZ2V0Q2FudmFzOiB0YXJnZXRDYW52YXNcbiAgICAgIH07XG4gICAgICB2YXIgdGVtcEZibyA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRlbXBGYm8pO1xuICAgICAgZmlsdGVycy5mb3JFYWNoKGZ1bmN0aW9uKGZpbHRlcikgeyBmaWx0ZXIgJiYgZmlsdGVyLmFwcGx5VG8ocGlwZWxpbmVTdGF0ZSk7IH0pO1xuICAgICAgcmVzaXplQ2FudmFzSWZOZWVkZWQocGlwZWxpbmVTdGF0ZSk7XG4gICAgICB0aGlzLmNvcHlHTFRvMkQoZ2wsIHBpcGVsaW5lU3RhdGUpO1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgICBnbC5kZWxldGVUZXh0dXJlKHBpcGVsaW5lU3RhdGUuc291cmNlVGV4dHVyZSk7XG4gICAgICBnbC5kZWxldGVUZXh0dXJlKHBpcGVsaW5lU3RhdGUudGFyZ2V0VGV4dHVyZSk7XG4gICAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcih0ZW1wRmJvKTtcbiAgICAgIHRhcmdldENhbnZhcy5nZXRDb250ZXh0KCcyZCcpLnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIHJldHVybiBwaXBlbGluZVN0YXRlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRhY2ggZXZlbnQgbGlzdGVuZXJzLCByZW1vdmUgcmVmZXJlbmNlcywgYW5kIGNsZWFuIHVwIGNhY2hlcy5cbiAgICAgKi9cbiAgICBkaXNwb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgICAgIHRoaXMuZ2wgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5jbGVhcldlYkdMQ2FjaGVzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdpcGUgb3V0IFdlYkdMLXJlbGF0ZWQgY2FjaGVzLlxuICAgICAqL1xuICAgIGNsZWFyV2ViR0xDYWNoZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5wcm9ncmFtQ2FjaGUgPSB7fTtcbiAgICAgIHRoaXMudGV4dHVyZUNhY2hlID0ge307XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIFdlYkdMIHRleHR1cmUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQWNjZXB0cyBzcGVjaWZpYyBkaW1lbnNpb25zIHRvIGluaXRpYWxpemUgdGhlIHRleHR1cmUgdG8gb3IgYSBzb3VyY2UgaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNvbnRleHQgdG8gdXNlIGZvciBjcmVhdGluZyB0aGUgdGV4dHVyZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggVGhlIHdpZHRoIHRvIGluaXRpYWxpemUgdGhlIHRleHR1cmUgYXQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IHRvIGluaXRpYWxpemUgdGhlIHRleHR1cmUuXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSB0ZXh0dXJlSW1hZ2VTb3VyY2UgQSBzb3VyY2UgZm9yIHRoZSB0ZXh0dXJlIGRhdGEuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZpbHRlclR5cGUgZ2wuTkVBUkVTVCBvciBnbC5MSU5FQVIgdXN1YWxseSwgd2ViZ2wgbnVtZXJpIGNvbnN0YW50c1xuICAgICAqIEByZXR1cm5zIHtXZWJHTFRleHR1cmV9XG4gICAgICovXG4gICAgY3JlYXRlVGV4dHVyZTogZnVuY3Rpb24oZ2wsIHdpZHRoLCBoZWlnaHQsIHRleHR1cmVJbWFnZVNvdXJjZSwgZmlsdGVyVHlwZSkge1xuICAgICAgdmFyIHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBmaWx0ZXJUeXBlIHx8IGdsLk5FQVJFU1QpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGZpbHRlclR5cGUgfHwgZ2wuTkVBUkVTVCk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgaWYgKHRleHR1cmVJbWFnZVNvdXJjZSkge1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRleHR1cmVJbWFnZVNvdXJjZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB3aWR0aCwgaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYW4gYmUgb3B0aW9uYWxseSB1c2VkIHRvIGdldCBhIHRleHR1cmUgZnJvbSB0aGUgY2FjaGUgYXJyYXlcbiAgICAgKlxuICAgICAqIElmIGFuIGV4aXN0aW5nIHRleHR1cmUgaXMgbm90IGZvdW5kLCBhIG5ldyB0ZXh0dXJlIGlzIGNyZWF0ZWQgYW5kIGNhY2hlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1bmlxdWVJZCBBIGNhY2hlIGtleSB0byB1c2UgdG8gZmluZCBhbiBleGlzdGluZyB0ZXh0dXJlLlxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH0gdGV4dHVyZUltYWdlU291cmNlIEEgc291cmNlIHRvIHVzZSB0byBjcmVhdGUgdGhlXG4gICAgICogdGV4dHVyZSBjYWNoZSBlbnRyeSBpZiBvbmUgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cbiAgICAgKi9cbiAgICBnZXRDYWNoZWRUZXh0dXJlOiBmdW5jdGlvbih1bmlxdWVJZCwgdGV4dHVyZUltYWdlU291cmNlKSB7XG4gICAgICBpZiAodGhpcy50ZXh0dXJlQ2FjaGVbdW5pcXVlSWRdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHR1cmVDYWNoZVt1bmlxdWVJZF07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLmNyZWF0ZVRleHR1cmUoXG4gICAgICAgICAgdGhpcy5nbCwgdGV4dHVyZUltYWdlU291cmNlLndpZHRoLCB0ZXh0dXJlSW1hZ2VTb3VyY2UuaGVpZ2h0LCB0ZXh0dXJlSW1hZ2VTb3VyY2UpO1xuICAgICAgICB0aGlzLnRleHR1cmVDYWNoZVt1bmlxdWVJZF0gPSB0ZXh0dXJlO1xuICAgICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgb3V0IGNhY2hlZCByZXNvdXJjZXMgcmVsYXRlZCB0byBhIHNvdXJjZSBpbWFnZSB0aGF0IGhhcyBiZWVuXG4gICAgICogZmlsdGVyZWQgcHJldmlvdXNseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjYWNoZUtleSBUaGUgY2FjaGUga2V5IHByb3ZpZGVkIHdoZW4gdGhlIHNvdXJjZSBpbWFnZSB3YXMgZmlsdGVyZWQuXG4gICAgICovXG4gICAgZXZpY3RDYWNoZXNGb3JLZXk6IGZ1bmN0aW9uKGNhY2hlS2V5KSB7XG4gICAgICBpZiAodGhpcy50ZXh0dXJlQ2FjaGVbY2FjaGVLZXldKSB7XG4gICAgICAgIHRoaXMuZ2wuZGVsZXRlVGV4dHVyZSh0aGlzLnRleHR1cmVDYWNoZVtjYWNoZUtleV0pO1xuICAgICAgICBkZWxldGUgdGhpcy50ZXh0dXJlQ2FjaGVbY2FjaGVLZXldO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb3B5R0xUbzJEOiBjb3B5R0xUbzJERHJhd0ltYWdlLFxuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCB0byBleHRyYWN0IEdQVSBpbmZvcm1hdGlvbiBzdHJpbmdzIGZyb20gYSBXZWJHTCBjb250ZXh0LlxuICAgICAqXG4gICAgICogVXNlZnVsIGluZm9ybWF0aW9uIHdoZW4gZGVidWdnaW5nIG9yIGJsYWNrbGlzdGluZyBzcGVjaWZpYyBHUFVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH0gQSBHUFUgaW5mbyBvYmplY3Qgd2l0aCByZW5kZXJlciBhbmQgdmVuZG9yIHN0cmluZ3MuXG4gICAgICovXG4gICAgY2FwdHVyZUdQVUluZm86IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZ3B1SW5mbykge1xuICAgICAgICByZXR1cm4gdGhpcy5ncHVJbmZvO1xuICAgICAgfVxuICAgICAgdmFyIGdsID0gdGhpcy5nbCwgZ3B1SW5mbyA9IHsgcmVuZGVyZXI6ICcnLCB2ZW5kb3I6ICcnIH07XG4gICAgICBpZiAoIWdsKSB7XG4gICAgICAgIHJldHVybiBncHVJbmZvO1xuICAgICAgfVxuICAgICAgdmFyIGV4dCA9IGdsLmdldEV4dGVuc2lvbignV0VCR0xfZGVidWdfcmVuZGVyZXJfaW5mbycpO1xuICAgICAgaWYgKGV4dCkge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSBnbC5nZXRQYXJhbWV0ZXIoZXh0LlVOTUFTS0VEX1JFTkRFUkVSX1dFQkdMKTtcbiAgICAgICAgdmFyIHZlbmRvciA9IGdsLmdldFBhcmFtZXRlcihleHQuVU5NQVNLRURfVkVORE9SX1dFQkdMKTtcbiAgICAgICAgaWYgKHJlbmRlcmVyKSB7XG4gICAgICAgICAgZ3B1SW5mby5yZW5kZXJlciA9IHJlbmRlcmVyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZlbmRvcikge1xuICAgICAgICAgIGdwdUluZm8udmVuZG9yID0gdmVuZG9yLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZ3B1SW5mbyA9IGdwdUluZm87XG4gICAgICByZXR1cm4gZ3B1SW5mbztcbiAgICB9LFxuICB9O1xufSkoKTtcblxuZnVuY3Rpb24gcmVzaXplQ2FudmFzSWZOZWVkZWQocGlwZWxpbmVTdGF0ZSkge1xuICB2YXIgdGFyZ2V0Q2FudmFzID0gcGlwZWxpbmVTdGF0ZS50YXJnZXRDYW52YXMsXG4gICAgICB3aWR0aCA9IHRhcmdldENhbnZhcy53aWR0aCwgaGVpZ2h0ID0gdGFyZ2V0Q2FudmFzLmhlaWdodCxcbiAgICAgIGRXaWR0aCA9IHBpcGVsaW5lU3RhdGUuZGVzdGluYXRpb25XaWR0aCxcbiAgICAgIGRIZWlnaHQgPSBwaXBlbGluZVN0YXRlLmRlc3RpbmF0aW9uSGVpZ2h0O1xuXG4gIGlmICh3aWR0aCAhPT0gZFdpZHRoIHx8IGhlaWdodCAhPT0gZEhlaWdodCkge1xuICAgIHRhcmdldENhbnZhcy53aWR0aCA9IGRXaWR0aDtcbiAgICB0YXJnZXRDYW52YXMuaGVpZ2h0ID0gZEhlaWdodDtcbiAgfVxufVxuXG4vKipcbiAqIENvcHkgYW4gaW5wdXQgV2ViR0wgY2FudmFzIG9uIHRvIGFuIG91dHB1dCAyRCBjYW52YXMuXG4gKlxuICogVGhlIFdlYkdMIGNhbnZhcyBpcyBhc3N1bWVkIHRvIGJlIHVwc2lkZSBkb3duLCB3aXRoIHRoZSB0b3AtbGVmdCBwaXhlbCBvZiB0aGVcbiAqIGRlc2lyZWQgb3V0cHV0IGltYWdlIGFwcGVhcmluZyBpbiB0aGUgYm90dG9tLWxlZnQgY29ybmVyIG9mIHRoZSBXZWJHTCBjYW52YXMuXG4gKlxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IHNvdXJjZUNvbnRleHQgVGhlIFdlYkdMIGNvbnRleHQgdG8gY29weSBmcm9tLlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gdGFyZ2V0Q2FudmFzIFRoZSAyRCB0YXJnZXQgY2FudmFzIHRvIGNvcHkgb24gdG8uXG4gKiBAcGFyYW0ge09iamVjdH0gcGlwZWxpbmVTdGF0ZSBUaGUgMkQgdGFyZ2V0IGNhbnZhcyB0byBjb3B5IG9uIHRvLlxuICovXG5mdW5jdGlvbiBjb3B5R0xUbzJERHJhd0ltYWdlKGdsLCBwaXBlbGluZVN0YXRlKSB7XG4gIHZhciBnbENhbnZhcyA9IGdsLmNhbnZhcywgdGFyZ2V0Q2FudmFzID0gcGlwZWxpbmVTdGF0ZS50YXJnZXRDYW52YXMsXG4gICAgICBjdHggPSB0YXJnZXRDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgY3R4LnRyYW5zbGF0ZSgwLCB0YXJnZXRDYW52YXMuaGVpZ2h0KTsgLy8gbW92ZSBpdCBkb3duIGFnYWluXG4gIGN0eC5zY2FsZSgxLCAtMSk7IC8vIHZlcnRpY2FsIGZsaXBcbiAgLy8gd2hlcmUgaXMgbXkgaW1hZ2Ugb24gdGhlIGJpZyBnbGNhbnZhcz9cbiAgdmFyIHNvdXJjZVkgPSBnbENhbnZhcy5oZWlnaHQgLSB0YXJnZXRDYW52YXMuaGVpZ2h0O1xuICBjdHguZHJhd0ltYWdlKGdsQ2FudmFzLCAwLCBzb3VyY2VZLCB0YXJnZXRDYW52YXMud2lkdGgsIHRhcmdldENhbnZhcy5oZWlnaHQsIDAsIDAsXG4gICAgdGFyZ2V0Q2FudmFzLndpZHRoLCB0YXJnZXRDYW52YXMuaGVpZ2h0KTtcbn1cblxuLyoqXG4gKiBDb3B5IGFuIGlucHV0IFdlYkdMIGNhbnZhcyBvbiB0byBhbiBvdXRwdXQgMkQgY2FudmFzIHVzaW5nIDJkIGNhbnZhcycgcHV0SW1hZ2VEYXRhXG4gKiBBUEkuIE1lYXN1cmFibHkgZmFzdGVyIHRoYW4gdXNpbmcgY3R4LmRyYXdJbWFnZSBpbiBGaXJlZm94ICh2ZXJzaW9uIDU0IG9uIE9TWCBTaWVycmEpLlxuICpcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBzb3VyY2VDb250ZXh0IFRoZSBXZWJHTCBjb250ZXh0IHRvIGNvcHkgZnJvbS5cbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IHRhcmdldENhbnZhcyBUaGUgMkQgdGFyZ2V0IGNhbnZhcyB0byBjb3B5IG9uIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IHBpcGVsaW5lU3RhdGUgVGhlIDJEIHRhcmdldCBjYW52YXMgdG8gY29weSBvbiB0by5cbiAqL1xuZnVuY3Rpb24gY29weUdMVG8yRFB1dEltYWdlRGF0YShnbCwgcGlwZWxpbmVTdGF0ZSkge1xuICB2YXIgdGFyZ2V0Q2FudmFzID0gcGlwZWxpbmVTdGF0ZS50YXJnZXRDYW52YXMsIGN0eCA9IHRhcmdldENhbnZhcy5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgZFdpZHRoID0gcGlwZWxpbmVTdGF0ZS5kZXN0aW5hdGlvbldpZHRoLFxuICAgICAgZEhlaWdodCA9IHBpcGVsaW5lU3RhdGUuZGVzdGluYXRpb25IZWlnaHQsXG4gICAgICBudW1CeXRlcyA9IGRXaWR0aCAqIGRIZWlnaHQgKiA0O1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgdTggPSBuZXcgVWludDhBcnJheSh0aGlzLmltYWdlQnVmZmVyLCAwLCBudW1CeXRlcyk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgdThDbGFtcGVkID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHRoaXMuaW1hZ2VCdWZmZXIsIDAsIG51bUJ5dGVzKTtcblxuICBnbC5yZWFkUGl4ZWxzKDAsIDAsIGRXaWR0aCwgZEhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdTgpO1xuICB2YXIgaW1nRGF0YSA9IG5ldyBJbWFnZURhdGEodThDbGFtcGVkLCBkV2lkdGgsIGRIZWlnaHQpO1xuICBjdHgucHV0SW1hZ2VEYXRhKGltZ0RhdGEsIDAsIDApO1xufVxuXG5cbihmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXG4gIGZhYnJpYy5DYW52YXMyZEZpbHRlckJhY2tlbmQgPSBDYW52YXMyZEZpbHRlckJhY2tlbmQ7XG5cbiAgLyoqXG4gICAqIENhbnZhcyAyRCBmaWx0ZXIgYmFja2VuZC5cbiAgICovXG4gIGZ1bmN0aW9uIENhbnZhczJkRmlsdGVyQmFja2VuZCgpIHt9O1xuXG4gIENhbnZhczJkRmlsdGVyQmFja2VuZC5wcm90b3R5cGUgPSAvKiogQGxlbmRzIGZhYnJpYy5DYW52YXMyZEZpbHRlckJhY2tlbmQucHJvdG90eXBlICovIHtcbiAgICBldmljdENhY2hlc0ZvcktleTogbm9vcCxcbiAgICBkaXNwb3NlOiBub29wLFxuICAgIGNsZWFyV2ViR0xDYWNoZXM6IG5vb3AsXG5cbiAgICAvKipcbiAgICAgKiBFeHBlcmltZW50YWwuIFRoaXMgb2JqZWN0IGlzIGEgc29ydCBvZiByZXBvc2l0b3J5IG9mIGhlbHAgbGF5ZXJzIHVzZWQgdG8gYXZvaWRcbiAgICAgKiBvZiByZWNyZWF0aW5nIHRoZW0gZHVyaW5nIGZyZXF1ZW50IGZpbHRlcmluZy4gSWYgeW91IGFyZSBwcmV2aWV3aW5nIGEgZmlsdGVyIHdpdGhcbiAgICAgKiBhIHNsaWRlciB5b3UgcHJvYmFibHkgZG8gbm90IHdhbnQgdG8gY3JlYXRlIGhlbHAgbGF5ZXJzIGV2ZXJ5IGZpbHRlciBzdGVwLlxuICAgICAqIGluIHRoaXMgb2JqZWN0IHRoZXJlIHdpbGwgYmUgYXBwZW5kZWQgc29tZSBjYW52YXNlcywgY3JlYXRlZCBvbmNlLCByZXNpemVkIHNvbWV0aW1lc1xuICAgICAqIGNsZWFyZWQgbmV2ZXIuIENsZWFyaW5nIGlzIGxlZnQgdG8gdGhlIGRldmVsb3Blci5cbiAgICAgKiovXG4gICAgcmVzb3VyY2VzOiB7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgYSBzZXQgb2YgZmlsdGVycyBhZ2FpbnN0IGEgc291cmNlIGltYWdlIGFuZCBkcmF3IHRoZSBmaWx0ZXJlZCBvdXRwdXRcbiAgICAgKiB0byB0aGUgcHJvdmlkZWQgZGVzdGluYXRpb24gY2FudmFzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbmhhbmNlZEZpbHRlcn0gZmlsdGVycyBUaGUgZmlsdGVyIHRvIGFwcGx5LlxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH0gc291cmNlRWxlbWVudCBUaGUgc291cmNlIHRvIGJlIGZpbHRlcmVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzb3VyY2VXaWR0aCBUaGUgd2lkdGggb2YgdGhlIHNvdXJjZSBpbnB1dC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc291cmNlSGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIHNvdXJjZSBpbnB1dC5cbiAgICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSB0YXJnZXRDYW52YXMgVGhlIGRlc3RpbmF0aW9uIGZvciBmaWx0ZXJlZCBvdXRwdXQgdG8gYmUgZHJhd24uXG4gICAgICovXG4gICAgYXBwbHlGaWx0ZXJzOiBmdW5jdGlvbihmaWx0ZXJzLCBzb3VyY2VFbGVtZW50LCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0LCB0YXJnZXRDYW52YXMpIHtcbiAgICAgIHZhciBjdHggPSB0YXJnZXRDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2Uoc291cmNlRWxlbWVudCwgMCwgMCwgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCk7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0KTtcbiAgICAgIHZhciBvcmlnaW5hbEltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCk7XG4gICAgICB2YXIgcGlwZWxpbmVTdGF0ZSA9IHtcbiAgICAgICAgc291cmNlV2lkdGg6IHNvdXJjZVdpZHRoLFxuICAgICAgICBzb3VyY2VIZWlnaHQ6IHNvdXJjZUhlaWdodCxcbiAgICAgICAgaW1hZ2VEYXRhOiBpbWFnZURhdGEsXG4gICAgICAgIG9yaWdpbmFsRWw6IHNvdXJjZUVsZW1lbnQsXG4gICAgICAgIG9yaWdpbmFsSW1hZ2VEYXRhOiBvcmlnaW5hbEltYWdlRGF0YSxcbiAgICAgICAgY2FudmFzRWw6IHRhcmdldENhbnZhcyxcbiAgICAgICAgY3R4OiBjdHgsXG4gICAgICAgIGZpbHRlckJhY2tlbmQ6IHRoaXMsXG4gICAgICB9O1xuICAgICAgZmlsdGVycy5mb3JFYWNoKGZ1bmN0aW9uKGZpbHRlcikgeyBmaWx0ZXIuYXBwbHlUbyhwaXBlbGluZVN0YXRlKTsgfSk7XG4gICAgICBpZiAocGlwZWxpbmVTdGF0ZS5pbWFnZURhdGEud2lkdGggIT09IHNvdXJjZVdpZHRoIHx8IHBpcGVsaW5lU3RhdGUuaW1hZ2VEYXRhLmhlaWdodCAhPT0gc291cmNlSGVpZ2h0KSB7XG4gICAgICAgIHRhcmdldENhbnZhcy53aWR0aCA9IHBpcGVsaW5lU3RhdGUuaW1hZ2VEYXRhLndpZHRoO1xuICAgICAgICB0YXJnZXRDYW52YXMuaGVpZ2h0ID0gcGlwZWxpbmVTdGF0ZS5pbWFnZURhdGEuaGVpZ2h0O1xuICAgICAgfVxuICAgICAgY3R4LnB1dEltYWdlRGF0YShwaXBlbGluZVN0YXRlLmltYWdlRGF0YSwgMCwgMCk7XG4gICAgICByZXR1cm4gcGlwZWxpbmVTdGF0ZTtcbiAgICB9LFxuXG4gIH07XG59KSgpO1xuXG5cbi8qKlxuICogQG5hbWVzcGFjZSBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZVxuICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTIjaW1hZ2VfZmlsdGVyc31cbiAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAqL1xuZmFicmljLkltYWdlID0gZmFicmljLkltYWdlIHx8IHsgfTtcbmZhYnJpYy5JbWFnZS5maWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMgfHwgeyB9O1xuXG4vKipcbiAqIFJvb3QgZmlsdGVyIGNsYXNzIGZyb20gd2hpY2ggYWxsIGZpbHRlciBjbGFzc2VzIGluaGVyaXQgZnJvbVxuICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICovXG5mYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLnByb3RvdHlwZSAqLyB7XG5cbiAgLyoqXG4gICAqIEZpbHRlciB0eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICB0eXBlOiAnQmFzZUZpbHRlcicsXG5cbiAgLyoqXG4gICAqIEFycmF5IG9mIGF0dHJpYnV0ZXMgdG8gc2VuZCB3aXRoIGJ1ZmZlcnMuIGRvIG5vdCBtb2RpZnlcbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdmVydGV4U291cmNlOiAnYXR0cmlidXRlIHZlYzIgYVBvc2l0aW9uO1xcbicgK1xuICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAndlRleENvb3JkID0gYVBvc2l0aW9uO1xcbicgK1xuICAgICAgJ2dsX1Bvc2l0aW9uID0gdmVjNChhUG9zaXRpb24gKiAyLjAgLSAxLjAsIDAuMCwgMS4wKTtcXG4nICtcbiAgICAnfScsXG5cbiAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAnZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICd9JyxcblxuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGZpbHRlcidzIHByb3BlcnRpZXMgZnJvbSBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICovXG4gIHNldE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIG9wdGlvbnMpIHtcbiAgICAgIHRoaXNbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlciBwcm9ncmFtLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHRvIHVzZSBmb3Igc2hhZGVyIGNvbXBpbGF0aW9uLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZnJhZ21lbnRTb3VyY2UgZnJhZ21lbnRTaGFkZXIgc291cmNlIGZvciBjb21waWxhdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmVydGV4U291cmNlIHZlcnRleFNoYWRlciBzb3VyY2UgZm9yIGNvbXBpbGF0aW9uXG4gICAqL1xuICBjcmVhdGVQcm9ncmFtOiBmdW5jdGlvbihnbCwgZnJhZ21lbnRTb3VyY2UsIHZlcnRleFNvdXJjZSkge1xuICAgIGZyYWdtZW50U291cmNlID0gZnJhZ21lbnRTb3VyY2UgfHwgdGhpcy5mcmFnbWVudFNvdXJjZTtcbiAgICB2ZXJ0ZXhTb3VyY2UgPSB2ZXJ0ZXhTb3VyY2UgfHwgdGhpcy52ZXJ0ZXhTb3VyY2U7XG4gICAgaWYgKGZhYnJpYy53ZWJHbFByZWNpc2lvbiAhPT0gJ2hpZ2hwJyl7XG4gICAgICBmcmFnbWVudFNvdXJjZSA9IGZyYWdtZW50U291cmNlLnJlcGxhY2UoXG4gICAgICAgIC9wcmVjaXNpb24gaGlnaHAgZmxvYXQvZyxcbiAgICAgICAgJ3ByZWNpc2lvbiAnICsgZmFicmljLndlYkdsUHJlY2lzaW9uICsgJyBmbG9hdCdcbiAgICAgICk7XG4gICAgfVxuICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUik7XG4gICAgZ2wuc2hhZGVyU291cmNlKHZlcnRleFNoYWRlciwgdmVydGV4U291cmNlKTtcbiAgICBnbC5jb21waWxlU2hhZGVyKHZlcnRleFNoYWRlcik7XG4gICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIodmVydGV4U2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci10ZW1wbGF0ZVxuICAgICAgICAnVmVydGV4IHNoYWRlciBjb21waWxlIGVycm9yIGZvciAnICsgdGhpcy50eXBlICsgJzogJyArXG4gICAgICAgIGdsLmdldFNoYWRlckluZm9Mb2codmVydGV4U2hhZGVyKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgICBnbC5zaGFkZXJTb3VyY2UoZnJhZ21lbnRTaGFkZXIsIGZyYWdtZW50U291cmNlKTtcbiAgICBnbC5jb21waWxlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcbiAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihmcmFnbWVudFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItdGVtcGxhdGVcbiAgICAgICAgJ0ZyYWdtZW50IHNoYWRlciBjb21waWxlIGVycm9yIGZvciAnICsgdGhpcy50eXBlICsgJzogJyArXG4gICAgICAgIGdsLmdldFNoYWRlckluZm9Mb2coZnJhZ21lbnRTaGFkZXIpXG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG4gICAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXRlbXBsYXRlXG4gICAgICAgICdTaGFkZXIgbGluayBlcnJvciBmb3IgXCIke3RoaXMudHlwZX1cIiAnICtcbiAgICAgICAgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGF0dHJpYnV0ZUxvY2F0aW9ucyA9IHRoaXMuZ2V0QXR0cmlidXRlTG9jYXRpb25zKGdsLCBwcm9ncmFtKTtcbiAgICB2YXIgdW5pZm9ybUxvY2F0aW9ucyA9IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9ucyhnbCwgcHJvZ3JhbSkgfHwgeyB9O1xuICAgIHVuaWZvcm1Mb2NhdGlvbnMudVN0ZXBXID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1U3RlcFcnKTtcbiAgICB1bmlmb3JtTG9jYXRpb25zLnVTdGVwSCA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVN0ZXBIJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb2dyYW06IHByb2dyYW0sXG4gICAgICBhdHRyaWJ1dGVMb2NhdGlvbnM6IGF0dHJpYnV0ZUxvY2F0aW9ucyxcbiAgICAgIHVuaWZvcm1Mb2NhdGlvbnM6IHVuaWZvcm1Mb2NhdGlvbnNcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBtYXAgb2YgYXR0cmlidXRlIG5hbWVzIHRvIFdlYkdMQXR0cmlidXRlTG9jYXRpb24gb2JqZWN0cy5cbiAgICpcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhlIHNoYWRlciBwcm9ncmFtLlxuICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGUgc2hhZGVyIHByb2dyYW0gZnJvbSB3aGljaCB0byB0YWtlIGF0dHJpYnV0ZSBsb2NhdGlvbnMuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEEgbWFwIG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhdHRyaWJ1dGUgbG9jYXRpb25zLlxuICAgKi9cbiAgZ2V0QXR0cmlidXRlTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgIHJldHVybiB7XG4gICAgICBhUG9zaXRpb246IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhUG9zaXRpb24nKSxcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBtYXAgb2YgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzLlxuICAgKlxuICAgKiBJbnRlbmRlZCB0byBiZSBvdmVycmlkZGVuIGJ5IHN1YmNsYXNzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoZSBzaGFkZXIgcHJvZ3JhbS5cbiAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhlIHNoYWRlciBwcm9ncmFtIGZyb20gd2hpY2ggdG8gdGFrZSB1bmlmb3JtIGxvY2F0aW9ucy5cbiAgICogQHJldHVybnMge09iamVjdH0gQSBtYXAgb2YgdW5pZm9ybSBuYW1lcyB0byB1bmlmb3JtIGxvY2F0aW9ucy5cbiAgICovXG4gIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uICgvKiBnbCwgcHJvZ3JhbSAqLykge1xuICAgIC8vIGluIGNhc2UgaSBkbyBub3QgbmVlZCBhbnkgc3BlY2lhbCB1bmlmb3JtIGkgbmVlZCB0byByZXR1cm4gYW4gZW1wdHkgb2JqZWN0XG4gICAgcmV0dXJuIHsgfTtcbiAgfSxcblxuICAvKipcbiAgICogU2VuZCBhdHRyaWJ1dGUgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSBvbiB0aGUgR1BVLlxuICAgKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGUgc2hhZGVyIHByb2dyYW0uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVMb2NhdGlvbnMgQSBtYXAgb2Ygc2hhZGVyIGF0dHJpYnV0ZSBuYW1lcyB0byB0aGVpciBsb2NhdGlvbnMuXG4gICAqL1xuICBzZW5kQXR0cmlidXRlRGF0YTogZnVuY3Rpb24oZ2wsIGF0dHJpYnV0ZUxvY2F0aW9ucywgYVBvc2l0aW9uRGF0YSkge1xuICAgIHZhciBhdHRyaWJ1dGVMb2NhdGlvbiA9IGF0dHJpYnV0ZUxvY2F0aW9ucy5hUG9zaXRpb247XG4gICAgdmFyIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHJpYnV0ZUxvY2F0aW9uKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGF0dHJpYnV0ZUxvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBhUG9zaXRpb25EYXRhLCBnbC5TVEFUSUNfRFJBVyk7XG4gIH0sXG5cbiAgX3NldHVwRnJhbWVCdWZmZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgZ2wgPSBvcHRpb25zLmNvbnRleHQsIHdpZHRoLCBoZWlnaHQ7XG4gICAgaWYgKG9wdGlvbnMucGFzc2VzID4gMSkge1xuICAgICAgd2lkdGggPSBvcHRpb25zLmRlc3RpbmF0aW9uV2lkdGg7XG4gICAgICBoZWlnaHQgPSBvcHRpb25zLmRlc3RpbmF0aW9uSGVpZ2h0O1xuICAgICAgaWYgKG9wdGlvbnMuc291cmNlV2lkdGggIT09IHdpZHRoIHx8IG9wdGlvbnMuc291cmNlSGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgZ2wuZGVsZXRlVGV4dHVyZShvcHRpb25zLnRhcmdldFRleHR1cmUpO1xuICAgICAgICBvcHRpb25zLnRhcmdldFRleHR1cmUgPSBvcHRpb25zLmZpbHRlckJhY2tlbmQuY3JlYXRlVGV4dHVyZShnbCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsXG4gICAgICAgIG9wdGlvbnMudGFyZ2V0VGV4dHVyZSwgMCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gZHJhdyBsYXN0IGZpbHRlciBvbiBjYW52YXMgYW5kIG5vdCB0byBmcmFtZWJ1ZmZlci5cbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICBnbC5maW5pc2goKTtcbiAgICB9XG4gIH0sXG5cbiAgX3N3YXBUZXh0dXJlczogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMucGFzc2VzLS07XG4gICAgb3B0aW9ucy5wYXNzKys7XG4gICAgdmFyIHRlbXAgPSBvcHRpb25zLnRhcmdldFRleHR1cmU7XG4gICAgb3B0aW9ucy50YXJnZXRUZXh0dXJlID0gb3B0aW9ucy5zb3VyY2VUZXh0dXJlO1xuICAgIG9wdGlvbnMuc291cmNlVGV4dHVyZSA9IHRlbXA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdlbmVyaWMgaXNOZXV0cmFsIGltcGxlbWVudGF0aW9uIGZvciBvbmUgcGFyYW1ldGVyIGJhc2VkIGZpbHRlcnMuXG4gICAqIFVzZWQgb25seSBpbiBpbWFnZSBhcHBseUZpbHRlcnMgdG8gZGlzY2FyZCBmaWx0ZXJzIHRoYXQgd2lsbCBub3QgaGF2ZSBhbiBlZmZlY3RcbiAgICogb24gdGhlIGltYWdlXG4gICAqIE90aGVyIGZpbHRlcnMgbWF5IG5lZWQgdGhlaXIgb3duIHZlcnNpb24gKCBDb2xvck1hdHJpeCwgSHVlUm90YXRpb24sIGdhbW1hLCBDb21wb3NlZEZpbHRlciApXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqKi9cbiAgaXNOZXV0cmFsU3RhdGU6IGZ1bmN0aW9uKC8qIG9wdGlvbnMgKi8pIHtcbiAgICB2YXIgbWFpbiA9IHRoaXMubWFpblBhcmFtZXRlcixcbiAgICAgICAgX2NsYXNzID0gZmFicmljLkltYWdlLmZpbHRlcnNbdGhpcy50eXBlXS5wcm90b3R5cGU7XG4gICAgaWYgKG1haW4pIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KF9jbGFzc1ttYWluXSkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IF9jbGFzc1ttYWluXS5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICBpZiAodGhpc1ttYWluXVtpXSAhPT0gX2NsYXNzW21haW5dW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBfY2xhc3NbbWFpbl0gPT09IHRoaXNbbWFpbl07XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQXBwbHkgdGhpcyBmaWx0ZXIgdG8gdGhlIGlucHV0IGltYWdlIGRhdGEgcHJvdmlkZWQuXG4gICAqXG4gICAqIERldGVybWluZXMgd2hldGhlciB0byB1c2UgV2ViR0wgb3IgQ2FudmFzMkQgYmFzZWQgb24gdGhlIG9wdGlvbnMud2ViZ2wgZmxhZy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucGFzc2VzIFRoZSBudW1iZXIgb2YgZmlsdGVycyByZW1haW5pbmcgdG8gYmUgZXhlY3V0ZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLndlYmdsIFdoZXRoZXIgdG8gdXNlIHdlYmdsIHRvIHJlbmRlciB0aGUgZmlsdGVyLlxuICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gb3B0aW9ucy5zb3VyY2VUZXh0dXJlIFRoZSB0ZXh0dXJlIHNldHVwIGFzIHRoZSBzb3VyY2UgdG8gYmUgZmlsdGVyZWQuXG4gICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLnRhcmdldFRleHR1cmUgVGhlIHRleHR1cmUgd2hlcmUgZmlsdGVyZWQgb3V0cHV0IHNob3VsZCBiZSBkcmF3bi5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgKi9cbiAgYXBwbHlUbzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLndlYmdsKSB7XG4gICAgICB0aGlzLl9zZXR1cEZyYW1lQnVmZmVyKG9wdGlvbnMpO1xuICAgICAgdGhpcy5hcHBseVRvV2ViR0wob3B0aW9ucyk7XG4gICAgICB0aGlzLl9zd2FwVGV4dHVyZXMob3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5hcHBseVRvMmQob3B0aW9ucyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGNhY2hlZCBzaGFkZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICovXG4gIHJldHJpZXZlU2hhZGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLnByb2dyYW1DYWNoZS5oYXNPd25Qcm9wZXJ0eSh0aGlzLnR5cGUpKSB7XG4gICAgICBvcHRpb25zLnByb2dyYW1DYWNoZVt0aGlzLnR5cGVdID0gdGhpcy5jcmVhdGVQcm9ncmFtKG9wdGlvbnMuY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zLnByb2dyYW1DYWNoZVt0aGlzLnR5cGVdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBcHBseSB0aGlzIGZpbHRlciB1c2luZyB3ZWJnbC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucGFzc2VzIFRoZSBudW1iZXIgb2YgZmlsdGVycyByZW1haW5pbmcgdG8gYmUgZXhlY3V0ZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLndlYmdsIFdoZXRoZXIgdG8gdXNlIHdlYmdsIHRvIHJlbmRlciB0aGUgZmlsdGVyLlxuICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gb3B0aW9ucy5vcmlnaW5hbFRleHR1cmUgVGhlIHRleHR1cmUgb2YgdGhlIG9yaWdpbmFsIGlucHV0IGltYWdlLlxuICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gb3B0aW9ucy5zb3VyY2VUZXh0dXJlIFRoZSB0ZXh0dXJlIHNldHVwIGFzIHRoZSBzb3VyY2UgdG8gYmUgZmlsdGVyZWQuXG4gICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLnRhcmdldFRleHR1cmUgVGhlIHRleHR1cmUgd2hlcmUgZmlsdGVyZWQgb3V0cHV0IHNob3VsZCBiZSBkcmF3bi5cbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgKi9cbiAgYXBwbHlUb1dlYkdMOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGdsID0gb3B0aW9ucy5jb250ZXh0O1xuICAgIHZhciBzaGFkZXIgPSB0aGlzLnJldHJpZXZlU2hhZGVyKG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLnBhc3MgPT09IDAgJiYgb3B0aW9ucy5vcmlnaW5hbFRleHR1cmUpIHtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG9wdGlvbnMub3JpZ2luYWxUZXh0dXJlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBvcHRpb25zLnNvdXJjZVRleHR1cmUpO1xuICAgIH1cbiAgICBnbC51c2VQcm9ncmFtKHNoYWRlci5wcm9ncmFtKTtcbiAgICB0aGlzLnNlbmRBdHRyaWJ1dGVEYXRhKGdsLCBzaGFkZXIuYXR0cmlidXRlTG9jYXRpb25zLCBvcHRpb25zLmFQb3NpdGlvbik7XG5cbiAgICBnbC51bmlmb3JtMWYoc2hhZGVyLnVuaWZvcm1Mb2NhdGlvbnMudVN0ZXBXLCAxIC8gb3B0aW9ucy5zb3VyY2VXaWR0aCk7XG4gICAgZ2wudW5pZm9ybTFmKHNoYWRlci51bmlmb3JtTG9jYXRpb25zLnVTdGVwSCwgMSAvIG9wdGlvbnMuc291cmNlSGVpZ2h0KTtcblxuICAgIHRoaXMuc2VuZFVuaWZvcm1EYXRhKGdsLCBzaGFkZXIudW5pZm9ybUxvY2F0aW9ucyk7XG4gICAgZ2wudmlld3BvcnQoMCwgMCwgb3B0aW9ucy5kZXN0aW5hdGlvbldpZHRoLCBvcHRpb25zLmRlc3RpbmF0aW9uSGVpZ2h0KTtcbiAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcbiAgfSxcblxuICBiaW5kQWRkaXRpb25hbFRleHR1cmU6IGZ1bmN0aW9uKGdsLCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCkge1xuICAgIGdsLmFjdGl2ZVRleHR1cmUodGV4dHVyZVVuaXQpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIC8vIHJlc2V0IGFjdGl2ZSB0ZXh0dXJlIHRvIDAgYXMgdXN1YWxcbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgfSxcblxuICB1bmJpbmRBZGRpdGlvbmFsVGV4dHVyZTogZnVuY3Rpb24oZ2wsIHRleHR1cmVVbml0KSB7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0ZXh0dXJlVW5pdCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gIH0sXG5cbiAgZ2V0TWFpblBhcmFtZXRlcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXNbdGhpcy5tYWluUGFyYW1ldGVyXTtcbiAgfSxcblxuICBzZXRNYWluUGFyYW1ldGVyOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHRoaXNbdGhpcy5tYWluUGFyYW1ldGVyXSA9IHZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZW5kIHVuaWZvcm0gZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSBvbiB0aGUgR1BVLlxuICAgKlxuICAgKiBJbnRlbmRlZCB0byBiZSBvdmVycmlkZGVuIGJ5IHN1YmNsYXNzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoZSBzaGFkZXIgcHJvZ3JhbS5cbiAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc2hhZGVyIHVuaWZvcm0gbmFtZXMgdG8gdGhlaXIgbG9jYXRpb25zLlxuICAgKi9cbiAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbigvKiBnbCwgdW5pZm9ybUxvY2F0aW9ucyAqLykge1xuICAgIC8vIEludGVudGlvbmFsbHkgbGVmdCBibGFuay4gIE92ZXJyaWRlIG1lIGluIHN1YmNsYXNzZXMuXG4gIH0sXG5cbiAgLyoqXG4gICAqIElmIG5lZWRlZCBieSBhIDJkIGZpbHRlciwgdGhpcyBmdW5jdGlvbnMgY2FuIGNyZWF0ZSBhbiBoZWxwZXIgY2FudmFzIHRvIGJlIHVzZWRcbiAgICogcmVtZW1iZXIgdGhhdCBvcHRpb25zLnRhcmdldENhbnZhcyBpcyBhdmFpbGFibGUgZm9yIHVzZSB0aWxsIGVuZCBvZiBjaGFpbi5cbiAgICovXG4gIGNyZWF0ZUhlbHBMYXllcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5oZWxwTGF5ZXIpIHtcbiAgICAgIHZhciBoZWxwTGF5ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIGhlbHBMYXllci53aWR0aCA9IG9wdGlvbnMuc291cmNlV2lkdGg7XG4gICAgICBoZWxwTGF5ZXIuaGVpZ2h0ID0gb3B0aW9ucy5zb3VyY2VIZWlnaHQ7XG4gICAgICBvcHRpb25zLmhlbHBMYXllciA9IGhlbHBMYXllcjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAqL1xuICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9iamVjdCA9IHsgdHlwZTogdGhpcy50eXBlIH0sIG1haW5QID0gdGhpcy5tYWluUGFyYW1ldGVyO1xuICAgIGlmIChtYWluUCkge1xuICAgICAgb2JqZWN0W21haW5QXSA9IHRoaXNbbWFpblBdO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEpTT05cbiAgICovXG4gIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgLy8gZGVsZWdhdGUsIG5vdCBhbGlhc1xuICAgIHJldHVybiB0aGlzLnRvT2JqZWN0KCk7XG4gIH1cbn0pO1xuXG5mYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnNbb2JqZWN0LnR5cGVdKG9iamVjdCk7XG4gIGNhbGxiYWNrICYmIGNhbGxiYWNrKGZpbHRlcik7XG4gIHJldHVybiBmaWx0ZXI7XG59O1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIENvbG9yIE1hdHJpeCBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbG9yTWF0cml4XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbG9yTWF0cml4I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQHNlZSB7QExpbmsgaHR0cDovL3d3dy53ZWJ3YXNwLmNvLnVrL3R1dG9yaWFscy8yMTkvQ29sb3JfTWF0cml4X0ZpbHRlci5waHB9XG4gICAqIEBzZWUge0BMaW5rIGh0dHA6Ly9waG9ib3NsYWIub3JnL2xvZy8yMDEzLzExL2Zhc3QtaW1hZ2UtZmlsdGVycy13aXRoLXdlYmdsfVxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Lb2RhY2hyb21lIGZpbHRlcjwvY2FwdGlvbj5cbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db2xvck1hdHJpeCh7XG4gICAqICBtYXRyaXg6IFtcbiAgICAgICAxLjEyODU1ODIzOTY1OTM1MjUsIC0wLjM5NjczODIyODM2MDEzNDgsIC0wLjAzOTkyNTU5MTcyOTIxNzkzLCAwLCA2My43Mjk1ODc2MjE5NjUwMixcbiAgICAgICAtMC4xNjQwNDMzOTk2MjI0NDYxNiwgMS4wODM1MjUxNTY2MjkxMzA0LCAtMC4wNTQ5ODgwNTExNTYzMzEzMiwgMCwgMjQuNzMyNDA3ODk2NzA2MjAzLFxuICAgICAgIC0wLjE2Nzg2MDEwNzA2MTU1NzYzLCAtMC41NjAzNDE2Mjc3Njk1MjQ4LCAxLjYwMTQ4NTA3NjE5NjQ5NDMsIDAsIDM1LjYyOTgyODA3NDYwOTQ2LFxuICAgICAgIDAsIDAsIDAsIDEsIDBcbiAgICAgIF1cbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKi9cbiAgZmlsdGVycy5Db2xvck1hdHJpeCA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db2xvck1hdHJpeC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0NvbG9yTWF0cml4JyxcblxuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBtYXQ0IHVDb2xvck1hdHJpeDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHZlYzQgdUNvbnN0YW50cztcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAnY29sb3IgKj0gdUNvbG9yTWF0cml4O1xcbicgK1xuICAgICAgICAnY29sb3IgKz0gdUNvbnN0YW50cztcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogQ29sb3JtYXRyaXggZm9yIHBpeGVscy5cbiAgICAgKiBhcnJheSBvZiAyMCBmbG9hdHMuIE51bWJlcnMgaW4gcG9zaXRpb25zIDQsIDksIDE0LCAxOSBsb29zZSBtZWFuaW5nXG4gICAgICogb3V0c2lkZSB0aGUgLTEsIDEgcmFuZ2UuXG4gICAgICogMC4wMDM5MjE1Njg2IGlzIHRoZSBwYXJ0IG9mIDEgdGhhdCBnZXQgdHJhbnNsYXRlZCB0byAxIGluIDJkXG4gICAgICogQHBhcmFtIHtBcnJheX0gbWF0cml4IGFycmF5IG9mIDIwIG51bWJlcnMuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtYXRyaXg6IFtcbiAgICAgIDEsIDAsIDAsIDAsIDAsXG4gICAgICAwLCAxLCAwLCAwLCAwLFxuICAgICAgMCwgMCwgMSwgMCwgMCxcbiAgICAgIDAsIDAsIDAsIDEsIDBcbiAgICBdLFxuXG4gICAgbWFpblBhcmFtZXRlcjogJ21hdHJpeCcsXG5cbiAgICAvKipcbiAgICAgKiBMb2NrIHRoZSBjb2xvcm1hdHJpeCBvbiB0aGUgY29sb3IgcGFydCwgc2tpcHBpbmcgYWxwaGEsIG1haW5seSBmb3Igbm9uIHdlYmdsIHNjZW5hcmlvXG4gICAgICogdG8gc2F2ZSBzb21lIGNhbGN1bGF0aW9uXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBjb2xvcnNPbmx5OiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIC8vIGNyZWF0ZSBhIG5ldyBhcnJheSBpbnN0ZWFkIG11dGF0aW5nIHRoZSBwcm90b3R5cGUgd2l0aCBwdXNoXG4gICAgICB0aGlzLm1hdHJpeCA9IHRoaXMubWF0cml4LnNsaWNlKDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgQ29sb3JNYXRyaXggb3BlcmF0aW9uIHRvIGEgVWludDhBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICBpTGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgbSA9IHRoaXMubWF0cml4LFxuICAgICAgICAgIHIsIGcsIGIsIGEsIGksIGNvbG9yc09ubHkgPSB0aGlzLmNvbG9yc09ubHk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpTGVuOyBpICs9IDQpIHtcbiAgICAgICAgciA9IGRhdGFbaV07XG4gICAgICAgIGcgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgYiA9IGRhdGFbaSArIDJdO1xuICAgICAgICBpZiAoY29sb3JzT25seSkge1xuICAgICAgICAgIGRhdGFbaV0gPSByICogbVswXSArIGcgKiBtWzFdICsgYiAqIG1bMl0gKyBtWzRdICogMjU1O1xuICAgICAgICAgIGRhdGFbaSArIDFdID0gciAqIG1bNV0gKyBnICogbVs2XSArIGIgKiBtWzddICsgbVs5XSAqIDI1NTtcbiAgICAgICAgICBkYXRhW2kgKyAyXSA9IHIgKiBtWzEwXSArIGcgKiBtWzExXSArIGIgKiBtWzEyXSArIG1bMTRdICogMjU1O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGEgPSBkYXRhW2kgKyAzXTtcbiAgICAgICAgICBkYXRhW2ldID0gciAqIG1bMF0gKyBnICogbVsxXSArIGIgKiBtWzJdICsgYSAqIG1bM10gKyBtWzRdICogMjU1O1xuICAgICAgICAgIGRhdGFbaSArIDFdID0gciAqIG1bNV0gKyBnICogbVs2XSArIGIgKiBtWzddICsgYSAqIG1bOF0gKyBtWzldICogMjU1O1xuICAgICAgICAgIGRhdGFbaSArIDJdID0gciAqIG1bMTBdICsgZyAqIG1bMTFdICsgYiAqIG1bMTJdICsgYSAqIG1bMTNdICsgbVsxNF0gKiAyNTU7XG4gICAgICAgICAgZGF0YVtpICsgM10gPSByICogbVsxNV0gKyBnICogbVsxNl0gKyBiICogbVsxN10gKyBhICogbVsxOF0gKyBtWzE5XSAqIDI1NTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdUNvbG9yTWF0cml4OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VDb2xvck1hdHJpeCcpLFxuICAgICAgICB1Q29uc3RhbnRzOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VDb25zdGFudHMnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIHZhciBtID0gdGhpcy5tYXRyaXgsXG4gICAgICAgICAgbWF0cml4ID0gW1xuICAgICAgICAgICAgbVswXSwgbVsxXSwgbVsyXSwgbVszXSxcbiAgICAgICAgICAgIG1bNV0sIG1bNl0sIG1bN10sIG1bOF0sXG4gICAgICAgICAgICBtWzEwXSwgbVsxMV0sIG1bMTJdLCBtWzEzXSxcbiAgICAgICAgICAgIG1bMTVdLCBtWzE2XSwgbVsxN10sIG1bMThdXG4gICAgICAgICAgXSxcbiAgICAgICAgICBjb25zdGFudHMgPSBbbVs0XSwgbVs5XSwgbVsxNF0sIG1bMTldXTtcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodW5pZm9ybUxvY2F0aW9ucy51Q29sb3JNYXRyaXgsIGZhbHNlLCBtYXRyaXgpO1xuICAgICAgZ2wudW5pZm9ybTRmdih1bmlmb3JtTG9jYXRpb25zLnVDb25zdGFudHMsIGNvbnN0YW50cyk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBmdW5jdGlvbiB0byBpbnZva2UgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbG9yTWF0cml4fSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db2xvck1hdHJpeFxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuQ29sb3JNYXRyaXguZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBCcmlnaHRuZXNzIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuQnJpZ2h0bmVzc1xuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CcmlnaHRuZXNzI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CcmlnaHRuZXNzKHtcbiAgICogICBicmlnaHRuZXNzOiAwLjA1XG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICovXG4gIGZpbHRlcnMuQnJpZ2h0bmVzcyA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CcmlnaHRuZXNzLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnQnJpZ2h0bmVzcycsXG5cbiAgICAvKipcbiAgICAgKiBGcmFnbWVudCBzb3VyY2UgZm9yIHRoZSBicmlnaHRuZXNzIHByb2dyYW1cbiAgICAgKi9cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIGZsb2F0IHVCcmlnaHRuZXNzO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgJ2NvbG9yLnJnYiArPSB1QnJpZ2h0bmVzcztcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogQnJpZ2h0bmVzcyB2YWx1ZSwgZnJvbSAtMSB0byAxLlxuICAgICAqIHRyYW5zbGF0ZWQgdG8gLTI1NSB0byAyNTUgZm9yIDJkXG4gICAgICogMC4wMDM5MjE1Njg2IGlzIHRoZSBwYXJ0IG9mIDEgdGhhdCBnZXQgdHJhbnNsYXRlZCB0byAxIGluIDJkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGJyaWdodG5lc3NcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJyaWdodG5lc3M6IDAsXG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSB0aGUgcHJvcGVydHkgdGhhdCBpcyB0aGUgZmlsdGVyIHBhcmFtZXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtYWluUGFyYW1ldGVyOiAnYnJpZ2h0bmVzcycsXG5cbiAgICAvKipcbiAgICAqIEFwcGx5IHRoZSBCcmlnaHRuZXNzIG9wZXJhdGlvbiB0byBhIFVpbnQ4Q2xhbXBlZEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICpcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4Q2xhbXBlZEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5icmlnaHRuZXNzID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIGksIGxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIGJyaWdodG5lc3MgPSBNYXRoLnJvdW5kKHRoaXMuYnJpZ2h0bmVzcyAqIDI1NSk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgZGF0YVtpXSA9IGRhdGFbaV0gKyBicmlnaHRuZXNzO1xuICAgICAgICBkYXRhW2kgKyAxXSA9IGRhdGFbaSArIDFdICsgYnJpZ2h0bmVzcztcbiAgICAgICAgZGF0YVtpICsgMl0gPSBkYXRhW2kgKyAyXSArIGJyaWdodG5lc3M7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1QnJpZ2h0bmVzczogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1QnJpZ2h0bmVzcycpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1Mb2NhdGlvbnMudUJyaWdodG5lc3MsIHRoaXMuYnJpZ2h0bmVzcyk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5CcmlnaHRuZXNzfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CcmlnaHRuZXNzXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CcmlnaHRuZXNzLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBleHRlbmQgPSBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogQWRhcHRlZCBmcm9tIDxhIGhyZWY9XCJodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9jYW52YXMvaW1hZ2VmaWx0ZXJzL1wiPmh0bWw1cm9ja3MgYXJ0aWNsZTwvYT5cbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZVxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TaGFycGVuIGZpbHRlcjwvY2FwdGlvbj5cbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUoe1xuICAgKiAgIG1hdHJpeDogWyAwLCAtMSwgIDAsXG4gICAqICAgICAgICAgICAgLTEsICA1LCAtMSxcbiAgICogICAgICAgICAgICAgMCwgLTEsICAwIF1cbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkJsdXIgZmlsdGVyPC9jYXB0aW9uPlxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZSh7XG4gICAqICAgbWF0cml4OiBbIDEvOSwgMS85LCAxLzksXG4gICAqICAgICAgICAgICAgIDEvOSwgMS85LCAxLzksXG4gICAqICAgICAgICAgICAgIDEvOSwgMS85LCAxLzkgXVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+RW1ib3NzIGZpbHRlcjwvY2FwdGlvbj5cbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUoe1xuICAgKiAgIG1hdHJpeDogWyAxLCAgIDEsICAxLFxuICAgKiAgICAgICAgICAgICAxLCAwLjcsIC0xLFxuICAgKiAgICAgICAgICAgIC0xLCAgLTEsIC0xIF1cbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtYm9zcyBmaWx0ZXIgd2l0aCBvcGFxdWVuZXNzPC9jYXB0aW9uPlxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZSh7XG4gICAqICAgb3BhcXVlOiB0cnVlLFxuICAgKiAgIG1hdHJpeDogWyAxLCAgIDEsICAxLFxuICAgKiAgICAgICAgICAgICAxLCAwLjcsIC0xLFxuICAgKiAgICAgICAgICAgIC0xLCAgLTEsIC0xIF1cbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAqL1xuICBmaWx0ZXJzLkNvbnZvbHV0ZSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdDb252b2x1dGUnLFxuXG4gICAgLypcbiAgICAgKiBPcGFxdWUgdmFsdWUgKHRydWUvZmFsc2UpXG4gICAgICovXG4gICAgb3BhcXVlOiBmYWxzZSxcblxuICAgIC8qXG4gICAgICogbWF0cml4IGZvciB0aGUgZmlsdGVyLCBtYXggOXg5XG4gICAgICovXG4gICAgbWF0cml4OiBbMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMF0sXG5cbiAgICAvKipcbiAgICAgKiBGcmFnbWVudCBzb3VyY2UgZm9yIHRoZSBicmlnaHRuZXNzIHByb2dyYW1cbiAgICAgKi9cbiAgICBmcmFnbWVudFNvdXJjZToge1xuICAgICAgQ29udm9sdXRlXzNfMTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1TWF0cml4WzldO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcFc7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwSDtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB2ZWM0KDAsIDAsIDAsIDApO1xcbicgK1xuICAgICAgICAgICdmb3IgKGZsb2F0IGggPSAwLjA7IGggPCAzLjA7IGgrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgJ2ZvciAoZmxvYXQgdyA9IDAuMDsgdyA8IDMuMDsgdys9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAgICd2ZWMyIG1hdHJpeFBvcyA9IHZlYzIodVN0ZXBXICogKHcgLSAxKSwgdVN0ZXBIICogKGggLSAxKSk7XFxuJyArXG4gICAgICAgICAgICAgICdjb2xvciArPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCArIG1hdHJpeFBvcykgKiB1TWF0cml4W2ludChoICogMy4wICsgdyldO1xcbicgK1xuICAgICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgQ29udm9sdXRlXzNfMDogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1TWF0cml4WzldO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcFc7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwSDtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB2ZWM0KDAsIDAsIDAsIDEpO1xcbicgK1xuICAgICAgICAgICdmb3IgKGZsb2F0IGggPSAwLjA7IGggPCAzLjA7IGgrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgJ2ZvciAoZmxvYXQgdyA9IDAuMDsgdyA8IDMuMDsgdys9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAgICd2ZWMyIG1hdHJpeFBvcyA9IHZlYzIodVN0ZXBXICogKHcgLSAxLjApLCB1U3RlcEggKiAoaCAtIDEuMCkpO1xcbicgK1xuICAgICAgICAgICAgICAnY29sb3IucmdiICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgbWF0cml4UG9zKS5yZ2IgKiB1TWF0cml4W2ludChoICogMy4wICsgdyldO1xcbicgK1xuICAgICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICdmbG9hdCBhbHBoYSA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKS5hO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLmEgPSBhbHBoYTtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgQ29udm9sdXRlXzVfMTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1TWF0cml4WzI1XTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAwKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgNS4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCA1LjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gMi4wKSwgdVN0ZXBIICogKGggLSAyLjApKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgbWF0cml4UG9zKSAqIHVNYXRyaXhbaW50KGggKiA1LjAgKyB3KV07XFxuJyArXG4gICAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgICBDb252b2x1dGVfNV8wOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVNYXRyaXhbMjVdO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcFc7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwSDtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB2ZWM0KDAsIDAsIDAsIDEpO1xcbicgK1xuICAgICAgICAgICdmb3IgKGZsb2F0IGggPSAwLjA7IGggPCA1LjA7IGgrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgJ2ZvciAoZmxvYXQgdyA9IDAuMDsgdyA8IDUuMDsgdys9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAgICd2ZWMyIG1hdHJpeFBvcyA9IHZlYzIodVN0ZXBXICogKHcgLSAyLjApLCB1U3RlcEggKiAoaCAtIDIuMCkpO1xcbicgK1xuICAgICAgICAgICAgICAnY29sb3IucmdiICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgbWF0cml4UG9zKS5yZ2IgKiB1TWF0cml4W2ludChoICogNS4wICsgdyldO1xcbicgK1xuICAgICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICdmbG9hdCBhbHBoYSA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKS5hO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLmEgPSBhbHBoYTtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgQ29udm9sdXRlXzdfMTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1TWF0cml4WzQ5XTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAwKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgNy4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCA3LjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gMy4wKSwgdVN0ZXBIICogKGggLSAzLjApKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgbWF0cml4UG9zKSAqIHVNYXRyaXhbaW50KGggKiA3LjAgKyB3KV07XFxuJyArXG4gICAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgICBDb252b2x1dGVfN18wOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVNYXRyaXhbNDldO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcFc7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwSDtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB2ZWM0KDAsIDAsIDAsIDEpO1xcbicgK1xuICAgICAgICAgICdmb3IgKGZsb2F0IGggPSAwLjA7IGggPCA3LjA7IGgrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgJ2ZvciAoZmxvYXQgdyA9IDAuMDsgdyA8IDcuMDsgdys9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAgICd2ZWMyIG1hdHJpeFBvcyA9IHZlYzIodVN0ZXBXICogKHcgLSAzLjApLCB1U3RlcEggKiAoaCAtIDMuMCkpO1xcbicgK1xuICAgICAgICAgICAgICAnY29sb3IucmdiICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgbWF0cml4UG9zKS5yZ2IgKiB1TWF0cml4W2ludChoICogNy4wICsgdyldO1xcbicgK1xuICAgICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICdmbG9hdCBhbHBoYSA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKS5hO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLmEgPSBhbHBoYTtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgICAgQ29udm9sdXRlXzlfMTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1TWF0cml4WzgxXTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgdVN0ZXBXO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcEg7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdmVjNCgwLCAwLCAwLCAwKTtcXG4nICtcbiAgICAgICAgICAnZm9yIChmbG9hdCBoID0gMC4wOyBoIDwgOS4wOyBoKz0xLjApIHtcXG4nICtcbiAgICAgICAgICAgICdmb3IgKGZsb2F0IHcgPSAwLjA7IHcgPCA5LjA7IHcrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgICAndmVjMiBtYXRyaXhQb3MgPSB2ZWMyKHVTdGVwVyAqICh3IC0gNC4wKSwgdVN0ZXBIICogKGggLSA0LjApKTtcXG4nICtcbiAgICAgICAgICAgICAgJ2NvbG9yICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgbWF0cml4UG9zKSAqIHVNYXRyaXhbaW50KGggKiA5LjAgKyB3KV07XFxuJyArXG4gICAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgICBDb252b2x1dGVfOV8wOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVNYXRyaXhbODFdO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBmbG9hdCB1U3RlcFc7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwSDtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB2ZWM0KDAsIDAsIDAsIDEpO1xcbicgK1xuICAgICAgICAgICdmb3IgKGZsb2F0IGggPSAwLjA7IGggPCA5LjA7IGgrPTEuMCkge1xcbicgK1xuICAgICAgICAgICAgJ2ZvciAoZmxvYXQgdyA9IDAuMDsgdyA8IDkuMDsgdys9MS4wKSB7XFxuJyArXG4gICAgICAgICAgICAgICd2ZWMyIG1hdHJpeFBvcyA9IHZlYzIodVN0ZXBXICogKHcgLSA0LjApLCB1U3RlcEggKiAoaCAtIDQuMCkpO1xcbicgK1xuICAgICAgICAgICAgICAnY29sb3IucmdiICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkICsgbWF0cml4UG9zKS5yZ2IgKiB1TWF0cml4W2ludChoICogOS4wICsgdyldO1xcbicgK1xuICAgICAgICAgICAgJ31cXG4nICtcbiAgICAgICAgICAnfVxcbicgK1xuICAgICAgICAgICdmbG9hdCBhbHBoYSA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKS5hO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLmEgPSBhbHBoYTtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub3BhcXVlPWZhbHNlXSBPcGFxdWUgdmFsdWUgKHRydWUvZmFsc2UpXG4gICAgICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMubWF0cml4XSBGaWx0ZXIgbWF0cml4XG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICogUmV0cmlldmVzIHRoZSBjYWNoZWQgc2hhZGVyLlxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAgKi9cbiAgICByZXRyaWV2ZVNoYWRlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIHNpemUgPSBNYXRoLnNxcnQodGhpcy5tYXRyaXgubGVuZ3RoKTtcbiAgICAgIHZhciBjYWNoZUtleSA9IHRoaXMudHlwZSArICdfJyArIHNpemUgKyAnXycgKyAodGhpcy5vcGFxdWUgPyAxIDogMCk7XG4gICAgICB2YXIgc2hhZGVyU291cmNlID0gdGhpcy5mcmFnbWVudFNvdXJjZVtjYWNoZUtleV07XG4gICAgICBpZiAoIW9wdGlvbnMucHJvZ3JhbUNhY2hlLmhhc093blByb3BlcnR5KGNhY2hlS2V5KSkge1xuICAgICAgICBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV0gPSB0aGlzLmNyZWF0ZVByb2dyYW0ob3B0aW9ucy5jb250ZXh0LCBzaGFkZXJTb3VyY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIEJyaWdodG5lc3Mgb3BlcmF0aW9uIHRvIGEgVWludDhDbGFtcGVkQXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhDbGFtcGVkQXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgIHdlaWdodHMgPSB0aGlzLm1hdHJpeCxcbiAgICAgICAgICBzaWRlID0gTWF0aC5yb3VuZChNYXRoLnNxcnQod2VpZ2h0cy5sZW5ndGgpKSxcbiAgICAgICAgICBoYWxmU2lkZSA9IE1hdGguZmxvb3Ioc2lkZSAvIDIpLFxuICAgICAgICAgIHN3ID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICAgIHNoID0gaW1hZ2VEYXRhLmhlaWdodCxcbiAgICAgICAgICBvdXRwdXQgPSBvcHRpb25zLmN0eC5jcmVhdGVJbWFnZURhdGEoc3csIHNoKSxcbiAgICAgICAgICBkc3QgPSBvdXRwdXQuZGF0YSxcbiAgICAgICAgICAvLyBnbyB0aHJvdWdoIHRoZSBkZXN0aW5hdGlvbiBpbWFnZSBwaXhlbHNcbiAgICAgICAgICBhbHBoYUZhYyA9IHRoaXMub3BhcXVlID8gMSA6IDAsXG4gICAgICAgICAgciwgZywgYiwgYSwgZHN0T2ZmLFxuICAgICAgICAgIHNjeCwgc2N5LCBzcmNPZmYsIHd0LFxuICAgICAgICAgIHgsIHksIGN4LCBjeTtcblxuICAgICAgZm9yICh5ID0gMDsgeSA8IHNoOyB5KyspIHtcbiAgICAgICAgZm9yICh4ID0gMDsgeCA8IHN3OyB4KyspIHtcbiAgICAgICAgICBkc3RPZmYgPSAoeSAqIHN3ICsgeCkgKiA0O1xuICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgd2VpZ2hlZCBzdW0gb2YgdGhlIHNvdXJjZSBpbWFnZSBwaXhlbHMgdGhhdFxuICAgICAgICAgIC8vIGZhbGwgdW5kZXIgdGhlIGNvbnZvbHV0aW9uIG1hdHJpeFxuICAgICAgICAgIHIgPSAwOyBnID0gMDsgYiA9IDA7IGEgPSAwO1xuXG4gICAgICAgICAgZm9yIChjeSA9IDA7IGN5IDwgc2lkZTsgY3krKykge1xuICAgICAgICAgICAgZm9yIChjeCA9IDA7IGN4IDwgc2lkZTsgY3grKykge1xuICAgICAgICAgICAgICBzY3kgPSB5ICsgY3kgLSBoYWxmU2lkZTtcbiAgICAgICAgICAgICAgc2N4ID0geCArIGN4IC0gaGFsZlNpZGU7XG5cbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1kZXB0aFxuICAgICAgICAgICAgICBpZiAoc2N5IDwgMCB8fCBzY3kgPj0gc2ggfHwgc2N4IDwgMCB8fCBzY3ggPj0gc3cpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHNyY09mZiA9IChzY3kgKiBzdyArIHNjeCkgKiA0O1xuICAgICAgICAgICAgICB3dCA9IHdlaWdodHNbY3kgKiBzaWRlICsgY3hdO1xuXG4gICAgICAgICAgICAgIHIgKz0gZGF0YVtzcmNPZmZdICogd3Q7XG4gICAgICAgICAgICAgIGcgKz0gZGF0YVtzcmNPZmYgKyAxXSAqIHd0O1xuICAgICAgICAgICAgICBiICs9IGRhdGFbc3JjT2ZmICsgMl0gKiB3dDtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1kZXB0aFxuICAgICAgICAgICAgICBpZiAoIWFscGhhRmFjKSB7XG4gICAgICAgICAgICAgICAgYSArPSBkYXRhW3NyY09mZiArIDNdICogd3Q7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZHN0W2RzdE9mZl0gPSByO1xuICAgICAgICAgIGRzdFtkc3RPZmYgKyAxXSA9IGc7XG4gICAgICAgICAgZHN0W2RzdE9mZiArIDJdID0gYjtcbiAgICAgICAgICBpZiAoIWFscGhhRmFjKSB7XG4gICAgICAgICAgICBkc3RbZHN0T2ZmICsgM10gPSBhO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRzdFtkc3RPZmYgKyAzXSA9IGRhdGFbZHN0T2ZmICsgM107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvcHRpb25zLmltYWdlRGF0YSA9IG91dHB1dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVNYXRyaXg6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndU1hdHJpeCcpLFxuICAgICAgICB1T3BhcXVlOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VPcGFxdWUnKSxcbiAgICAgICAgdUhhbGZTaXplOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VIYWxmU2l6ZScpLFxuICAgICAgICB1U2l6ZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1U2l6ZScpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTFmdih1bmlmb3JtTG9jYXRpb25zLnVNYXRyaXgsIHRoaXMubWF0cml4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHRlbmQodGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JyksIHtcbiAgICAgICAgb3BhcXVlOiB0aGlzLm9wYXF1ZSxcbiAgICAgICAgbWF0cml4OiB0aGlzLm1hdHJpeFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnZvbHV0ZX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udm9sdXRlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db252b2x1dGUuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEdyYXlzY2FsZSBpbWFnZSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYXlzY2FsZVxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuR3JheXNjYWxlKCk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKi9cbiAgZmlsdGVycy5HcmF5c2NhbGUgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuR3JheXNjYWxlLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnR3JheXNjYWxlJyxcblxuICAgIGZyYWdtZW50U291cmNlOiB7XG4gICAgICBhdmVyYWdlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAgICdmbG9hdCBhdmVyYWdlID0gKGNvbG9yLnIgKyBjb2xvci5iICsgY29sb3IuZykgLyAzLjA7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IHZlYzQoYXZlcmFnZSwgYXZlcmFnZSwgYXZlcmFnZSwgY29sb3IuYSk7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIGxpZ2h0bmVzczogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBpbnQgdU1vZGU7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbCA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgICAnZmxvYXQgYXZlcmFnZSA9IChtYXgobWF4KGNvbC5yLCBjb2wuZyksY29sLmIpICsgbWluKG1pbihjb2wuciwgY29sLmcpLGNvbC5iKSkgLyAyLjA7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IHZlYzQoYXZlcmFnZSwgYXZlcmFnZSwgYXZlcmFnZSwgY29sLmEpO1xcbicgK1xuICAgICAgICAnfScsXG4gICAgICBsdW1pbm9zaXR5OiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIGludCB1TW9kZTtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAgICdmbG9hdCBhdmVyYWdlID0gMC4yMSAqIGNvbC5yICsgMC43MiAqIGNvbC5nICsgMC4wNyAqIGNvbC5iO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSB2ZWM0KGF2ZXJhZ2UsIGF2ZXJhZ2UsIGF2ZXJhZ2UsIGNvbC5hKTtcXG4nICtcbiAgICAgICAgJ30nLFxuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEdyYXlzY2FsZSBtb2RlLCBiZXR3ZWVuICdhdmVyYWdlJywgJ2xpZ2h0bmVzcycsICdsdW1pbm9zaXR5J1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtb2RlOiAnYXZlcmFnZScsXG5cbiAgICBtYWluUGFyYW1ldGVyOiAnbW9kZScsXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgR3JheXNjYWxlIG9wZXJhdGlvbiB0byBhIFVpbnQ4QXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwaXhlbHMgb2YgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBvcHRpb25zLmltYWdlRGF0YSBUaGUgVWludDhBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIGksXG4gICAgICAgICAgbGVuID0gZGF0YS5sZW5ndGgsIHZhbHVlLFxuICAgICAgICAgIG1vZGUgPSB0aGlzLm1vZGU7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgaWYgKG1vZGUgPT09ICdhdmVyYWdlJykge1xuICAgICAgICAgIHZhbHVlID0gKGRhdGFbaV0gKyBkYXRhW2kgKyAxXSArIGRhdGFbaSArIDJdKSAvIDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gJ2xpZ2h0bmVzcycpIHtcbiAgICAgICAgICB2YWx1ZSA9IChNYXRoLm1pbihkYXRhW2ldLCBkYXRhW2kgKyAxXSwgZGF0YVtpICsgMl0pICtcbiAgICAgICAgICAgIE1hdGgubWF4KGRhdGFbaV0sIGRhdGFbaSArIDFdLCBkYXRhW2kgKyAyXSkpIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtb2RlID09PSAnbHVtaW5vc2l0eScpIHtcbiAgICAgICAgICB2YWx1ZSA9IDAuMjEgKiBkYXRhW2ldICsgMC43MiAqIGRhdGFbaSArIDFdICsgMC4wNyAqIGRhdGFbaSArIDJdO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbaV0gPSB2YWx1ZTtcbiAgICAgICAgZGF0YVtpICsgMV0gPSB2YWx1ZTtcbiAgICAgICAgZGF0YVtpICsgMl0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjYWNoZWQgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAgICovXG4gICAgcmV0cmlldmVTaGFkZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjYWNoZUtleSA9IHRoaXMudHlwZSArICdfJyArIHRoaXMubW9kZTtcbiAgICAgIGlmICghb3B0aW9ucy5wcm9ncmFtQ2FjaGUuaGFzT3duUHJvcGVydHkoY2FjaGVLZXkpKSB7XG4gICAgICAgIHZhciBzaGFkZXJTb3VyY2UgPSB0aGlzLmZyYWdtZW50U291cmNlW3RoaXMubW9kZV07XG4gICAgICAgIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XSA9IHRoaXMuY3JlYXRlUHJvZ3JhbShvcHRpb25zLmNvbnRleHQsIHNoYWRlclNvdXJjZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucy5wcm9ncmFtQ2FjaGVbY2FjaGVLZXldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdU1vZGU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndU1vZGUnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIC8vIGRlZmF1bHQgYXZlcmFnZSBtb2RlLlxuICAgICAgdmFyIG1vZGUgPSAxO1xuICAgICAgZ2wudW5pZm9ybTFpKHVuaWZvcm1Mb2NhdGlvbnMudU1vZGUsIG1vZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHcmF5c2NhbGUgZmlsdGVyIGlzTmV1dHJhbFN0YXRlIGltcGxlbWVudGF0aW9uXG4gICAgICogVGhlIGZpbHRlciBpcyBuZXZlciBuZXV0cmFsXG4gICAgICogb24gdGhlIGltYWdlXG4gICAgICoqL1xuICAgIGlzTmV1dHJhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkdyYXlzY2FsZX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuR3JheXNjYWxlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HcmF5c2NhbGUuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEludmVydCBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkludmVydFxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuSW52ZXJ0KCk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycyhjYW52YXMucmVuZGVyQWxsLmJpbmQoY2FudmFzKSk7XG4gICAqL1xuICBmaWx0ZXJzLkludmVydCA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5JbnZlcnQucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdJbnZlcnQnLFxuXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSBpbnQgdUludmVydDtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICdpZiAodUludmVydCA9PSAxKSB7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IHZlYzQoMS4wIC0gY29sb3IuciwxLjAgLWNvbG9yLmcsMS4wIC1jb2xvci5iLGNvbG9yLmEpO1xcbicgK1xuICAgICAgICAnfSBlbHNlIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICd9XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgaW52ZXJ0LiBpZiBmYWxzZSwgZG9lcyBub3RoaW5nXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpbnZlcnRcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGludmVydDogdHJ1ZSxcblxuICAgIG1haW5QYXJhbWV0ZXI6ICdpbnZlcnQnLFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIEludmVydCBvcGVyYXRpb24gdG8gYSBVaW50OEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4QXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBpLFxuICAgICAgICAgIGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIGRhdGFbaV0gPSAyNTUgLSBkYXRhW2ldO1xuICAgICAgICBkYXRhW2kgKyAxXSA9IDI1NSAtIGRhdGFbaSArIDFdO1xuICAgICAgICBkYXRhW2kgKyAyXSA9IDI1NSAtIGRhdGFbaSArIDJdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnZlcnQgZmlsdGVyIGlzTmV1dHJhbFN0YXRlIGltcGxlbWVudGF0aW9uXG4gICAgICogVXNlZCBvbmx5IGluIGltYWdlIGFwcGx5RmlsdGVycyB0byBkaXNjYXJkIGZpbHRlcnMgdGhhdCB3aWxsIG5vdCBoYXZlIGFuIGVmZmVjdFxuICAgICAqIG9uIHRoZSBpbWFnZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICoqL1xuICAgIGlzTmV1dHJhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhdGhpcy5pbnZlcnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1SW52ZXJ0OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VJbnZlcnQnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0xaSh1bmlmb3JtTG9jYXRpb25zLnVJbnZlcnQsIHRoaXMuaW52ZXJ0KTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkludmVydH0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuSW52ZXJ0XG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5JbnZlcnQuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZXh0ZW5kID0gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIE5vaXNlIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuTm9pc2VcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuTm9pc2UjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLk5vaXNlKHtcbiAgICogICBub2lzZTogNzAwXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKi9cbiAgZmlsdGVycy5Ob2lzZSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Ob2lzZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ05vaXNlJyxcblxuICAgIC8qKlxuICAgICAqIEZyYWdtZW50IHNvdXJjZSBmb3IgdGhlIG5vaXNlIHByb2dyYW1cbiAgICAgKi9cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwSDtcXG4nICtcbiAgICAgICd1bmlmb3JtIGZsb2F0IHVOb2lzZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIGZsb2F0IHVTZWVkO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAnZmxvYXQgcmFuZCh2ZWMyIGNvLCBmbG9hdCBzZWVkLCBmbG9hdCB2U2NhbGUpIHtcXG4nICtcbiAgICAgICAgJ3JldHVybiBmcmFjdChzaW4oZG90KGNvLnh5ICogdlNjYWxlICx2ZWMyKDEyLjk4OTggLCA3OC4yMzMpKSkgKiA0Mzc1OC41NDUzICogKHNlZWQgKyAwLjAxKSAvIDIuMCk7XFxuJyArXG4gICAgICAnfVxcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICdjb2xvci5yZ2IgKz0gKDAuNSAtIHJhbmQodlRleENvb3JkLCB1U2VlZCwgMC4xIC8gdVN0ZXBIKSkgKiB1Tm9pc2U7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIHRoZSBwcm9wZXJ0eSB0aGF0IGlzIHRoZSBmaWx0ZXIgcGFyYW1ldGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1haW5QYXJhbWV0ZXI6ICdub2lzZScsXG5cbiAgICAvKipcbiAgICAgKiBOb2lzZSB2YWx1ZSwgZnJvbVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBub2lzZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgbm9pc2U6IDAsXG5cbiAgICAvKipcbiAgICAgKiBBcHBseSB0aGUgQnJpZ2h0bmVzcyBvcGVyYXRpb24gdG8gYSBVaW50OENsYW1wZWRBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OENsYW1wZWRBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLm5vaXNlID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIGksIGxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIG5vaXNlID0gdGhpcy5ub2lzZSwgcmFuZDtcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkgKz0gNCkge1xuXG4gICAgICAgIHJhbmQgPSAoMC41IC0gTWF0aC5yYW5kb20oKSkgKiBub2lzZTtcblxuICAgICAgICBkYXRhW2ldICs9IHJhbmQ7XG4gICAgICAgIGRhdGFbaSArIDFdICs9IHJhbmQ7XG4gICAgICAgIGRhdGFbaSArIDJdICs9IHJhbmQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1Tm9pc2U6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndU5vaXNlJyksXG4gICAgICAgIHVTZWVkOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VTZWVkJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtMWYodW5pZm9ybUxvY2F0aW9ucy51Tm9pc2UsIHRoaXMubm9pc2UgLyAyNTUpO1xuICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1Mb2NhdGlvbnMudVNlZWQsIE1hdGgucmFuZG9tKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnKSwge1xuICAgICAgICBub2lzZTogdGhpcy5ub2lzZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLk5vaXNlfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Ob2lzZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuTm9pc2UuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIFBpeGVsYXRlIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuUGl4ZWxhdGVcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuUGl4ZWxhdGUjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLlBpeGVsYXRlKHtcbiAgICogICBibG9ja3NpemU6IDhcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKi9cbiAgZmlsdGVycy5QaXhlbGF0ZSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5QaXhlbGF0ZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ1BpeGVsYXRlJyxcblxuICAgIGJsb2Nrc2l6ZTogNCxcblxuICAgIG1haW5QYXJhbWV0ZXI6ICdibG9ja3NpemUnLFxuXG4gICAgLyoqXG4gICAgICogRnJhZ21lbnQgc291cmNlIGZvciB0aGUgUGl4ZWxhdGUgcHJvZ3JhbVxuICAgICAqL1xuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gZmxvYXQgdUJsb2Nrc2l6ZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwVztcXG4nICtcbiAgICAgICd1bmlmb3JtIGZsb2F0IHVTdGVwSDtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IGJsb2NrVyA9IHVCbG9ja3NpemUgKiB1U3RlcFc7XFxuJyArXG4gICAgICAgICdmbG9hdCBibG9ja0ggPSB1QmxvY2tzaXplICogdVN0ZXBXO1xcbicgK1xuICAgICAgICAnaW50IHBvc1ggPSBpbnQodlRleENvb3JkLnggLyBibG9ja1cpO1xcbicgK1xuICAgICAgICAnaW50IHBvc1kgPSBpbnQodlRleENvb3JkLnkgLyBibG9ja0gpO1xcbicgK1xuICAgICAgICAnZmxvYXQgZnBvc1ggPSBmbG9hdChwb3NYKTtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IGZwb3NZID0gZmxvYXQocG9zWSk7XFxuJyArXG4gICAgICAgICd2ZWMyIHNxdWFyZUNvb3JkcyA9IHZlYzIoZnBvc1ggKiBibG9ja1csIGZwb3NZICogYmxvY2tIKTtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHNxdWFyZUNvb3Jkcyk7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBQaXhlbGF0ZSBvcGVyYXRpb24gdG8gYSBVaW50OENsYW1wZWRBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OENsYW1wZWRBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICAgICAgaUxlbiA9IGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICAgICAgakxlbiA9IGltYWdlRGF0YS53aWR0aCxcbiAgICAgICAgICBpbmRleCwgaSwgaiwgciwgZywgYiwgYSxcbiAgICAgICAgICBfaSwgX2osIF9pTGVuLCBfakxlbjtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGlMZW47IGkgKz0gdGhpcy5ibG9ja3NpemUpIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gdGhpcy5ibG9ja3NpemUpIHtcblxuICAgICAgICAgIGluZGV4ID0gKGkgKiA0KSAqIGpMZW4gKyAoaiAqIDQpO1xuXG4gICAgICAgICAgciA9IGRhdGFbaW5kZXhdO1xuICAgICAgICAgIGcgPSBkYXRhW2luZGV4ICsgMV07XG4gICAgICAgICAgYiA9IGRhdGFbaW5kZXggKyAyXTtcbiAgICAgICAgICBhID0gZGF0YVtpbmRleCArIDNdO1xuXG4gICAgICAgICAgX2lMZW4gPSBNYXRoLm1pbihpICsgdGhpcy5ibG9ja3NpemUsIGlMZW4pO1xuICAgICAgICAgIF9qTGVuID0gTWF0aC5taW4oaiArIHRoaXMuYmxvY2tzaXplLCBqTGVuKTtcbiAgICAgICAgICBmb3IgKF9pID0gaTsgX2kgPCBfaUxlbjsgX2krKykge1xuICAgICAgICAgICAgZm9yIChfaiA9IGo7IF9qIDwgX2pMZW47IF9qKyspIHtcbiAgICAgICAgICAgICAgaW5kZXggPSAoX2kgKiA0KSAqIGpMZW4gKyAoX2ogKiA0KTtcbiAgICAgICAgICAgICAgZGF0YVtpbmRleF0gPSByO1xuICAgICAgICAgICAgICBkYXRhW2luZGV4ICsgMV0gPSBnO1xuICAgICAgICAgICAgICBkYXRhW2luZGV4ICsgMl0gPSBiO1xuICAgICAgICAgICAgICBkYXRhW2luZGV4ICsgM10gPSBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZSB3aGVuIHRoZSBmaWx0ZXIgaXMgbm90IGdvbm5hIGFwcGx5IGNoYW5nZXMgdG8gdGhlIGltYWdlXG4gICAgICoqL1xuICAgIGlzTmV1dHJhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmJsb2Nrc2l6ZSA9PT0gMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVCbG9ja3NpemU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUJsb2Nrc2l6ZScpLFxuICAgICAgICB1U3RlcFc6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVN0ZXBXJyksXG4gICAgICAgIHVTdGVwSDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1U3RlcEgnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3JtTG9jYXRpb25zLnVCbG9ja3NpemUsIHRoaXMuYmxvY2tzaXplKTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLlBpeGVsYXRlfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5QaXhlbGF0ZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuUGl4ZWxhdGUuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGV4dGVuZCA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQsXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgd2hpdGUgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVDb2xvclxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVDb2xvciNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlQ29sb3Ioe1xuICAgKiAgIHRocmVzaG9sZDogMC4yLFxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICovXG4gIGZpbHRlcnMuUmVtb3ZlQ29sb3IgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlQ29sb3IucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdSZW1vdmVDb2xvcicsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciB0byByZW1vdmUsIGluIGFueSBmb3JtYXQgdW5kZXJzdG9vZCBieSBmYWJyaWMuQ29sb3IuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNvbG9yOiAnI0ZGRkZGRicsXG5cbiAgICAvKipcbiAgICAgKiBGcmFnbWVudCBzb3VyY2UgZm9yIHRoZSBicmlnaHRuZXNzIHByb2dyYW1cbiAgICAgKi9cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIHZlYzQgdUxvdztcXG4nICtcbiAgICAgICd1bmlmb3JtIHZlYzQgdUhpZ2g7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4nICtcbiAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICdpZihhbGwoZ3JlYXRlclRoYW4oZ2xfRnJhZ0NvbG9yLnJnYix1TG93LnJnYikpICYmIGFsbChncmVhdGVyVGhhbih1SGlnaC5yZ2IsZ2xfRnJhZ0NvbG9yLnJnYikpKSB7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5hID0gMC4wO1xcbicgK1xuICAgICAgICAnfVxcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogZGlzdGFuY2UgdG8gYWN0dWFsIGNvbG9yLCBhcyB2YWx1ZSB1cCBvciBkb3duIGZyb20gZWFjaCByLGcsYlxuICAgICAqIGJldHdlZW4gMCBhbmQgMVxuICAgICAqKi9cbiAgICBkaXN0YW5jZTogMC4wMixcblxuICAgIC8qKlxuICAgICAqIEZvciBjb2xvciB0byByZW1vdmUgaW5zaWRlIGRpc3RhbmNlLCB1c2UgYWxwaGEgY2hhbm5lbCBmb3IgYSBzbW9vdGhlciBkZWxldGlvblxuICAgICAqIE5PVCBJTVBMRU1FTlRFRCBZRVRcbiAgICAgKiovXG4gICAgdXNlQWxwaGE6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlV2hpdGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb2xvcj0jUlJHR0JCXSBUaHJlc2hvbGQgdmFsdWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZGlzdGFuY2U9MTBdIERpc3RhbmNlIHZhbHVlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZpbHRlciB0byBjYW52YXMgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsIGksXG4gICAgICAgICAgZGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlICogMjU1LFxuICAgICAgICAgIHIsIGcsIGIsXG4gICAgICAgICAgc291cmNlID0gbmV3IGZhYnJpYy5Db2xvcih0aGlzLmNvbG9yKS5nZXRTb3VyY2UoKSxcbiAgICAgICAgICBsb3dDID0gW1xuICAgICAgICAgICAgc291cmNlWzBdIC0gZGlzdGFuY2UsXG4gICAgICAgICAgICBzb3VyY2VbMV0gLSBkaXN0YW5jZSxcbiAgICAgICAgICAgIHNvdXJjZVsyXSAtIGRpc3RhbmNlLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgaGlnaEMgPSBbXG4gICAgICAgICAgICBzb3VyY2VbMF0gKyBkaXN0YW5jZSxcbiAgICAgICAgICAgIHNvdXJjZVsxXSArIGRpc3RhbmNlLFxuICAgICAgICAgICAgc291cmNlWzJdICsgZGlzdGFuY2UsXG4gICAgICAgICAgXTtcblxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICByID0gZGF0YVtpXTtcbiAgICAgICAgZyA9IGRhdGFbaSArIDFdO1xuICAgICAgICBiID0gZGF0YVtpICsgMl07XG5cbiAgICAgICAgaWYgKHIgPiBsb3dDWzBdICYmXG4gICAgICAgICAgICBnID4gbG93Q1sxXSAmJlxuICAgICAgICAgICAgYiA+IGxvd0NbMl0gJiZcbiAgICAgICAgICAgIHIgPCBoaWdoQ1swXSAmJlxuICAgICAgICAgICAgZyA8IGhpZ2hDWzFdICYmXG4gICAgICAgICAgICBiIDwgaGlnaENbMl0pIHtcbiAgICAgICAgICBkYXRhW2kgKyAzXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVMb3c6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUxvdycpLFxuICAgICAgICB1SGlnaDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1SGlnaCcpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgdmFyIHNvdXJjZSA9IG5ldyBmYWJyaWMuQ29sb3IodGhpcy5jb2xvcikuZ2V0U291cmNlKCksXG4gICAgICAgICAgZGlzdGFuY2UgPSBwYXJzZUZsb2F0KHRoaXMuZGlzdGFuY2UpLFxuICAgICAgICAgIGxvd0MgPSBbXG4gICAgICAgICAgICAwICsgc291cmNlWzBdIC8gMjU1IC0gZGlzdGFuY2UsXG4gICAgICAgICAgICAwICsgc291cmNlWzFdIC8gMjU1IC0gZGlzdGFuY2UsXG4gICAgICAgICAgICAwICsgc291cmNlWzJdIC8gMjU1IC0gZGlzdGFuY2UsXG4gICAgICAgICAgICAxXG4gICAgICAgICAgXSxcbiAgICAgICAgICBoaWdoQyA9IFtcbiAgICAgICAgICAgIHNvdXJjZVswXSAvIDI1NSArIGRpc3RhbmNlLFxuICAgICAgICAgICAgc291cmNlWzFdIC8gMjU1ICsgZGlzdGFuY2UsXG4gICAgICAgICAgICBzb3VyY2VbMl0gLyAyNTUgKyBkaXN0YW5jZSxcbiAgICAgICAgICAgIDFcbiAgICAgICAgICBdO1xuICAgICAgZ2wudW5pZm9ybTRmdih1bmlmb3JtTG9jYXRpb25zLnVMb3csIGxvd0MpO1xuICAgICAgZ2wudW5pZm9ybTRmdih1bmlmb3JtTG9jYXRpb25zLnVIaWdoLCBoaWdoQyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXh0ZW5kKHRoaXMuY2FsbFN1cGVyKCd0b09iamVjdCcpLCB7XG4gICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICBkaXN0YW5jZTogdGhpcy5kaXN0YW5jZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlbW92ZUNvbG9yfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZW1vdmVXaGl0ZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuUmVtb3ZlQ29sb3IuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgdmFyIG1hdHJpY2VzID0ge1xuICAgIEJyb3duaWU6IFtcbiAgICAgIDAuNTk5NzAsMC4zNDU1MywtMC4yNzA4MiwwLDAuMTg2LFxuICAgICAgLTAuMDM3NzAsMC44NjA5NSwwLjE1MDU5LDAsLTAuMTQ0OSxcbiAgICAgIDAuMjQxMTMsLTAuMDc0NDEsMC40NDk3MiwwLC0wLjAyOTY1LFxuICAgICAgMCwwLDAsMSwwXG4gICAgXSxcbiAgICBWaW50YWdlOiBbXG4gICAgICAwLjYyNzkzLDAuMzIwMjEsLTAuMDM5NjUsMCwwLjAzNzg0LFxuICAgICAgMC4wMjU3OCwwLjY0NDExLDAuMDMyNTksMCwwLjAyOTI2LFxuICAgICAgMC4wNDY2MCwtMC4wODUxMiwwLjUyNDE2LDAsMC4wMjAyMyxcbiAgICAgIDAsMCwwLDEsMFxuICAgIF0sXG4gICAgS29kYWNocm9tZTogW1xuICAgICAgMS4xMjg1NSwtMC4zOTY3MywtMC4wMzk5MiwwLDAuMjQ5OTEsXG4gICAgICAtMC4xNjQwNCwxLjA4MzUyLC0wLjA1NDk4LDAsMC4wOTY5OCxcbiAgICAgIC0wLjE2Nzg2LC0wLjU2MDM0LDEuNjAxNDgsMCwwLjEzOTcyLFxuICAgICAgMCwwLDAsMSwwXG4gICAgXSxcbiAgICBUZWNobmljb2xvcjogW1xuICAgICAgMS45MTI1MiwtMC44NTQ1MywtMC4wOTE1NSwwLDAuMDQ2MjQsXG4gICAgICAtMC4zMDg3OCwxLjc2NTg5LC0wLjEwNjAxLDAsLTAuMjc1ODksXG4gICAgICAtMC4yMzExMCwtMC43NTAxOCwxLjg0NzU5LDAsMC4xMjEzNyxcbiAgICAgIDAsMCwwLDEsMFxuICAgIF0sXG4gICAgUG9sYXJvaWQ6IFtcbiAgICAgIDEuNDM4LC0wLjA2MiwtMC4wNjIsMCwwLFxuICAgICAgLTAuMTIyLDEuMzc4LC0wLjEyMiwwLDAsXG4gICAgICAtMC4wMTYsLTAuMDE2LDEuNDgzLDAsMCxcbiAgICAgIDAsMCwwLDEsMFxuICAgIF0sXG4gICAgU2VwaWE6IFtcbiAgICAgIDAuMzkzLCAwLjc2OSwgMC4xODksIDAsIDAsXG4gICAgICAwLjM0OSwgMC42ODYsIDAuMTY4LCAwLCAwLFxuICAgICAgMC4yNzIsIDAuNTM0LCAwLjEzMSwgMCwgMCxcbiAgICAgIDAsIDAsIDAsIDEsIDBcbiAgICBdLFxuICAgIEJsYWNrV2hpdGU6IFtcbiAgICAgIDEuNSwgMS41LCAxLjUsIDAsIC0xLFxuICAgICAgMS41LCAxLjUsIDEuNSwgMCwgLTEsXG4gICAgICAxLjUsIDEuNSwgMS41LCAwLCAtMSxcbiAgICAgIDAsIDAsIDAsIDEsIDAsXG4gICAgXVxuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBtYXRyaWNlcykge1xuICAgIGZpbHRlcnNba2V5XSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQ29sb3JNYXRyaXgsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuU2VwaWEucHJvdG90eXBlICovIHtcblxuICAgICAgLyoqXG4gICAgICAgKiBGaWx0ZXIgdHlwZVxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgICAqIEBkZWZhdWx0XG4gICAgICAgKi9cbiAgICAgIHR5cGU6IGtleSxcblxuICAgICAgLyoqXG4gICAgICAgKiBDb2xvcm1hdHJpeCBmb3IgdGhlIGVmZmVjdFxuICAgICAgICogYXJyYXkgb2YgMjAgZmxvYXRzLiBOdW1iZXJzIGluIHBvc2l0aW9ucyA0LCA5LCAxNCwgMTkgbG9vc2UgbWVhbmluZ1xuICAgICAgICogb3V0c2lkZSB0aGUgLTEsIDEgcmFuZ2UuXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBtYXRyaXggYXJyYXkgb2YgMjAgbnVtYmVycy5cbiAgICAgICAqIEBkZWZhdWx0XG4gICAgICAgKi9cbiAgICAgIG1hdHJpeDogbWF0cmljZXNba2V5XSxcblxuICAgICAgLyoqXG4gICAgICAgKiBMb2NrIHRoZSBtYXRyaXggZXhwb3J0IGZvciB0aGlzIGtpbmQgb2Ygc3RhdGljLCBwYXJhbWV0ZXIgbGVzcyBmaWx0ZXJzLlxuICAgICAgICovXG4gICAgICBtYWluUGFyYW1ldGVyOiBmYWxzZSxcbiAgICAgIC8qKlxuICAgICAgICogTG9jayB0aGUgY29sb3JtYXRyaXggb24gdGhlIGNvbG9yIHBhcnQsIHNraXBwaW5nIGFscGhhXG4gICAgICAgKi9cbiAgICAgIGNvbG9yc09ubHk6IHRydWUsXG5cbiAgICB9KTtcbiAgICBmYWJyaWMuSW1hZ2UuZmlsdGVyc1trZXldLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG4gIH1cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIENvbG9yIEJsZW5kIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlci5CbGVuZENvbG9yXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRDb2xvcih7XG4gICAqICBjb2xvcjogJyMwMDAnLFxuICAgKiAgbW9kZTogJ211bHRpcGx5J1xuICAgKiB9KTtcbiAgICpcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbGVuZEltYWdlKHtcbiAgICogIGltYWdlOiBmYWJyaWNJbWFnZU9iamVjdCxcbiAgICogIG1vZGU6ICdtdWx0aXBseScsXG4gICAqICBhbHBoYTogMC41XG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICogY2FudmFzLnJlbmRlckFsbCgpO1xuICAgKi9cblxuICBmaWx0ZXJzLkJsZW5kQ29sb3IgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmQucHJvdG90eXBlICovIHtcbiAgICB0eXBlOiAnQmxlbmRDb2xvcicsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciB0byBtYWtlIHRoZSBibGVuZCBvcGVyYXRpb24gd2l0aC4gZGVmYXVsdCB0byBhIHJlZGRpc2ggY29sb3Igc2luY2UgYmxhY2sgb3Igd2hpdGVcbiAgICAgKiBnaXZlcyBhbHdheXMgc3Ryb25nIHJlc3VsdC5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqKi9cbiAgICBjb2xvcjogJyNGOTVDNjMnLFxuXG4gICAgLyoqXG4gICAgICogQmxlbmQgbW9kZSBmb3IgdGhlIGZpbHRlcjogb25lIG9mIG11bHRpcGx5LCBhZGQsIGRpZmYsIHNjcmVlbiwgc3VidHJhY3QsXG4gICAgICogZGFya2VuLCBsaWdodGVuLCBvdmVybGF5LCBleGNsdXNpb24sIHRpbnQuXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiovXG4gICAgbW9kZTogJ211bHRpcGx5JyxcblxuICAgIC8qKlxuICAgICAqIGFscGhhIHZhbHVlLiByZXByZXNlbnQgdGhlIHN0cmVuZ3RoIG9mIHRoZSBibGVuZCBjb2xvciBvcGVyYXRpb24uXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiovXG4gICAgYWxwaGE6IDEsXG5cbiAgICAvKipcbiAgICAgKiBGcmFnbWVudCBzb3VyY2UgZm9yIHRoZSBNdWx0aXBseSBwcm9ncmFtXG4gICAgICovXG4gICAgZnJhZ21lbnRTb3VyY2U6IHtcbiAgICAgIG11bHRpcGx5OiAnZ2xfRnJhZ0NvbG9yLnJnYiAqPSB1Q29sb3IucmdiO1xcbicsXG4gICAgICBzY3JlZW46ICdnbF9GcmFnQ29sb3IucmdiID0gMS4wIC0gKDEuMCAtIGdsX0ZyYWdDb2xvci5yZ2IpICogKDEuMCAtIHVDb2xvci5yZ2IpO1xcbicsXG4gICAgICBhZGQ6ICdnbF9GcmFnQ29sb3IucmdiICs9IHVDb2xvci5yZ2I7XFxuJyxcbiAgICAgIGRpZmY6ICdnbF9GcmFnQ29sb3IucmdiID0gYWJzKGdsX0ZyYWdDb2xvci5yZ2IgLSB1Q29sb3IucmdiKTtcXG4nLFxuICAgICAgc3VidHJhY3Q6ICdnbF9GcmFnQ29sb3IucmdiIC09IHVDb2xvci5yZ2I7XFxuJyxcbiAgICAgIGxpZ2h0ZW46ICdnbF9GcmFnQ29sb3IucmdiID0gbWF4KGdsX0ZyYWdDb2xvci5yZ2IsIHVDb2xvci5yZ2IpO1xcbicsXG4gICAgICBkYXJrZW46ICdnbF9GcmFnQ29sb3IucmdiID0gbWluKGdsX0ZyYWdDb2xvci5yZ2IsIHVDb2xvci5yZ2IpO1xcbicsXG4gICAgICBleGNsdXNpb246ICdnbF9GcmFnQ29sb3IucmdiICs9IHVDb2xvci5yZ2IgLSAyLjAgKiAodUNvbG9yLnJnYiAqIGdsX0ZyYWdDb2xvci5yZ2IpO1xcbicsXG4gICAgICBvdmVybGF5OiAnaWYgKHVDb2xvci5yIDwgMC41KSB7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5yICo9IDIuMCAqIHVDb2xvci5yO1xcbicgK1xuICAgICAgICAnfSBlbHNlIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLnIgPSAxLjAgLSAyLjAgKiAoMS4wIC0gZ2xfRnJhZ0NvbG9yLnIpICogKDEuMCAtIHVDb2xvci5yKTtcXG4nICtcbiAgICAgICAgJ31cXG4nICtcbiAgICAgICAgJ2lmICh1Q29sb3IuZyA8IDAuNSkge1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IuZyAqPSAyLjAgKiB1Q29sb3IuZztcXG4nICtcbiAgICAgICAgJ30gZWxzZSB7XFxuJyArXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvci5nID0gMS4wIC0gMi4wICogKDEuMCAtIGdsX0ZyYWdDb2xvci5nKSAqICgxLjAgLSB1Q29sb3IuZyk7XFxuJyArXG4gICAgICAgICd9XFxuJyArXG4gICAgICAgICdpZiAodUNvbG9yLmIgPCAwLjUpIHtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yLmIgKj0gMi4wICogdUNvbG9yLmI7XFxuJyArXG4gICAgICAgICd9IGVsc2Uge1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IuYiA9IDEuMCAtIDIuMCAqICgxLjAgLSBnbF9GcmFnQ29sb3IuYikgKiAoMS4wIC0gdUNvbG9yLmIpO1xcbicgK1xuICAgICAgICAnfVxcbicsXG4gICAgICB0aW50OiAnZ2xfRnJhZ0NvbG9yLnJnYiAqPSAoMS4wIC0gdUNvbG9yLmEpO1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yLnJnYiArPSB1Q29sb3IucmdiO1xcbicsXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGJ1aWxkIHRoZSBmcmFnbWVudCBzb3VyY2UgZm9yIHRoZSBmaWx0ZXJzLCBqb2luaW5nIHRoZSBjb21tb24gcGFydCB3aXRoXG4gICAgICogdGhlIHNwZWNpZmljIG9uZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbW9kZSB0aGUgbW9kZSBvZiB0aGUgZmlsdGVyLCBhIGtleSBvZiB0aGlzLmZyYWdtZW50U291cmNlXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgc291cmNlIHRvIGJlIGNvbXBpbGVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBidWlsZFNvdXJjZTogZnVuY3Rpb24obW9kZSkge1xuICAgICAgcmV0dXJuICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gdmVjNCB1Q29sb3I7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAgICd2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpO1xcbicgK1xuICAgICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICAgICAnaWYgKGNvbG9yLmEgPiAwLjApIHtcXG4nICtcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRTb3VyY2VbbW9kZV0gK1xuICAgICAgICAgICd9XFxuJyArXG4gICAgICAgICd9JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjYWNoZWQgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAgICovXG4gICAgcmV0cmlldmVTaGFkZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjYWNoZUtleSA9IHRoaXMudHlwZSArICdfJyArIHRoaXMubW9kZSwgc2hhZGVyU291cmNlO1xuICAgICAgaWYgKCFvcHRpb25zLnByb2dyYW1DYWNoZS5oYXNPd25Qcm9wZXJ0eShjYWNoZUtleSkpIHtcbiAgICAgICAgc2hhZGVyU291cmNlID0gdGhpcy5idWlsZFNvdXJjZSh0aGlzLm1vZGUpO1xuICAgICAgICBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV0gPSB0aGlzLmNyZWF0ZVByb2dyYW0ob3B0aW9ucy5jb250ZXh0LCBzaGFkZXJTb3VyY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIEJsZW5kIG9wZXJhdGlvbiB0byBhIFVpbnQ4Q2xhbXBlZEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4Q2xhbXBlZEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgaUxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIHRyLCB0ZywgdGIsXG4gICAgICAgICAgciwgZywgYixcbiAgICAgICAgICBzb3VyY2UsIGFscGhhMSA9IDEgLSB0aGlzLmFscGhhO1xuXG4gICAgICBzb3VyY2UgPSBuZXcgZmFicmljLkNvbG9yKHRoaXMuY29sb3IpLmdldFNvdXJjZSgpO1xuICAgICAgdHIgPSBzb3VyY2VbMF0gKiB0aGlzLmFscGhhO1xuICAgICAgdGcgPSBzb3VyY2VbMV0gKiB0aGlzLmFscGhhO1xuICAgICAgdGIgPSBzb3VyY2VbMl0gKiB0aGlzLmFscGhhO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlMZW47IGkgKz0gNCkge1xuXG4gICAgICAgIHIgPSBkYXRhW2ldO1xuICAgICAgICBnID0gZGF0YVtpICsgMV07XG4gICAgICAgIGIgPSBkYXRhW2kgKyAyXTtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgICAgICAgIGNhc2UgJ211bHRpcGx5JzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSByICogdHIgLyAyNTU7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IGcgKiB0ZyAvIDI1NTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gYiAqIHRiIC8gMjU1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc2NyZWVuJzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSAyNTUgLSAoMjU1IC0gcikgKiAoMjU1IC0gdHIpIC8gMjU1O1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSAyNTUgLSAoMjU1IC0gZykgKiAoMjU1IC0gdGcpIC8gMjU1O1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSAyNTUgLSAoMjU1IC0gYikgKiAoMjU1IC0gdGIpIC8gMjU1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYWRkJzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSByICsgdHI7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IGcgKyB0ZztcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gYiArIHRiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZGlmZic6XG4gICAgICAgICAgY2FzZSAnZGlmZmVyZW5jZSc6XG4gICAgICAgICAgICBkYXRhW2ldID0gTWF0aC5hYnMociAtIHRyKTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gTWF0aC5hYnMoZyAtIHRnKTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gTWF0aC5hYnMoYiAtIHRiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3N1YnRyYWN0JzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSByIC0gdHI7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IGcgLSB0ZztcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gYiAtIHRiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZGFya2VuJzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSBNYXRoLm1pbihyLCB0cik7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IE1hdGgubWluKGcsIHRnKTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gTWF0aC5taW4oYiwgdGIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbGlnaHRlbic6XG4gICAgICAgICAgICBkYXRhW2ldID0gTWF0aC5tYXgociwgdHIpO1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSBNYXRoLm1heChnLCB0Zyk7XG4gICAgICAgICAgICBkYXRhW2kgKyAyXSA9IE1hdGgubWF4KGIsIHRiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ292ZXJsYXknOlxuICAgICAgICAgICAgZGF0YVtpXSA9IHRyIDwgMTI4ID8gKDIgKiByICogdHIgLyAyNTUpIDogKDI1NSAtIDIgKiAoMjU1IC0gcikgKiAoMjU1IC0gdHIpIC8gMjU1KTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gdGcgPCAxMjggPyAoMiAqIGcgKiB0ZyAvIDI1NSkgOiAoMjU1IC0gMiAqICgyNTUgLSBnKSAqICgyNTUgLSB0ZykgLyAyNTUpO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSB0YiA8IDEyOCA/ICgyICogYiAqIHRiIC8gMjU1KSA6ICgyNTUgLSAyICogKDI1NSAtIGIpICogKDI1NSAtIHRiKSAvIDI1NSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdleGNsdXNpb24nOlxuICAgICAgICAgICAgZGF0YVtpXSA9IHRyICsgciAtICgoMiAqIHRyICogcikgLyAyNTUpO1xuICAgICAgICAgICAgZGF0YVtpICsgMV0gPSB0ZyArIGcgLSAoKDIgKiB0ZyAqIGcpIC8gMjU1KTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gdGIgKyBiIC0gKCgyICogdGIgKiBiKSAvIDI1NSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd0aW50JzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSB0ciArIHIgKiBhbHBoYTE7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IHRnICsgZyAqIGFscGhhMTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gdGIgKyBiICogYWxwaGExO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1Q29sb3I6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUNvbG9yJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICB2YXIgc291cmNlID0gbmV3IGZhYnJpYy5Db2xvcih0aGlzLmNvbG9yKS5nZXRTb3VyY2UoKTtcbiAgICAgIHNvdXJjZVswXSA9IHRoaXMuYWxwaGEgKiBzb3VyY2VbMF0gLyAyNTU7XG4gICAgICBzb3VyY2VbMV0gPSB0aGlzLmFscGhhICogc291cmNlWzFdIC8gMjU1O1xuICAgICAgc291cmNlWzJdID0gdGhpcy5hbHBoYSAqIHNvdXJjZVsyXSAvIDI1NTtcbiAgICAgIHNvdXJjZVszXSA9IHRoaXMuYWxwaGE7XG4gICAgICBnbC51bmlmb3JtNGZ2KHVuaWZvcm1Mb2NhdGlvbnMudUNvbG9yLCBzb3VyY2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBjb2xvcjogdGhpcy5jb2xvcixcbiAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICBhbHBoYTogdGhpcy5hbHBoYVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRDb2xvcn0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRDb2xvclxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRDb2xvci5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyA9IGdsb2JhbC5mYWJyaWMsXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBJbWFnZSBCbGVuZCBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXIuQmxlbmRJbWFnZVxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kQ29sb3Ioe1xuICAgKiAgY29sb3I6ICcjMDAwJyxcbiAgICogIG1vZGU6ICdtdWx0aXBseSdcbiAgICogfSk7XG4gICAqXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuQmxlbmRJbWFnZSh7XG4gICAqICBpbWFnZTogZmFicmljSW1hZ2VPYmplY3QsXG4gICAqICBtb2RlOiAnbXVsdGlwbHknLFxuICAgKiAgYWxwaGE6IDAuNVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqIGNhbnZhcy5yZW5kZXJBbGwoKTtcbiAgICovXG5cbiAgZmlsdGVycy5CbGVuZEltYWdlID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kSW1hZ2UucHJvdG90eXBlICovIHtcbiAgICB0eXBlOiAnQmxlbmRJbWFnZScsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciB0byBtYWtlIHRoZSBibGVuZCBvcGVyYXRpb24gd2l0aC4gZGVmYXVsdCB0byBhIHJlZGRpc2ggY29sb3Igc2luY2UgYmxhY2sgb3Igd2hpdGVcbiAgICAgKiBnaXZlcyBhbHdheXMgc3Ryb25nIHJlc3VsdC5cbiAgICAgKiovXG4gICAgaW1hZ2U6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBCbGVuZCBtb2RlIGZvciB0aGUgZmlsdGVyIChvbmUgb2YgXCJtdWx0aXBseVwiLCBcIm1hc2tcIilcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqKi9cbiAgICBtb2RlOiAnbXVsdGlwbHknLFxuXG4gICAgLyoqXG4gICAgICogYWxwaGEgdmFsdWUuIHJlcHJlc2VudCB0aGUgc3RyZW5ndGggb2YgdGhlIGJsZW5kIGltYWdlIG9wZXJhdGlvbi5cbiAgICAgKiBub3QgaW1wbGVtZW50ZWQuXG4gICAgICoqL1xuICAgIGFscGhhOiAxLFxuXG4gICAgdmVydGV4U291cmNlOiAnYXR0cmlidXRlIHZlYzIgYVBvc2l0aW9uO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDI7XFxuJyArXG4gICAgICAndW5pZm9ybSBtYXQzIHVUcmFuc2Zvcm1NYXRyaXg7XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAndlRleENvb3JkID0gYVBvc2l0aW9uO1xcbicgK1xuICAgICAgICAndlRleENvb3JkMiA9ICh1VHJhbnNmb3JtTWF0cml4ICogdmVjMyhhUG9zaXRpb24sIDEuMCkpLnh5O1xcbicgK1xuICAgICAgICAnZ2xfUG9zaXRpb24gPSB2ZWM0KGFQb3NpdGlvbiAqIDIuMCAtIDEuMCwgMC4wLCAxLjApO1xcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogRnJhZ21lbnQgc291cmNlIGZvciB0aGUgTXVsdGlwbHkgcHJvZ3JhbVxuICAgICAqL1xuICAgIGZyYWdtZW50U291cmNlOiB7XG4gICAgICBtdWx0aXBseTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdUltYWdlO1xcbicgK1xuICAgICAgICAndW5pZm9ybSB2ZWM0IHVDb2xvcjtcXG4nICtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkMjtcXG4nICtcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgICAndmVjNCBjb2xvcjIgPSB0ZXh0dXJlMkQodUltYWdlLCB2VGV4Q29vcmQyKTtcXG4nICtcbiAgICAgICAgICAnY29sb3IucmdiYSAqPSBjb2xvcjIucmdiYTtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICAgIG1hc2s6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVJbWFnZTtcXG4nICtcbiAgICAgICAgJ3VuaWZvcm0gdmVjNCB1Q29sb3I7XFxuJyArXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgICAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDI7XFxuJyArXG4gICAgICAgICd2b2lkIG1haW4oKSB7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICAgJ3ZlYzQgY29sb3IyID0gdGV4dHVyZTJEKHVJbWFnZSwgdlRleENvb3JkMik7XFxuJyArXG4gICAgICAgICAgJ2NvbG9yLmEgPSBjb2xvcjIuYTtcXG4nICtcbiAgICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICd9JyxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjYWNoZWQgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IG9wdGlvbnMuY29udGV4dCBUaGUgR0wgY29udGV4dCB1c2VkIGZvciByZW5kZXJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucHJvZ3JhbUNhY2hlIEEgbWFwIG9mIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtcywga2V5ZWQgYnkgZmlsdGVyIHR5cGUuXG4gICAgICovXG4gICAgcmV0cmlldmVTaGFkZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjYWNoZUtleSA9IHRoaXMudHlwZSArICdfJyArIHRoaXMubW9kZTtcbiAgICAgIHZhciBzaGFkZXJTb3VyY2UgPSB0aGlzLmZyYWdtZW50U291cmNlW3RoaXMubW9kZV07XG4gICAgICBpZiAoIW9wdGlvbnMucHJvZ3JhbUNhY2hlLmhhc093blByb3BlcnR5KGNhY2hlS2V5KSkge1xuICAgICAgICBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV0gPSB0aGlzLmNyZWF0ZVByb2dyYW0ob3B0aW9ucy5jb250ZXh0LCBzaGFkZXJTb3VyY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XTtcbiAgICB9LFxuXG4gICAgYXBwbHlUb1dlYkdMOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAvLyBsb2FkIHRleHR1cmUgdG8gYmxlbmQuXG4gICAgICB2YXIgZ2wgPSBvcHRpb25zLmNvbnRleHQsXG4gICAgICAgICAgdGV4dHVyZSA9IHRoaXMuY3JlYXRlVGV4dHVyZShvcHRpb25zLmZpbHRlckJhY2tlbmQsIHRoaXMuaW1hZ2UpO1xuICAgICAgdGhpcy5iaW5kQWRkaXRpb25hbFRleHR1cmUoZ2wsIHRleHR1cmUsIGdsLlRFWFRVUkUxKTtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdhcHBseVRvV2ViR0wnLCBvcHRpb25zKTtcbiAgICAgIHRoaXMudW5iaW5kQWRkaXRpb25hbFRleHR1cmUoZ2wsIGdsLlRFWFRVUkUxKTtcbiAgICB9LFxuXG4gICAgY3JlYXRlVGV4dHVyZTogZnVuY3Rpb24oYmFja2VuZCwgaW1hZ2UpIHtcbiAgICAgIHJldHVybiBiYWNrZW5kLmdldENhY2hlZFRleHR1cmUoaW1hZ2UuY2FjaGVLZXksIGltYWdlLl9lbGVtZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGEgdHJhbnNmb3JtTWF0cml4IHRvIGFkYXB0IHRoZSBpbWFnZSB0byBibGVuZCBvdmVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAgKi9cbiAgICBjYWxjdWxhdGVNYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGltYWdlID0gdGhpcy5pbWFnZSxcbiAgICAgICAgICB3aWR0aCA9IGltYWdlLl9lbGVtZW50LndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IGltYWdlLl9lbGVtZW50LmhlaWdodDtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIDEgLyBpbWFnZS5zY2FsZVgsIDAsIDAsXG4gICAgICAgIDAsIDEgLyBpbWFnZS5zY2FsZVksIDAsXG4gICAgICAgIC1pbWFnZS5sZWZ0IC8gd2lkdGgsIC1pbWFnZS50b3AgLyBoZWlnaHQsIDFcbiAgICAgIF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBCbGVuZCBvcGVyYXRpb24gdG8gYSBVaW50OENsYW1wZWRBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OENsYW1wZWRBcnJheSB0byBiZSBmaWx0ZXJlZC5cbiAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICByZXNvdXJjZXMgPSBvcHRpb25zLmZpbHRlckJhY2tlbmQucmVzb3VyY2VzLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgaUxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIHdpZHRoID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICAgICAgdHIsIHRnLCB0YiwgdGEsXG4gICAgICAgICAgciwgZywgYiwgYSxcbiAgICAgICAgICBjYW52YXMxLCBjb250ZXh0LCBpbWFnZSA9IHRoaXMuaW1hZ2UsIGJsZW5kRGF0YTtcblxuICAgICAgaWYgKCFyZXNvdXJjZXMuYmxlbmRJbWFnZSkge1xuICAgICAgICByZXNvdXJjZXMuYmxlbmRJbWFnZSA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIH1cbiAgICAgIGNhbnZhczEgPSByZXNvdXJjZXMuYmxlbmRJbWFnZTtcbiAgICAgIGNvbnRleHQgPSBjYW52YXMxLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBpZiAoY2FudmFzMS53aWR0aCAhPT0gd2lkdGggfHwgY2FudmFzMS5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICBjYW52YXMxLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGNhbnZhczEuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oaW1hZ2Uuc2NhbGVYLCAwLCAwLCBpbWFnZS5zY2FsZVksIGltYWdlLmxlZnQsIGltYWdlLnRvcCk7XG4gICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZS5fZWxlbWVudCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBibGVuZERhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpTGVuOyBpICs9IDQpIHtcblxuICAgICAgICByID0gZGF0YVtpXTtcbiAgICAgICAgZyA9IGRhdGFbaSArIDFdO1xuICAgICAgICBiID0gZGF0YVtpICsgMl07XG4gICAgICAgIGEgPSBkYXRhW2kgKyAzXTtcblxuICAgICAgICB0ciA9IGJsZW5kRGF0YVtpXTtcbiAgICAgICAgdGcgPSBibGVuZERhdGFbaSArIDFdO1xuICAgICAgICB0YiA9IGJsZW5kRGF0YVtpICsgMl07XG4gICAgICAgIHRhID0gYmxlbmREYXRhW2kgKyAzXTtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgICAgICAgIGNhc2UgJ211bHRpcGx5JzpcbiAgICAgICAgICAgIGRhdGFbaV0gPSByICogdHIgLyAyNTU7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IGcgKiB0ZyAvIDI1NTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gYiAqIHRiIC8gMjU1O1xuICAgICAgICAgICAgZGF0YVtpICsgM10gPSBhICogdGEgLyAyNTU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdtYXNrJzpcbiAgICAgICAgICAgIGRhdGFbaSArIDNdID0gdGE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdVRyYW5zZm9ybU1hdHJpeDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1VHJhbnNmb3JtTWF0cml4JyksXG4gICAgICAgIHVJbWFnZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1SW1hZ2UnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIHZhciBtYXRyaXggPSB0aGlzLmNhbGN1bGF0ZU1hdHJpeCgpO1xuICAgICAgZ2wudW5pZm9ybTFpKHVuaWZvcm1Mb2NhdGlvbnMudUltYWdlLCAxKTsgLy8gdGV4dHVyZSB1bml0IDEuXG4gICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHVuaWZvcm1Mb2NhdGlvbnMudVRyYW5zZm9ybU1hdHJpeCwgZmFsc2UsIG1hdHJpeCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGltYWdlOiB0aGlzLmltYWdlICYmIHRoaXMuaW1hZ2UudG9PYmplY3QoKSxcbiAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICBhbHBoYTogdGhpcy5hbHBoYVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kSW1hZ2V9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kSW1hZ2VcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kSW1hZ2UuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICBmYWJyaWMuSW1hZ2UuZnJvbU9iamVjdChvYmplY3QuaW1hZ2UsIGZ1bmN0aW9uKGltYWdlKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZShvYmplY3QpO1xuICAgICAgb3B0aW9ucy5pbWFnZSA9IGltYWdlO1xuICAgICAgY2FsbGJhY2sobmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJsZW5kSW1hZ2Uob3B0aW9ucykpO1xuICAgIH0pO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLCBwb3cgPSBNYXRoLnBvdywgZmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgc3FydCA9IE1hdGguc3FydCwgYWJzID0gTWF0aC5hYnMsIHJvdW5kID0gTWF0aC5yb3VuZCwgc2luID0gTWF0aC5zaW4sXG4gICAgICBjZWlsID0gTWF0aC5jZWlsLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogUmVzaXplIGltYWdlIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuUmVzaXplXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZXNpemUoKTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKGNhbnZhcy5yZW5kZXJBbGwuYmluZChjYW52YXMpKTtcbiAgICovXG4gIGZpbHRlcnMuUmVzaXplID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5CYXNlRmlsdGVyLCAvKiogQGxlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlc2l6ZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ1Jlc2l6ZScsXG5cbiAgICAvKipcbiAgICAgKiBSZXNpemUgdHlwZVxuICAgICAqIGZvciB3ZWJnbCByZXNpemVUeXBlIGlzIGp1c3QgbGFuY3pvcywgZm9yIGNhbnZhczJkIGNhbiBiZTpcbiAgICAgKiBiaWxpbmVhciwgaGVybWl0ZSwgc2xpY2VIYWNrLCBsYW5jem9zLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXNpemVUeXBlXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICByZXNpemVUeXBlOiAnaGVybWl0ZScsXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZSBmYWN0b3IgZm9yIHJlc2l6aW5nLCB4IGF4aXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVYXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzY2FsZVg6IDEsXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZSBmYWN0b3IgZm9yIHJlc2l6aW5nLCB5IGF4aXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVZXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzY2FsZVk6IDEsXG5cbiAgICAvKipcbiAgICAgKiBMYW5jem9zTG9iZXMgcGFyYW1ldGVyIGZvciBsYW5jem9zIGZpbHRlciwgdmFsaWQgZm9yIHJlc2l6ZVR5cGUgbGFuY3pvc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsYW5jem9zTG9iZXNcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxhbmN6b3NMb2JlczogMyxcblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVEZWx0YTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1RGVsdGEnKSxcbiAgICAgICAgdVRhcHM6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVRhcHMnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0yZnYodW5pZm9ybUxvY2F0aW9ucy51RGVsdGEsIHRoaXMuaG9yaXpvbnRhbCA/IFsxIC8gdGhpcy53aWR0aCwgMF0gOiBbMCwgMSAvIHRoaXMuaGVpZ2h0XSk7XG4gICAgICBnbC51bmlmb3JtMWZ2KHVuaWZvcm1Mb2NhdGlvbnMudVRhcHMsIHRoaXMudGFwcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgY2FjaGVkIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgICAqL1xuICAgIHJldHJpZXZlU2hhZGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgZmlsdGVyV2luZG93ID0gdGhpcy5nZXRGaWx0ZXJXaW5kb3coKSwgY2FjaGVLZXkgPSB0aGlzLnR5cGUgKyAnXycgKyBmaWx0ZXJXaW5kb3c7XG4gICAgICBpZiAoIW9wdGlvbnMucHJvZ3JhbUNhY2hlLmhhc093blByb3BlcnR5KGNhY2hlS2V5KSkge1xuICAgICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmdlbmVyYXRlU2hhZGVyKGZpbHRlcldpbmRvdyk7XG4gICAgICAgIG9wdGlvbnMucHJvZ3JhbUNhY2hlW2NhY2hlS2V5XSA9IHRoaXMuY3JlYXRlUHJvZ3JhbShvcHRpb25zLmNvbnRleHQsIGZyYWdtZW50U2hhZGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLnByb2dyYW1DYWNoZVtjYWNoZUtleV07XG4gICAgfSxcblxuICAgIGdldEZpbHRlcldpbmRvdzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2NhbGUgPSB0aGlzLnRlbXBTY2FsZTtcbiAgICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5sYW5jem9zTG9iZXMgLyBzY2FsZSk7XG4gICAgfSxcblxuICAgIGdldFRhcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxvYmVGdW5jdGlvbiA9IHRoaXMubGFuY3pvc0NyZWF0ZSh0aGlzLmxhbmN6b3NMb2JlcyksIHNjYWxlID0gdGhpcy50ZW1wU2NhbGUsXG4gICAgICAgICAgZmlsdGVyV2luZG93ID0gdGhpcy5nZXRGaWx0ZXJXaW5kb3coKSwgdGFwcyA9IG5ldyBBcnJheShmaWx0ZXJXaW5kb3cpO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gZmlsdGVyV2luZG93OyBpKyspIHtcbiAgICAgICAgdGFwc1tpIC0gMV0gPSBsb2JlRnVuY3Rpb24oaSAqIHNjYWxlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXBzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB2ZXJ0ZXggYW5kIHNoYWRlciBzb3VyY2VzIGZyb20gdGhlIG5lY2Vzc2FyeSBzdGVwcyBudW1iZXJzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGZpbHRlcldpbmRvd1xuICAgICAqL1xuICAgIGdlbmVyYXRlU2hhZGVyOiBmdW5jdGlvbihmaWx0ZXJXaW5kb3cpIHtcbiAgICAgIHZhciBvZmZzZXRzID0gbmV3IEFycmF5KGZpbHRlcldpbmRvdyksXG4gICAgICAgICAgZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmZyYWdtZW50U291cmNlVE9QLCBmaWx0ZXJXaW5kb3c7XG5cbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IGZpbHRlcldpbmRvdzsgaSsrKSB7XG4gICAgICAgIG9mZnNldHNbaSAtIDFdID0gaSArICcuMCAqIHVEZWx0YSc7XG4gICAgICB9XG5cbiAgICAgIGZyYWdtZW50U2hhZGVyICs9ICd1bmlmb3JtIGZsb2F0IHVUYXBzWycgKyBmaWx0ZXJXaW5kb3cgKyAnXTtcXG4nO1xuICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJ3ZvaWQgbWFpbigpIHtcXG4nO1xuICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJyAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nO1xuICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJyAgZmxvYXQgc3VtID0gMS4wO1xcbic7XG5cbiAgICAgIG9mZnNldHMuZm9yRWFjaChmdW5jdGlvbihvZmZzZXQsIGkpIHtcbiAgICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJyAgY29sb3IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyAnICsgb2Zmc2V0ICsgJykgKiB1VGFwc1snICsgaSArICddO1xcbic7XG4gICAgICAgIGZyYWdtZW50U2hhZGVyICs9ICcgIGNvbG9yICs9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkIC0gJyArIG9mZnNldCArICcpICogdVRhcHNbJyArIGkgKyAnXTtcXG4nO1xuICAgICAgICBmcmFnbWVudFNoYWRlciArPSAnICBzdW0gKz0gMi4wICogdVRhcHNbJyArIGkgKyAnXTtcXG4nO1xuICAgICAgfSk7XG4gICAgICBmcmFnbWVudFNoYWRlciArPSAnICBnbF9GcmFnQ29sb3IgPSBjb2xvciAvIHN1bTtcXG4nO1xuICAgICAgZnJhZ21lbnRTaGFkZXIgKz0gJ30nO1xuICAgICAgcmV0dXJuIGZyYWdtZW50U2hhZGVyO1xuICAgIH0sXG5cbiAgICBmcmFnbWVudFNvdXJjZVRPUDogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIHZlYzIgdURlbHRhO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSByZXNpemUgZmlsdGVyIHRvIHRoZSBpbWFnZVxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0byB1c2UgV2ViR0wgb3IgQ2FudmFzMkQgYmFzZWQgb24gdGhlIG9wdGlvbnMud2ViZ2wgZmxhZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMucGFzc2VzIFRoZSBudW1iZXIgb2YgZmlsdGVycyByZW1haW5pbmcgdG8gYmUgZXhlY3V0ZWRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMud2ViZ2wgV2hldGhlciB0byB1c2Ugd2ViZ2wgdG8gcmVuZGVyIHRoZSBmaWx0ZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IG9wdGlvbnMuc291cmNlVGV4dHVyZSBUaGUgdGV4dHVyZSBzZXR1cCBhcyB0aGUgc291cmNlIHRvIGJlIGZpbHRlcmVkLlxuICAgICAqIEBwYXJhbSB7V2ViR0xUZXh0dXJlfSBvcHRpb25zLnRhcmdldFRleHR1cmUgVGhlIHRleHR1cmUgd2hlcmUgZmlsdGVyZWQgb3V0cHV0IHNob3VsZCBiZSBkcmF3bi5cbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gb3B0aW9ucy5jb250ZXh0IFRoZSBHTCBjb250ZXh0IHVzZWQgZm9yIHJlbmRlcmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wcm9ncmFtQ2FjaGUgQSBtYXAgb2YgY29tcGlsZWQgc2hhZGVyIHByb2dyYW1zLCBrZXllZCBieSBmaWx0ZXIgdHlwZS5cbiAgICAgKi9cbiAgICBhcHBseVRvOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy53ZWJnbCkge1xuICAgICAgICBvcHRpb25zLnBhc3NlcysrO1xuICAgICAgICB0aGlzLndpZHRoID0gb3B0aW9ucy5zb3VyY2VXaWR0aDtcbiAgICAgICAgdGhpcy5ob3Jpem9udGFsID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kVyA9IE1hdGgucm91bmQodGhpcy53aWR0aCAqIHRoaXMuc2NhbGVYKTtcbiAgICAgICAgdGhpcy5kSCA9IG9wdGlvbnMuc291cmNlSGVpZ2h0O1xuICAgICAgICB0aGlzLnRlbXBTY2FsZSA9IHRoaXMuZFcgLyB0aGlzLndpZHRoO1xuICAgICAgICB0aGlzLnRhcHMgPSB0aGlzLmdldFRhcHMoKTtcbiAgICAgICAgb3B0aW9ucy5kZXN0aW5hdGlvbldpZHRoID0gdGhpcy5kVztcbiAgICAgICAgdGhpcy5fc2V0dXBGcmFtZUJ1ZmZlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5hcHBseVRvV2ViR0wob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3N3YXBUZXh0dXJlcyhvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy5zb3VyY2VXaWR0aCA9IG9wdGlvbnMuZGVzdGluYXRpb25XaWR0aDtcblxuICAgICAgICB0aGlzLmhlaWdodCA9IG9wdGlvbnMuc291cmNlSGVpZ2h0O1xuICAgICAgICB0aGlzLmhvcml6b250YWwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kSCA9IE1hdGgucm91bmQodGhpcy5oZWlnaHQgKiB0aGlzLnNjYWxlWSk7XG4gICAgICAgIHRoaXMudGVtcFNjYWxlID0gdGhpcy5kSCAvIHRoaXMuaGVpZ2h0O1xuICAgICAgICB0aGlzLnRhcHMgPSB0aGlzLmdldFRhcHMoKTtcbiAgICAgICAgb3B0aW9ucy5kZXN0aW5hdGlvbkhlaWdodCA9IHRoaXMuZEg7XG4gICAgICAgIHRoaXMuX3NldHVwRnJhbWVCdWZmZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYXBwbHlUb1dlYkdMKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9zd2FwVGV4dHVyZXMob3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMuc291cmNlSGVpZ2h0ID0gb3B0aW9ucy5kZXN0aW5hdGlvbkhlaWdodDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmFwcGx5VG8yZChvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaXNOZXV0cmFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2NhbGVYID09PSAxICYmIHRoaXMuc2NhbGVZID09PSAxO1xuICAgIH0sXG5cbiAgICBsYW5jem9zQ3JlYXRlOiBmdW5jdGlvbihsb2Jlcykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgaWYgKHggPj0gbG9iZXMgfHwgeCA8PSAtbG9iZXMpIHtcbiAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4IDwgMS4xOTIwOTI5MEUtMDcgJiYgeCA+IC0xLjE5MjA5MjkwRS0wNykge1xuICAgICAgICAgIHJldHVybiAxLjA7XG4gICAgICAgIH1cbiAgICAgICAgeCAqPSBNYXRoLlBJO1xuICAgICAgICB2YXIgeHggPSB4IC8gbG9iZXM7XG4gICAgICAgIHJldHVybiAoc2luKHgpIC8geCkgKiBzaW4oeHgpIC8geHg7XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZpbHRlciB0byBjYW52YXMgZWxlbWVudFxuICAgICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZXNpemUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZVhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVZXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgc2NhbGVYID0gdGhpcy5zY2FsZVgsXG4gICAgICAgICAgc2NhbGVZID0gdGhpcy5zY2FsZVk7XG5cbiAgICAgIHRoaXMucmNwU2NhbGVYID0gMSAvIHNjYWxlWDtcbiAgICAgIHRoaXMucmNwU2NhbGVZID0gMSAvIHNjYWxlWTtcblxuICAgICAgdmFyIG9XID0gaW1hZ2VEYXRhLndpZHRoLCBvSCA9IGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICAgICAgZFcgPSByb3VuZChvVyAqIHNjYWxlWCksIGRIID0gcm91bmQob0ggKiBzY2FsZVkpLFxuICAgICAgICAgIG5ld0RhdGE7XG5cbiAgICAgIGlmICh0aGlzLnJlc2l6ZVR5cGUgPT09ICdzbGljZUhhY2snKSB7XG4gICAgICAgIG5ld0RhdGEgPSB0aGlzLnNsaWNlQnlUd28ob3B0aW9ucywgb1csIG9ILCBkVywgZEgpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5yZXNpemVUeXBlID09PSAnaGVybWl0ZScpIHtcbiAgICAgICAgbmV3RGF0YSA9IHRoaXMuaGVybWl0ZUZhc3RSZXNpemUob3B0aW9ucywgb1csIG9ILCBkVywgZEgpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5yZXNpemVUeXBlID09PSAnYmlsaW5lYXInKSB7XG4gICAgICAgIG5ld0RhdGEgPSB0aGlzLmJpbGluZWFyRmlsdGVyaW5nKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMucmVzaXplVHlwZSA9PT0gJ2xhbmN6b3MnKSB7XG4gICAgICAgIG5ld0RhdGEgPSB0aGlzLmxhbmN6b3NSZXNpemUob3B0aW9ucywgb1csIG9ILCBkVywgZEgpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5pbWFnZURhdGEgPSBuZXdEYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgc2xpY2VCeVR3b1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW52YXNFbCBDYW52YXMgZWxlbWVudCB0byBhcHBseSBmaWx0ZXIgdG9cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb1cgT3JpZ2luYWwgV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb0ggT3JpZ2luYWwgSGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRXIERlc3RpbmF0aW9uIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRIIERlc3RpbmF0aW9uIEhlaWdodFxuICAgICAqIEByZXR1cm5zIHtJbWFnZURhdGF9XG4gICAgICovXG4gICAgc2xpY2VCeVR3bzogZnVuY3Rpb24ob3B0aW9ucywgb1csIG9ILCBkVywgZEgpIHtcbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSxcbiAgICAgICAgICBtdWx0ID0gMC41LCBkb25lVyA9IGZhbHNlLCBkb25lSCA9IGZhbHNlLCBzdGVwVyA9IG9XICogbXVsdCxcbiAgICAgICAgICBzdGVwSCA9IG9IICogbXVsdCwgcmVzb3VyY2VzID0gZmFicmljLmZpbHRlckJhY2tlbmQucmVzb3VyY2VzLFxuICAgICAgICAgIHRtcENhbnZhcywgY3R4LCBzWCA9IDAsIHNZID0gMCwgZFggPSBvVywgZFkgPSAwO1xuICAgICAgaWYgKCFyZXNvdXJjZXMuc2xpY2VCeVR3bykge1xuICAgICAgICByZXNvdXJjZXMuc2xpY2VCeVR3byA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgfVxuICAgICAgdG1wQ2FudmFzID0gcmVzb3VyY2VzLnNsaWNlQnlUd287XG4gICAgICBpZiAodG1wQ2FudmFzLndpZHRoIDwgb1cgKiAxLjUgfHwgdG1wQ2FudmFzLmhlaWdodCA8IG9IKSB7XG4gICAgICAgIHRtcENhbnZhcy53aWR0aCA9IG9XICogMS41O1xuICAgICAgICB0bXBDYW52YXMuaGVpZ2h0ID0gb0g7XG4gICAgICB9XG4gICAgICBjdHggPSB0bXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgb1cgKiAxLjUsIG9IKTtcbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcblxuICAgICAgZFcgPSBmbG9vcihkVyk7XG4gICAgICBkSCA9IGZsb29yKGRIKTtcblxuICAgICAgd2hpbGUgKCFkb25lVyB8fCAhZG9uZUgpIHtcbiAgICAgICAgb1cgPSBzdGVwVztcbiAgICAgICAgb0ggPSBzdGVwSDtcbiAgICAgICAgaWYgKGRXIDwgZmxvb3Ioc3RlcFcgKiBtdWx0KSkge1xuICAgICAgICAgIHN0ZXBXID0gZmxvb3Ioc3RlcFcgKiBtdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzdGVwVyA9IGRXO1xuICAgICAgICAgIGRvbmVXID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZEggPCBmbG9vcihzdGVwSCAqIG11bHQpKSB7XG4gICAgICAgICAgc3RlcEggPSBmbG9vcihzdGVwSCAqIG11bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHN0ZXBIID0gZEg7XG4gICAgICAgICAgZG9uZUggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodG1wQ2FudmFzLCBzWCwgc1ksIG9XLCBvSCwgZFgsIGRZLCBzdGVwVywgc3RlcEgpO1xuICAgICAgICBzWCA9IGRYO1xuICAgICAgICBzWSA9IGRZO1xuICAgICAgICBkWSArPSBzdGVwSDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdHguZ2V0SW1hZ2VEYXRhKHNYLCBzWSwgZFcsIGRIKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIGxhbmN6b3NSZXNpemVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9XIE9yaWdpbmFsIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9IIE9yaWdpbmFsIEhlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkVyBEZXN0aW5hdGlvbiBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkSCBEZXN0aW5hdGlvbiBIZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7SW1hZ2VEYXRhfVxuICAgICAqL1xuICAgIGxhbmN6b3NSZXNpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIG9XLCBvSCwgZFcsIGRIKSB7XG5cbiAgICAgIGZ1bmN0aW9uIHByb2Nlc3ModSkge1xuICAgICAgICB2YXIgdiwgaSwgd2VpZ2h0LCBpZHgsIGEsIHJlZCwgZ3JlZW4sXG4gICAgICAgICAgICBibHVlLCBhbHBoYSwgZlgsIGZZO1xuICAgICAgICBjZW50ZXIueCA9ICh1ICsgMC41KSAqIHJhdGlvWDtcbiAgICAgICAgaWNlbnRlci54ID0gZmxvb3IoY2VudGVyLngpO1xuICAgICAgICBmb3IgKHYgPSAwOyB2IDwgZEg7IHYrKykge1xuICAgICAgICAgIGNlbnRlci55ID0gKHYgKyAwLjUpICogcmF0aW9ZO1xuICAgICAgICAgIGljZW50ZXIueSA9IGZsb29yKGNlbnRlci55KTtcbiAgICAgICAgICBhID0gMDsgcmVkID0gMDsgZ3JlZW4gPSAwOyBibHVlID0gMDsgYWxwaGEgPSAwO1xuICAgICAgICAgIGZvciAoaSA9IGljZW50ZXIueCAtIHJhbmdlMlg7IGkgPD0gaWNlbnRlci54ICsgcmFuZ2UyWDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA8IDAgfHwgaSA+PSBvVykge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZYID0gZmxvb3IoMTAwMCAqIGFicyhpIC0gY2VudGVyLngpKTtcbiAgICAgICAgICAgIGlmICghY2FjaGVMYW5jW2ZYXSkge1xuICAgICAgICAgICAgICBjYWNoZUxhbmNbZlhdID0geyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGljZW50ZXIueSAtIHJhbmdlMlk7IGogPD0gaWNlbnRlci55ICsgcmFuZ2UyWTsgaisrKSB7XG4gICAgICAgICAgICAgIGlmIChqIDwgMCB8fCBqID49IG9IKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZlkgPSBmbG9vcigxMDAwICogYWJzKGogLSBjZW50ZXIueSkpO1xuICAgICAgICAgICAgICBpZiAoIWNhY2hlTGFuY1tmWF1bZlldKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVMYW5jW2ZYXVtmWV0gPSBsYW5jem9zKHNxcnQocG93KGZYICogcmNwUmF0aW9YLCAyKSArIHBvdyhmWSAqIHJjcFJhdGlvWSwgMikpIC8gMTAwMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd2VpZ2h0ID0gY2FjaGVMYW5jW2ZYXVtmWV07XG4gICAgICAgICAgICAgIGlmICh3ZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWR4ID0gKGogKiBvVyArIGkpICogNDtcbiAgICAgICAgICAgICAgICBhICs9IHdlaWdodDtcbiAgICAgICAgICAgICAgICByZWQgKz0gd2VpZ2h0ICogc3JjRGF0YVtpZHhdO1xuICAgICAgICAgICAgICAgIGdyZWVuICs9IHdlaWdodCAqIHNyY0RhdGFbaWR4ICsgMV07XG4gICAgICAgICAgICAgICAgYmx1ZSArPSB3ZWlnaHQgKiBzcmNEYXRhW2lkeCArIDJdO1xuICAgICAgICAgICAgICAgIGFscGhhICs9IHdlaWdodCAqIHNyY0RhdGFbaWR4ICsgM107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWR4ID0gKHYgKiBkVyArIHUpICogNDtcbiAgICAgICAgICBkZXN0RGF0YVtpZHhdID0gcmVkIC8gYTtcbiAgICAgICAgICBkZXN0RGF0YVtpZHggKyAxXSA9IGdyZWVuIC8gYTtcbiAgICAgICAgICBkZXN0RGF0YVtpZHggKyAyXSA9IGJsdWUgLyBhO1xuICAgICAgICAgIGRlc3REYXRhW2lkeCArIDNdID0gYWxwaGEgLyBhO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCsrdSA8IGRXKSB7XG4gICAgICAgICAgcmV0dXJuIHByb2Nlc3ModSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGRlc3RJbWc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNyY0RhdGEgPSBvcHRpb25zLmltYWdlRGF0YS5kYXRhLFxuICAgICAgICAgIGRlc3RJbWcgPSBvcHRpb25zLmN0eC5jcmVhdGVJbWFnZURhdGEoZFcsIGRIKSxcbiAgICAgICAgICBkZXN0RGF0YSA9IGRlc3RJbWcuZGF0YSxcbiAgICAgICAgICBsYW5jem9zID0gdGhpcy5sYW5jem9zQ3JlYXRlKHRoaXMubGFuY3pvc0xvYmVzKSxcbiAgICAgICAgICByYXRpb1ggPSB0aGlzLnJjcFNjYWxlWCwgcmF0aW9ZID0gdGhpcy5yY3BTY2FsZVksXG4gICAgICAgICAgcmNwUmF0aW9YID0gMiAvIHRoaXMucmNwU2NhbGVYLCByY3BSYXRpb1kgPSAyIC8gdGhpcy5yY3BTY2FsZVksXG4gICAgICAgICAgcmFuZ2UyWCA9IGNlaWwocmF0aW9YICogdGhpcy5sYW5jem9zTG9iZXMgLyAyKSxcbiAgICAgICAgICByYW5nZTJZID0gY2VpbChyYXRpb1kgKiB0aGlzLmxhbmN6b3NMb2JlcyAvIDIpLFxuICAgICAgICAgIGNhY2hlTGFuYyA9IHsgfSwgY2VudGVyID0geyB9LCBpY2VudGVyID0geyB9O1xuXG4gICAgICByZXR1cm4gcHJvY2VzcygwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYmlsaW5lYXJGaWx0ZXJpbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2FudmFzRWwgQ2FudmFzIGVsZW1lbnQgdG8gYXBwbHkgZmlsdGVyIHRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9XIE9yaWdpbmFsIFdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9IIE9yaWdpbmFsIEhlaWdodFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkVyBEZXN0aW5hdGlvbiBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkSCBEZXN0aW5hdGlvbiBIZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7SW1hZ2VEYXRhfVxuICAgICAqL1xuICAgIGJpbGluZWFyRmlsdGVyaW5nOiBmdW5jdGlvbihvcHRpb25zLCBvVywgb0gsIGRXLCBkSCkge1xuICAgICAgdmFyIGEsIGIsIGMsIGQsIHgsIHksIGksIGosIHhEaWZmLCB5RGlmZiwgY2hubCxcbiAgICAgICAgICBjb2xvciwgb2Zmc2V0ID0gMCwgb3JpZ1BpeCwgcmF0aW9YID0gdGhpcy5yY3BTY2FsZVgsXG4gICAgICAgICAgcmF0aW9ZID0gdGhpcy5yY3BTY2FsZVksXG4gICAgICAgICAgdzQgPSA0ICogKG9XIC0gMSksIGltZyA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIHBpeGVscyA9IGltZy5kYXRhLCBkZXN0SW1hZ2UgPSBvcHRpb25zLmN0eC5jcmVhdGVJbWFnZURhdGEoZFcsIGRIKSxcbiAgICAgICAgICBkZXN0UGl4ZWxzID0gZGVzdEltYWdlLmRhdGE7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZEg7IGkrKykge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgZFc7IGorKykge1xuICAgICAgICAgIHggPSBmbG9vcihyYXRpb1ggKiBqKTtcbiAgICAgICAgICB5ID0gZmxvb3IocmF0aW9ZICogaSk7XG4gICAgICAgICAgeERpZmYgPSByYXRpb1ggKiBqIC0geDtcbiAgICAgICAgICB5RGlmZiA9IHJhdGlvWSAqIGkgLSB5O1xuICAgICAgICAgIG9yaWdQaXggPSA0ICogKHkgKiBvVyArIHgpO1xuXG4gICAgICAgICAgZm9yIChjaG5sID0gMDsgY2hubCA8IDQ7IGNobmwrKykge1xuICAgICAgICAgICAgYSA9IHBpeGVsc1tvcmlnUGl4ICsgY2hubF07XG4gICAgICAgICAgICBiID0gcGl4ZWxzW29yaWdQaXggKyA0ICsgY2hubF07XG4gICAgICAgICAgICBjID0gcGl4ZWxzW29yaWdQaXggKyB3NCArIGNobmxdO1xuICAgICAgICAgICAgZCA9IHBpeGVsc1tvcmlnUGl4ICsgdzQgKyA0ICsgY2hubF07XG4gICAgICAgICAgICBjb2xvciA9IGEgKiAoMSAtIHhEaWZmKSAqICgxIC0geURpZmYpICsgYiAqIHhEaWZmICogKDEgLSB5RGlmZikgK1xuICAgICAgICAgICAgICAgICAgICBjICogeURpZmYgKiAoMSAtIHhEaWZmKSArIGQgKiB4RGlmZiAqIHlEaWZmO1xuICAgICAgICAgICAgZGVzdFBpeGVsc1tvZmZzZXQrK10gPSBjb2xvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXN0SW1hZ2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGhlcm1pdGVGYXN0UmVzaXplXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNhbnZhc0VsIENhbnZhcyBlbGVtZW50IHRvIGFwcGx5IGZpbHRlciB0b1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvVyBPcmlnaW5hbCBXaWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvSCBPcmlnaW5hbCBIZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZFcgRGVzdGluYXRpb24gV2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZEggRGVzdGluYXRpb24gSGVpZ2h0XG4gICAgICogQHJldHVybnMge0ltYWdlRGF0YX1cbiAgICAgKi9cbiAgICBoZXJtaXRlRmFzdFJlc2l6ZTogZnVuY3Rpb24ob3B0aW9ucywgb1csIG9ILCBkVywgZEgpIHtcbiAgICAgIHZhciByYXRpb1cgPSB0aGlzLnJjcFNjYWxlWCwgcmF0aW9IID0gdGhpcy5yY3BTY2FsZVksXG4gICAgICAgICAgcmF0aW9XSGFsZiA9IGNlaWwocmF0aW9XIC8gMiksXG4gICAgICAgICAgcmF0aW9ISGFsZiA9IGNlaWwocmF0aW9IIC8gMiksXG4gICAgICAgICAgaW1nID0gb3B0aW9ucy5pbWFnZURhdGEsIGRhdGEgPSBpbWcuZGF0YSxcbiAgICAgICAgICBpbWcyID0gb3B0aW9ucy5jdHguY3JlYXRlSW1hZ2VEYXRhKGRXLCBkSCksIGRhdGEyID0gaW1nMi5kYXRhO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkSDsgaisrKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZFc7IGkrKykge1xuICAgICAgICAgIHZhciB4MiA9IChpICsgaiAqIGRXKSAqIDQsIHdlaWdodCA9IDAsIHdlaWdodHMgPSAwLCB3ZWlnaHRzQWxwaGEgPSAwLFxuICAgICAgICAgICAgICBneFIgPSAwLCBneEcgPSAwLCBneEIgPSAwLCBneEEgPSAwLCBjZW50ZXJZID0gKGogKyAwLjUpICogcmF0aW9IO1xuICAgICAgICAgIGZvciAodmFyIHl5ID0gZmxvb3IoaiAqIHJhdGlvSCk7IHl5IDwgKGogKyAxKSAqIHJhdGlvSDsgeXkrKykge1xuICAgICAgICAgICAgdmFyIGR5ID0gYWJzKGNlbnRlclkgLSAoeXkgKyAwLjUpKSAvIHJhdGlvSEhhbGYsXG4gICAgICAgICAgICAgICAgY2VudGVyWCA9IChpICsgMC41KSAqIHJhdGlvVywgdzAgPSBkeSAqIGR5O1xuICAgICAgICAgICAgZm9yICh2YXIgeHggPSBmbG9vcihpICogcmF0aW9XKTsgeHggPCAoaSArIDEpICogcmF0aW9XOyB4eCsrKSB7XG4gICAgICAgICAgICAgIHZhciBkeCA9IGFicyhjZW50ZXJYIC0gKHh4ICsgMC41KSkgLyByYXRpb1dIYWxmLFxuICAgICAgICAgICAgICAgICAgdyA9IHNxcnQodzAgKyBkeCAqIGR4KTtcbiAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWRlcHRoICovXG4gICAgICAgICAgICAgIGlmICh3ID4gMSAmJiB3IDwgLTEpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvL2hlcm1pdGUgZmlsdGVyXG4gICAgICAgICAgICAgIHdlaWdodCA9IDIgKiB3ICogdyAqIHcgLSAzICogdyAqIHcgKyAxO1xuICAgICAgICAgICAgICBpZiAod2VpZ2h0ID4gMCkge1xuICAgICAgICAgICAgICAgIGR4ID0gNCAqICh4eCArIHl5ICogb1cpO1xuICAgICAgICAgICAgICAgIC8vYWxwaGFcbiAgICAgICAgICAgICAgICBneEEgKz0gd2VpZ2h0ICogZGF0YVtkeCArIDNdO1xuICAgICAgICAgICAgICAgIHdlaWdodHNBbHBoYSArPSB3ZWlnaHQ7XG4gICAgICAgICAgICAgICAgLy9jb2xvcnNcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtkeCArIDNdIDwgMjU1KSB7XG4gICAgICAgICAgICAgICAgICB3ZWlnaHQgPSB3ZWlnaHQgKiBkYXRhW2R4ICsgM10gLyAyNTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGd4UiArPSB3ZWlnaHQgKiBkYXRhW2R4XTtcbiAgICAgICAgICAgICAgICBneEcgKz0gd2VpZ2h0ICogZGF0YVtkeCArIDFdO1xuICAgICAgICAgICAgICAgIGd4QiArPSB3ZWlnaHQgKiBkYXRhW2R4ICsgMl07XG4gICAgICAgICAgICAgICAgd2VpZ2h0cyArPSB3ZWlnaHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBtYXgtZGVwdGggKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YTJbeDJdID0gZ3hSIC8gd2VpZ2h0cztcbiAgICAgICAgICBkYXRhMlt4MiArIDFdID0gZ3hHIC8gd2VpZ2h0cztcbiAgICAgICAgICBkYXRhMlt4MiArIDJdID0gZ3hCIC8gd2VpZ2h0cztcbiAgICAgICAgICBkYXRhMlt4MiArIDNdID0gZ3hBIC8gd2VpZ2h0c0FscGhhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaW1nMjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgc2NhbGVYOiB0aGlzLnNjYWxlWCxcbiAgICAgICAgc2NhbGVZOiB0aGlzLnNjYWxlWSxcbiAgICAgICAgcmVzaXplVHlwZTogdGhpcy5yZXNpemVUeXBlLFxuICAgICAgICBsYW5jem9zTG9iZXM6IHRoaXMubGFuY3pvc0xvYmVzXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5SZXNpemV9IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlJlc2l6ZVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuUmVzaXplLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBDb250cmFzdCBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnRyYXN0XG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnRyYXN0I2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdCh7XG4gICAqICAgY29udHJhc3Q6IDAuMjVcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKi9cbiAgZmlsdGVycy5Db250cmFzdCA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0NvbnRyYXN0JyxcblxuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gZmxvYXQgdUNvbnRyYXN0O1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IGNvbnRyYXN0RiA9IDEuMDE1ICogKHVDb250cmFzdCArIDEuMCkgLyAoMS4wICogKDEuMDE1IC0gdUNvbnRyYXN0KSk7XFxuJyArXG4gICAgICAgICdjb2xvci5yZ2IgPSBjb250cmFzdEYgKiAoY29sb3IucmdiIC0gMC41KSArIDAuNTtcXG4nICtcbiAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbicgK1xuICAgICAgJ30nLFxuXG4gICAgLyoqXG4gICAgICogY29udHJhc3QgdmFsdWUsIHJhbmdlIGZyb20gLTEgdG8gMS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29udHJhc3RcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgY29udHJhc3Q6IDAsXG5cbiAgICBtYWluUGFyYW1ldGVyOiAnY29udHJhc3QnLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3QucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb250cmFzdD0wXSBWYWx1ZSB0byBjb250cmFzdCB0aGUgaW1hZ2UgdXAgKC0xLi4uMSlcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAgKiBBcHBseSB0aGUgQ29udHJhc3Qgb3BlcmF0aW9uIHRvIGEgVWludDhBcnJheSByZXByZXNlbnRpbmcgdGhlIHBpeGVscyBvZiBhbiBpbWFnZS5cbiAgICAgICpcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICogQHBhcmFtIHtJbWFnZURhdGF9IG9wdGlvbnMuaW1hZ2VEYXRhIFRoZSBVaW50OEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAgKi9cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRyYXN0ID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpbWFnZURhdGEgPSBvcHRpb25zLmltYWdlRGF0YSwgaSwgbGVuLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgbGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgY29udHJhc3QgPSBNYXRoLmZsb29yKHRoaXMuY29udHJhc3QgKiAyNTUpLFxuICAgICAgICAgIGNvbnRyYXN0RiA9IDI1OSAqIChjb250cmFzdCArIDI1NSkgLyAoMjU1ICogKDI1OSAtIGNvbnRyYXN0KSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICBkYXRhW2ldID0gY29udHJhc3RGICogKGRhdGFbaV0gLSAxMjgpICsgMTI4O1xuICAgICAgICBkYXRhW2kgKyAxXSA9IGNvbnRyYXN0RiAqIChkYXRhW2kgKyAxXSAtIDEyOCkgKyAxMjg7XG4gICAgICAgIGRhdGFbaSArIDJdID0gY29udHJhc3RGICogKGRhdGFbaSArIDJdIC0gMTI4KSArIDEyODtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVDb250cmFzdDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sICd1Q29udHJhc3QnKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3JtTG9jYXRpb25zLnVDb250cmFzdCwgdGhpcy5jb250cmFzdCk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5Db250cmFzdH0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuQ29udHJhc3RcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbnRyYXN0LmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBTYXR1cmF0ZSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRpb25cbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuU2F0dXJhdGlvbiNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuU2F0dXJhdGlvbih7XG4gICAqICAgc2F0dXJhdGlvbjogMVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLlNhdHVyYXRpb24gPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuU2F0dXJhdGlvbi5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ1NhdHVyYXRpb24nLFxuXG4gICAgZnJhZ21lbnRTb3VyY2U6ICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuJyArXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVRleHR1cmU7XFxuJyArXG4gICAgICAndW5pZm9ybSBmbG9hdCB1U2F0dXJhdGlvbjtcXG4nICtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVRleHR1cmUsIHZUZXhDb29yZCk7XFxuJyArXG4gICAgICAgICdmbG9hdCByZ01heCA9IG1heChjb2xvci5yLCBjb2xvci5nKTtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IHJnYk1heCA9IG1heChyZ01heCwgY29sb3IuYik7XFxuJyArXG4gICAgICAgICdjb2xvci5yICs9IHJnYk1heCAhPSBjb2xvci5yID8gKHJnYk1heCAtIGNvbG9yLnIpICogdVNhdHVyYXRpb24gOiAwLjAwO1xcbicgK1xuICAgICAgICAnY29sb3IuZyArPSByZ2JNYXggIT0gY29sb3IuZyA/IChyZ2JNYXggLSBjb2xvci5nKSAqIHVTYXR1cmF0aW9uIDogMC4wMDtcXG4nICtcbiAgICAgICAgJ2NvbG9yLmIgKz0gcmdiTWF4ICE9IGNvbG9yLmIgPyAocmdiTWF4IC0gY29sb3IuYikgKiB1U2F0dXJhdGlvbiA6IDAuMDA7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4nICtcbiAgICAgICd9JyxcblxuICAgIC8qKlxuICAgICAqIFNhdHVyYXRpb24gdmFsdWUsIGZyb20gLTEgdG8gMS5cbiAgICAgKiBJbmNyZWFzZXMvZGVjcmVhc2VzIHRoZSBjb2xvciBzYXR1cmF0aW9uLlxuICAgICAqIEEgdmFsdWUgb2YgMCBoYXMgbm8gZWZmZWN0LlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzYXR1cmF0aW9uXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzYXR1cmF0aW9uOiAwLFxuXG4gICAgbWFpblBhcmFtZXRlcjogJ3NhdHVyYXRpb24nLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuU2F0dXJhdGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zYXR1cmF0ZT0wXSBWYWx1ZSB0byBzYXR1cmF0ZSB0aGUgaW1hZ2UgKC0xLi4uMSlcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBTYXR1cmF0aW9uIG9wZXJhdGlvbiB0byBhIFVpbnQ4Q2xhbXBlZEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4Q2xhbXBlZEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMuc2F0dXJhdGlvbiA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsXG4gICAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLCBsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICBhZGp1c3QgPSAtdGhpcy5zYXR1cmF0aW9uLCBpLCBtYXg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICBtYXggPSBNYXRoLm1heChkYXRhW2ldLCBkYXRhW2kgKyAxXSwgZGF0YVtpICsgMl0pO1xuICAgICAgICBkYXRhW2ldICs9IG1heCAhPT0gZGF0YVtpXSA/IChtYXggLSBkYXRhW2ldKSAqIGFkanVzdCA6IDA7XG4gICAgICAgIGRhdGFbaSArIDFdICs9IG1heCAhPT0gZGF0YVtpICsgMV0gPyAobWF4IC0gZGF0YVtpICsgMV0pICogYWRqdXN0IDogMDtcbiAgICAgICAgZGF0YVtpICsgMl0gKz0gbWF4ICE9PSBkYXRhW2kgKyAyXSA/IChtYXggLSBkYXRhW2kgKyAyXSkgKiBhZGp1c3QgOiAwO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdVNhdHVyYXRpb246IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVNhdHVyYXRpb24nKSxcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgZGF0YSBmcm9tIHRoaXMgZmlsdGVyIHRvIGl0cyBzaGFkZXIgcHJvZ3JhbSdzIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1Mb2NhdGlvbnMgQSBtYXAgb2Ygc3RyaW5nIHVuaWZvcm0gbmFtZXMgdG8gV2ViR0xVbmlmb3JtTG9jYXRpb24gb2JqZWN0c1xuICAgICAqL1xuICAgIHNlbmRVbmlmb3JtRGF0YTogZnVuY3Rpb24oZ2wsIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGdsLnVuaWZvcm0xZih1bmlmb3JtTG9jYXRpb25zLnVTYXR1cmF0aW9uLCAtdGhpcy5zYXR1cmF0aW9uKTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRpb259IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlNhdHVyYXRlXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5TYXR1cmF0aW9uLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBWaWJyYW5jZSBmaWx0ZXIgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlZpYnJhbmNlXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuSW1hZ2UuZmlsdGVyc1xuICAgKiBAZXh0ZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyXG4gICAqIEBzZWUge0BsaW5rIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlZpYnJhbmNlI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5WaWJyYW5jZSh7XG4gICAqICAgdmlicmFuY2U6IDFcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKi9cbiAgZmlsdGVycy5WaWJyYW5jZSA9IGNyZWF0ZUNsYXNzKGZpbHRlcnMuQmFzZUZpbHRlciwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5WaWJyYW5jZS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ1ZpYnJhbmNlJyxcblxuICAgIGZyYWdtZW50U291cmNlOiAncHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbicgK1xuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbicgK1xuICAgICAgJ3VuaWZvcm0gZmxvYXQgdVZpYnJhbmNlO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IG1heCA9IG1heChjb2xvci5yLCBtYXgoY29sb3IuZywgY29sb3IuYikpO1xcbicgK1xuICAgICAgICAnZmxvYXQgYXZnID0gKGNvbG9yLnIgKyBjb2xvci5nICsgY29sb3IuYikgLyAzLjA7XFxuJyArXG4gICAgICAgICdmbG9hdCBhbXQgPSAoYWJzKG1heCAtIGF2ZykgKiAyLjApICogdVZpYnJhbmNlO1xcbicgK1xuICAgICAgICAnY29sb3IuciArPSBtYXggIT0gY29sb3IuciA/IChtYXggLSBjb2xvci5yKSAqIGFtdCA6IDAuMDA7XFxuJyArXG4gICAgICAgICdjb2xvci5nICs9IG1heCAhPSBjb2xvci5nID8gKG1heCAtIGNvbG9yLmcpICogYW10IDogMC4wMDtcXG4nICtcbiAgICAgICAgJ2NvbG9yLmIgKz0gbWF4ICE9IGNvbG9yLmIgPyAobWF4IC0gY29sb3IuYikgKiBhbXQgOiAwLjAwO1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBWaWJyYW5jZSB2YWx1ZSwgZnJvbSAtMSB0byAxLlxuICAgICAqIEluY3JlYXNlcy9kZWNyZWFzZXMgdGhlIHNhdHVyYXRpb24gb2YgbW9yZSBtdXRlZCBjb2xvcnMgd2l0aCBsZXNzIGVmZmVjdCBvbiBzYXR1cmF0ZWQgY29sb3JzLlxuICAgICAqIEEgdmFsdWUgb2YgMCBoYXMgbm8gZWZmZWN0LlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2aWJyYW5jZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdmlicmFuY2U6IDAsXG5cbiAgICBtYWluUGFyYW1ldGVyOiAndmlicmFuY2UnLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnMuVmlicmFuY2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy52aWJyYW5jZT0wXSBWaWJyYW5jZSB2YWx1ZSBmb3IgdGhlIGltYWdlIChiZXR3ZWVuIC0xIGFuZCAxKVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIFZpYnJhbmNlIG9wZXJhdGlvbiB0byBhIFVpbnQ4Q2xhbXBlZEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4Q2xhbXBlZEFycmF5IHRvIGJlIGZpbHRlcmVkLlxuICAgICAqL1xuICAgIGFwcGx5VG8yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMudmlicmFuY2UgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGltYWdlRGF0YSA9IG9wdGlvbnMuaW1hZ2VEYXRhLFxuICAgICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSwgbGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgYWRqdXN0ID0gLXRoaXMudmlicmFuY2UsIGksIG1heCwgYXZnLCBhbXQ7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICBtYXggPSBNYXRoLm1heChkYXRhW2ldLCBkYXRhW2kgKyAxXSwgZGF0YVtpICsgMl0pO1xuICAgICAgICBhdmcgPSAoZGF0YVtpXSArIGRhdGFbaSArIDFdICsgZGF0YVtpICsgMl0pIC8gMztcbiAgICAgICAgYW10ID0gKChNYXRoLmFicyhtYXggLSBhdmcpICogMiAvIDI1NSkgKiBhZGp1c3QpO1xuICAgICAgICBkYXRhW2ldICs9IG1heCAhPT0gZGF0YVtpXSA/IChtYXggLSBkYXRhW2ldKSAqIGFtdCA6IDA7XG4gICAgICAgIGRhdGFbaSArIDFdICs9IG1heCAhPT0gZGF0YVtpICsgMV0gPyAobWF4IC0gZGF0YVtpICsgMV0pICogYW10IDogMDtcbiAgICAgICAgZGF0YVtpICsgMl0gKz0gbWF4ICE9PSBkYXRhW2kgKyAyXSA/IChtYXggLSBkYXRhW2kgKyAyXSkgKiBhbXQgOiAwO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gV2ViR0wgdW5pZm9ybSBsb2NhdGlvbnMgZm9yIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIFRoZSBHTCBjYW52YXMgY29udGV4dCB1c2VkIHRvIGNvbXBpbGUgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtXZWJHTFNoYWRlclByb2dyYW19IHByb2dyYW0gVGhpcyBmaWx0ZXIncyBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBnZXRVbmlmb3JtTG9jYXRpb25zOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdVZpYnJhbmNlOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VWaWJyYW5jZScpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgZ2wudW5pZm9ybTFmKHVuaWZvcm1Mb2NhdGlvbnMudVZpYnJhbmNlLCAtdGhpcy52aWJyYW5jZSk7XG4gICAgfSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmlsdGVyIGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QgdG8gY3JlYXRlIGFuIGluc3RhbmNlIGZyb21cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSB0byBiZSBpbnZva2VkIGFmdGVyIGZpbHRlciBjcmVhdGlvblxuICAgKiBAcmV0dXJuIHtmYWJyaWMuSW1hZ2UuZmlsdGVycy5WaWJyYW5jZX0gSW5zdGFuY2Ugb2YgZmFicmljLkltYWdlLmZpbHRlcnMuVmlicmFuY2VcbiAgICovXG4gIGZhYnJpYy5JbWFnZS5maWx0ZXJzLlZpYnJhbmNlLmZyb21PYmplY3QgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CYXNlRmlsdGVyLmZyb21PYmplY3Q7XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyA/IGV4cG9ydHMgOiB0aGlzKTtcblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBmaWx0ZXJzID0gZmFicmljLkltYWdlLmZpbHRlcnMsXG4gICAgICBjcmVhdGVDbGFzcyA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzO1xuXG4gIC8qKlxuICAgKiBCbHVyIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuQmx1clxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbHVyI2luaXRpYWxpemV9IGZvciBjb25zdHJ1Y3RvciBkZWZpbml0aW9uXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9mYWJyaWNqcy5jb20vaW1hZ2UtZmlsdGVyc3xJbWFnZUZpbHRlcnMgZGVtb31cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGZpbHRlciA9IG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5CbHVyKHtcbiAgICogICBibHVyOiAwLjVcbiAgICogfSk7XG4gICAqIG9iamVjdC5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICogb2JqZWN0LmFwcGx5RmlsdGVycygpO1xuICAgKiBjYW52YXMucmVuZGVyQWxsKCk7XG4gICAqL1xuICBmaWx0ZXJzLkJsdXIgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmx1ci5wcm90b3R5cGUgKi8ge1xuXG4gICAgdHlwZTogJ0JsdXInLFxuXG4gICAgLypcbidnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCk7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIC03ICogdURlbHRhKSowLjAwNDQyOTkxMjEwNTUxMTMyNjU7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIC02ICogdURlbHRhKSowLjAwODk1NzgxMjExNzk0OycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAtNSAqIHVEZWx0YSkqMC4wMjE1OTYzODY2MDUzOycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAtNCAqIHVEZWx0YSkqMC4wNDQzNjgzMzM4NzE4OycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAtMyAqIHVEZWx0YSkqMC4wNzc2NzQ0MjE5OTMzOycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAtMiAqIHVEZWx0YSkqMC4xMTU4NzY2MjExMDU7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIC0xICogdURlbHRhKSowLjE0NzMwODA1NjEyMTsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICAgICAgICAgICAgICApKjAuMTU5NTc2OTEyMTYxOycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyAxICogdURlbHRhKSowLjE0NzMwODA1NjEyMTsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgMiAqIHVEZWx0YSkqMC4xMTU4NzY2MjExMDU7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIDMgKiB1RGVsdGEpKjAuMDc3Njc0NDIxOTkzMzsnLFxuJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodGV4dHVyZSwgdlRleENvb3JkICsgNCAqIHVEZWx0YSkqMC4wNDQzNjgzMzM4NzE4OycsXG4nZ2xfRnJhZ0NvbG9yICs9IHRleHR1cmUyRCh0ZXh0dXJlLCB2VGV4Q29vcmQgKyA1ICogdURlbHRhKSowLjAyMTU5NjM4NjYwNTM7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIDYgKiB1RGVsdGEpKjAuMDA4OTU3ODEyMTE3OTQ7JyxcbidnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHRleHR1cmUsIHZUZXhDb29yZCArIDcgKiB1RGVsdGEpKjAuMDA0NDI5OTEyMTA1NTExMzI2NTsnLFxuKi9cblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIHZlYzIgdURlbHRhO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAnY29uc3QgZmxvYXQgblNhbXBsZXMgPSAxNS4wO1xcbicgK1xuICAgICAgJ3ZlYzMgdjNvZmZzZXQgPSB2ZWMzKDEyLjk4OTgsIDc4LjIzMywgMTUxLjcxODIpO1xcbicgK1xuICAgICAgJ2Zsb2F0IHJhbmRvbSh2ZWMzIHNjYWxlKSB7XFxuJyArXG4gICAgICAgIC8qIHVzZSB0aGUgZnJhZ21lbnQgcG9zaXRpb24gZm9yIGEgZGlmZmVyZW50IHNlZWQgcGVyLXBpeGVsICovXG4gICAgICAgICdyZXR1cm4gZnJhY3Qoc2luKGRvdChnbF9GcmFnQ29vcmQueHl6LCBzY2FsZSkpICogNDM3NTguNTQ1Myk7XFxuJyArXG4gICAgICAnfVxcbicgK1xuICAgICAgJ3ZvaWQgbWFpbigpIHtcXG4nICtcbiAgICAgICAgJ3ZlYzQgY29sb3IgPSB2ZWM0KDAuMCk7XFxuJyArXG4gICAgICAgICdmbG9hdCB0b3RhbCA9IDAuMDtcXG4nICtcbiAgICAgICAgJ2Zsb2F0IG9mZnNldCA9IHJhbmRvbSh2M29mZnNldCk7XFxuJyArXG4gICAgICAgICdmb3IgKGZsb2F0IHQgPSAtblNhbXBsZXM7IHQgPD0gblNhbXBsZXM7IHQrKykge1xcbicgK1xuICAgICAgICAgICdmbG9hdCBwZXJjZW50ID0gKHQgKyBvZmZzZXQgLSAwLjUpIC8gblNhbXBsZXM7XFxuJyArXG4gICAgICAgICAgJ2Zsb2F0IHdlaWdodCA9IDEuMCAtIGFicyhwZXJjZW50KTtcXG4nICtcbiAgICAgICAgICAnY29sb3IgKz0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQgKyB1RGVsdGEgKiBwZXJjZW50KSAqIHdlaWdodDtcXG4nICtcbiAgICAgICAgICAndG90YWwgKz0gd2VpZ2h0O1xcbicgK1xuICAgICAgICAnfVxcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3IgLyB0b3RhbDtcXG4nICtcbiAgICAgICd9JyxcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuICAgIC8qKlxuICAgICAqIGJsdXIgdmFsdWUsIGluIHBlcmNlbnRhZ2Ugb2YgaW1hZ2UgZGltZW5zaW9ucy5cbiAgICAgKiBzcGVjaWZpYyB0byBrZWVwIHRoZSBpbWFnZSBibHVyIGNvbnN0YW50IGF0IGRpZmZlcmVudCByZXNvbHV0aW9uc1xuICAgICAqIHJhbmdlIGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGJsdXI6IDAsXG5cbiAgICBtYWluUGFyYW1ldGVyOiAnYmx1cicsXG5cbiAgICBhcHBseVRvOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy53ZWJnbCkge1xuICAgICAgICAvLyB0aGlzIGFzcGVjdFJhdGlvIGlzIHVzZWQgdG8gZ2l2ZSB0aGUgc2FtZSBibHVyIHRvIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsXG4gICAgICAgIHRoaXMuYXNwZWN0UmF0aW8gPSBvcHRpb25zLnNvdXJjZVdpZHRoIC8gb3B0aW9ucy5zb3VyY2VIZWlnaHQ7XG4gICAgICAgIG9wdGlvbnMucGFzc2VzKys7XG4gICAgICAgIHRoaXMuX3NldHVwRnJhbWVCdWZmZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuaG9yaXpvbnRhbCA9IHRydWU7XG4gICAgICAgIHRoaXMuYXBwbHlUb1dlYkdMKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9zd2FwVGV4dHVyZXMob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3NldHVwRnJhbWVCdWZmZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuaG9yaXpvbnRhbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFwcGx5VG9XZWJHTChvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fc3dhcFRleHR1cmVzKG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuYXBwbHlUbzJkKG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBhcHBseVRvMmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIC8vIHBhaW50IGNhbnZhc0VsIHdpdGggY3VycmVudCBpbWFnZSBkYXRhLlxuICAgICAgLy9vcHRpb25zLmN0eC5wdXRJbWFnZURhdGEob3B0aW9ucy5pbWFnZURhdGEsIDAsIDApO1xuICAgICAgb3B0aW9ucy5pbWFnZURhdGEgPSB0aGlzLnNpbXBsZUJsdXIob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIHNpbXBsZUJsdXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciByZXNvdXJjZXMgPSBvcHRpb25zLmZpbHRlckJhY2tlbmQucmVzb3VyY2VzLCBjYW52YXMxLCBjYW52YXMyLFxuICAgICAgICAgIHdpZHRoID0gb3B0aW9ucy5pbWFnZURhdGEud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5pbWFnZURhdGEuaGVpZ2h0O1xuXG4gICAgICBpZiAoIXJlc291cmNlcy5ibHVyTGF5ZXIxKSB7XG4gICAgICAgIHJlc291cmNlcy5ibHVyTGF5ZXIxID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgICByZXNvdXJjZXMuYmx1ckxheWVyMiA9IGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgIH1cbiAgICAgIGNhbnZhczEgPSByZXNvdXJjZXMuYmx1ckxheWVyMTtcbiAgICAgIGNhbnZhczIgPSByZXNvdXJjZXMuYmx1ckxheWVyMjtcbiAgICAgIGlmIChjYW52YXMxLndpZHRoICE9PSB3aWR0aCB8fCBjYW52YXMxLmhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICAgIGNhbnZhczIud2lkdGggPSBjYW52YXMxLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGNhbnZhczIuaGVpZ2h0ID0gY2FudmFzMS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB9XG4gICAgICB2YXIgY3R4MSA9IGNhbnZhczEuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICBjdHgyID0gY2FudmFzMi5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgICAgIG5TYW1wbGVzID0gMTUsXG4gICAgICAgICAgcmFuZG9tLCBwZXJjZW50LCBqLCBpLFxuICAgICAgICAgIGJsdXIgPSB0aGlzLmJsdXIgKiAwLjA2ICogMC41O1xuXG4gICAgICAvLyBsb2FkIGZpcnN0IGNhbnZhc1xuICAgICAgY3R4MS5wdXRJbWFnZURhdGEob3B0aW9ucy5pbWFnZURhdGEsIDAsIDApO1xuICAgICAgY3R4Mi5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgIGZvciAoaSA9IC1uU2FtcGxlczsgaSA8PSBuU2FtcGxlczsgaSsrKSB7XG4gICAgICAgIHJhbmRvbSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAvIDQ7XG4gICAgICAgIHBlcmNlbnQgPSBpIC8gblNhbXBsZXM7XG4gICAgICAgIGogPSBibHVyICogcGVyY2VudCAqIHdpZHRoICsgcmFuZG9tO1xuICAgICAgICBjdHgyLmdsb2JhbEFscGhhID0gMSAtIE1hdGguYWJzKHBlcmNlbnQpO1xuICAgICAgICBjdHgyLmRyYXdJbWFnZShjYW52YXMxLCBqLCByYW5kb20pO1xuICAgICAgICBjdHgxLmRyYXdJbWFnZShjYW52YXMyLCAwLCAwKTtcbiAgICAgICAgY3R4Mi5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgIGN0eDIuY2xlYXJSZWN0KDAsIDAsIGNhbnZhczIud2lkdGgsIGNhbnZhczIuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IC1uU2FtcGxlczsgaSA8PSBuU2FtcGxlczsgaSsrKSB7XG4gICAgICAgIHJhbmRvbSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAvIDQ7XG4gICAgICAgIHBlcmNlbnQgPSBpIC8gblNhbXBsZXM7XG4gICAgICAgIGogPSBibHVyICogcGVyY2VudCAqIGhlaWdodCArIHJhbmRvbTtcbiAgICAgICAgY3R4Mi5nbG9iYWxBbHBoYSA9IDEgLSBNYXRoLmFicyhwZXJjZW50KTtcbiAgICAgICAgY3R4Mi5kcmF3SW1hZ2UoY2FudmFzMSwgcmFuZG9tLCBqKTtcbiAgICAgICAgY3R4MS5kcmF3SW1hZ2UoY2FudmFzMiwgMCwgMCk7XG4gICAgICAgIGN0eDIuZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICBjdHgyLmNsZWFyUmVjdCgwLCAwLCBjYW52YXMyLndpZHRoLCBjYW52YXMyLmhlaWdodCk7XG4gICAgICB9XG4gICAgICBvcHRpb25zLmN0eC5kcmF3SW1hZ2UoY2FudmFzMSwgMCwgMCk7XG4gICAgICB2YXIgbmV3SW1hZ2VEYXRhID0gb3B0aW9ucy5jdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhczEud2lkdGgsIGNhbnZhczEuaGVpZ2h0KTtcbiAgICAgIGN0eDEuZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgY3R4MS5jbGVhclJlY3QoMCwgMCwgY2FudmFzMS53aWR0aCwgY2FudmFzMS5oZWlnaHQpO1xuICAgICAgcmV0dXJuIG5ld0ltYWdlRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFdlYkdMIHVuaWZvcm0gbG9jYXRpb25zIGZvciB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJQcm9ncmFtfSBwcm9ncmFtIFRoaXMgZmlsdGVyJ3MgY29tcGlsZWQgc2hhZGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uczogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlbHRhOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3VEZWx0YScpLFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VuZCBkYXRhIGZyb20gdGhpcyBmaWx0ZXIgdG8gaXRzIHNoYWRlciBwcm9ncmFtJ3MgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybUxvY2F0aW9ucyBBIG1hcCBvZiBzdHJpbmcgdW5pZm9ybSBuYW1lcyB0byBXZWJHTFVuaWZvcm1Mb2NhdGlvbiBvYmplY3RzXG4gICAgICovXG4gICAgc2VuZFVuaWZvcm1EYXRhOiBmdW5jdGlvbihnbCwgdW5pZm9ybUxvY2F0aW9ucykge1xuICAgICAgdmFyIGRlbHRhID0gdGhpcy5jaG9vc2VSaWdodERlbHRhKCk7XG4gICAgICBnbC51bmlmb3JtMmZ2KHVuaWZvcm1Mb2NhdGlvbnMuZGVsdGEsIGRlbHRhKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2hvb3NlIHJpZ2h0IHZhbHVlIG9mIGltYWdlIHBlcmNlbnRhZ2UgdG8gYmx1ciB3aXRoXG4gICAgICogQHJldHVybnMge0FycmF5fSBhIG51bWVyaWMgYXJyYXkgd2l0aCBkZWx0YSB2YWx1ZXNcbiAgICAgKi9cbiAgICBjaG9vc2VSaWdodERlbHRhOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBibHVyU2NhbGUgPSAxLCBkZWx0YSA9IFswLCAwXSwgYmx1cjtcbiAgICAgIGlmICh0aGlzLmhvcml6b250YWwpIHtcbiAgICAgICAgaWYgKHRoaXMuYXNwZWN0UmF0aW8gPiAxKSB7XG4gICAgICAgICAgLy8gaW1hZ2UgaXMgd2lkZSwgaSB3YW50IHRvIHNocmluayByYWRpdXMgaG9yaXpvbnRhbFxuICAgICAgICAgIGJsdXJTY2FsZSA9IDEgLyB0aGlzLmFzcGVjdFJhdGlvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuYXNwZWN0UmF0aW8gPCAxKSB7XG4gICAgICAgICAgLy8gaW1hZ2UgaXMgdGFsbCwgaSB3YW50IHRvIHNocmluayByYWRpdXMgdmVydGljYWxcbiAgICAgICAgICBibHVyU2NhbGUgPSB0aGlzLmFzcGVjdFJhdGlvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBibHVyID0gYmx1clNjYWxlICogdGhpcy5ibHVyICogMC4xMjtcbiAgICAgIGlmICh0aGlzLmhvcml6b250YWwpIHtcbiAgICAgICAgZGVsdGFbMF0gPSBibHVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGRlbHRhWzFdID0gYmx1cjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWx0YTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogRGVzZXJpYWxpemUgYSBKU09OIGRlZmluaXRpb24gb2YgYSBCbHVyRmlsdGVyIGludG8gYSBjb25jcmV0ZSBpbnN0YW5jZS5cbiAgICovXG4gIGZpbHRlcnMuQmx1ci5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljICA9IGdsb2JhbC5mYWJyaWMgfHwgKGdsb2JhbC5mYWJyaWMgPSB7IH0pLFxuICAgICAgZmlsdGVycyA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLFxuICAgICAgY3JlYXRlQ2xhc3MgPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcztcblxuICAvKipcbiAgICogR2FtbWEgZmlsdGVyIGNsYXNzXG4gICAqIEBjbGFzcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HYW1tYVxuICAgKiBAbWVtYmVyT2YgZmFicmljLkltYWdlLmZpbHRlcnNcbiAgICogQGV4dGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlclxuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HYW1tYSNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ltYWdlLWZpbHRlcnN8SW1hZ2VGaWx0ZXJzIGRlbW99XG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBmaWx0ZXIgPSBuZXcgZmFicmljLkltYWdlLmZpbHRlcnMuR2FtbWEoe1xuICAgKiAgIGdhbW1hOiBbMSwgMC41LCAyLjFdXG4gICAqIH0pO1xuICAgKiBvYmplY3QuZmlsdGVycy5wdXNoKGZpbHRlcik7XG4gICAqIG9iamVjdC5hcHBseUZpbHRlcnMoKTtcbiAgICovXG4gIGZpbHRlcnMuR2FtbWEgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuR2FtbWEucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHR5cGU6ICdHYW1tYScsXG5cbiAgICBmcmFnbWVudFNvdXJjZTogJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4nICtcbiAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4nICtcbiAgICAgICd1bmlmb3JtIHZlYzMgdUdhbW1hO1xcbicgK1xuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuJyArXG4gICAgICAndm9pZCBtYWluKCkge1xcbicgK1xuICAgICAgICAndmVjNCBjb2xvciA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKTtcXG4nICtcbiAgICAgICAgJ3ZlYzMgY29ycmVjdGlvbiA9ICgxLjAgLyB1R2FtbWEpO1xcbicgK1xuICAgICAgICAnY29sb3IuciA9IHBvdyhjb2xvci5yLCBjb3JyZWN0aW9uLnIpO1xcbicgK1xuICAgICAgICAnY29sb3IuZyA9IHBvdyhjb2xvci5nLCBjb3JyZWN0aW9uLmcpO1xcbicgK1xuICAgICAgICAnY29sb3IuYiA9IHBvdyhjb2xvci5iLCBjb3JyZWN0aW9uLmIpO1xcbicgK1xuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxuJyArXG4gICAgICAgICdnbF9GcmFnQ29sb3IucmdiICo9IGNvbG9yLmE7XFxuJyArXG4gICAgICAnfScsXG5cbiAgICAvKipcbiAgICAgKiBHYW1tYSBhcnJheSB2YWx1ZSwgZnJvbSAwLjAxIHRvIDIuMi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBnYW1tYVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZ2FtbWE6IFsxLCAxLCAxXSxcblxuICAgIC8qKlxuICAgICAqIERlc2NyaWJlIHRoZSBwcm9wZXJ0eSB0aGF0IGlzIHRoZSBmaWx0ZXIgcGFyYW1ldGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIG1haW5QYXJhbWV0ZXI6ICdnYW1tYScsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLmdhbW1hID0gWzEsIDEsIDFdO1xuICAgICAgZmlsdGVycy5CYXNlRmlsdGVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBHYW1tYSBvcGVyYXRpb24gdG8gYSBVaW50OEFycmF5IHJlcHJlc2VudGluZyB0aGUgcGl4ZWxzIG9mIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gb3B0aW9ucy5pbWFnZURhdGEgVGhlIFVpbnQ4QXJyYXkgdG8gYmUgZmlsdGVyZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzJkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gb3B0aW9ucy5pbWFnZURhdGEsIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgICBnYW1tYSA9IHRoaXMuZ2FtbWEsIGxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIHJJbnYgPSAxIC8gZ2FtbWFbMF0sIGdJbnYgPSAxIC8gZ2FtbWFbMV0sXG4gICAgICAgICAgYkludiA9IDEgLyBnYW1tYVsyXSwgaTtcblxuICAgICAgaWYgKCF0aGlzLnJWYWxzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICB0aGlzLnJWYWxzID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHRoaXMuZ1ZhbHMgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgdGhpcy5iVmFscyA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgaXMgYW4gb3B0aW1pemF0aW9uIC0gcHJlLWNvbXB1dGUgYSBsb29rLXVwIHRhYmxlIGZvciBlYWNoIGNvbG9yIGNoYW5uZWxcbiAgICAgIC8vIGluc3RlYWQgb2YgcGVyZm9ybWluZyB0aGVzZSBwb3cgY2FsbHMgZm9yIGVhY2ggcGl4ZWwgaW4gdGhlIGltYWdlLlxuICAgICAgZm9yIChpID0gMCwgbGVuID0gMjU2OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5yVmFsc1tpXSA9IE1hdGgucG93KGkgLyAyNTUsIHJJbnYpICogMjU1O1xuICAgICAgICB0aGlzLmdWYWxzW2ldID0gTWF0aC5wb3coaSAvIDI1NSwgZ0ludikgKiAyNTU7XG4gICAgICAgIHRoaXMuYlZhbHNbaV0gPSBNYXRoLnBvdyhpIC8gMjU1LCBiSW52KSAqIDI1NTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgZGF0YVtpXSA9IHRoaXMuclZhbHNbZGF0YVtpXV07XG4gICAgICAgIGRhdGFbaSArIDFdID0gdGhpcy5nVmFsc1tkYXRhW2kgKyAxXV07XG4gICAgICAgIGRhdGFbaSArIDJdID0gdGhpcy5iVmFsc1tkYXRhW2kgKyAyXV07XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBXZWJHTCB1bmlmb3JtIGxvY2F0aW9ucyBmb3IgdGhpcyBmaWx0ZXIncyBzaGFkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgVGhlIEdMIGNhbnZhcyBjb250ZXh0IHVzZWQgdG8gY29tcGlsZSB0aGlzIGZpbHRlcidzIHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMU2hhZGVyUHJvZ3JhbX0gcHJvZ3JhbSBUaGlzIGZpbHRlcidzIGNvbXBpbGVkIHNoYWRlciBwcm9ncmFtLlxuICAgICAqL1xuICAgIGdldFVuaWZvcm1Mb2NhdGlvbnM6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1R2FtbWE6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUdhbW1hJyksXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgZnJvbSB0aGlzIGZpbHRlciB0byBpdHMgc2hhZGVyIHByb2dyYW0ncyB1bmlmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBUaGUgR0wgY2FudmFzIGNvbnRleHQgdXNlZCB0byBjb21waWxlIHRoaXMgZmlsdGVyJ3Mgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtTG9jYXRpb25zIEEgbWFwIG9mIHN0cmluZyB1bmlmb3JtIG5hbWVzIHRvIFdlYkdMVW5pZm9ybUxvY2F0aW9uIG9iamVjdHNcbiAgICAgKi9cbiAgICBzZW5kVW5pZm9ybURhdGE6IGZ1bmN0aW9uKGdsLCB1bmlmb3JtTG9jYXRpb25zKSB7XG4gICAgICBnbC51bmlmb3JtM2Z2KHVuaWZvcm1Mb2NhdGlvbnMudUdhbW1hLCB0aGlzLmdhbW1hKTtcbiAgICB9LFxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmaWx0ZXIgaW5zdGFuY2UgZnJvbSBhbiBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIHRvIGJlIGludm9rZWQgYWZ0ZXIgZmlsdGVyIGNyZWF0aW9uXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JbWFnZS5maWx0ZXJzLkdhbW1hfSBJbnN0YW5jZSBvZiBmYWJyaWMuSW1hZ2UuZmlsdGVycy5HYW1tYVxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuR2FtbWEuZnJvbU9iamVjdCA9IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXIuZnJvbU9iamVjdDtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEEgY29udGFpbmVyIGNsYXNzIHRoYXQga25vd3MgaG93IHRvIGFwcGx5IGEgc2VxdWVuY2Ugb2YgZmlsdGVycyB0byBhbiBpbnB1dCBpbWFnZS5cbiAgICovXG4gIGZpbHRlcnMuQ29tcG9zZWQgPSBjcmVhdGVDbGFzcyhmaWx0ZXJzLkJhc2VGaWx0ZXIsIC8qKiBAbGVuZHMgZmFicmljLkltYWdlLmZpbHRlcnMuQ29tcG9zZWQucHJvdG90eXBlICovIHtcblxuICAgIHR5cGU6ICdDb21wb3NlZCcsXG5cbiAgICAvKipcbiAgICAgKiBBIG5vbiBzcGFyc2UgYXJyYXkgb2YgZmlsdGVycyB0byBhcHBseVxuICAgICAqL1xuICAgIHN1YkZpbHRlcnM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIC8vIGNyZWF0ZSBhIG5ldyBhcnJheSBpbnN0ZWFkIG11dGF0aW5nIHRoZSBwcm90b3R5cGUgd2l0aCBwdXNoXG4gICAgICB0aGlzLnN1YkZpbHRlcnMgPSB0aGlzLnN1YkZpbHRlcnMuc2xpY2UoMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoaXMgY29udGFpbmVyJ3MgZmlsdGVycyB0byB0aGUgaW5wdXQgaW1hZ2UgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLnBhc3NlcyBUaGUgbnVtYmVyIG9mIGZpbHRlcnMgcmVtYWluaW5nIHRvIGJlIGFwcGxpZWQuXG4gICAgICovXG4gICAgYXBwbHlUbzogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucy5wYXNzZXMgKz0gdGhpcy5zdWJGaWx0ZXJzLmxlbmd0aCAtIDE7XG4gICAgICB0aGlzLnN1YkZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICAgICAgZmlsdGVyLmFwcGx5VG8ob3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoaXMgZmlsdGVyIGludG8gSlNPTi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IEEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZpbHRlci5cbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZCh0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnKSwge1xuICAgICAgICBzdWJGaWx0ZXJzOiB0aGlzLnN1YkZpbHRlcnMubWFwKGZ1bmN0aW9uKGZpbHRlcikgeyByZXR1cm4gZmlsdGVyLnRvT2JqZWN0KCk7IH0pLFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGlzTmV1dHJhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhdGhpcy5zdWJGaWx0ZXJzLnNvbWUoZnVuY3Rpb24oZmlsdGVyKSB7IHJldHVybiAhZmlsdGVyLmlzTmV1dHJhbFN0YXRlKCk7IH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIGEgSlNPTiBkZWZpbml0aW9uIG9mIGEgQ29tcG9zZWRGaWx0ZXIgaW50byBhIGNvbmNyZXRlIGluc3RhbmNlLlxuICAgKi9cbiAgZmFicmljLkltYWdlLmZpbHRlcnMuQ29tcG9zZWQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZmlsdGVycyA9IG9iamVjdC5zdWJGaWx0ZXJzIHx8IFtdLFxuICAgICAgICBzdWJGaWx0ZXJzID0gZmlsdGVycy5tYXAoZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBmYWJyaWMuSW1hZ2UuZmlsdGVyc1tmaWx0ZXIudHlwZV0oZmlsdGVyKTtcbiAgICAgICAgfSksXG4gICAgICAgIGluc3RhbmNlID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkNvbXBvc2VkKHsgc3ViRmlsdGVyczogc3ViRmlsdGVycyB9KTtcbiAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhpbnN0YW5jZSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZhYnJpYyAgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0geyB9KSxcbiAgICAgIGZpbHRlcnMgPSBmYWJyaWMuSW1hZ2UuZmlsdGVycyxcbiAgICAgIGNyZWF0ZUNsYXNzID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3M7XG5cbiAgLyoqXG4gICAqIEh1ZVJvdGF0aW9uIGZpbHRlciBjbGFzc1xuICAgKiBAY2xhc3MgZmFicmljLkltYWdlLmZpbHRlcnMuSHVlUm90YXRpb25cbiAgICogQG1lbWJlck9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzXG4gICAqIEBleHRlbmRzIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkJhc2VGaWx0ZXJcbiAgICogQHNlZSB7QGxpbmsgZmFicmljLkltYWdlLmZpbHRlcnMuSHVlUm90YXRpb24jaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICogQHNlZSB7QGxpbmsgaHR0cDovL2ZhYnJpY2pzLmNvbS9pbWFnZS1maWx0ZXJzfEltYWdlRmlsdGVycyBkZW1vfVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgZmlsdGVyID0gbmV3IGZhYnJpYy5JbWFnZS5maWx0ZXJzLkh1ZVJvdGF0aW9uKHtcbiAgICogICByb3RhdGlvbjogLTAuNVxuICAgKiB9KTtcbiAgICogb2JqZWN0LmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgKiBvYmplY3QuYXBwbHlGaWx0ZXJzKCk7XG4gICAqL1xuICBmaWx0ZXJzLkh1ZVJvdGF0aW9uID0gY3JlYXRlQ2xhc3MoZmlsdGVycy5Db2xvck1hdHJpeCwgLyoqIEBsZW5kcyBmYWJyaWMuSW1hZ2UuZmlsdGVycy5IdWVSb3RhdGlvbi5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ0h1ZVJvdGF0aW9uJyxcblxuICAgIC8qKlxuICAgICAqIEh1ZVJvdGF0aW9uIHZhbHVlLCBmcm9tIC0xIHRvIDEuXG4gICAgICogdGhlIHVuaXQgaXMgcmFkaWFuc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBteVBhcmFtZXRlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgcm90YXRpb246IDAsXG5cbiAgICAvKipcbiAgICAgKiBEZXNjcmliZSB0aGUgcHJvcGVydHkgdGhhdCBpcyB0aGUgZmlsdGVyIHBhcmFtZXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtYWluUGFyYW1ldGVyOiAncm90YXRpb24nLFxuXG4gICAgY2FsY3VsYXRlTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByYWQgPSB0aGlzLnJvdGF0aW9uICogTWF0aC5QSSwgY29zID0gZmFicmljLnV0aWwuY29zKHJhZCksIHNpbiA9IGZhYnJpYy51dGlsLnNpbihyYWQpLFxuICAgICAgICAgIGFUaGlyZCA9IDEgLyAzLCBhVGhpcmRTcXRTaW4gPSBNYXRoLnNxcnQoYVRoaXJkKSAqIHNpbiwgT25lTWludXNDb3MgPSAxIC0gY29zO1xuICAgICAgdGhpcy5tYXRyaXggPSBbXG4gICAgICAgIDEsIDAsIDAsIDAsIDAsXG4gICAgICAgIDAsIDEsIDAsIDAsIDAsXG4gICAgICAgIDAsIDAsIDEsIDAsIDAsXG4gICAgICAgIDAsIDAsIDAsIDEsIDBcbiAgICAgIF07XG4gICAgICB0aGlzLm1hdHJpeFswXSA9IGNvcyArIE9uZU1pbnVzQ29zIC8gMztcbiAgICAgIHRoaXMubWF0cml4WzFdID0gYVRoaXJkICogT25lTWludXNDb3MgLSBhVGhpcmRTcXRTaW47XG4gICAgICB0aGlzLm1hdHJpeFsyXSA9IGFUaGlyZCAqIE9uZU1pbnVzQ29zICsgYVRoaXJkU3F0U2luO1xuICAgICAgdGhpcy5tYXRyaXhbNV0gPSBhVGhpcmQgKiBPbmVNaW51c0NvcyArIGFUaGlyZFNxdFNpbjtcbiAgICAgIHRoaXMubWF0cml4WzZdID0gY29zICsgYVRoaXJkICogT25lTWludXNDb3M7XG4gICAgICB0aGlzLm1hdHJpeFs3XSA9IGFUaGlyZCAqIE9uZU1pbnVzQ29zIC0gYVRoaXJkU3F0U2luO1xuICAgICAgdGhpcy5tYXRyaXhbMTBdID0gYVRoaXJkICogT25lTWludXNDb3MgLSBhVGhpcmRTcXRTaW47XG4gICAgICB0aGlzLm1hdHJpeFsxMV0gPSBhVGhpcmQgKiBPbmVNaW51c0NvcyArIGFUaGlyZFNxdFNpbjtcbiAgICAgIHRoaXMubWF0cml4WzEyXSA9IGNvcyArIGFUaGlyZCAqIE9uZU1pbnVzQ29zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIdWVSb3RhdGlvbiBpc05ldXRyYWxTdGF0ZSBpbXBsZW1lbnRhdGlvblxuICAgICAqIFVzZWQgb25seSBpbiBpbWFnZSBhcHBseUZpbHRlcnMgdG8gZGlzY2FyZCBmaWx0ZXJzIHRoYXQgd2lsbCBub3QgaGF2ZSBhbiBlZmZlY3RcbiAgICAgKiBvbiB0aGUgaW1hZ2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqKi9cbiAgICBpc05ldXRyYWxTdGF0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdGhpcy5jYWxjdWxhdGVNYXRyaXgoKTtcbiAgICAgIHJldHVybiBmaWx0ZXJzLkJhc2VGaWx0ZXIucHJvdG90eXBlLmlzTmV1dHJhbFN0YXRlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoaXMgZmlsdGVyIHRvIHRoZSBpbnB1dCBpbWFnZSBkYXRhIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIHVzZSBXZWJHTCBvciBDYW52YXMyRCBiYXNlZCBvbiB0aGUgb3B0aW9ucy53ZWJnbCBmbGFnLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5wYXNzZXMgVGhlIG51bWJlciBvZiBmaWx0ZXJzIHJlbWFpbmluZyB0byBiZSBleGVjdXRlZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy53ZWJnbCBXaGV0aGVyIHRvIHVzZSB3ZWJnbCB0byByZW5kZXIgdGhlIGZpbHRlci5cbiAgICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gb3B0aW9ucy5zb3VyY2VUZXh0dXJlIFRoZSB0ZXh0dXJlIHNldHVwIGFzIHRoZSBzb3VyY2UgdG8gYmUgZmlsdGVyZWQuXG4gICAgICogQHBhcmFtIHtXZWJHTFRleHR1cmV9IG9wdGlvbnMudGFyZ2V0VGV4dHVyZSBUaGUgdGV4dHVyZSB3aGVyZSBmaWx0ZXJlZCBvdXRwdXQgc2hvdWxkIGJlIGRyYXduLlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBvcHRpb25zLmNvbnRleHQgVGhlIEdMIGNvbnRleHQgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnByb2dyYW1DYWNoZSBBIG1hcCBvZiBjb21waWxlZCBzaGFkZXIgcHJvZ3JhbXMsIGtleWVkIGJ5IGZpbHRlciB0eXBlLlxuICAgICAqL1xuICAgIGFwcGx5VG86IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuY2FsY3VsYXRlTWF0cml4KCk7XG4gICAgICBmaWx0ZXJzLkJhc2VGaWx0ZXIucHJvdG90eXBlLmFwcGx5VG8uY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZpbHRlciBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gdG8gYmUgaW52b2tlZCBhZnRlciBmaWx0ZXIgY3JlYXRpb25cbiAgICogQHJldHVybiB7ZmFicmljLkltYWdlLmZpbHRlcnMuSHVlUm90YXRpb259IEluc3RhbmNlIG9mIGZhYnJpYy5JbWFnZS5maWx0ZXJzLkh1ZVJvdGF0aW9uXG4gICAqL1xuICBmYWJyaWMuSW1hZ2UuZmlsdGVycy5IdWVSb3RhdGlvbi5mcm9tT2JqZWN0ID0gZmFicmljLkltYWdlLmZpbHRlcnMuQmFzZUZpbHRlci5mcm9tT2JqZWN0O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpcyk7XG5cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZmFicmljID0gZ2xvYmFsLmZhYnJpYyB8fCAoZ2xvYmFsLmZhYnJpYyA9IHsgfSksXG4gICAgICBjbG9uZSA9IGZhYnJpYy51dGlsLm9iamVjdC5jbG9uZTtcblxuICBpZiAoZmFicmljLlRleHQpIHtcbiAgICBmYWJyaWMud2FybignZmFicmljLlRleHQgaXMgYWxyZWFkeSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGFkZGl0aW9uYWxQcm9wcyA9XG4gICAgKCdmb250RmFtaWx5IGZvbnRXZWlnaHQgZm9udFNpemUgdGV4dCB1bmRlcmxpbmUgb3ZlcmxpbmUgbGluZXRocm91Z2gnICtcbiAgICAnIHRleHRBbGlnbiBmb250U3R5bGUgbGluZUhlaWdodCB0ZXh0QmFja2dyb3VuZENvbG9yIGNoYXJTcGFjaW5nIHN0eWxlcycgK1xuICAgICcgZGlyZWN0aW9uIHBhdGggcGF0aFN0YXJ0T2Zmc2V0IHBhdGhTaWRlIHBhdGhBbGlnbicpLnNwbGl0KCcgJyk7XG5cbiAgLyoqXG4gICAqIFRleHQgY2xhc3NcbiAgICogQGNsYXNzIGZhYnJpYy5UZXh0XG4gICAqIEBleHRlbmRzIGZhYnJpYy5PYmplY3RcbiAgICogQHJldHVybiB7ZmFicmljLlRleHR9IHRoaXNBcmdcbiAgICogQHR1dG9yaWFsIHtAbGluayBodHRwOi8vZmFicmljanMuY29tL2ZhYnJpYy1pbnRyby1wYXJ0LTIjdGV4dH1cbiAgICogQHNlZSB7QGxpbmsgZmFicmljLlRleHQjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICovXG4gIGZhYnJpYy5UZXh0ID0gZmFicmljLnV0aWwuY3JlYXRlQ2xhc3MoZmFicmljLk9iamVjdCwgLyoqIEBsZW5kcyBmYWJyaWMuVGV4dC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyB3aGljaCB3aGVuIHNldCBjYXVzZSBvYmplY3QgdG8gY2hhbmdlIGRpbWVuc2lvbnNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2RpbWVuc2lvbkFmZmVjdGluZ1Byb3BzOiBbXG4gICAgICAnZm9udFNpemUnLFxuICAgICAgJ2ZvbnRXZWlnaHQnLFxuICAgICAgJ2ZvbnRGYW1pbHknLFxuICAgICAgJ2ZvbnRTdHlsZScsXG4gICAgICAnbGluZUhlaWdodCcsXG4gICAgICAndGV4dCcsXG4gICAgICAnY2hhclNwYWNpbmcnLFxuICAgICAgJ3RleHRBbGlnbicsXG4gICAgICAnc3R5bGVzJyxcbiAgICAgICdwYXRoJyxcbiAgICAgICdwYXRoU3RhcnRPZmZzZXQnLFxuICAgICAgJ3BhdGhTaWRlJyxcbiAgICAgICdwYXRoQWxpZ24nXG4gICAgXSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlTmV3bGluZTogL1xccj9cXG4vLFxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgcmVndWxhciBleHByZXNzaW9uIHRvIGZpbHRlciBmb3Igd2hpdGVzcGFjZXMgdGhhdCBpcyBub3QgYSBuZXcgbGluZS5cbiAgICAgKiBNb3N0bHkgdXNlZCB3aGVuIHRleHQgaXMgJ2p1c3RpZnknIGFsaWduZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVTcGFjZXNBbmRUYWJzOiAvWyBcXHRcXHJdL2csXG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyByZWd1bGFyIGV4cHJlc3Npb24gdG8gZmlsdGVyIGZvciB3aGl0ZXNwYWNlIHRoYXQgaXMgbm90IGEgbmV3IGxpbmUuXG4gICAgICogTW9zdGx5IHVzZWQgd2hlbiB0ZXh0IGlzICdqdXN0aWZ5JyBhbGlnbmVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlU3BhY2VBbmRUYWI6IC9bIFxcdFxccl0vLFxuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgcmVndWxhciBleHByZXNzaW9uIHRvIGZpbHRlciBjb25zZWN1dGl2ZSBncm91cHMgb2Ygbm9uIHNwYWNlcy5cbiAgICAgKiBNb3N0bHkgdXNlZCB3aGVuIHRleHQgaXMgJ2p1c3RpZnknIGFsaWduZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVXb3JkczogL1xcUysvZyxcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAgICAgICAgICAgICAgICAgJ3RleHQnLFxuXG4gICAgLyoqXG4gICAgICogRm9udCBzaXplIChpbiBwaXhlbHMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmb250U2l6ZTogICAgICAgICAgICAgNDAsXG5cbiAgICAvKipcbiAgICAgKiBGb250IHdlaWdodCAoZS5nLiBib2xkLCBub3JtYWwsIDQwMCwgNjAwLCA4MDApXG4gICAgICogQHR5cGUgeyhOdW1iZXJ8U3RyaW5nKX1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGZvbnRXZWlnaHQ6ICAgICAgICAgICAnbm9ybWFsJyxcblxuICAgIC8qKlxuICAgICAqIEZvbnQgZmFtaWx5XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBmb250RmFtaWx5OiAgICAgICAgICAgJ1RpbWVzIE5ldyBSb21hbicsXG5cbiAgICAvKipcbiAgICAgKiBUZXh0IGRlY29yYXRpb24gdW5kZXJsaW5lLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHVuZGVybGluZTogICAgICAgZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUZXh0IGRlY29yYXRpb24gb3ZlcmxpbmUuXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgb3ZlcmxpbmU6ICAgICAgIGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGV4dCBkZWNvcmF0aW9uIGxpbmV0aHJvdWdoLlxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxpbmV0aHJvdWdoOiAgICAgICBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFRleHQgYWxpZ25tZW50LiBQb3NzaWJsZSB2YWx1ZXM6IFwibGVmdFwiLCBcImNlbnRlclwiLCBcInJpZ2h0XCIsIFwianVzdGlmeVwiLFxuICAgICAqIFwianVzdGlmeS1sZWZ0XCIsIFwianVzdGlmeS1jZW50ZXJcIiBvciBcImp1c3RpZnktcmlnaHRcIi5cbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHRleHRBbGlnbjogICAgICAgICAgICAnbGVmdCcsXG5cbiAgICAvKipcbiAgICAgKiBGb250IHN0eWxlIC4gUG9zc2libGUgdmFsdWVzOiBcIlwiLCBcIm5vcm1hbFwiLCBcIml0YWxpY1wiIG9yIFwib2JsaXF1ZVwiLlxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZm9udFN0eWxlOiAgICAgICAgICAgICdub3JtYWwnLFxuXG4gICAgLyoqXG4gICAgICogTGluZSBoZWlnaHRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGxpbmVIZWlnaHQ6ICAgICAgICAgICAxLjE2LFxuXG4gICAgLyoqXG4gICAgICogU3VwZXJzY3JpcHQgc2NoZW1hIG9iamVjdCAobWluaW11bSBvdmVybGFwKVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdXBlcnNjcmlwdDoge1xuICAgICAgc2l6ZTogICAgICAwLjYwLCAvLyBmb250U2l6ZSBmYWN0b3JcbiAgICAgIGJhc2VsaW5lOiAtMC4zNSAgLy8gYmFzZWxpbmUtc2hpZnQgZmFjdG9yICh1cHdhcmRzKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpcHQgc2NoZW1hIG9iamVjdCAobWluaW11bSBvdmVybGFwKVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdWJzY3JpcHQ6IHtcbiAgICAgIHNpemU6ICAgICAgMC42MCwgLy8gZm9udFNpemUgZmFjdG9yXG4gICAgICBiYXNlbGluZTogIDAuMTEgIC8vIGJhc2VsaW5lLXNoaWZ0IGZhY3RvciAoZG93bndhcmRzKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCYWNrZ3JvdW5kIGNvbG9yIG9mIHRleHQgbGluZXNcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHRleHRCYWNrZ3JvdW5kQ29sb3I6ICAnJyxcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgcHJvcGVydGllcyB0byBjb25zaWRlciB3aGVuIGNoZWNraW5nIGlmXG4gICAgICogc3RhdGUgb2YgYW4gb2JqZWN0IGlzIGNoYW5nZWQgKHtAbGluayBmYWJyaWMuT2JqZWN0I2hhc1N0YXRlQ2hhbmdlZH0pXG4gICAgICogYXMgd2VsbCBhcyBmb3IgaGlzdG9yeSAodW5kby9yZWRvKSBwdXJwb3Nlc1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICovXG4gICAgc3RhdGVQcm9wZXJ0aWVzOiBmYWJyaWMuT2JqZWN0LnByb3RvdHlwZS5zdGF0ZVByb3BlcnRpZXMuY29uY2F0KGFkZGl0aW9uYWxQcm9wcyksXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHByb3BlcnRpZXMgdG8gY29uc2lkZXIgd2hlbiBjaGVja2luZyBpZiBjYWNoZSBuZWVkcyByZWZyZXNoXG4gICAgICogQHR5cGUgQXJyYXlcbiAgICAgKi9cbiAgICBjYWNoZVByb3BlcnRpZXM6IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNhY2hlUHJvcGVydGllcy5jb25jYXQoYWRkaXRpb25hbFByb3BzKSxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gZGVmaW5lZCwgYW4gb2JqZWN0IGlzIHJlbmRlcmVkIHZpYSBzdHJva2UgYW5kIHRoaXMgcHJvcGVydHkgc3BlY2lmaWVzIGl0cyBjb2xvci5cbiAgICAgKiA8Yj5CYWNrd2FyZHMgaW5jb21wYXRpYmlsaXR5IG5vdGU6PC9iPiBUaGlzIHByb3BlcnR5IHdhcyBuYW1lZCBcInN0cm9rZVN0eWxlXCIgdW50aWwgdjEuMS42XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHJva2U6ICAgICAgICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFNoYWRvdyBvYmplY3QgcmVwcmVzZW50aW5nIHNoYWRvdyBvZiB0aGlzIHNoYXBlLlxuICAgICAqIDxiPkJhY2t3YXJkcyBpbmNvbXBhdGliaWxpdHkgbm90ZTo8L2I+IFRoaXMgcHJvcGVydHkgd2FzIG5hbWVkIFwidGV4dFNoYWRvd1wiIChTdHJpbmcpIHVudGlsIHYxLjIuMTFcbiAgICAgKiBAdHlwZSBmYWJyaWMuU2hhZG93XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzaGFkb3c6ICAgICAgICAgICAgICAgbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGZhYnJpYy5QYXRoIHRoYXQgdGhlIHRleHQgc2hvdWxkIGZvbGxvdy5cbiAgICAgKiBzaW5jZSA0LjYuMCB0aGUgcGF0aCB3aWxsIGJlIGRyYXduIGF1dG9tYXRpY2FsbHkuXG4gICAgICogaWYgeW91IHdhbnQgdG8gbWFrZSB0aGUgcGF0aCB2aXNpYmxlLCBnaXZlIGl0IGEgc3Ryb2tlIGFuZCBzdHJva2VXaWR0aCBvciBmaWxsIHZhbHVlXG4gICAgICogaWYgeW91IHdhbnQgaXQgdG8gYmUgaGlkZGVuLCBhc3NpZ24gdmlzaWJsZSA9IGZhbHNlIHRvIHRoZSBwYXRoLlxuICAgICAqIFRoaXMgZmVhdHVyZSBpcyBpbiBCRVRBLCBhbmQgU1ZHIGltcG9ydC9leHBvcnQgaXMgbm90IHlldCBzdXBwb3J0ZWQuXG4gICAgICogQHR5cGUgZmFicmljLlBhdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciB0ZXh0UGF0aCA9IG5ldyBmYWJyaWMuVGV4dCgnVGV4dCBvbiBhIHBhdGgnLCB7XG4gICAgICogICAgIHRvcDogMTUwLFxuICAgICAqICAgICBsZWZ0OiAxNTAsXG4gICAgICogICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICogICAgIGNoYXJTcGFjaW5nOiAtNTAsXG4gICAgICogICAgIHBhdGg6IG5ldyBmYWJyaWMuUGF0aCgnTSAwIDAgQyA1MCAtMTAwIDE1MCAtMTAwIDIwMCAwJywge1xuICAgICAqICAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICogICAgICAgICB2aXNpYmxlOiBmYWxzZVxuICAgICAqICAgICB9KSxcbiAgICAgKiAgICAgcGF0aFNpZGU6ICdsZWZ0JyxcbiAgICAgKiAgICAgcGF0aFN0YXJ0T2Zmc2V0OiAwXG4gICAgICogfSk7XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwYXRoOiAgICAgICAgICAgICAgIG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBPZmZzZXQgYW1vdW50IGZvciB0ZXh0IHBhdGggc3RhcnRpbmcgcG9zaXRpb25cbiAgICAgKiBPbmx5IHVzZWQgd2hlbiB0ZXh0IGhhcyBhIHBhdGhcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBhdGhTdGFydE9mZnNldDogICAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogV2hpY2ggc2lkZSBvZiB0aGUgcGF0aCB0aGUgdGV4dCBzaG91bGQgYmUgZHJhd24gb24uXG4gICAgICogT25seSB1c2VkIHdoZW4gdGV4dCBoYXMgYSBwYXRoXG4gICAgICogQHR5cGUge1N0cmluZ30gJ2xlZnR8cmlnaHQnXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBwYXRoU2lkZTogICAgICAgICAgICAgICAnbGVmdCcsXG5cbiAgICAvKipcbiAgICAgKiBIb3cgdGV4dCBpcyBhbGlnbmVkIHRvIHRoZSBwYXRoLiBUaGlzIHByb3BlcnR5IGRldGVybWluZXNcbiAgICAgKiB0aGUgcGVycGVuZGljdWxhciBwb3NpdGlvbiBvZiBlYWNoIGNoYXJhY3RlciByZWxhdGl2ZSB0byB0aGUgcGF0aC5cbiAgICAgKiAob25lIG9mIFwiYmFzZWxpbmVcIiwgXCJjZW50ZXJcIiwgXCJhc2NlbmRlclwiLCBcImRlc2NlbmRlclwiKVxuICAgICAqIFRoaXMgZmVhdHVyZSBpcyBpbiBCRVRBLCBhbmQgaXRzIGJlaGF2aW9yIG1heSBjaGFuZ2VcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIHBhdGhBbGlnbjogICAgICAgICAgICAgICAnYmFzZWxpbmUnLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZm9udFNpemVGcmFjdGlvbjogMC4yMjIsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9mZnNldHM6IHtcbiAgICAgIHVuZGVybGluZTogMC4xMCxcbiAgICAgIGxpbmV0aHJvdWdoOiAtMC4zMTUsXG4gICAgICBvdmVybGluZTogLTAuODhcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGV4dCBMaW5lIHByb3BvcnRpb24gdG8gZm9udCBTaXplIChpbiBwaXhlbHMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBfZm9udFNpemVNdWx0OiAgICAgICAgICAgICAxLjEzLFxuXG4gICAgLyoqXG4gICAgICogYWRkaXRpb25hbCBzcGFjZSBiZXR3ZWVuIGNoYXJhY3RlcnNcbiAgICAgKiBleHByZXNzZWQgaW4gdGhvdXNhbmRzIG9mIGVtIHVuaXRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNoYXJTcGFjaW5nOiAgICAgICAgICAgICAwLFxuXG4gICAgLyoqXG4gICAgICogT2JqZWN0IGNvbnRhaW5pbmcgY2hhcmFjdGVyIHN0eWxlcyAtIHRvcC1sZXZlbCBwcm9wZXJ0aWVzIC0+IGxpbmUgbnVtYmVycyxcbiAgICAgKiAybmQtbGV2ZWwgcHJvcGVydGllcyAtIGNoYXJhY3RlciBudW1iZXJzXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzdHlsZXM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gYSBjb250ZXh0IHRvIG1lYXN1cmUgdGV4dCBjaGFyIG9yIGNvdXBsZSBvZiBjaGFyc1xuICAgICAqIHRoZSBjYWNoZUNvbnRleHQgb2YgdGhlIGNhbnZhcyB3aWxsIGJlIHVzZWQgb3IgYSBmcmVzaGx5IGNyZWF0ZWQgb25lIGlmIHRoZSBvYmplY3QgaXMgbm90IG9uIGNhbnZhc1xuICAgICAqIG9uY2UgY3JlYXRlZCBpdCB3aWxsIGJlIHJlZmVyZW5jZWQgb24gZmFicmljLl9tZWFzdXJpbmdDb250ZXh0IHRvIGF2b2lkIGNyZWF0aW5nIGEgY2FudmFzIGZvciBldmVyeVxuICAgICAqIHRleHQgb2JqZWN0IGNyZWF0ZWQuXG4gICAgICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIF9tZWFzdXJpbmdDb250ZXh0OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQmFzZWxpbmUgc2hpZnQsIHN0eWxlcyBvbmx5LCBrZWVwIGF0IDAgZm9yIHRoZSBtYWluIHRleHQgb2JqZWN0XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGRlbHRhWTogMCxcblxuICAgIC8qKlxuICAgICAqIFdBUk5JTkc6IEVYUEVSSU1FTlRBTC4gTk9UIFNVUFBPUlRFRCBZRVRcbiAgICAgKiBkZXRlcm1pbmUgdGhlIGRpcmVjdGlvbiBvZiB0aGUgdGV4dC5cbiAgICAgKiBUaGlzIGhhcyB0byBiZSBzZXQgbWFudWFsbHkgdG9nZXRoZXIgd2l0aCB0ZXh0QWxpZ24gYW5kIG9yaWdpblggZm9yIHByb3BlclxuICAgICAqIGV4cGVyaWVuY2UuXG4gICAgICogc29tZSBpbnRlcmVzdGluZyBsaW5rIGZvciB0aGUgZnV0dXJlXG4gICAgICogaHR0cHM6Ly93d3cudzMub3JnL0ludGVybmF0aW9uYWwvcXVlc3Rpb25zL3FhLWJpZGktdW5pY29kZS1jb250cm9sc1xuICAgICAqIEBzaW5jZSA0LjUuMFxuICAgICAqIEB0eXBlIHtTdHJpbmd9ICdsdHJ8cnRsJ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgZGlyZWN0aW9uOiAnbHRyJyxcblxuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIHByb3BlcnRpZXMgdGhhdCBkZWZpbmUgYSBzdHlsZSB1bml0IChvZiAnc3R5bGVzJykuXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgX3N0eWxlUHJvcGVydGllczogW1xuICAgICAgJ3N0cm9rZScsXG4gICAgICAnc3Ryb2tlV2lkdGgnLFxuICAgICAgJ2ZpbGwnLFxuICAgICAgJ2ZvbnRGYW1pbHknLFxuICAgICAgJ2ZvbnRTaXplJyxcbiAgICAgICdmb250V2VpZ2h0JyxcbiAgICAgICdmb250U3R5bGUnLFxuICAgICAgJ3VuZGVybGluZScsXG4gICAgICAnb3ZlcmxpbmUnLFxuICAgICAgJ2xpbmV0aHJvdWdoJyxcbiAgICAgICdkZWx0YVknLFxuICAgICAgJ3RleHRCYWNrZ3JvdW5kQ29sb3InLFxuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBjb250YWlucyBjaGFyYWN0ZXJzIGJvdW5kaW5nIGJveGVzXG4gICAgICovXG4gICAgX19jaGFyQm91bmRzOiBbXSxcblxuICAgIC8qKlxuICAgICAqIHVzZSB0aGlzIHNpemUgd2hlbiBtZWFzdXJpbmcgdGV4dC4gVG8gYXZvaWQgSUUxMSByb3VuZGluZyBlcnJvcnNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBDQUNIRV9GT05UX1NJWkU6IDQwMCxcblxuICAgIC8qKlxuICAgICAqIGNvbnRhaW5zIHRoZSBtaW4gdGV4dCB3aWR0aCB0byBhdm9pZCBnZXR0aW5nIDBcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgTUlOX1RFWFRfV0lEVEg6IDIsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRleHQgc3RyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5UZXh0fSB0aGlzQXJnXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24odGV4dCwgb3B0aW9ucykge1xuICAgICAgdGhpcy5zdHlsZXMgPSBvcHRpb25zID8gKG9wdGlvbnMuc3R5bGVzIHx8IHsgfSkgOiB7IH07XG4gICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgdGhpcy5fX3NraXBEaW1lbnNpb24gPSB0cnVlO1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ2luaXRpYWxpemUnLCBvcHRpb25zKTtcbiAgICAgIGlmICh0aGlzLnBhdGgpIHtcbiAgICAgICAgdGhpcy5zZXRQYXRoSW5mbygpO1xuICAgICAgfVxuICAgICAgdGhpcy5fX3NraXBEaW1lbnNpb24gPSBmYWxzZTtcbiAgICAgIHRoaXMuaW5pdERpbWVuc2lvbnMoKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgICB0aGlzLnNldHVwU3RhdGUoeyBwcm9wZXJ0eVNldDogJ19kaW1lbnNpb25BZmZlY3RpbmdQcm9wcycgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRleHQgaGFzIGEgcGF0aCwgaXQgd2lsbCBhZGQgdGhlIGV4dHJhIGluZm9ybWF0aW9uIG5lZWRlZFxuICAgICAqIGZvciBwYXRoIGFuZCB0ZXh0IGNhbGN1bGF0aW9uc1xuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5UZXh0fSB0aGlzQXJnXG4gICAgICovXG4gICAgc2V0UGF0aEluZm86IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICBwYXRoLnNlZ21lbnRzSW5mbyA9IGZhYnJpYy51dGlsLmdldFBhdGhTZWdtZW50c0luZm8ocGF0aC5wYXRoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgY29udGV4dCBmb3IgbWVhc3VyZW1lbnQgb2YgdGV4dCBzdHJpbmcuXG4gICAgICogaWYgY3JlYXRlZCBpdCBnZXRzIHN0b3JlZCBmb3IgcmV1c2VcbiAgICAgKiB0aGlzIGlzIGZvciBpbnRlcm5hbCB1c2UsIHBsZWFzZSBkbyBub3QgdXNlIGl0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUZXh0IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGdldE1lYXN1cmluZ0NvbnRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gaWYgd2UgZGlkIG5vdCByZXR1cm4gd2UgaGF2ZSB0byBtZWFzdXJlIHNvbWV0aGluZy5cbiAgICAgIGlmICghZmFicmljLl9tZWFzdXJpbmdDb250ZXh0KSB7XG4gICAgICAgIGZhYnJpYy5fbWVhc3VyaW5nQ29udGV4dCA9IHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmNvbnRleHRDYWNoZSB8fFxuICAgICAgICAgIGZhYnJpYy51dGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhYnJpYy5fbWVhc3VyaW5nQ29udGV4dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBEaXZpZGVzIHRleHQgaW50byBsaW5lcyBvZiB0ZXh0IGFuZCBsaW5lcyBvZiBncmFwaGVtZXMuXG4gICAgICovXG4gICAgX3NwbGl0VGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbmV3TGluZXMgPSB0aGlzLl9zcGxpdFRleHRJbnRvTGluZXModGhpcy50ZXh0KTtcbiAgICAgIHRoaXMudGV4dExpbmVzID0gbmV3TGluZXMubGluZXM7XG4gICAgICB0aGlzLl90ZXh0TGluZXMgPSBuZXdMaW5lcy5ncmFwaGVtZUxpbmVzO1xuICAgICAgdGhpcy5fdW53cmFwcGVkVGV4dExpbmVzID0gbmV3TGluZXMuX3Vud3JhcHBlZExpbmVzO1xuICAgICAgdGhpcy5fdGV4dCA9IG5ld0xpbmVzLmdyYXBoZW1lVGV4dDtcbiAgICAgIHJldHVybiBuZXdMaW5lcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBvciB1cGRhdGUgdGV4dCBkaW1lbnNpb25zLlxuICAgICAqIFVwZGF0ZXMgdGhpcy53aWR0aCBhbmQgdGhpcy5oZWlnaHQgd2l0aCB0aGUgcHJvcGVyIHZhbHVlcy5cbiAgICAgKiBEb2VzIG5vdCByZXR1cm4gZGltZW5zaW9ucy5cbiAgICAgKi9cbiAgICBpbml0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fX3NraXBEaW1lbnNpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3BsaXRUZXh0KCk7XG4gICAgICB0aGlzLl9jbGVhckNhY2hlKCk7XG4gICAgICBpZiAodGhpcy5wYXRoKSB7XG4gICAgICAgIC8vIEFkZCB0aGUgc3BhY2Ugb2YgYSBsaW5lIGFyb3VuZCB0aGUgcGF0aC4gVGhpcyBpcyBhbiBhcHByb3hpbWF0aW9uXG4gICAgICAgIHZhciBhZGRpdGlvbmFsV2lkdGggPSB0aGlzLmdldEhlaWdodE9mTGluZSgwKSAqIDEuMTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMucGF0aC53aWR0aCArIGFkZGl0aW9uYWxXaWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLnBhdGguaGVpZ2h0ICsgYWRkaXRpb25hbFdpZHRoO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLmNhbGNUZXh0V2lkdGgoKSB8fCB0aGlzLmN1cnNvcldpZHRoIHx8IHRoaXMuTUlOX1RFWFRfV0lEVEg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jYWxjVGV4dEhlaWdodCgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudGV4dEFsaWduLmluZGV4T2YoJ2p1c3RpZnknKSAhPT0gLTEpIHtcbiAgICAgICAgLy8gb25jZSB0ZXh0IGlzIG1lYXN1cmVkIHdlIG5lZWQgdG8gbWFrZSBzcGFjZSBmYXR0ZXIgdG8gbWFrZSBqdXN0aWZpZWQgdGV4dC5cbiAgICAgICAgdGhpcy5lbmxhcmdlU3BhY2VzKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnNhdmVTdGF0ZSh7IHByb3BlcnR5U2V0OiAnX2RpbWVuc2lvbkFmZmVjdGluZ1Byb3BzJyB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW5sYXJnZSBzcGFjZSBib3hlcyBhbmQgc2hpZnQgdGhlIG90aGVyc1xuICAgICAqL1xuICAgIGVubGFyZ2VTcGFjZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRpZmZTcGFjZSwgY3VycmVudExpbmVXaWR0aCwgbnVtYmVyT2ZTcGFjZXMsIGFjY3VtdWxhdGVkU3BhY2UsIGxpbmUsIGNoYXJCb3VuZCwgc3BhY2VzO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAodGhpcy50ZXh0QWxpZ24gIT09ICdqdXN0aWZ5JyAmJiAoaSA9PT0gbGVuIC0gMSB8fCB0aGlzLmlzRW5kT2ZXcmFwcGluZyhpKSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBhY2N1bXVsYXRlZFNwYWNlID0gMDtcbiAgICAgICAgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tpXTtcbiAgICAgICAgY3VycmVudExpbmVXaWR0aCA9IHRoaXMuZ2V0TGluZVdpZHRoKGkpO1xuICAgICAgICBpZiAoY3VycmVudExpbmVXaWR0aCA8IHRoaXMud2lkdGggJiYgKHNwYWNlcyA9IHRoaXMudGV4dExpbmVzW2ldLm1hdGNoKHRoaXMuX3JlU3BhY2VzQW5kVGFicykpKSB7XG4gICAgICAgICAgbnVtYmVyT2ZTcGFjZXMgPSBzcGFjZXMubGVuZ3RoO1xuICAgICAgICAgIGRpZmZTcGFjZSA9ICh0aGlzLndpZHRoIC0gY3VycmVudExpbmVXaWR0aCkgLyBudW1iZXJPZlNwYWNlcztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGxpbmUubGVuZ3RoOyBqIDw9IGpsZW47IGorKykge1xuICAgICAgICAgICAgY2hhckJvdW5kID0gdGhpcy5fX2NoYXJCb3VuZHNbaV1bal07XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVTcGFjZUFuZFRhYi50ZXN0KGxpbmVbal0pKSB7XG4gICAgICAgICAgICAgIGNoYXJCb3VuZC53aWR0aCArPSBkaWZmU3BhY2U7XG4gICAgICAgICAgICAgIGNoYXJCb3VuZC5rZXJuZWRXaWR0aCArPSBkaWZmU3BhY2U7XG4gICAgICAgICAgICAgIGNoYXJCb3VuZC5sZWZ0ICs9IGFjY3VtdWxhdGVkU3BhY2U7XG4gICAgICAgICAgICAgIGFjY3VtdWxhdGVkU3BhY2UgKz0gZGlmZlNwYWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGNoYXJCb3VuZC5sZWZ0ICs9IGFjY3VtdWxhdGVkU3BhY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBpZiB0aGUgdGV4dCBsaW5lIGlzIGVuZGVkIHdpdGggYW4gaGFyZCBicmVha1xuICAgICAqIHRleHQgYW5kIGl0ZXh0IGRvIG5vdCBoYXZlIHdyYXBwaW5nLCByZXR1cm4gZmFsc2VcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzRW5kT2ZXcmFwcGluZzogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICByZXR1cm4gbGluZUluZGV4ID09PSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoIC0gMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IGlmIGEgbGluZSBoYXMgYSBsaW5lYnJlYWsgYW5kIHNvIHdlIG5lZWQgdG8gYWNjb3VudCBmb3IgaXQgd2hlbiBtb3ZpbmdcbiAgICAgKiBhbmQgY291bnRpbmcgc3R5bGUuXG4gICAgICogSXQgcmV0dXJuIGFsd2F5cyBmb3IgdGV4dCBhbmQgSXRleHQuXG4gICAgICogQHJldHVybiBOdW1iZXJcbiAgICAgKi9cbiAgICBtaXNzaW5nTmV3bGluZU9mZnNldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0ZXh0IG9iamVjdFxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAnIzxmYWJyaWMuVGV4dCAoJyArIHRoaXMuY29tcGxleGl0eSgpICtcbiAgICAgICAgJyk6IHsgXCJ0ZXh0XCI6IFwiJyArIHRoaXMudGV4dCArICdcIiwgXCJmb250RmFtaWx5XCI6IFwiJyArIHRoaXMuZm9udEZhbWlseSArICdcIiB9Pic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZGltZW5zaW9uIGFuZCB0aGUgem9vbSBsZXZlbCBuZWVkZWQgdG8gY3JlYXRlIGEgY2FjaGUgY2FudmFzXG4gICAgICogYmlnIGVub3VnaCB0byBob3N0IHRoZSBvYmplY3QgdG8gYmUgY2FjaGVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRpbS54IHdpZHRoIG9mIG9iamVjdCB0byBiZSBjYWNoZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGltLnkgaGVpZ2h0IG9mIG9iamVjdCB0byBiZSBjYWNoZWRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9LndpZHRoIHdpZHRoIG9mIGNhbnZhc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0uaGVpZ2h0IGhlaWdodCBvZiBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9Lnpvb21YIHpvb21YIHpvb20gdmFsdWUgdG8gdW5zY2FsZSB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIGNhY2hlXG4gICAgICogQHJldHVybiB7T2JqZWN0fS56b29tWSB6b29tWSB6b29tIHZhbHVlIHRvIHVuc2NhbGUgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZyBjYWNoZVxuICAgICAqL1xuICAgIF9nZXRDYWNoZUNhbnZhc0RpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRpbXMgPSB0aGlzLmNhbGxTdXBlcignX2dldENhY2hlQ2FudmFzRGltZW5zaW9ucycpO1xuICAgICAgdmFyIGZvbnRTaXplID0gdGhpcy5mb250U2l6ZTtcbiAgICAgIGRpbXMud2lkdGggKz0gZm9udFNpemUgKiBkaW1zLnpvb21YO1xuICAgICAgZGltcy5oZWlnaHQgKz0gZm9udFNpemUgKiBkaW1zLnpvb21ZO1xuICAgICAgcmV0dXJuIGRpbXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICBwYXRoICYmICFwYXRoLmlzTm90VmlzaWJsZSgpICYmIHBhdGguX3JlbmRlcihjdHgpO1xuICAgICAgdGhpcy5fc2V0VGV4dFN0eWxlcyhjdHgpO1xuICAgICAgdGhpcy5fcmVuZGVyVGV4dExpbmVzQmFja2dyb3VuZChjdHgpO1xuICAgICAgdGhpcy5fcmVuZGVyVGV4dERlY29yYXRpb24oY3R4LCAndW5kZXJsaW5lJyk7XG4gICAgICB0aGlzLl9yZW5kZXJUZXh0KGN0eCk7XG4gICAgICB0aGlzLl9yZW5kZXJUZXh0RGVjb3JhdGlvbihjdHgsICdvdmVybGluZScpO1xuICAgICAgdGhpcy5fcmVuZGVyVGV4dERlY29yYXRpb24oY3R4LCAnbGluZXRocm91Z2gnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlclRleHQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgaWYgKHRoaXMucGFpbnRGaXJzdCA9PT0gJ3N0cm9rZScpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dFN0cm9rZShjdHgpO1xuICAgICAgICB0aGlzLl9yZW5kZXJUZXh0RmlsbChjdHgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlbmRlclRleHRGaWxsKGN0eCk7XG4gICAgICAgIHRoaXMuX3JlbmRlclRleHRTdHJva2UoY3R4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBmb250IHBhcmFtZXRlciBvZiB0aGUgY29udGV4dCB3aXRoIHRoZSBvYmplY3QgcHJvcGVydGllcyBvciB3aXRoIGNoYXJTdHlsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY2hhclN0eWxlXSBvYmplY3Qgd2l0aCBmb250IHN0eWxlIHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NoYXJTdHlsZS5mb250RmFtaWx5XSBGb250IEZhbWlseVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY2hhclN0eWxlLmZvbnRTaXplXSBGb250IHNpemUgaW4gcGl4ZWxzLiAoIHdpdGhvdXQgcHggc3VmZml4IClcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NoYXJTdHlsZS5mb250V2VpZ2h0XSBGb250IHdlaWdodFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY2hhclN0eWxlLmZvbnRTdHlsZV0gRm9udCBzdHlsZSAoaXRhbGljfG5vcm1hbClcbiAgICAgKi9cbiAgICBfc2V0VGV4dFN0eWxlczogZnVuY3Rpb24oY3R4LCBjaGFyU3R5bGUsIGZvck1lYXN1cmluZykge1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdhbHBoYWJldGljJztcbiAgICAgIGlmICh0aGlzLnBhdGgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnBhdGhBbGlnbikge1xuICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdhc2NlbmRlcic6XG4gICAgICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdkZXNjZW5kZXInOlxuICAgICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdib3R0b20nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN0eC5mb250ID0gdGhpcy5fZ2V0Rm9udERlY2xhcmF0aW9uKGNoYXJTdHlsZSwgZm9yTWVhc3VyaW5nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlIGFuZCByZXR1cm4gdGhlIHRleHQgV2lkdGggbWVhc3VyaW5nIGVhY2ggbGluZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IE1heGltdW0gd2lkdGggb2YgZmFicmljLlRleHQgb2JqZWN0XG4gICAgICovXG4gICAgY2FsY1RleHRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWF4V2lkdGggPSB0aGlzLmdldExpbmVXaWR0aCgwKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgY3VycmVudExpbmVXaWR0aCA9IHRoaXMuZ2V0TGluZVdpZHRoKGkpO1xuICAgICAgICBpZiAoY3VycmVudExpbmVXaWR0aCA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgbWF4V2lkdGggPSBjdXJyZW50TGluZVdpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF4V2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCBNZXRob2QgbmFtZSAoXCJmaWxsVGV4dFwiIG9yIFwic3Ryb2tlVGV4dFwiKVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGluZSBUZXh0IHRvIHJlbmRlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0IExlZnQgcG9zaXRpb24gb2YgdGV4dFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b3AgVG9wIHBvc2l0aW9uIG9mIHRleHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IEluZGV4IG9mIGEgbGluZSBpbiBhIHRleHRcbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dExpbmU6IGZ1bmN0aW9uKG1ldGhvZCwgY3R4LCBsaW5lLCBsZWZ0LCB0b3AsIGxpbmVJbmRleCkge1xuICAgICAgdGhpcy5fcmVuZGVyQ2hhcnMobWV0aG9kLCBjdHgsIGxpbmUsIGxlZnQsIHRvcCwgbGluZUluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgdGV4dCBiYWNrZ3JvdW5kIGZvciBsaW5lcywgdGFraW5nIGNhcmUgb2Ygc3R5bGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dExpbmVzQmFja2dyb3VuZDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICBpZiAoIXRoaXMudGV4dEJhY2tncm91bmRDb2xvciAmJiAhdGhpcy5zdHlsZUhhcygndGV4dEJhY2tncm91bmRDb2xvcicpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBoZWlnaHRPZkxpbmUsXG4gICAgICAgICAgbGluZUxlZnRPZmZzZXQsIG9yaWdpbmFsRmlsbCA9IGN0eC5maWxsU3R5bGUsXG4gICAgICAgICAgbGluZSwgbGFzdENvbG9yLFxuICAgICAgICAgIGxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMZWZ0T2Zmc2V0KCksXG4gICAgICAgICAgbGluZVRvcE9mZnNldCA9IHRoaXMuX2dldFRvcE9mZnNldCgpLFxuICAgICAgICAgIGJveFN0YXJ0ID0gMCwgYm94V2lkdGggPSAwLCBjaGFyQm94LCBjdXJyZW50Q29sb3IsIHBhdGggPSB0aGlzLnBhdGgsXG4gICAgICAgICAgZHJhd1N0YXJ0O1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGhlaWdodE9mTGluZSA9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGkpO1xuICAgICAgICBpZiAoIXRoaXMudGV4dEJhY2tncm91bmRDb2xvciAmJiAhdGhpcy5zdHlsZUhhcygndGV4dEJhY2tncm91bmRDb2xvcicsIGkpKSB7XG4gICAgICAgICAgbGluZVRvcE9mZnNldCArPSBoZWlnaHRPZkxpbmU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tpXTtcbiAgICAgICAgbGluZUxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChpKTtcbiAgICAgICAgYm94V2lkdGggPSAwO1xuICAgICAgICBib3hTdGFydCA9IDA7XG4gICAgICAgIGxhc3RDb2xvciA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgMCwgJ3RleHRCYWNrZ3JvdW5kQ29sb3InKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpsZW4gPSBsaW5lLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgICAgIGNoYXJCb3ggPSB0aGlzLl9fY2hhckJvdW5kc1tpXVtqXTtcbiAgICAgICAgICBjdXJyZW50Q29sb3IgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIGosICd0ZXh0QmFja2dyb3VuZENvbG9yJyk7XG4gICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKGNoYXJCb3gucmVuZGVyTGVmdCwgY2hhckJveC5yZW5kZXJUb3ApO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShjaGFyQm94LmFuZ2xlKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjdXJyZW50Q29sb3I7XG4gICAgICAgICAgICBjdXJyZW50Q29sb3IgJiYgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgICAtY2hhckJveC53aWR0aCAvIDIsXG4gICAgICAgICAgICAgIC1oZWlnaHRPZkxpbmUgLyB0aGlzLmxpbmVIZWlnaHQgKiAoMSAtIHRoaXMuX2ZvbnRTaXplRnJhY3Rpb24pLFxuICAgICAgICAgICAgICBjaGFyQm94LndpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHRPZkxpbmUgLyB0aGlzLmxpbmVIZWlnaHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChjdXJyZW50Q29sb3IgIT09IGxhc3RDb2xvcikge1xuICAgICAgICAgICAgZHJhd1N0YXJ0ID0gbGVmdE9mZnNldCArIGxpbmVMZWZ0T2Zmc2V0ICsgYm94U3RhcnQ7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgICAgICAgICAgIGRyYXdTdGFydCA9IHRoaXMud2lkdGggLSBkcmF3U3RhcnQgLSBib3hXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBsYXN0Q29sb3I7XG4gICAgICAgICAgICBsYXN0Q29sb3IgJiYgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgICBkcmF3U3RhcnQsXG4gICAgICAgICAgICAgIGxpbmVUb3BPZmZzZXQsXG4gICAgICAgICAgICAgIGJveFdpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHRPZkxpbmUgLyB0aGlzLmxpbmVIZWlnaHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBib3hTdGFydCA9IGNoYXJCb3gubGVmdDtcbiAgICAgICAgICAgIGJveFdpZHRoID0gY2hhckJveC53aWR0aDtcbiAgICAgICAgICAgIGxhc3RDb2xvciA9IGN1cnJlbnRDb2xvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib3hXaWR0aCArPSBjaGFyQm94Lmtlcm5lZFdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudENvbG9yICYmICFwYXRoKSB7XG4gICAgICAgICAgZHJhd1N0YXJ0ID0gbGVmdE9mZnNldCArIGxpbmVMZWZ0T2Zmc2V0ICsgYm94U3RhcnQ7XG4gICAgICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgICAgICAgICAgZHJhd1N0YXJ0ID0gdGhpcy53aWR0aCAtIGRyYXdTdGFydCAtIGJveFdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY3VycmVudENvbG9yO1xuICAgICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgIGRyYXdTdGFydCxcbiAgICAgICAgICAgIGxpbmVUb3BPZmZzZXQsXG4gICAgICAgICAgICBib3hXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodE9mTGluZSAvIHRoaXMubGluZUhlaWdodFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbGluZVRvcE9mZnNldCArPSBoZWlnaHRPZkxpbmU7XG4gICAgICB9XG4gICAgICBjdHguZmlsbFN0eWxlID0gb3JpZ2luYWxGaWxsO1xuICAgICAgLy8gaWYgdGhlcmUgaXMgdGV4dCBiYWNrZ3JvdW5kIGNvbG9yIG5vXG4gICAgICAvLyBvdGhlciBzaGFkb3dzIHNob3VsZCBiZSBjYXN0ZWRcbiAgICAgIHRoaXMuX3JlbW92ZVNoYWRvdyhjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkZWNsIHN0eWxlIGRlY2xhcmF0aW9uIGZvciBjYWNoZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkZWNsLmZvbnRGYW1pbHkgZm9udEZhbWlseVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkZWNsLmZvbnRTdHlsZSBmb250U3R5bGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGVjbC5mb250V2VpZ2h0IGZvbnRXZWlnaHRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHJlZmVyZW5jZSB0byBjYWNoZVxuICAgICAqL1xuICAgIGdldEZvbnRDYWNoZTogZnVuY3Rpb24oZGVjbCkge1xuICAgICAgdmFyIGZvbnRGYW1pbHkgPSBkZWNsLmZvbnRGYW1pbHkudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICghZmFicmljLmNoYXJXaWR0aHNDYWNoZVtmb250RmFtaWx5XSkge1xuICAgICAgICBmYWJyaWMuY2hhcldpZHRoc0NhY2hlW2ZvbnRGYW1pbHldID0geyB9O1xuICAgICAgfVxuICAgICAgdmFyIGNhY2hlID0gZmFicmljLmNoYXJXaWR0aHNDYWNoZVtmb250RmFtaWx5XSxcbiAgICAgICAgICBjYWNoZVByb3AgPSBkZWNsLmZvbnRTdHlsZS50b0xvd2VyQ2FzZSgpICsgJ18nICsgKGRlY2wuZm9udFdlaWdodCArICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKCFjYWNoZVtjYWNoZVByb3BdKSB7XG4gICAgICAgIGNhY2hlW2NhY2hlUHJvcF0gPSB7IH07XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FjaGVbY2FjaGVQcm9wXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogbWVhc3VyZSBhbmQgcmV0dXJuIHRoZSB3aWR0aCBvZiBhIHNpbmdsZSBjaGFyYWN0ZXIuXG4gICAgICogcG9zc2libHkgb3ZlcnJpZGRlbiB0byBhY2NvbW1vZGF0ZSBkaWZmZXJlbnQgbWVhc3VyZSBsb2dpYyBvclxuICAgICAqIHRvIGhvb2sgc29tZSBleHRlcm5hbCBsaWIgZm9yIGNoYXJhY3RlciBtZWFzdXJlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IF9jaGFyLCBjaGFyIHRvIGJlIG1lYXN1cmVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNoYXJTdHlsZSBzdHlsZSBvZiBjaGFyIHRvIGJlIG1lYXN1cmVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwcmV2aW91c0NoYXJdIHByZXZpb3VzIGNoYXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3ByZXZDaGFyU3R5bGVdIHN0eWxlIG9mIHByZXZpb3VzIGNoYXJcbiAgICAgKi9cbiAgICBfbWVhc3VyZUNoYXI6IGZ1bmN0aW9uKF9jaGFyLCBjaGFyU3R5bGUsIHByZXZpb3VzQ2hhciwgcHJldkNoYXJTdHlsZSkge1xuICAgICAgLy8gZmlyc3QgaSB0cnkgdG8gcmV0dXJuIGZyb20gY2FjaGVcbiAgICAgIHZhciBmb250Q2FjaGUgPSB0aGlzLmdldEZvbnRDYWNoZShjaGFyU3R5bGUpLCBmb250RGVjbGFyYXRpb24gPSB0aGlzLl9nZXRGb250RGVjbGFyYXRpb24oY2hhclN0eWxlKSxcbiAgICAgICAgICBwcmV2aW91c0ZvbnREZWNsYXJhdGlvbiA9IHRoaXMuX2dldEZvbnREZWNsYXJhdGlvbihwcmV2Q2hhclN0eWxlKSwgY291cGxlID0gcHJldmlvdXNDaGFyICsgX2NoYXIsXG4gICAgICAgICAgc3R5bGVzQXJlRXF1YWwgPSBmb250RGVjbGFyYXRpb24gPT09IHByZXZpb3VzRm9udERlY2xhcmF0aW9uLCB3aWR0aCwgY291cGxlV2lkdGgsIHByZXZpb3VzV2lkdGgsXG4gICAgICAgICAgZm9udE11bHRpcGxpZXIgPSBjaGFyU3R5bGUuZm9udFNpemUgLyB0aGlzLkNBQ0hFX0ZPTlRfU0laRSwga2VybmVkV2lkdGg7XG5cbiAgICAgIGlmIChwcmV2aW91c0NoYXIgJiYgZm9udENhY2hlW3ByZXZpb3VzQ2hhcl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcmV2aW91c1dpZHRoID0gZm9udENhY2hlW3ByZXZpb3VzQ2hhcl07XG4gICAgICB9XG4gICAgICBpZiAoZm9udENhY2hlW19jaGFyXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGtlcm5lZFdpZHRoID0gd2lkdGggPSBmb250Q2FjaGVbX2NoYXJdO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlc0FyZUVxdWFsICYmIGZvbnRDYWNoZVtjb3VwbGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY291cGxlV2lkdGggPSBmb250Q2FjaGVbY291cGxlXTtcbiAgICAgICAga2VybmVkV2lkdGggPSBjb3VwbGVXaWR0aCAtIHByZXZpb3VzV2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCB8fCBwcmV2aW91c1dpZHRoID09PSB1bmRlZmluZWQgfHwgY291cGxlV2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5nZXRNZWFzdXJpbmdDb250ZXh0KCk7XG4gICAgICAgIC8vIHNlbmQgYSBUUlVFIHRvIHNwZWNpZnkgbWVhc3VyaW5nIGZvbnQgc2l6ZSBDQUNIRV9GT05UX1NJWkVcbiAgICAgICAgdGhpcy5fc2V0VGV4dFN0eWxlcyhjdHgsIGNoYXJTdHlsZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBrZXJuZWRXaWR0aCA9IHdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KF9jaGFyKS53aWR0aDtcbiAgICAgICAgZm9udENhY2hlW19jaGFyXSA9IHdpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKHByZXZpb3VzV2lkdGggPT09IHVuZGVmaW5lZCAmJiBzdHlsZXNBcmVFcXVhbCAmJiBwcmV2aW91c0NoYXIpIHtcbiAgICAgICAgcHJldmlvdXNXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChwcmV2aW91c0NoYXIpLndpZHRoO1xuICAgICAgICBmb250Q2FjaGVbcHJldmlvdXNDaGFyXSA9IHByZXZpb3VzV2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVzQXJlRXF1YWwgJiYgY291cGxlV2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyB3ZSBjYW4gbWVhc3VyZSB0aGUga2VybmluZyBjb3VwbGUgYW5kIHN1YnRyYWN0IHRoZSB3aWR0aCBvZiB0aGUgcHJldmlvdXMgY2hhcmFjdGVyXG4gICAgICAgIGNvdXBsZVdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGNvdXBsZSkud2lkdGg7XG4gICAgICAgIGZvbnRDYWNoZVtjb3VwbGVdID0gY291cGxlV2lkdGg7XG4gICAgICAgIGtlcm5lZFdpZHRoID0gY291cGxlV2lkdGggLSBwcmV2aW91c1dpZHRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgd2lkdGg6IHdpZHRoICogZm9udE11bHRpcGxpZXIsIGtlcm5lZFdpZHRoOiBrZXJuZWRXaWR0aCAqIGZvbnRNdWx0aXBsaWVyIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGhlaWdodCBvZiBjaGFyYWN0ZXIgYXQgZ2l2ZW4gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZSB0aGUgbGluZSBpbmRleCBudW1iZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gX2NoYXIgdGhlIGNoYXJhY3RlciBpbmRleCBudW1iZXJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGZvbnRTaXplIG9mIHRoZSBjaGFyYWN0ZXJcbiAgICAgKi9cbiAgICBnZXRIZWlnaHRPZkNoYXI6IGZ1bmN0aW9uKGxpbmUsIF9jaGFyKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChsaW5lLCBfY2hhciwgJ2ZvbnRTaXplJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIG1lYXN1cmUgYSB0ZXh0IGxpbmUgbWVhc3VyaW5nIGFsbCBjaGFyYWN0ZXJzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggbGluZSBudW1iZXJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IExpbmUgd2lkdGhcbiAgICAgKi9cbiAgICBtZWFzdXJlTGluZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICB2YXIgbGluZUluZm8gPSB0aGlzLl9tZWFzdXJlTGluZShsaW5lSW5kZXgpO1xuICAgICAgaWYgKHRoaXMuY2hhclNwYWNpbmcgIT09IDApIHtcbiAgICAgICAgbGluZUluZm8ud2lkdGggLT0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAobGluZUluZm8ud2lkdGggPCAwKSB7XG4gICAgICAgIGxpbmVJbmZvLndpZHRoID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaW5lSW5mbztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogbWVhc3VyZSBldmVyeSBncmFwaGVtZSBvZiBhIGxpbmUsIHBvcHVsYXRpbmcgX19jaGFyQm91bmRzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0LndpZHRoIHRvdGFsIHdpZHRoIG9mIGNoYXJhY3RlcnNcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdC53aWR0aE9mU3BhY2VzIGxlbmd0aCBvZiBjaGFycyB0aGF0IG1hdGNoIHRoaXMuX3JlU3BhY2VzQW5kVGFic1xuICAgICAqL1xuICAgIF9tZWFzdXJlTGluZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICB2YXIgd2lkdGggPSAwLCBpLCBncmFwaGVtZSwgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLCBwcmV2R3JhcGhlbWUsXG4gICAgICAgICAgZ3JhcGhlbWVJbmZvLCBudW1PZlNwYWNlcyA9IDAsIGxpbmVCb3VuZHMgPSBuZXcgQXJyYXkobGluZS5sZW5ndGgpLFxuICAgICAgICAgIHBvc2l0aW9uSW5QYXRoID0gMCwgc3RhcnRpbmdQb2ludCwgdG90YWxQYXRoTGVuZ3RoLCBwYXRoID0gdGhpcy5wYXRoLFxuICAgICAgICAgIHJldmVyc2UgPSB0aGlzLnBhdGhTaWRlID09PSAncmlnaHQnO1xuXG4gICAgICB0aGlzLl9fY2hhckJvdW5kc1tsaW5lSW5kZXhdID0gbGluZUJvdW5kcztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGdyYXBoZW1lID0gbGluZVtpXTtcbiAgICAgICAgZ3JhcGhlbWVJbmZvID0gdGhpcy5fZ2V0R3JhcGhlbWVCb3goZ3JhcGhlbWUsIGxpbmVJbmRleCwgaSwgcHJldkdyYXBoZW1lKTtcbiAgICAgICAgbGluZUJvdW5kc1tpXSA9IGdyYXBoZW1lSW5mbztcbiAgICAgICAgd2lkdGggKz0gZ3JhcGhlbWVJbmZvLmtlcm5lZFdpZHRoO1xuICAgICAgICBwcmV2R3JhcGhlbWUgPSBncmFwaGVtZTtcbiAgICAgIH1cbiAgICAgIC8vIHRoaXMgbGF0ZXN0IGJvdW5kIGJveCByZXByZXNlbnQgdGhlIGxhc3QgY2hhcmFjdGVyIG9mIHRoZSBsaW5lXG4gICAgICAvLyB0byBzaW1wbGlmeSBjdXJzb3IgaGFuZGxpbmcgaW4gaW50ZXJhY3RpdmUgbW9kZS5cbiAgICAgIGxpbmVCb3VuZHNbaV0gPSB7XG4gICAgICAgIGxlZnQ6IGdyYXBoZW1lSW5mbyA/IGdyYXBoZW1lSW5mby5sZWZ0ICsgZ3JhcGhlbWVJbmZvLndpZHRoIDogMCxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGtlcm5lZFdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuZm9udFNpemVcbiAgICAgIH07XG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICB0b3RhbFBhdGhMZW5ndGggPSBwYXRoLnNlZ21lbnRzSW5mb1twYXRoLnNlZ21lbnRzSW5mby5sZW5ndGggLSAxXS5sZW5ndGg7XG4gICAgICAgIHN0YXJ0aW5nUG9pbnQgPSBmYWJyaWMudXRpbC5nZXRQb2ludE9uUGF0aChwYXRoLnBhdGgsIDAsIHBhdGguc2VnbWVudHNJbmZvKTtcbiAgICAgICAgc3RhcnRpbmdQb2ludC54ICs9IHBhdGgucGF0aE9mZnNldC54O1xuICAgICAgICBzdGFydGluZ1BvaW50LnkgKz0gcGF0aC5wYXRoT2Zmc2V0Lnk7XG4gICAgICAgIHN3aXRjaCAodGhpcy50ZXh0QWxpZ24pIHtcbiAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIHBvc2l0aW9uSW5QYXRoID0gcmV2ZXJzZSA/ICh0b3RhbFBhdGhMZW5ndGggLSB3aWR0aCkgOiAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgIHBvc2l0aW9uSW5QYXRoID0gKHRvdGFsUGF0aExlbmd0aCAtIHdpZHRoKSAvIDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICBwb3NpdGlvbkluUGF0aCA9IHJldmVyc2UgPyAwIDogKHRvdGFsUGF0aExlbmd0aCAtIHdpZHRoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vdG9kbyAtIGFkZCBzdXBwb3J0IGZvciBqdXN0aWZ5XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpb25JblBhdGggKz0gdGhpcy5wYXRoU3RhcnRPZmZzZXQgKiAocmV2ZXJzZSA/IC0xIDogMSk7XG4gICAgICAgIGZvciAoaSA9IHJldmVyc2UgPyBsaW5lLmxlbmd0aCAtIDEgOiAwO1xuICAgICAgICAgIHJldmVyc2UgPyBpID49IDAgOiBpIDwgbGluZS5sZW5ndGg7XG4gICAgICAgICAgcmV2ZXJzZSA/IGktLSA6IGkrKykge1xuICAgICAgICAgIGdyYXBoZW1lSW5mbyA9IGxpbmVCb3VuZHNbaV07XG4gICAgICAgICAgaWYgKHBvc2l0aW9uSW5QYXRoID4gdG90YWxQYXRoTGVuZ3RoKSB7XG4gICAgICAgICAgICBwb3NpdGlvbkluUGF0aCAlPSB0b3RhbFBhdGhMZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHBvc2l0aW9uSW5QYXRoIDwgMCkge1xuICAgICAgICAgICAgcG9zaXRpb25JblBhdGggKz0gdG90YWxQYXRoTGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpdCB3b3VsZCBwcm9iYWJseSBtdWNoIGZhc3RlciB0byBzZW5kIGFsbCB0aGUgZ3JhcGhlbWUgcG9zaXRpb24gZm9yIGEgbGluZVxuICAgICAgICAgIC8vIGFuZCBjYWxjdWxhdGUgcGF0aCBwb3NpdGlvbi9hbmdsZSBhdCBvbmNlLlxuICAgICAgICAgIHRoaXMuX3NldEdyYXBoZW1lT25QYXRoKHBvc2l0aW9uSW5QYXRoLCBncmFwaGVtZUluZm8sIHN0YXJ0aW5nUG9pbnQpO1xuICAgICAgICAgIHBvc2l0aW9uSW5QYXRoICs9IGdyYXBoZW1lSW5mby5rZXJuZWRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgd2lkdGg6IHdpZHRoLCBudW1PZlNwYWNlczogbnVtT2ZTcGFjZXMgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBhbmdsZSAgYW5kIHRoZSBsZWZ0LHRvcCBwb3NpdGlvbiBvZiB0aGUgY2hhciB0aGF0IGZvbGxvdyBhIHBhdGguXG4gICAgICogSXQgYXBwZW5kcyBpdCB0byBncmFwaGVtZUluZm8gdG8gYmUgcmV1c2VkIGxhdGVyIGF0IHJlbmRlcmluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uSW5QYXRoIHRvIGJlIG1lYXN1cmVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGdyYXBoZW1lSW5mbyBjdXJyZW50IGdyYXBoZW1lIGJveCBpbmZvcm1hdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFydGluZ1BvaW50IHBvc2l0aW9uIG9mIHRoZSBwb2ludFxuICAgICAqL1xuICAgIF9zZXRHcmFwaGVtZU9uUGF0aDogZnVuY3Rpb24ocG9zaXRpb25JblBhdGgsIGdyYXBoZW1lSW5mbywgc3RhcnRpbmdQb2ludCkge1xuICAgICAgdmFyIGNlbnRlclBvc2l0aW9uID0gcG9zaXRpb25JblBhdGggKyBncmFwaGVtZUluZm8ua2VybmVkV2lkdGggLyAyLFxuICAgICAgICAgIHBhdGggPSB0aGlzLnBhdGg7XG5cbiAgICAgIC8vIHdlIGFyZSBhdCBjdXJyZW50UG9zaXRpb25PblBhdGguIHdlIHdhbnQgdG8ga25vdyB3aGF0IHBvaW50IG9uIHRoZSBwYXRoIGlzLlxuICAgICAgdmFyIGluZm8gPSBmYWJyaWMudXRpbC5nZXRQb2ludE9uUGF0aChwYXRoLnBhdGgsIGNlbnRlclBvc2l0aW9uLCBwYXRoLnNlZ21lbnRzSW5mbyk7XG4gICAgICBncmFwaGVtZUluZm8ucmVuZGVyTGVmdCA9IGluZm8ueCAtIHN0YXJ0aW5nUG9pbnQueDtcbiAgICAgIGdyYXBoZW1lSW5mby5yZW5kZXJUb3AgPSBpbmZvLnkgLSBzdGFydGluZ1BvaW50Lnk7XG4gICAgICBncmFwaGVtZUluZm8uYW5nbGUgPSBpbmZvLmFuZ2xlICsgKHRoaXMucGF0aFNpZGUgPT09ICAncmlnaHQnID8gTWF0aC5QSSA6IDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNZWFzdXJlIGFuZCByZXR1cm4gdGhlIGluZm8gb2YgYSBzaW5nbGUgZ3JhcGhlbWUuXG4gICAgICogbmVlZHMgdGhlIHRoZSBpbmZvIG9mIHByZXZpb3VzIGdyYXBoZW1lcyBhbHJlYWR5IGZpbGxlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGdyYXBoZW1lIHRvIGJlIG1lYXN1cmVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBpbmRleCBvZiB0aGUgbGluZSB3aGVyZSB0aGUgY2hhciBpc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXggcG9zaXRpb24gaW4gdGhlIGxpbmVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3ByZXZHcmFwaGVtZV0gY2hhcmFjdGVyIHByZWNlZGluZyB0aGUgb25lIHRvIGJlIG1lYXN1cmVkXG4gICAgICovXG4gICAgX2dldEdyYXBoZW1lQm94OiBmdW5jdGlvbihncmFwaGVtZSwgbGluZUluZGV4LCBjaGFySW5kZXgsIHByZXZHcmFwaGVtZSwgc2tpcExlZnQpIHtcbiAgICAgIHZhciBzdHlsZSA9IHRoaXMuZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSxcbiAgICAgICAgICBwcmV2U3R5bGUgPSBwcmV2R3JhcGhlbWUgPyB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCAtIDEpIDogeyB9LFxuICAgICAgICAgIGluZm8gPSB0aGlzLl9tZWFzdXJlQ2hhcihncmFwaGVtZSwgc3R5bGUsIHByZXZHcmFwaGVtZSwgcHJldlN0eWxlKSxcbiAgICAgICAgICBrZXJuZWRXaWR0aCA9IGluZm8ua2VybmVkV2lkdGgsXG4gICAgICAgICAgd2lkdGggPSBpbmZvLndpZHRoLCBjaGFyU3BhY2luZztcblxuICAgICAgaWYgKHRoaXMuY2hhclNwYWNpbmcgIT09IDApIHtcbiAgICAgICAgY2hhclNwYWNpbmcgPSB0aGlzLl9nZXRXaWR0aE9mQ2hhclNwYWNpbmcoKTtcbiAgICAgICAgd2lkdGggKz0gY2hhclNwYWNpbmc7XG4gICAgICAgIGtlcm5lZFdpZHRoICs9IGNoYXJTcGFjaW5nO1xuICAgICAgfVxuXG4gICAgICB2YXIgYm94ID0ge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIGhlaWdodDogc3R5bGUuZm9udFNpemUsXG4gICAgICAgIGtlcm5lZFdpZHRoOiBrZXJuZWRXaWR0aCxcbiAgICAgICAgZGVsdGFZOiBzdHlsZS5kZWx0YVksXG4gICAgICB9O1xuICAgICAgaWYgKGNoYXJJbmRleCA+IDAgJiYgIXNraXBMZWZ0KSB7XG4gICAgICAgIHZhciBwcmV2aW91c0JveCA9IHRoaXMuX19jaGFyQm91bmRzW2xpbmVJbmRleF1bY2hhckluZGV4IC0gMV07XG4gICAgICAgIGJveC5sZWZ0ID0gcHJldmlvdXNCb3gubGVmdCArIHByZXZpb3VzQm94LndpZHRoICsgaW5mby5rZXJuZWRXaWR0aCAtIGluZm8ud2lkdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYm94O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgaGVpZ2h0IG9mIGxpbmUgYXQgJ2xpbmVJbmRleCdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IGluZGV4IG9mIGxpbmUgdG8gY2FsY3VsYXRlXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldEhlaWdodE9mTGluZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICBpZiAodGhpcy5fX2xpbmVIZWlnaHRzW2xpbmVJbmRleF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19saW5lSGVpZ2h0c1tsaW5lSW5kZXhdO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLFxuICAgICAgICAgIC8vIGNoYXIgMCBpcyBtZWFzdXJlZCBiZWZvcmUgdGhlIGxpbmUgY3ljbGUgYmVjYXVzZSBpdCBubmVkcyB0byBjaGFyXG4gICAgICAgICAgLy8gZW1wdHlsaW5lc1xuICAgICAgICAgIG1heEhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0T2ZDaGFyKGxpbmVJbmRleCwgMCk7XG4gICAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gbGluZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBtYXhIZWlnaHQgPSBNYXRoLm1heCh0aGlzLmdldEhlaWdodE9mQ2hhcihsaW5lSW5kZXgsIGkpLCBtYXhIZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fX2xpbmVIZWlnaHRzW2xpbmVJbmRleF0gPSBtYXhIZWlnaHQgKiB0aGlzLmxpbmVIZWlnaHQgKiB0aGlzLl9mb250U2l6ZU11bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0ZXh0IGJveCBoZWlnaHRcbiAgICAgKi9cbiAgICBjYWxjVGV4dEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGluZUhlaWdodCwgaGVpZ2h0ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbGluZUhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGkpO1xuICAgICAgICBoZWlnaHQgKz0gKGkgPT09IGxlbiAtIDEgPyBsaW5lSGVpZ2h0IC8gdGhpcy5saW5lSGVpZ2h0IDogbGluZUhlaWdodCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTGVmdCBvZmZzZXRcbiAgICAgKi9cbiAgICBfZ2V0TGVmdE9mZnNldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb24gPT09ICdsdHInID8gLXRoaXMud2lkdGggLyAyIDogdGhpcy53aWR0aCAvIDI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBUb3Agb2Zmc2V0XG4gICAgICovXG4gICAgX2dldFRvcE9mZnNldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gLXRoaXMuaGVpZ2h0IC8gMjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCBNZXRob2QgbmFtZSAoXCJmaWxsVGV4dFwiIG9yIFwic3Ryb2tlVGV4dFwiKVxuICAgICAqL1xuICAgIF9yZW5kZXJUZXh0Q29tbW9uOiBmdW5jdGlvbihjdHgsIG1ldGhvZCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHZhciBsaW5lSGVpZ2h0cyA9IDAsIGxlZnQgPSB0aGlzLl9nZXRMZWZ0T2Zmc2V0KCksIHRvcCA9IHRoaXMuX2dldFRvcE9mZnNldCgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgaGVpZ2h0T2ZMaW5lID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaSksXG4gICAgICAgICAgICBtYXhIZWlnaHQgPSBoZWlnaHRPZkxpbmUgLyB0aGlzLmxpbmVIZWlnaHQsXG4gICAgICAgICAgICBsZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQoaSk7XG4gICAgICAgIHRoaXMuX3JlbmRlclRleHRMaW5lKFxuICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICBjdHgsXG4gICAgICAgICAgdGhpcy5fdGV4dExpbmVzW2ldLFxuICAgICAgICAgIGxlZnQgKyBsZWZ0T2Zmc2V0LFxuICAgICAgICAgIHRvcCArIGxpbmVIZWlnaHRzICsgbWF4SGVpZ2h0LFxuICAgICAgICAgIGlcbiAgICAgICAgKTtcbiAgICAgICAgbGluZUhlaWdodHMgKz0gaGVpZ2h0T2ZMaW5lO1xuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgX3JlbmRlclRleHRGaWxsOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICghdGhpcy5maWxsICYmICF0aGlzLnN0eWxlSGFzKCdmaWxsJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZW5kZXJUZXh0Q29tbW9uKGN0eCwgJ2ZpbGxUZXh0Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXJUZXh0U3Ryb2tlOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIGlmICgoIXRoaXMuc3Ryb2tlIHx8IHRoaXMuc3Ryb2tlV2lkdGggPT09IDApICYmIHRoaXMuaXNFbXB0eVN0eWxlcygpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2hhZG93ICYmICF0aGlzLnNoYWRvdy5hZmZlY3RTdHJva2UpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlU2hhZG93KGN0eCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0aGlzLl9zZXRMaW5lRGFzaChjdHgsIHRoaXMuc3Ryb2tlRGFzaEFycmF5KTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHRoaXMuX3JlbmRlclRleHRDb21tb24oY3R4LCAnc3Ryb2tlVGV4dCcpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIGZpbGxUZXh0IG9yIHN0cm9rZVRleHQuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpbmUgQ29udGVudCBvZiB0aGUgbGluZSwgc3BsaXR0ZWQgaW4gYW4gYXJyYXkgYnkgZ3JhcGhlbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVmdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0b3BcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICovXG4gICAgX3JlbmRlckNoYXJzOiBmdW5jdGlvbihtZXRob2QsIGN0eCwgbGluZSwgbGVmdCwgdG9wLCBsaW5lSW5kZXgpIHtcbiAgICAgIC8vIHNldCBwcm9wZXIgbGluZSBvZmZzZXRcbiAgICAgIHZhciBsaW5lSGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUobGluZUluZGV4KSxcbiAgICAgICAgICBpc0p1c3RpZnkgPSB0aGlzLnRleHRBbGlnbi5pbmRleE9mKCdqdXN0aWZ5JykgIT09IC0xLFxuICAgICAgICAgIGFjdHVhbFN0eWxlLFxuICAgICAgICAgIG5leHRTdHlsZSxcbiAgICAgICAgICBjaGFyc1RvUmVuZGVyID0gJycsXG4gICAgICAgICAgY2hhckJveCxcbiAgICAgICAgICBib3hXaWR0aCA9IDAsXG4gICAgICAgICAgdGltZVRvUmVuZGVyLFxuICAgICAgICAgIHBhdGggPSB0aGlzLnBhdGgsXG4gICAgICAgICAgc2hvcnRDdXQgPSAhaXNKdXN0aWZ5ICYmIHRoaXMuY2hhclNwYWNpbmcgPT09IDAgJiYgdGhpcy5pc0VtcHR5U3R5bGVzKGxpbmVJbmRleCkgJiYgIXBhdGgsXG4gICAgICAgICAgaXNMdHIgPSB0aGlzLmRpcmVjdGlvbiA9PT0gJ2x0cicsIHNpZ24gPSB0aGlzLmRpcmVjdGlvbiA9PT0gJ2x0cicgPyAxIDogLTEsXG4gICAgICAgICAgZHJhd2luZ0xlZnQsIGN1cnJlbnREaXJlY3Rpb24gPSBjdHguY2FudmFzLmdldEF0dHJpYnV0ZSgnZGlyJyk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgaWYgKGN1cnJlbnREaXJlY3Rpb24gIT09IHRoaXMuZGlyZWN0aW9uKSB7XG4gICAgICAgIGN0eC5jYW52YXMuc2V0QXR0cmlidXRlKCdkaXInLCBpc0x0ciA/ICdsdHInIDogJ3J0bCcpO1xuICAgICAgICBjdHguZGlyZWN0aW9uID0gaXNMdHIgPyAnbHRyJyA6ICdydGwnO1xuICAgICAgICBjdHgudGV4dEFsaWduID0gaXNMdHIgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgfVxuICAgICAgdG9wIC09IGxpbmVIZWlnaHQgKiB0aGlzLl9mb250U2l6ZUZyYWN0aW9uIC8gdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgaWYgKHNob3J0Q3V0KSB7XG4gICAgICAgIC8vIHJlbmRlciBhbGwgdGhlIGxpbmUgaW4gb25lIHBhc3Mgd2l0aG91dCBjaGVja2luZ1xuICAgICAgICAvLyBkcmF3aW5nTGVmdCA9IGlzTHRyID8gbGVmdCA6IGxlZnQgLSB0aGlzLmdldExpbmVXaWR0aChsaW5lSW5kZXgpO1xuICAgICAgICB0aGlzLl9yZW5kZXJDaGFyKG1ldGhvZCwgY3R4LCBsaW5lSW5kZXgsIDAsIGxpbmUuam9pbignJyksIGxlZnQsIHRvcCwgbGluZUhlaWdodCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lLmxlbmd0aCAtIDE7IGkgPD0gbGVuOyBpKyspIHtcbiAgICAgICAgdGltZVRvUmVuZGVyID0gaSA9PT0gbGVuIHx8IHRoaXMuY2hhclNwYWNpbmcgfHwgcGF0aDtcbiAgICAgICAgY2hhcnNUb1JlbmRlciArPSBsaW5lW2ldO1xuICAgICAgICBjaGFyQm94ID0gdGhpcy5fX2NoYXJCb3VuZHNbbGluZUluZGV4XVtpXTtcbiAgICAgICAgaWYgKGJveFdpZHRoID09PSAwKSB7XG4gICAgICAgICAgbGVmdCArPSBzaWduICogKGNoYXJCb3gua2VybmVkV2lkdGggLSBjaGFyQm94LndpZHRoKTtcbiAgICAgICAgICBib3hXaWR0aCArPSBjaGFyQm94LndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGJveFdpZHRoICs9IGNoYXJCb3gua2VybmVkV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSnVzdGlmeSAmJiAhdGltZVRvUmVuZGVyKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3JlU3BhY2VBbmRUYWIudGVzdChsaW5lW2ldKSkge1xuICAgICAgICAgICAgdGltZVRvUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aW1lVG9SZW5kZXIpIHtcbiAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGNoYXJTcGFjaW5nLCB3ZSByZW5kZXIgY2hhciBieSBjaGFyXG4gICAgICAgICAgYWN0dWFsU3R5bGUgPSBhY3R1YWxTdHlsZSB8fCB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGkpO1xuICAgICAgICAgIG5leHRTdHlsZSA9IHRoaXMuZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgaSArIDEpO1xuICAgICAgICAgIHRpbWVUb1JlbmRlciA9IGZhYnJpYy51dGlsLmhhc1N0eWxlQ2hhbmdlZChhY3R1YWxTdHlsZSwgbmV4dFN0eWxlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVUb1JlbmRlcikge1xuICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjaGFyQm94LnJlbmRlckxlZnQsIGNoYXJCb3gucmVuZGVyVG9wKTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoY2hhckJveC5hbmdsZSk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJDaGFyKG1ldGhvZCwgY3R4LCBsaW5lSW5kZXgsIGksIGNoYXJzVG9SZW5kZXIsIC1ib3hXaWR0aCAvIDIsIDAsIGxpbmVIZWlnaHQpO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkcmF3aW5nTGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJDaGFyKG1ldGhvZCwgY3R4LCBsaW5lSW5kZXgsIGksIGNoYXJzVG9SZW5kZXIsIGRyYXdpbmdMZWZ0LCB0b3AsIGxpbmVIZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGFyc1RvUmVuZGVyID0gJyc7XG4gICAgICAgICAgYWN0dWFsU3R5bGUgPSBuZXh0U3R5bGU7XG4gICAgICAgICAgbGVmdCArPSBzaWduICogYm94V2lkdGg7XG4gICAgICAgICAgYm94V2lkdGggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHRyeSB0byBwYXRjaCB0aGUgbWlzc2luZyBncmFkaWVudFRyYW5zZm9ybSBvbiBjYW52YXMgZ3JhZGllbnRzLlxuICAgICAqIHRyYW5zZm9ybWluZyBhIGNvbnRleHQgdG8gdHJhbnNmb3JtIHRoZSBncmFkaWVudCwgaXMgZ29pbmcgdG8gdHJhbnNmb3JtIHRoZSBzdHJva2UgdG9vLlxuICAgICAqIHdlIHdhbnQgdG8gdHJhbnNmb3JtIHRoZSBncmFkaWVudCBidXQgbm90IHRoZSBzdHJva2Ugb3BlcmF0aW9uLCBzbyB3ZSBjcmVhdGVcbiAgICAgKiBhIHRyYW5zZm9ybWVkIGdyYWRpZW50IG9uIGEgcGF0dGVybiBhbmQgdGhlbiB3ZSB1c2UgdGhlIHBhdHRlcm4gaW5zdGVhZCBvZiB0aGUgZ3JhZGllbnQuXG4gICAgICogdGhpcyBtZXRob2QgaGFzIGRyYXdiYWNrczogaXMgc2xvdywgaXMgaW4gbG93IHJlc29sdXRpb24sIG5lZWRzIGEgcGF0Y2ggZm9yIHdoZW4gdGhlIHNpemVcbiAgICAgKiBpcyBsaW1pdGVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtmYWJyaWMuR3JhZGllbnR9IGZpbGxlciBhIGZhYnJpYyBncmFkaWVudCBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge0NhbnZhc1BhdHRlcm59IGEgcGF0dGVybiB0byB1c2UgYXMgZmlsbC9zdHJva2Ugc3R5bGVcbiAgICAgKi9cbiAgICBfYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm1UZXh0OiBmdW5jdGlvbihmaWxsZXIpIHtcbiAgICAgIHZhciBwQ2FudmFzID0gZmFicmljLnV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLCBwQ3R4LFxuICAgICAgICAgIC8vIFRPRE86IHZlcmlmeSBjb21wYXRpYmlsaXR5IHdpdGggc3Ryb2tlVW5pZm9ybVxuICAgICAgICAgIHdpZHRoID0gdGhpcy53aWR0aCArIHRoaXMuc3Ryb2tlV2lkdGgsIGhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgdGhpcy5zdHJva2VXaWR0aDtcbiAgICAgIHBDYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHBDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgcEN0eCA9IHBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIHBDdHguYmVnaW5QYXRoKCk7IHBDdHgubW92ZVRvKDAsIDApOyBwQ3R4LmxpbmVUbyh3aWR0aCwgMCk7IHBDdHgubGluZVRvKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgcEN0eC5saW5lVG8oMCwgaGVpZ2h0KTsgcEN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIHBDdHgudHJhbnNsYXRlKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gICAgICBwQ3R4LmZpbGxTdHlsZSA9IGZpbGxlci50b0xpdmUocEN0eCk7XG4gICAgICB0aGlzLl9hcHBseVBhdHRlcm5HcmFkaWVudFRyYW5zZm9ybShwQ3R4LCBmaWxsZXIpO1xuICAgICAgcEN0eC5maWxsKCk7XG4gICAgICByZXR1cm4gcEN0eC5jcmVhdGVQYXR0ZXJuKHBDYW52YXMsICduby1yZXBlYXQnKTtcbiAgICB9LFxuXG4gICAgaGFuZGxlRmlsbGVyOiBmdW5jdGlvbihjdHgsIHByb3BlcnR5LCBmaWxsZXIpIHtcbiAgICAgIHZhciBvZmZzZXRYLCBvZmZzZXRZO1xuICAgICAgaWYgKGZpbGxlci50b0xpdmUpIHtcbiAgICAgICAgaWYgKGZpbGxlci5ncmFkaWVudFVuaXRzID09PSAncGVyY2VudGFnZScgfHwgZmlsbGVyLmdyYWRpZW50VHJhbnNmb3JtIHx8IGZpbGxlci5wYXR0ZXJuVHJhbnNmb3JtKSB7XG4gICAgICAgICAgLy8gbmVlZCB0byB0cmFuc2Zvcm0gZ3JhZGllbnQgaW4gYSBwYXR0ZXJuLlxuICAgICAgICAgIC8vIHRoaXMgaXMgYSBzbG93IHByb2Nlc3MuIElmIHlvdSBhcmUgaGl0dGluZyB0aGlzIGNvZGVwYXRoLCBhbmQgdGhlIG9iamVjdFxuICAgICAgICAgIC8vIGlzIG5vdCB1c2luZyBjYWNoaW5nLCB5b3Ugc2hvdWxkIGNvbnNpZGVyIHN3aXRjaGluZyBpdCBvbi5cbiAgICAgICAgICAvLyB3ZSBuZWVkIGEgY2FudmFzIGFzIGJpZyBhcyB0aGUgY3VycmVudCBvYmplY3QgY2FjaGluZyBjYW52YXMuXG4gICAgICAgICAgb2Zmc2V0WCA9IC10aGlzLndpZHRoIC8gMjtcbiAgICAgICAgICBvZmZzZXRZID0gLXRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgICBjdHgudHJhbnNsYXRlKG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgICAgIGN0eFtwcm9wZXJ0eV0gPSB0aGlzLl9hcHBseVBhdHRlcm5HcmFkaWVudFRyYW5zZm9ybVRleHQoZmlsbGVyKTtcbiAgICAgICAgICByZXR1cm4geyBvZmZzZXRYOiBvZmZzZXRYLCBvZmZzZXRZOiBvZmZzZXRZIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gaXMgYSBzaW1wbGUgZ3JhZGllbnQgb3IgcGF0dGVyblxuICAgICAgICAgIGN0eFtwcm9wZXJ0eV0gPSBmaWxsZXIudG9MaXZlKGN0eCwgdGhpcyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5UGF0dGVybkdyYWRpZW50VHJhbnNmb3JtKGN0eCwgZmlsbGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGlzIGEgY29sb3JcbiAgICAgICAgY3R4W3Byb3BlcnR5XSA9IGZpbGxlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG9mZnNldFg6IDAsIG9mZnNldFk6IDAgfTtcbiAgICB9LFxuXG4gICAgX3NldFN0cm9rZVN0eWxlczogZnVuY3Rpb24oY3R4LCBkZWNsKSB7XG4gICAgICBjdHgubGluZVdpZHRoID0gZGVjbC5zdHJva2VXaWR0aDtcbiAgICAgIGN0eC5saW5lQ2FwID0gdGhpcy5zdHJva2VMaW5lQ2FwO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gdGhpcy5zdHJva2VEYXNoT2Zmc2V0O1xuICAgICAgY3R4LmxpbmVKb2luID0gdGhpcy5zdHJva2VMaW5lSm9pbjtcbiAgICAgIGN0eC5taXRlckxpbWl0ID0gdGhpcy5zdHJva2VNaXRlckxpbWl0O1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlRmlsbGVyKGN0eCwgJ3N0cm9rZVN0eWxlJywgZGVjbC5zdHJva2UpO1xuICAgIH0sXG5cbiAgICBfc2V0RmlsbFN0eWxlczogZnVuY3Rpb24oY3R4LCBkZWNsKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVGaWxsZXIoY3R4LCAnZmlsbFN0eWxlJywgZGVjbC5maWxsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IF9jaGFyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSGVpZ2h0IEhlaWdodCBvZiB0aGUgbGluZVxuICAgICAqL1xuICAgIF9yZW5kZXJDaGFyOiBmdW5jdGlvbihtZXRob2QsIGN0eCwgbGluZUluZGV4LCBjaGFySW5kZXgsIF9jaGFyLCBsZWZ0LCB0b3ApIHtcbiAgICAgIHZhciBkZWNsID0gdGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCksXG4gICAgICAgICAgZnVsbERlY2wgPSB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCksXG4gICAgICAgICAgc2hvdWxkRmlsbCA9IG1ldGhvZCA9PT0gJ2ZpbGxUZXh0JyAmJiBmdWxsRGVjbC5maWxsLFxuICAgICAgICAgIHNob3VsZFN0cm9rZSA9IG1ldGhvZCA9PT0gJ3N0cm9rZVRleHQnICYmIGZ1bGxEZWNsLnN0cm9rZSAmJiBmdWxsRGVjbC5zdHJva2VXaWR0aCxcbiAgICAgICAgICBmaWxsT2Zmc2V0cywgc3Ryb2tlT2Zmc2V0cztcblxuICAgICAgaWYgKCFzaG91bGRTdHJva2UgJiYgIXNob3VsZEZpbGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgc2hvdWxkRmlsbCAmJiAoZmlsbE9mZnNldHMgPSB0aGlzLl9zZXRGaWxsU3R5bGVzKGN0eCwgZnVsbERlY2wpKTtcbiAgICAgIHNob3VsZFN0cm9rZSAmJiAoc3Ryb2tlT2Zmc2V0cyA9IHRoaXMuX3NldFN0cm9rZVN0eWxlcyhjdHgsIGZ1bGxEZWNsKSk7XG5cbiAgICAgIGN0eC5mb250ID0gdGhpcy5fZ2V0Rm9udERlY2xhcmF0aW9uKGZ1bGxEZWNsKTtcblxuXG4gICAgICBpZiAoZGVjbCAmJiBkZWNsLnRleHRCYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlU2hhZG93KGN0eCk7XG4gICAgICB9XG4gICAgICBpZiAoZGVjbCAmJiBkZWNsLmRlbHRhWSkge1xuICAgICAgICB0b3AgKz0gZGVjbC5kZWx0YVk7XG4gICAgICB9XG4gICAgICBzaG91bGRGaWxsICYmIGN0eC5maWxsVGV4dChfY2hhciwgbGVmdCAtIGZpbGxPZmZzZXRzLm9mZnNldFgsIHRvcCAtIGZpbGxPZmZzZXRzLm9mZnNldFkpO1xuICAgICAgc2hvdWxkU3Ryb2tlICYmIGN0eC5zdHJva2VUZXh0KF9jaGFyLCBsZWZ0IC0gc3Ryb2tlT2Zmc2V0cy5vZmZzZXRYLCB0b3AgLSBzdHJva2VPZmZzZXRzLm9mZnNldFkpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHVybnMgdGhlIGNoYXJhY3RlciBpbnRvIGEgJ3N1cGVyaW9yIGZpZ3VyZScgKGkuZS4gJ3N1cGVyc2NyaXB0JylcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgc2VsZWN0aW9uIHN0YXJ0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBzZWxlY3Rpb24gZW5kXG4gICAgICogQHJldHVybnMge2ZhYnJpYy5UZXh0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIHNldFN1cGVyc2NyaXB0OiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0U2NyaXB0KHN0YXJ0LCBlbmQsIHRoaXMuc3VwZXJzY3JpcHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUdXJucyB0aGUgY2hhcmFjdGVyIGludG8gYW4gJ2luZmVyaW9yIGZpZ3VyZScgKGkuZS4gJ3N1YnNjcmlwdCcpXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IHNlbGVjdGlvbiBzdGFydFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgc2VsZWN0aW9uIGVuZFxuICAgICAqIEByZXR1cm5zIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBzZXRTdWJzY3JpcHQ6IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXRTY3JpcHQoc3RhcnQsIGVuZCwgdGhpcy5zdWJzY3JpcHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzICdzY2hlbWEnIGF0IGdpdmVuIHBvc2l0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgc2VsZWN0aW9uIHN0YXJ0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBzZWxlY3Rpb24gZW5kXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjaGVtYVxuICAgICAqIEByZXR1cm5zIHtmYWJyaWMuVGV4dH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBfc2V0U2NyaXB0OiBmdW5jdGlvbihzdGFydCwgZW5kLCBzY2hlbWEpIHtcbiAgICAgIHZhciBsb2MgPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oc3RhcnQsIHRydWUpLFxuICAgICAgICAgIGZvbnRTaXplID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChsb2MubGluZUluZGV4LCBsb2MuY2hhckluZGV4LCAnZm9udFNpemUnKSxcbiAgICAgICAgICBkeSA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQobG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCwgJ2RlbHRhWScpLFxuICAgICAgICAgIHN0eWxlID0geyBmb250U2l6ZTogZm9udFNpemUgKiBzY2hlbWEuc2l6ZSwgZGVsdGFZOiBkeSArIGZvbnRTaXplICogc2NoZW1hLmJhc2VsaW5lIH07XG4gICAgICB0aGlzLnNldFNlbGVjdGlvblN0eWxlcyhzdHlsZSwgc3RhcnQsIGVuZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IGluZGV4IHRleHQgbGluZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTGluZSBsZWZ0IG9mZnNldFxuICAgICAqL1xuICAgIF9nZXRMaW5lTGVmdE9mZnNldDogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICB2YXIgbGluZVdpZHRoID0gdGhpcy5nZXRMaW5lV2lkdGgobGluZUluZGV4KSxcbiAgICAgICAgICBsaW5lRGlmZiA9IHRoaXMud2lkdGggLSBsaW5lV2lkdGgsIHRleHRBbGlnbiA9IHRoaXMudGV4dEFsaWduLCBkaXJlY3Rpb24gPSB0aGlzLmRpcmVjdGlvbixcbiAgICAgICAgICBpc0VuZE9mV3JhcHBpbmcsIGxlZnRPZmZzZXQgPSAwLCBpc0VuZE9mV3JhcHBpbmcgPSB0aGlzLmlzRW5kT2ZXcmFwcGluZyhsaW5lSW5kZXgpO1xuICAgICAgaWYgKHRleHRBbGlnbiA9PT0gJ2p1c3RpZnknXG4gICAgICAgIHx8ICh0ZXh0QWxpZ24gPT09ICdqdXN0aWZ5LWNlbnRlcicgJiYgIWlzRW5kT2ZXcmFwcGluZylcbiAgICAgICAgfHwgKHRleHRBbGlnbiA9PT0gJ2p1c3RpZnktcmlnaHQnICYmICFpc0VuZE9mV3JhcHBpbmcpXG4gICAgICAgIHx8ICh0ZXh0QWxpZ24gPT09ICdqdXN0aWZ5LWxlZnQnICYmICFpc0VuZE9mV3JhcHBpbmcpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBpZiAodGV4dEFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICBsZWZ0T2Zmc2V0ID0gbGluZURpZmYgLyAyO1xuICAgICAgfVxuICAgICAgaWYgKHRleHRBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICBsZWZ0T2Zmc2V0ID0gbGluZURpZmY7XG4gICAgICB9XG4gICAgICBpZiAodGV4dEFsaWduID09PSAnanVzdGlmeS1jZW50ZXInKSB7XG4gICAgICAgIGxlZnRPZmZzZXQgPSBsaW5lRGlmZiAvIDI7XG4gICAgICB9XG4gICAgICBpZiAodGV4dEFsaWduID09PSAnanVzdGlmeS1yaWdodCcpIHtcbiAgICAgICAgbGVmdE9mZnNldCA9IGxpbmVEaWZmO1xuICAgICAgfVxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICAgICAgbGVmdE9mZnNldCAtPSBsaW5lRGlmZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZWZ0T2Zmc2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jbGVhckNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX19saW5lV2lkdGhzID0gW107XG4gICAgICB0aGlzLl9fbGluZUhlaWdodHMgPSBbXTtcbiAgICAgIHRoaXMuX19jaGFyQm91bmRzID0gW107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Nob3VsZENsZWFyRGltZW5zaW9uQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNob3VsZENsZWFyID0gdGhpcy5fZm9yY2VDbGVhckNhY2hlO1xuICAgICAgc2hvdWxkQ2xlYXIgfHwgKHNob3VsZENsZWFyID0gdGhpcy5oYXNTdGF0ZUNoYW5nZWQoJ19kaW1lbnNpb25BZmZlY3RpbmdQcm9wcycpKTtcbiAgICAgIGlmIChzaG91bGRDbGVhcikge1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZm9yY2VDbGVhckNhY2hlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2hvdWxkQ2xlYXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1lYXN1cmUgYSBzaW5nbGUgbGluZSBnaXZlbiBpdHMgaW5kZXguIFVzZWQgdG8gY2FsY3VsYXRlIHRoZSBpbml0aWFsXG4gICAgICogdGV4dCBib3VuZGluZyBib3guIFRoZSB2YWx1ZXMgYXJlIGNhbGN1bGF0ZWQgYW5kIHN0b3JlZCBpbiBfX2xpbmVXaWR0aHMgY2FjaGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IGxpbmUgbnVtYmVyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBMaW5lIHdpZHRoXG4gICAgICovXG4gICAgZ2V0TGluZVdpZHRoOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLl9fbGluZVdpZHRoc1tsaW5lSW5kZXhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19saW5lV2lkdGhzW2xpbmVJbmRleF07XG4gICAgICB9XG5cbiAgICAgIHZhciBsaW5lSW5mbyA9IHRoaXMubWVhc3VyZUxpbmUobGluZUluZGV4KTtcbiAgICAgIHZhciB3aWR0aCA9IGxpbmVJbmZvLndpZHRoO1xuICAgICAgdGhpcy5fX2xpbmVXaWR0aHNbbGluZUluZGV4XSA9IHdpZHRoO1xuICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH0sXG5cbiAgICBfZ2V0V2lkdGhPZkNoYXJTcGFjaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNoYXJTcGFjaW5nICE9PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvbnRTaXplICogdGhpcy5jaGFyU3BhY2luZyAvIDEwMDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB2YWx1ZSBvZiBwcm9wZXJ0eSBhdCBnaXZlbiBjaGFyYWN0ZXIgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IHRoZSBsaW5lIG51bWJlclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXggdGhlIGNoYXJhY3RlciBudW1iZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgdGhlIHByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJucyB0aGUgdmFsdWUgb2YgJ3Byb3BlcnR5J1xuICAgICAqL1xuICAgIGdldFZhbHVlT2ZQcm9wZXJ0eUF0OiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCwgcHJvcGVydHkpIHtcbiAgICAgIHZhciBjaGFyU3R5bGUgPSB0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KTtcbiAgICAgIGlmIChjaGFyU3R5bGUgJiYgdHlwZW9mIGNoYXJTdHlsZVtwcm9wZXJ0eV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBjaGFyU3R5bGVbcHJvcGVydHldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNbcHJvcGVydHldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dCB0byByZW5kZXIgb25cbiAgICAgKi9cbiAgICBfcmVuZGVyVGV4dERlY29yYXRpb246IGZ1bmN0aW9uKGN0eCwgdHlwZSkge1xuICAgICAgaWYgKCF0aGlzW3R5cGVdICYmICF0aGlzLnN0eWxlSGFzKHR5cGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAvLyBpZiB0eXBlIGlzIG92ZXJsaW5lIG9yIGxpbmV0aHJvdWdoIHdlIHNob3VsZG4ndCBjYXN0IHNoYWRvd1xuICAgICAgaWYgKHR5cGUgPT09ICdvdmVybGluZScgfHwgdHlwZSA9PT0gJ2xpbmV0aHJvdWdoJykge1xuICAgICAgICB0aGlzLl9yZW1vdmVTaGFkb3coY3R4KTtcbiAgICAgIH1cbiAgICAgIHZhciBoZWlnaHRPZkxpbmUsIHNpemUsIF9zaXplLFxuICAgICAgICAgIGxpbmVMZWZ0T2Zmc2V0LCBkeSwgX2R5LFxuICAgICAgICAgIGxpbmUsIGxhc3REZWNvcmF0aW9uLFxuICAgICAgICAgIGxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMZWZ0T2Zmc2V0KCksXG4gICAgICAgICAgdG9wT2Zmc2V0ID0gdGhpcy5fZ2V0VG9wT2Zmc2V0KCksIHRvcCxcbiAgICAgICAgICBib3hTdGFydCwgYm94V2lkdGgsIGNoYXJCb3gsIGN1cnJlbnREZWNvcmF0aW9uLFxuICAgICAgICAgIG1heEhlaWdodCwgY3VycmVudEZpbGwsIGxhc3RGaWxsLCBwYXRoID0gdGhpcy5wYXRoLFxuICAgICAgICAgIGNoYXJTcGFjaW5nID0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCksXG4gICAgICAgICAgb2Zmc2V0WSA9IHRoaXMub2Zmc2V0c1t0eXBlXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBoZWlnaHRPZkxpbmUgPSB0aGlzLmdldEhlaWdodE9mTGluZShpKTtcbiAgICAgICAgaWYgKCF0aGlzW3R5cGVdICYmICF0aGlzLnN0eWxlSGFzKHR5cGUsIGkpKSB7XG4gICAgICAgICAgdG9wT2Zmc2V0ICs9IGhlaWdodE9mTGluZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2ldO1xuICAgICAgICBtYXhIZWlnaHQgPSBoZWlnaHRPZkxpbmUgLyB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgICAgIGxpbmVMZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQoaSk7XG4gICAgICAgIGJveFN0YXJ0ID0gMDtcbiAgICAgICAgYm94V2lkdGggPSAwO1xuICAgICAgICBsYXN0RGVjb3JhdGlvbiA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoaSwgMCwgdHlwZSk7XG4gICAgICAgIGxhc3RGaWxsID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCAwLCAnZmlsbCcpO1xuICAgICAgICB0b3AgPSB0b3BPZmZzZXQgKyBtYXhIZWlnaHQgKiAoMSAtIHRoaXMuX2ZvbnRTaXplRnJhY3Rpb24pO1xuICAgICAgICBzaXplID0gdGhpcy5nZXRIZWlnaHRPZkNoYXIoaSwgMCk7XG4gICAgICAgIGR5ID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCAwLCAnZGVsdGFZJyk7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gbGluZS5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgICBjaGFyQm94ID0gdGhpcy5fX2NoYXJCb3VuZHNbaV1bal07XG4gICAgICAgICAgY3VycmVudERlY29yYXRpb24gPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIGosIHR5cGUpO1xuICAgICAgICAgIGN1cnJlbnRGaWxsID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCBqLCAnZmlsbCcpO1xuICAgICAgICAgIF9zaXplID0gdGhpcy5nZXRIZWlnaHRPZkNoYXIoaSwgaik7XG4gICAgICAgICAgX2R5ID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCBqLCAnZGVsdGFZJyk7XG4gICAgICAgICAgaWYgKHBhdGggJiYgY3VycmVudERlY29yYXRpb24gJiYgY3VycmVudEZpbGwpIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFzdEZpbGw7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKGNoYXJCb3gucmVuZGVyTGVmdCwgY2hhckJveC5yZW5kZXJUb3ApO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShjaGFyQm94LmFuZ2xlKTtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgICAgLWNoYXJCb3gua2VybmVkV2lkdGggLyAyLFxuICAgICAgICAgICAgICBvZmZzZXRZICogX3NpemUgKyBfZHksXG4gICAgICAgICAgICAgIGNoYXJCb3gua2VybmVkV2lkdGgsXG4gICAgICAgICAgICAgIHRoaXMuZm9udFNpemUgLyAxNVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICAgKGN1cnJlbnREZWNvcmF0aW9uICE9PSBsYXN0RGVjb3JhdGlvbiB8fCBjdXJyZW50RmlsbCAhPT0gbGFzdEZpbGwgfHwgX3NpemUgIT09IHNpemUgfHwgX2R5ICE9PSBkeSlcbiAgICAgICAgICAgICYmIGJveFdpZHRoID4gMFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIGRyYXdTdGFydCA9IGxlZnRPZmZzZXQgKyBsaW5lTGVmdE9mZnNldCArIGJveFN0YXJ0O1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgICAgICAgICAgICBkcmF3U3RhcnQgPSB0aGlzLndpZHRoIC0gZHJhd1N0YXJ0IC0gYm94V2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdERlY29yYXRpb24gJiYgbGFzdEZpbGwpIHtcbiAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhc3RGaWxsO1xuICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgICAgICAgZHJhd1N0YXJ0LFxuICAgICAgICAgICAgICAgIHRvcCArIG9mZnNldFkgKiBzaXplICsgZHksXG4gICAgICAgICAgICAgICAgYm94V2lkdGgsXG4gICAgICAgICAgICAgICAgdGhpcy5mb250U2l6ZSAvIDE1XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib3hTdGFydCA9IGNoYXJCb3gubGVmdDtcbiAgICAgICAgICAgIGJveFdpZHRoID0gY2hhckJveC53aWR0aDtcbiAgICAgICAgICAgIGxhc3REZWNvcmF0aW9uID0gY3VycmVudERlY29yYXRpb247XG4gICAgICAgICAgICBsYXN0RmlsbCA9IGN1cnJlbnRGaWxsO1xuICAgICAgICAgICAgc2l6ZSA9IF9zaXplO1xuICAgICAgICAgICAgZHkgPSBfZHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm94V2lkdGggKz0gY2hhckJveC5rZXJuZWRXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRyYXdTdGFydCA9IGxlZnRPZmZzZXQgKyBsaW5lTGVmdE9mZnNldCArIGJveFN0YXJ0O1xuICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgICAgICAgZHJhd1N0YXJ0ID0gdGhpcy53aWR0aCAtIGRyYXdTdGFydCAtIGJveFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBjdXJyZW50RmlsbDtcbiAgICAgICAgY3VycmVudERlY29yYXRpb24gJiYgY3VycmVudEZpbGwgJiYgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgIGRyYXdTdGFydCxcbiAgICAgICAgICB0b3AgKyBvZmZzZXRZICogc2l6ZSArIGR5LFxuICAgICAgICAgIGJveFdpZHRoIC0gY2hhclNwYWNpbmcsXG4gICAgICAgICAgdGhpcy5mb250U2l6ZSAvIDE1XG4gICAgICAgICk7XG4gICAgICAgIHRvcE9mZnNldCArPSBoZWlnaHRPZkxpbmU7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gZm9udCBkZWNsYXJhdGlvbiBzdHJpbmcgZm9yIGNhbnZhcyBjb250ZXh0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdHlsZU9iamVjdF0gb2JqZWN0XG4gICAgICogQHJldHVybnMge1N0cmluZ30gZm9udCBkZWNsYXJhdGlvbiBmb3JtYXR0ZWQgZm9yIGNhbnZhcyBjb250ZXh0LlxuICAgICAqL1xuICAgIF9nZXRGb250RGVjbGFyYXRpb246IGZ1bmN0aW9uKHN0eWxlT2JqZWN0LCBmb3JNZWFzdXJpbmcpIHtcbiAgICAgIHZhciBzdHlsZSA9IHN0eWxlT2JqZWN0IHx8IHRoaXMsIGZhbWlseSA9IHRoaXMuZm9udEZhbWlseSxcbiAgICAgICAgICBmb250SXNHZW5lcmljID0gZmFicmljLlRleHQuZ2VuZXJpY0ZvbnRzLmluZGV4T2YoZmFtaWx5LnRvTG93ZXJDYXNlKCkpID4gLTE7XG4gICAgICB2YXIgZm9udEZhbWlseSA9IGZhbWlseSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICBmYW1pbHkuaW5kZXhPZignXFwnJykgPiAtMSB8fCBmYW1pbHkuaW5kZXhPZignLCcpID4gLTEgfHxcbiAgICAgIGZhbWlseS5pbmRleE9mKCdcIicpID4gLTEgfHwgZm9udElzR2VuZXJpY1xuICAgICAgICA/IHN0eWxlLmZvbnRGYW1pbHkgOiAnXCInICsgc3R5bGUuZm9udEZhbWlseSArICdcIic7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAvLyBub2RlLWNhbnZhcyBuZWVkcyBcIndlaWdodCBzdHlsZVwiLCB3aGlsZSBicm93c2VycyBuZWVkIFwic3R5bGUgd2VpZ2h0XCJcbiAgICAgICAgLy8gdmVyaWZ5IGlmIHRoaXMgY2FuIGJlIGZpeGVkIGluIEpTRE9NXG4gICAgICAgIChmYWJyaWMuaXNMaWtlbHlOb2RlID8gc3R5bGUuZm9udFdlaWdodCA6IHN0eWxlLmZvbnRTdHlsZSksXG4gICAgICAgIChmYWJyaWMuaXNMaWtlbHlOb2RlID8gc3R5bGUuZm9udFN0eWxlIDogc3R5bGUuZm9udFdlaWdodCksXG4gICAgICAgIGZvck1lYXN1cmluZyA/IHRoaXMuQ0FDSEVfRk9OVF9TSVpFICsgJ3B4JyA6IHN0eWxlLmZvbnRTaXplICsgJ3B4JyxcbiAgICAgICAgZm9udEZhbWlseVxuICAgICAgXS5qb2luKCcgJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGV4dCBpbnN0YW5jZSBvbiBhIHNwZWNpZmllZCBjb250ZXh0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oY3R4KSB7XG4gICAgICAvLyBkbyBub3QgcmVuZGVyIGlmIG9iamVjdCBpcyBub3QgdmlzaWJsZVxuICAgICAgaWYgKCF0aGlzLnZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnNraXBPZmZzY3JlZW4gJiYgIXRoaXMuZ3JvdXAgJiYgIXRoaXMuaXNPblNjcmVlbigpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9zaG91bGRDbGVhckRpbWVuc2lvbkNhY2hlKCkpIHtcbiAgICAgICAgdGhpcy5pbml0RGltZW5zaW9ucygpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWxsU3VwZXIoJ3JlbmRlcicsIGN0eCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRleHQgYXMgYW4gYXJyYXkgb2YgbGluZXMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgdGV4dCB0byBzcGxpdFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gTGluZXMgaW4gdGhlIHRleHRcbiAgICAgKi9cbiAgICBfc3BsaXRUZXh0SW50b0xpbmVzOiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KHRoaXMuX3JlTmV3bGluZSksXG4gICAgICAgICAgbmV3TGluZXMgPSBuZXcgQXJyYXkobGluZXMubGVuZ3RoKSxcbiAgICAgICAgICBuZXdMaW5lID0gWydcXG4nXSxcbiAgICAgICAgICBuZXdUZXh0ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5ld0xpbmVzW2ldID0gZmFicmljLnV0aWwuc3RyaW5nLmdyYXBoZW1lU3BsaXQobGluZXNbaV0pO1xuICAgICAgICBuZXdUZXh0ID0gbmV3VGV4dC5jb25jYXQobmV3TGluZXNbaV0sIG5ld0xpbmUpO1xuICAgICAgfVxuICAgICAgbmV3VGV4dC5wb3AoKTtcbiAgICAgIHJldHVybiB7IF91bndyYXBwZWRMaW5lczogbmV3TGluZXMsIGxpbmVzOiBsaW5lcywgZ3JhcGhlbWVUZXh0OiBuZXdUZXh0LCBncmFwaGVtZUxpbmVzOiBuZXdMaW5lcyB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wZXJ0aWVzVG9JbmNsdWRlXSBBbnkgcHJvcGVydGllcyB0aGF0IHlvdSBtaWdodCB3YW50IHRvIGFkZGl0aW9uYWxseSBpbmNsdWRlIGluIHRoZSBvdXRwdXRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbihwcm9wZXJ0aWVzVG9JbmNsdWRlKSB7XG4gICAgICB2YXIgYWxsUHJvcGVydGllcyA9IGFkZGl0aW9uYWxQcm9wcy5jb25jYXQocHJvcGVydGllc1RvSW5jbHVkZSk7XG4gICAgICB2YXIgb2JqID0gdGhpcy5jYWxsU3VwZXIoJ3RvT2JqZWN0JywgYWxsUHJvcGVydGllcyk7XG4gICAgICBvYmouc3R5bGVzID0gZmFicmljLnV0aWwuc3R5bGVzVG9BcnJheSh0aGlzLnN0eWxlcywgdGhpcy50ZXh0KTtcbiAgICAgIGlmIChvYmoucGF0aCkge1xuICAgICAgICBvYmoucGF0aCA9IHRoaXMucGF0aC50b09iamVjdCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBwcm9wZXJ0eSB0byBhIGdpdmVuIHZhbHVlLiBXaGVuIGNoYW5naW5nIHBvc2l0aW9uL2RpbWVuc2lvbiAtcmVsYXRlZCBwcm9wZXJ0aWVzIChsZWZ0LCB0b3AsIHNjYWxlLCBhbmdsZSwgZXRjLikgYHNldGAgZG9lcyBub3QgdXBkYXRlIHBvc2l0aW9uIG9mIG9iamVjdCdzIGJvcmRlcnMvY29udHJvbHMuIElmIHlvdSBuZWVkIHRvIHVwZGF0ZSB0aG9zZSwgY2FsbCBgc2V0Q29vcmRzKClgLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0ga2V5IFByb3BlcnR5IG5hbWUgb3Igb2JqZWN0IChpZiBvYmplY3QsIGl0ZXJhdGUgb3ZlciB0aGUgb2JqZWN0IHByb3BlcnRpZXMpXG4gICAgICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHZhbHVlIFByb3BlcnR5IHZhbHVlIChpZiBmdW5jdGlvbiwgdGhlIHZhbHVlIGlzIHBhc3NlZCBpbnRvIGl0IGFuZCBpdHMgcmV0dXJuIHZhbHVlIGlzIHVzZWQgYXMgYSBuZXcgb25lKVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5PYmplY3R9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLmNhbGxTdXBlcignc2V0Jywga2V5LCB2YWx1ZSk7XG4gICAgICB2YXIgbmVlZHNEaW1zID0gZmFsc2U7XG4gICAgICB2YXIgaXNBZGRpbmdQYXRoID0gZmFsc2U7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2YXIgX2tleSBpbiBrZXkpIHtcbiAgICAgICAgICBpZiAoX2tleSA9PT0gJ3BhdGgnKSB7XG4gICAgICAgICAgICB0aGlzLnNldFBhdGhJbmZvKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5lZWRzRGltcyA9IG5lZWRzRGltcyB8fCB0aGlzLl9kaW1lbnNpb25BZmZlY3RpbmdQcm9wcy5pbmRleE9mKF9rZXkpICE9PSAtMTtcbiAgICAgICAgICBpc0FkZGluZ1BhdGggPSBpc0FkZGluZ1BhdGggfHwgX2tleSA9PT0gJ3BhdGgnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmVlZHNEaW1zID0gdGhpcy5fZGltZW5zaW9uQWZmZWN0aW5nUHJvcHMuaW5kZXhPZihrZXkpICE9PSAtMTtcbiAgICAgICAgaXNBZGRpbmdQYXRoID0ga2V5ID09PSAncGF0aCc7XG4gICAgICB9XG4gICAgICBpZiAoaXNBZGRpbmdQYXRoKSB7XG4gICAgICAgIHRoaXMuc2V0UGF0aEluZm8oKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkc0RpbXMpIHtcbiAgICAgICAgdGhpcy5pbml0RGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29tcGxleGl0eSBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gY29tcGxleGl0eVxuICAgICAqL1xuICAgIGNvbXBsZXhpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9KTtcblxuICAvKiBfRlJPTV9TVkdfU1RBUlRfICovXG4gIC8qKlxuICAgKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0byBhY2NvdW50IGZvciB3aGVuIHBhcnNpbmcgU1ZHIGVsZW1lbnQgKHVzZWQgYnkge0BsaW5rIGZhYnJpYy5UZXh0LmZyb21FbGVtZW50fSlcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgZmFicmljLlRleHRcbiAgICogQHNlZTogaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3RleHQuaHRtbCNUZXh0RWxlbWVudFxuICAgKi9cbiAgZmFicmljLlRleHQuQVRUUklCVVRFX05BTUVTID0gZmFicmljLlNIQVJFRF9BVFRSSUJVVEVTLmNvbmNhdChcbiAgICAneCB5IGR4IGR5IGZvbnQtZmFtaWx5IGZvbnQtc3R5bGUgZm9udC13ZWlnaHQgZm9udC1zaXplIGxldHRlci1zcGFjaW5nIHRleHQtZGVjb3JhdGlvbiB0ZXh0LWFuY2hvcicuc3BsaXQoJyAnKSk7XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgU1ZHIGZvbnQgc2l6ZVxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuVGV4dFxuICAgKi9cbiAgZmFicmljLlRleHQuREVGQVVMVF9TVkdfRk9OVF9TSVpFID0gMTY7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLlRleHQgaW5zdGFuY2UgZnJvbSBhbiBTVkcgZWxlbWVudCAoPGI+bm90IHlldCBpbXBsZW1lbnRlZDwvYj4pXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5UZXh0XG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uIGludm9rZWQgYWZ0ZXIgcGFyc2luZ1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqL1xuICBmYWJyaWMuVGV4dC5mcm9tRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlZEF0dHJpYnV0ZXMgPSBmYWJyaWMucGFyc2VBdHRyaWJ1dGVzKGVsZW1lbnQsIGZhYnJpYy5UZXh0LkFUVFJJQlVURV9OQU1FUyksXG4gICAgICAgIHBhcnNlZEFuY2hvciA9IHBhcnNlZEF0dHJpYnV0ZXMudGV4dEFuY2hvciB8fCAnbGVmdCc7XG4gICAgb3B0aW9ucyA9IGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoKG9wdGlvbnMgPyBjbG9uZShvcHRpb25zKSA6IHsgfSksIHBhcnNlZEF0dHJpYnV0ZXMpO1xuXG4gICAgb3B0aW9ucy50b3AgPSBvcHRpb25zLnRvcCB8fCAwO1xuICAgIG9wdGlvbnMubGVmdCA9IG9wdGlvbnMubGVmdCB8fCAwO1xuICAgIGlmIChwYXJzZWRBdHRyaWJ1dGVzLnRleHREZWNvcmF0aW9uKSB7XG4gICAgICB2YXIgdGV4dERlY29yYXRpb24gPSBwYXJzZWRBdHRyaWJ1dGVzLnRleHREZWNvcmF0aW9uO1xuICAgICAgaWYgKHRleHREZWNvcmF0aW9uLmluZGV4T2YoJ3VuZGVybGluZScpICE9PSAtMSkge1xuICAgICAgICBvcHRpb25zLnVuZGVybGluZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGV4dERlY29yYXRpb24uaW5kZXhPZignb3ZlcmxpbmUnKSAhPT0gLTEpIHtcbiAgICAgICAgb3B0aW9ucy5vdmVybGluZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGV4dERlY29yYXRpb24uaW5kZXhPZignbGluZS10aHJvdWdoJykgIT09IC0xKSB7XG4gICAgICAgIG9wdGlvbnMubGluZXRocm91Z2ggPSB0cnVlO1xuICAgICAgfVxuICAgICAgZGVsZXRlIG9wdGlvbnMudGV4dERlY29yYXRpb247XG4gICAgfVxuICAgIGlmICgnZHgnIGluIHBhcnNlZEF0dHJpYnV0ZXMpIHtcbiAgICAgIG9wdGlvbnMubGVmdCArPSBwYXJzZWRBdHRyaWJ1dGVzLmR4O1xuICAgIH1cbiAgICBpZiAoJ2R5JyBpbiBwYXJzZWRBdHRyaWJ1dGVzKSB7XG4gICAgICBvcHRpb25zLnRvcCArPSBwYXJzZWRBdHRyaWJ1dGVzLmR5O1xuICAgIH1cbiAgICBpZiAoISgnZm9udFNpemUnIGluIG9wdGlvbnMpKSB7XG4gICAgICBvcHRpb25zLmZvbnRTaXplID0gZmFicmljLlRleHQuREVGQVVMVF9TVkdfRk9OVF9TSVpFO1xuICAgIH1cblxuICAgIHZhciB0ZXh0Q29udGVudCA9ICcnO1xuXG4gICAgLy8gVGhlIFhNTCBpcyBub3QgcHJvcGVybHkgcGFyc2VkIGluIElFOSBzbyBhIHdvcmthcm91bmQgdG8gZ2V0XG4gICAgLy8gdGV4dENvbnRlbnQgaXMgdGhyb3VnaCBmaXJzdENoaWxkLmRhdGEuIEFub3RoZXIgd29ya2Fyb3VuZCB3b3VsZCBiZVxuICAgIC8vIHRvIGNvbnZlcnQgWE1MIGxvYWRlZCBmcm9tIGEgZmlsZSB0byBiZSBjb252ZXJ0ZWQgdXNpbmcgRE9NUGFyc2VyIChzYW1lIHdheSBsb2FkU1ZHRnJvbVN0cmluZygpIGRvZXMpXG4gICAgaWYgKCEoJ3RleHRDb250ZW50JyBpbiBlbGVtZW50KSkge1xuICAgICAgaWYgKCdmaXJzdENoaWxkJyBpbiBlbGVtZW50ICYmIGVsZW1lbnQuZmlyc3RDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoJ2RhdGEnIGluIGVsZW1lbnQuZmlyc3RDaGlsZCAmJiBlbGVtZW50LmZpcnN0Q2hpbGQuZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgIHRleHRDb250ZW50ID0gZWxlbWVudC5maXJzdENoaWxkLmRhdGE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0ZXh0Q29udGVudCA9IGVsZW1lbnQudGV4dENvbnRlbnQ7XG4gICAgfVxuXG4gICAgdGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudC5yZXBsYWNlKC9eXFxzK3xcXHMrJHxcXG4rL2csICcnKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG4gICAgdmFyIG9yaWdpbmFsU3Ryb2tlV2lkdGggPSBvcHRpb25zLnN0cm9rZVdpZHRoO1xuICAgIG9wdGlvbnMuc3Ryb2tlV2lkdGggPSAwO1xuXG4gICAgdmFyIHRleHQgPSBuZXcgZmFicmljLlRleHQodGV4dENvbnRlbnQsIG9wdGlvbnMpLFxuICAgICAgICB0ZXh0SGVpZ2h0U2NhbGVGYWN0b3IgPSB0ZXh0LmdldFNjYWxlZEhlaWdodCgpIC8gdGV4dC5oZWlnaHQsXG4gICAgICAgIGxpbmVIZWlnaHREaWZmID0gKHRleHQuaGVpZ2h0ICsgdGV4dC5zdHJva2VXaWR0aCkgKiB0ZXh0LmxpbmVIZWlnaHQgLSB0ZXh0LmhlaWdodCxcbiAgICAgICAgc2NhbGVkRGlmZiA9IGxpbmVIZWlnaHREaWZmICogdGV4dEhlaWdodFNjYWxlRmFjdG9yLFxuICAgICAgICB0ZXh0SGVpZ2h0ID0gdGV4dC5nZXRTY2FsZWRIZWlnaHQoKSArIHNjYWxlZERpZmYsXG4gICAgICAgIG9mZlggPSAwO1xuICAgIC8qXG4gICAgICBBZGp1c3QgcG9zaXRpb25pbmc6XG4gICAgICAgIHgveSBhdHRyaWJ1dGVzIGluIFNWRyBjb3JyZXNwb25kIHRvIHRoZSBib3R0b20tbGVmdCBjb3JuZXIgb2YgdGV4dCBib3VuZGluZyBib3hcbiAgICAgICAgZmFicmljIG91dHB1dCBieSBkZWZhdWx0IGF0IHRvcCwgbGVmdC5cbiAgICAqL1xuICAgIGlmIChwYXJzZWRBbmNob3IgPT09ICdjZW50ZXInKSB7XG4gICAgICBvZmZYID0gdGV4dC5nZXRTY2FsZWRXaWR0aCgpIC8gMjtcbiAgICB9XG4gICAgaWYgKHBhcnNlZEFuY2hvciA9PT0gJ3JpZ2h0Jykge1xuICAgICAgb2ZmWCA9IHRleHQuZ2V0U2NhbGVkV2lkdGgoKTtcbiAgICB9XG4gICAgdGV4dC5zZXQoe1xuICAgICAgbGVmdDogdGV4dC5sZWZ0IC0gb2ZmWCxcbiAgICAgIHRvcDogdGV4dC50b3AgLSAodGV4dEhlaWdodCAtIHRleHQuZm9udFNpemUgKiAoMC4wNyArIHRleHQuX2ZvbnRTaXplRnJhY3Rpb24pKSAvIHRleHQubGluZUhlaWdodCxcbiAgICAgIHN0cm9rZVdpZHRoOiB0eXBlb2Ygb3JpZ2luYWxTdHJva2VXaWR0aCAhPT0gJ3VuZGVmaW5lZCcgPyBvcmlnaW5hbFN0cm9rZVdpZHRoIDogMSxcbiAgICB9KTtcbiAgICBjYWxsYmFjayh0ZXh0KTtcbiAgfTtcbiAgLyogX0ZST01fU1ZHX0VORF8gKi9cblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuVGV4dCBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuVGV4dFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHBsYWluIGpzIE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGZhYnJpYy5UZXh0IGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICovXG4gIGZhYnJpYy5UZXh0LmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9iamVjdENvcHkgPSBjbG9uZShvYmplY3QpLCBwYXRoID0gb2JqZWN0LnBhdGg7XG4gICAgZGVsZXRlIG9iamVjdENvcHkucGF0aDtcbiAgICByZXR1cm4gZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnVGV4dCcsIG9iamVjdENvcHksIGZ1bmN0aW9uKHRleHRJbnN0YW5jZSkge1xuICAgICAgdGV4dEluc3RhbmNlLnN0eWxlcyA9IGZhYnJpYy51dGlsLnN0eWxlc0Zyb21BcnJheShvYmplY3Quc3R5bGVzLCBvYmplY3QudGV4dCk7XG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdQYXRoJywgcGF0aCwgZnVuY3Rpb24ocGF0aEluc3RhbmNlKSB7XG4gICAgICAgICAgdGV4dEluc3RhbmNlLnNldCgncGF0aCcsIHBhdGhJbnN0YW5jZSk7XG4gICAgICAgICAgY2FsbGJhY2sodGV4dEluc3RhbmNlKTtcbiAgICAgICAgfSwgJ3BhdGgnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjYWxsYmFjayh0ZXh0SW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH0sICd0ZXh0Jyk7XG4gIH07XG5cbiAgZmFicmljLlRleHQuZ2VuZXJpY0ZvbnRzID0gWydzYW5zLXNlcmlmJywgJ3NlcmlmJywgJ2N1cnNpdmUnLCAnZmFudGFzeScsICdtb25vc3BhY2UnXTtcblxuICBmYWJyaWMudXRpbC5jcmVhdGVBY2Nlc3NvcnMgJiYgZmFicmljLnV0aWwuY3JlYXRlQWNjZXNzb3JzKGZhYnJpYy5UZXh0KTtcblxufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuVGV4dC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLlRleHQucHJvdG90eXBlICovIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGhhcyBubyBzdHlsaW5nIG9yIG5vIHN0eWxpbmcgaW4gYSBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCAsIGxpbmVJbmRleCBpcyBvbiB3cmFwcGVkIGxpbmVzLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNFbXB0eVN0eWxlczogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMuc3R5bGVzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBsaW5lSW5kZXggIT09ICd1bmRlZmluZWQnICYmICF0aGlzLnN0eWxlc1tsaW5lSW5kZXhdKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIG9iaiA9IHR5cGVvZiBsaW5lSW5kZXggPT09ICd1bmRlZmluZWQnID8gdGhpcy5zdHlsZXMgOiB7IGxpbmU6IHRoaXMuc3R5bGVzW2xpbmVJbmRleF0gfTtcbiAgICAgIGZvciAodmFyIHAxIGluIG9iaikge1xuICAgICAgICBmb3IgKHZhciBwMiBpbiBvYmpbcDFdKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgICAgZm9yICh2YXIgcDMgaW4gb2JqW3AxXVtwMl0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGhhcyBhIHN0eWxlIHByb3BlcnR5IG9yIGhhcyBpdCBpbmEgc3BlY2lmaWVkIGxpbmVcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gZGV0ZWN0IGlmIGEgdGV4dCB3aWxsIHVzZSBhIHBhcnRpY3VsYXIgcHJvcGVydHkgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSB0byBjaGVjayBmb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IHRvIGNoZWNrIHRoZSBzdHlsZSBvblxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3R5bGVIYXM6IGZ1bmN0aW9uKHByb3BlcnR5LCBsaW5lSW5kZXgpIHtcbiAgICAgIGlmICghdGhpcy5zdHlsZXMgfHwgIXByb3BlcnR5IHx8IHByb3BlcnR5ID09PSAnJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGxpbmVJbmRleCAhPT0gJ3VuZGVmaW5lZCcgJiYgIXRoaXMuc3R5bGVzW2xpbmVJbmRleF0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIG9iaiA9IHR5cGVvZiBsaW5lSW5kZXggPT09ICd1bmRlZmluZWQnID8gdGhpcy5zdHlsZXMgOiB7IDA6IHRoaXMuc3R5bGVzW2xpbmVJbmRleF0gfTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgZm9yICh2YXIgcDEgaW4gb2JqKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBmb3IgKHZhciBwMiBpbiBvYmpbcDFdKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvYmpbcDFdW3AyXVtwcm9wZXJ0eV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgY2hhcmFjdGVycyBpbiBhIHRleHQgaGF2ZSBhIHZhbHVlIGZvciBhIHByb3BlcnR5XG4gICAgICogd2hvc2UgdmFsdWUgbWF0Y2hlcyB0aGUgdGV4dGJveCdzIHZhbHVlIGZvciB0aGF0IHByb3BlcnR5LiAgSWYgc28sXG4gICAgICogdGhlIGNoYXJhY3Rlci1sZXZlbCBwcm9wZXJ0eSBpcyBkZWxldGVkLiAgSWYgdGhlIGNoYXJhY3RlclxuICAgICAqIGhhcyBubyBvdGhlciBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFsc28gZGVsZXRlZC4gIEZpbmFsbHksXG4gICAgICogaWYgdGhlIGxpbmUgY29udGFpbmluZyB0aGF0IGNoYXJhY3RlciBoYXMgbm8gb3RoZXIgY2hhcmFjdGVyc1xuICAgICAqIHRoZW4gaXQgYWxzbyBpcyBkZWxldGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBwcm9wZXJ0eSB0byBjb21wYXJlIGJldHdlZW4gY2hhcmFjdGVycyBhbmQgdGV4dC5cbiAgICAgKi9cbiAgICBjbGVhblN0eWxlOiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgaWYgKCF0aGlzLnN0eWxlcyB8fCAhcHJvcGVydHkgfHwgcHJvcGVydHkgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBvYmogPSB0aGlzLnN0eWxlcywgc3R5bGVzQ291bnQgPSAwLCBsZXR0ZXJDb3VudCwgc3R5bGVQcm9wZXJ0eVZhbHVlLFxuICAgICAgICAgIGFsbFN0eWxlT2JqZWN0UHJvcGVydGllc01hdGNoID0gdHJ1ZSwgZ3JhcGhlbWVDb3VudCA9IDAsIHN0eWxlT2JqZWN0O1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBmb3IgKHZhciBwMSBpbiBvYmopIHtcbiAgICAgICAgbGV0dGVyQ291bnQgPSAwO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgZm9yICh2YXIgcDIgaW4gb2JqW3AxXSkge1xuICAgICAgICAgIHZhciBzdHlsZU9iamVjdCA9IG9ialtwMV1bcDJdLFxuICAgICAgICAgICAgICBzdHlsZVByb3BlcnR5SGFzQmVlblNldCA9IHN0eWxlT2JqZWN0Lmhhc093blByb3BlcnR5KHByb3BlcnR5KTtcblxuICAgICAgICAgIHN0eWxlc0NvdW50Kys7XG5cbiAgICAgICAgICBpZiAoc3R5bGVQcm9wZXJ0eUhhc0JlZW5TZXQpIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVQcm9wZXJ0eVZhbHVlKSB7XG4gICAgICAgICAgICAgIHN0eWxlUHJvcGVydHlWYWx1ZSA9IHN0eWxlT2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0eWxlT2JqZWN0W3Byb3BlcnR5XSAhPT0gc3R5bGVQcm9wZXJ0eVZhbHVlKSB7XG4gICAgICAgICAgICAgIGFsbFN0eWxlT2JqZWN0UHJvcGVydGllc01hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdHlsZU9iamVjdFtwcm9wZXJ0eV0gPT09IHRoaXNbcHJvcGVydHldKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBzdHlsZU9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWxsU3R5bGVPYmplY3RQcm9wZXJ0aWVzTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoc3R5bGVPYmplY3QpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgbGV0dGVyQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgb2JqW3AxXVtwMl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxldHRlckNvdW50ID09PSAwKSB7XG4gICAgICAgICAgZGVsZXRlIG9ialtwMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGlmIGV2ZXJ5IGdyYXBoZW1lIGhhcyB0aGUgc2FtZSBzdHlsZSBzZXQgdGhlblxuICAgICAgLy8gZGVsZXRlIHRob3NlIHN0eWxlcyBhbmQgc2V0IGl0IG9uIHRoZSBwYXJlbnRcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdGV4dExpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGdyYXBoZW1lQ291bnQgKz0gdGhpcy5fdGV4dExpbmVzW2ldLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChhbGxTdHlsZU9iamVjdFByb3BlcnRpZXNNYXRjaCAmJiBzdHlsZXNDb3VudCA9PT0gZ3JhcGhlbWVDb3VudCkge1xuICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IHN0eWxlUHJvcGVydHlWYWx1ZTtcbiAgICAgICAgdGhpcy5yZW1vdmVTdHlsZShwcm9wZXJ0eSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHN0eWxlIHByb3BlcnR5IG9yIHByb3BlcnRpZXMgZnJvbSBhbGwgaW5kaXZpZHVhbCBjaGFyYWN0ZXIgc3R5bGVzXG4gICAgICogaW4gYSB0ZXh0IG9iamVjdC4gIERlbGV0ZXMgdGhlIGNoYXJhY3RlciBzdHlsZSBvYmplY3QgaWYgaXQgY29udGFpbnMgbm8gb3RoZXIgc3R5bGVcbiAgICAgKiBwcm9wcy4gIERlbGV0ZXMgYSBsaW5lIHN0eWxlIG9iamVjdCBpZiBpdCBjb250YWlucyBubyBvdGhlciBjaGFyYWN0ZXIgc3R5bGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BzIFRoZSBwcm9wZXJ0eSB0byByZW1vdmUgZnJvbSBjaGFyYWN0ZXIgc3R5bGVzLlxuICAgICAqL1xuICAgIHJlbW92ZVN0eWxlOiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgaWYgKCF0aGlzLnN0eWxlcyB8fCAhcHJvcGVydHkgfHwgcHJvcGVydHkgPT09ICcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBvYmogPSB0aGlzLnN0eWxlcywgbGluZSwgbGluZU51bSwgY2hhck51bTtcbiAgICAgIGZvciAobGluZU51bSBpbiBvYmopIHtcbiAgICAgICAgbGluZSA9IG9ialtsaW5lTnVtXTtcbiAgICAgICAgZm9yIChjaGFyTnVtIGluIGxpbmUpIHtcbiAgICAgICAgICBkZWxldGUgbGluZVtjaGFyTnVtXVtwcm9wZXJ0eV07XG4gICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGxpbmVbY2hhck51bV0pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIGxpbmVbY2hhck51bV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhsaW5lKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgb2JqW2xpbmVOdW1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2V4dGVuZFN0eWxlczogZnVuY3Rpb24oaW5kZXgsIHN0eWxlcykge1xuICAgICAgdmFyIGxvYyA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihpbmRleCk7XG5cbiAgICAgIGlmICghdGhpcy5fZ2V0TGluZVN0eWxlKGxvYy5saW5lSW5kZXgpKSB7XG4gICAgICAgIHRoaXMuX3NldExpbmVTdHlsZShsb2MubGluZUluZGV4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxvYy5saW5lSW5kZXgsIGxvYy5jaGFySW5kZXgpKSB7XG4gICAgICAgIHRoaXMuX3NldFN0eWxlRGVjbGFyYXRpb24obG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCwge30pO1xuICAgICAgfVxuXG4gICAgICBmYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKHRoaXMuX2dldFN0eWxlRGVjbGFyYXRpb24obG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCksIHN0eWxlcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgMmQgcmVwcmVzZW50YXRpb24gKGxpbmVJbmRleCBhbmQgY2hhckluZGV4KSBvZiBjdXJzb3IgKG9yIHNlbGVjdGlvbiBzdGFydClcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3NlbGVjdGlvblN0YXJ0XSBPcHRpb25hbCBpbmRleC4gV2hlbiBub3QgZ2l2ZW4sIGN1cnJlbnQgc2VsZWN0aW9uU3RhcnQgaXMgdXNlZC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtza2lwV3JhcHBpbmddIGNvbnNpZGVyIHRoZSBsb2NhdGlvbiBmb3IgdW53cmFwcGVkIGxpbmVzLiB1c2VmdWwgdG8gbWFuYWdlIHN0eWxlcy5cbiAgICAgKi9cbiAgICBnZXQyREN1cnNvckxvY2F0aW9uOiBmdW5jdGlvbihzZWxlY3Rpb25TdGFydCwgc2tpcFdyYXBwaW5nKSB7XG4gICAgICBpZiAodHlwZW9mIHNlbGVjdGlvblN0YXJ0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzZWxlY3Rpb25TdGFydCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICB9XG4gICAgICB2YXIgbGluZXMgPSBza2lwV3JhcHBpbmcgPyB0aGlzLl91bndyYXBwZWRUZXh0TGluZXMgOiB0aGlzLl90ZXh0TGluZXMsXG4gICAgICAgICAgbGVuID0gbGluZXMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPD0gbGluZXNbaV0ubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpbmVJbmRleDogaSxcbiAgICAgICAgICAgIGNoYXJJbmRleDogc2VsZWN0aW9uU3RhcnRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGlvblN0YXJ0IC09IGxpbmVzW2ldLmxlbmd0aCArIHRoaXMubWlzc2luZ05ld2xpbmVPZmZzZXQoaSwgc2tpcFdyYXBwaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmVJbmRleDogaSAtIDEsXG4gICAgICAgIGNoYXJJbmRleDogbGluZXNbaSAtIDFdLmxlbmd0aCA8IHNlbGVjdGlvblN0YXJ0ID8gbGluZXNbaSAtIDFdLmxlbmd0aCA6IHNlbGVjdGlvblN0YXJ0XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHN0eWxlIG9mIGEgY3VycmVudCBzZWxlY3Rpb24vY3Vyc29yIChhdCB0aGUgc3RhcnQgcG9zaXRpb24pXG4gICAgICogaWYgc3RhcnRJbmRleCBvciBlbmRJbmRleCBhcmUgbm90IHByb3ZpZGVkLCBzZWxlY3Rpb25TdGFydCBvciBzZWxlY3Rpb25FbmQgd2lsbCBiZSB1c2VkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRJbmRleF0gU3RhcnQgaW5kZXggdG8gZ2V0IHN0eWxlcyBhdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZW5kSW5kZXhdIEVuZCBpbmRleCB0byBnZXQgc3R5bGVzIGF0LCBpZiBub3Qgc3BlY2lmaWVkIHNlbGVjdGlvbkVuZCBvciBzdGFydEluZGV4ICsgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbXBsZXRlXSBnZXQgZnVsbCBzdHlsZSBvciBub3RcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gc3R5bGVzIGFuIGFycmF5IHdpdGggb25lLCB6ZXJvIG9yIG1vcmUgU3R5bGUgb2JqZWN0c1xuICAgICAqL1xuICAgIGdldFNlbGVjdGlvblN0eWxlczogZnVuY3Rpb24oc3RhcnRJbmRleCwgZW5kSW5kZXgsIGNvbXBsZXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHN0YXJ0SW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHN0YXJ0SW5kZXggPSB0aGlzLnNlbGVjdGlvblN0YXJ0IHx8IDA7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGVuZEluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBlbmRJbmRleCA9IHRoaXMuc2VsZWN0aW9uRW5kIHx8IHN0YXJ0SW5kZXg7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgc3R5bGVzLnB1c2godGhpcy5nZXRTdHlsZUF0UG9zaXRpb24oaSwgY29tcGxldGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgc3R5bGUgb2YgYSBjdXJyZW50IHNlbGVjdGlvbi9jdXJzb3IgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gIHRvIGdldCBzdHlsZXMgYXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb21wbGV0ZV0gZnVsbCBzdHlsZSBpZiB0cnVlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBzdHlsZSBTdHlsZSBvYmplY3QgYXQgYSBzcGVjaWZpZWQgaW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldFN0eWxlQXRQb3NpdGlvbjogZnVuY3Rpb24ocG9zaXRpb24sIGNvbXBsZXRlKSB7XG4gICAgICB2YXIgbG9jID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHBvc2l0aW9uKSxcbiAgICAgICAgICBzdHlsZSA9IGNvbXBsZXRlID8gdGhpcy5nZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb24obG9jLmxpbmVJbmRleCwgbG9jLmNoYXJJbmRleCkgOlxuICAgICAgICAgICAgdGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbihsb2MubGluZUluZGV4LCBsb2MuY2hhckluZGV4KTtcbiAgICAgIHJldHVybiBzdHlsZSB8fCB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBzdHlsZSBvZiBhIGN1cnJlbnQgc2VsZWN0aW9uLCBpZiBubyBzZWxlY3Rpb24gZXhpc3QsIGRvIG5vdCBzZXQgYW55dGhpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdHlsZXNdIFN0eWxlcyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0SW5kZXhdIFN0YXJ0IGluZGV4IHRvIGdldCBzdHlsZXMgYXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2VuZEluZGV4XSBFbmQgaW5kZXggdG8gZ2V0IHN0eWxlcyBhdCwgaWYgbm90IHNwZWNpZmllZCBzZWxlY3Rpb25FbmQgb3Igc3RhcnRJbmRleCArIDFcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2V0U2VsZWN0aW9uU3R5bGVzOiBmdW5jdGlvbihzdHlsZXMsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG4gICAgICBpZiAodHlwZW9mIHN0YXJ0SW5kZXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHN0YXJ0SW5kZXggPSB0aGlzLnNlbGVjdGlvblN0YXJ0IHx8IDA7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGVuZEluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBlbmRJbmRleCA9IHRoaXMuc2VsZWN0aW9uRW5kIHx8IHN0YXJ0SW5kZXg7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgdGhpcy5fZXh0ZW5kU3R5bGVzKGksIHN0eWxlcyk7XG4gICAgICB9XG4gICAgICAvKiBub3QgaW5jbHVkZWQgaW4gX2V4dGVuZFN0eWxlcyB0byBhdm9pZCBjbGVhcmluZyBjYWNoZSBtb3JlIHRoYW4gb25jZSAqL1xuICAgICAgdGhpcy5fZm9yY2VDbGVhckNhY2hlID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIHJlZmVyZW5jZSwgbm90IGEgY2xvbmUsIG9mIHRoZSBzdHlsZSBvYmplY3QgZm9yIGEgZ2l2ZW4gY2hhcmFjdGVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHN0eWxlIG9iamVjdFxuICAgICAqL1xuICAgIF9nZXRTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCkge1xuICAgICAgdmFyIGxpbmVTdHlsZSA9IHRoaXMuc3R5bGVzICYmIHRoaXMuc3R5bGVzW2xpbmVJbmRleF07XG4gICAgICBpZiAoIWxpbmVTdHlsZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaW5lU3R5bGVbY2hhckluZGV4XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGEgbmV3IG9iamVjdCB0aGF0IGNvbnRhaW5zIGFsbCB0aGUgc3R5bGUgcHJvcGVydHkgZm9yIGEgY2hhcmFjdGVyXG4gICAgICogdGhlIG9iamVjdCByZXR1cm5lZCBpcyBuZXdseSBjcmVhdGVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBvZiB0aGUgbGluZSB3aGVyZSB0aGUgY2hhcmFjdGVyIGlzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleCBwb3NpdGlvbiBvZiB0aGUgY2hhcmFjdGVyIG9uIHRoZSBsaW5lXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBzdHlsZSBvYmplY3RcbiAgICAgKi9cbiAgICBnZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSB7XG4gICAgICB2YXIgc3R5bGUgPSB0aGlzLl9nZXRTdHlsZURlY2xhcmF0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSB8fCB7IH0sXG4gICAgICAgICAgc3R5bGVPYmplY3QgPSB7IH0sIHByb3A7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3N0eWxlUHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcm9wID0gdGhpcy5fc3R5bGVQcm9wZXJ0aWVzW2ldO1xuICAgICAgICBzdHlsZU9iamVjdFtwcm9wXSA9IHR5cGVvZiBzdHlsZVtwcm9wXSA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzW3Byb3BdIDogc3R5bGVbcHJvcF07XG4gICAgICB9XG4gICAgICByZXR1cm4gc3R5bGVPYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0U3R5bGVEZWNsYXJhdGlvbjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgsIHN0eWxlKSB7XG4gICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2NoYXJJbmRleF0gPSBzdHlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2RlbGV0ZVN0eWxlRGVjbGFyYXRpb246IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4KSB7XG4gICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gaWYgdGhlIGxpbmUgZXhpc3RzIG9yIG5vdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldExpbmVTdHlsZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICByZXR1cm4gISF0aGlzLnN0eWxlc1tsaW5lSW5kZXhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGxpbmUgc3R5bGUgdG8gYW4gZW1wdHkgb2JqZWN0IHNvIHRoYXQgaXMgaW5pdGlhbGl6ZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0TGluZVN0eWxlOiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleF0gPSB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2RlbGV0ZUxpbmVTdHlsZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbGluZUluZGV4XTtcbiAgICB9XG4gIH0pO1xufSkoKTtcblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgZnVuY3Rpb24gcGFyc2VEZWNvcmF0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QudGV4dERlY29yYXRpb24pIHtcbiAgICAgIG9iamVjdC50ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCd1bmRlcmxpbmUnKSA+IC0xICYmIChvYmplY3QudW5kZXJsaW5lID0gdHJ1ZSk7XG4gICAgICBvYmplY3QudGV4dERlY29yYXRpb24uaW5kZXhPZignbGluZS10aHJvdWdoJykgPiAtMSAmJiAob2JqZWN0LmxpbmV0aHJvdWdoID0gdHJ1ZSk7XG4gICAgICBvYmplY3QudGV4dERlY29yYXRpb24uaW5kZXhPZignb3ZlcmxpbmUnKSA+IC0xICYmIChvYmplY3Qub3ZlcmxpbmUgPSB0cnVlKTtcbiAgICAgIGRlbGV0ZSBvYmplY3QudGV4dERlY29yYXRpb247XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIElUZXh0IGNsYXNzIChpbnRyb2R1Y2VkIGluIDxiPnYxLjQ8L2I+KSBFdmVudHMgYXJlIGFsc28gZmlyZWQgd2l0aCBcInRleHQ6XCJcbiAgICogcHJlZml4IHdoZW4gb2JzZXJ2aW5nIGNhbnZhcy5cbiAgICogQGNsYXNzIGZhYnJpYy5JVGV4dFxuICAgKiBAZXh0ZW5kcyBmYWJyaWMuVGV4dFxuICAgKiBAbWl4ZXMgZmFicmljLk9ic2VydmFibGVcbiAgICpcbiAgICogQGZpcmVzIGNoYW5nZWRcbiAgICogQGZpcmVzIHNlbGVjdGlvbjpjaGFuZ2VkXG4gICAqIEBmaXJlcyBlZGl0aW5nOmVudGVyZWRcbiAgICogQGZpcmVzIGVkaXRpbmc6ZXhpdGVkXG4gICAqXG4gICAqIEByZXR1cm4ge2ZhYnJpYy5JVGV4dH0gdGhpc0FyZ1xuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuSVRleHQjaW5pdGlhbGl6ZX0gZm9yIGNvbnN0cnVjdG9yIGRlZmluaXRpb25cbiAgICpcbiAgICogPHA+U3VwcG9ydGVkIGtleSBjb21iaW5hdGlvbnM6PC9wPlxuICAgKiA8cHJlPlxuICAgKiAgIE1vdmUgY3Vyc29yOiAgICAgICAgICAgICAgICAgICAgbGVmdCwgcmlnaHQsIHVwLCBkb3duXG4gICAqICAgU2VsZWN0IGNoYXJhY3RlcjogICAgICAgICAgICAgICBzaGlmdCArIGxlZnQsIHNoaWZ0ICsgcmlnaHRcbiAgICogICBTZWxlY3QgdGV4dCB2ZXJ0aWNhbGx5OiAgICAgICAgIHNoaWZ0ICsgdXAsIHNoaWZ0ICsgZG93blxuICAgKiAgIE1vdmUgY3Vyc29yIGJ5IHdvcmQ6ICAgICAgICAgICAgYWx0ICsgbGVmdCwgYWx0ICsgcmlnaHRcbiAgICogICBTZWxlY3Qgd29yZHM6ICAgICAgICAgICAgICAgICAgIHNoaWZ0ICsgYWx0ICsgbGVmdCwgc2hpZnQgKyBhbHQgKyByaWdodFxuICAgKiAgIE1vdmUgY3Vyc29yIHRvIGxpbmUgc3RhcnQvZW5kOiAgY21kICsgbGVmdCwgY21kICsgcmlnaHQgb3IgaG9tZSwgZW5kXG4gICAqICAgU2VsZWN0IHRpbGwgc3RhcnQvZW5kIG9mIGxpbmU6ICBjbWQgKyBzaGlmdCArIGxlZnQsIGNtZCArIHNoaWZ0ICsgcmlnaHQgb3Igc2hpZnQgKyBob21lLCBzaGlmdCArIGVuZFxuICAgKiAgIEp1bXAgdG8gc3RhcnQvZW5kIG9mIHRleHQ6ICAgICAgY21kICsgdXAsIGNtZCArIGRvd25cbiAgICogICBTZWxlY3QgdGlsbCBzdGFydC9lbmQgb2YgdGV4dDogIGNtZCArIHNoaWZ0ICsgdXAsIGNtZCArIHNoaWZ0ICsgZG93biBvciBzaGlmdCArIHBnVXAsIHNoaWZ0ICsgcGdEb3duXG4gICAqICAgRGVsZXRlIGNoYXJhY3RlcjogICAgICAgICAgICAgICBiYWNrc3BhY2VcbiAgICogICBEZWxldGUgd29yZDogICAgICAgICAgICAgICAgICAgIGFsdCArIGJhY2tzcGFjZVxuICAgKiAgIERlbGV0ZSBsaW5lOiAgICAgICAgICAgICAgICAgICAgY21kICsgYmFja3NwYWNlXG4gICAqICAgRm9yd2FyZCBkZWxldGU6ICAgICAgICAgICAgICAgICBkZWxldGVcbiAgICogICBDb3B5IHRleHQ6ICAgICAgICAgICAgICAgICAgICAgIGN0cmwvY21kICsgY1xuICAgKiAgIFBhc3RlIHRleHQ6ICAgICAgICAgICAgICAgICAgICAgY3RybC9jbWQgKyB2XG4gICAqICAgQ3V0IHRleHQ6ICAgICAgICAgICAgICAgICAgICAgICBjdHJsL2NtZCArIHhcbiAgICogICBTZWxlY3QgZW50aXJlIHRleHQ6ICAgICAgICAgICAgIGN0cmwvY21kICsgYVxuICAgKiAgIFF1aXQgZWRpdGluZyAgICAgICAgICAgICAgICAgICAgdGFiIG9yIGVzY1xuICAgKiA8L3ByZT5cbiAgICpcbiAgICogPHA+U3VwcG9ydGVkIG1vdXNlL3RvdWNoIGNvbWJpbmF0aW9uPC9wPlxuICAgKiA8cHJlPlxuICAgKiAgIFBvc2l0aW9uIGN1cnNvcjogICAgICAgICAgICAgICAgY2xpY2svdG91Y2hcbiAgICogICBDcmVhdGUgc2VsZWN0aW9uOiAgICAgICAgICAgICAgIGNsaWNrL3RvdWNoICYgZHJhZ1xuICAgKiAgIENyZWF0ZSBzZWxlY3Rpb246ICAgICAgICAgICAgICAgY2xpY2sgJiBzaGlmdCArIGNsaWNrXG4gICAqICAgU2VsZWN0IHdvcmQ6ICAgICAgICAgICAgICAgICAgICBkb3VibGUgY2xpY2tcbiAgICogICBTZWxlY3QgbGluZTogICAgICAgICAgICAgICAgICAgIHRyaXBsZSBjbGlja1xuICAgKiA8L3ByZT5cbiAgICovXG4gIGZhYnJpYy5JVGV4dCA9IGZhYnJpYy51dGlsLmNyZWF0ZUNsYXNzKGZhYnJpYy5UZXh0LCBmYWJyaWMuT2JzZXJ2YWJsZSwgLyoqIEBsZW5kcyBmYWJyaWMuSVRleHQucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgYW4gb2JqZWN0XG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICB0eXBlOiAnaS10ZXh0JyxcblxuICAgIC8qKlxuICAgICAqIEluZGV4IHdoZXJlIHRleHQgc2VsZWN0aW9uIHN0YXJ0cyAob3Igd2hlcmUgY3Vyc29yIGlzIHdoZW4gdGhlcmUgaXMgbm8gc2VsZWN0aW9uKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uU3RhcnQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBJbmRleCB3aGVyZSB0ZXh0IHNlbGVjdGlvbiBlbmRzXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25FbmQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBvZiB0ZXh0IHNlbGVjdGlvblxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgc2VsZWN0aW9uQ29sb3I6ICdyZ2JhKDE3LDExOSwyNTUsMC4zKScsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0ZXh0IGlzIGluIGVkaXRpbmcgbW9kZVxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGlzRWRpdGluZzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBhIHRleHQgY2FuIGJlIGVkaXRlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGVkaXRhYmxlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQm9yZGVyIGNvbG9yIG9mIHRleHQgb2JqZWN0IHdoaWxlIGl0J3MgaW4gZWRpdGluZyBtb2RlXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBlZGl0aW5nQm9yZGVyQ29sb3I6ICdyZ2JhKDEwMiwxNTMsMjU1LDAuMjUpJyxcblxuICAgIC8qKlxuICAgICAqIFdpZHRoIG9mIGN1cnNvciAoaW4gcHgpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjdXJzb3JXaWR0aDogMixcblxuICAgIC8qKlxuICAgICAqIENvbG9yIG9mIHRleHQgY3Vyc29yIGNvbG9yIGluIGVkaXRpbmcgbW9kZS5cbiAgICAgKiBpZiBub3Qgc2V0IChkZWZhdWx0KSB3aWxsIHRha2UgY29sb3IgZnJvbSB0aGUgdGV4dC5cbiAgICAgKiBpZiBzZXQgdG8gYSBjb2xvciB2YWx1ZSB0aGF0IGZhYnJpYyBjYW4gdW5kZXJzdGFuZCwgaXQgd2lsbFxuICAgICAqIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgY29sb3Igb2YgdGhlIHRleHQgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjdXJzb3JDb2xvcjogJycsXG5cbiAgICAvKipcbiAgICAgKiBEZWxheSBiZXR3ZWVuIGN1cnNvciBibGluayAoaW4gbXMpXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBjdXJzb3JEZWxheTogMTAwMCxcblxuICAgIC8qKlxuICAgICAqIER1cmF0aW9uIG9mIGN1cnNvciBmYWRlaW4gKGluIG1zKVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgY3Vyc29yRHVyYXRpb246IDYwMCxcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIGludGVybmFsIHRleHQgY2hhciB3aWR0aHMgY2FuIGJlIGNhY2hlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqL1xuICAgIGNhY2hpbmc6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBET00gY29udGFpbmVyIHRvIGFwcGVuZCB0aGUgaGlkZGVuVGV4dGFyZWEuXG4gICAgICogQW4gYWx0ZXJuYXRpdmUgdG8gYXR0YWNoaW5nIHRvIHRoZSBkb2N1bWVudC5ib2R5LlxuICAgICAqIFVzZWZ1bCB0byByZWR1Y2UgbGFnZ2lzaCByZWRyYXcgb2YgdGhlIGZ1bGwgZG9jdW1lbnQuYm9keSB0cmVlIGFuZFxuICAgICAqIGFsc28gd2l0aCBtb2RhbHMgZXZlbnQgY2FwdHVyaW5nIHRoYXQgd29uJ3QgbGV0IHRoZSB0ZXh0YXJlYSB0YWtlIGZvY3VzLlxuICAgICAqIEB0eXBlIEhUTUxFbGVtZW50XG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBoaWRkZW5UZXh0YXJlYUNvbnRhaW5lcjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlU3BhY2U6IC9cXHN8XFxuLyxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2N1cnJlbnRDdXJzb3JPcGFjaXR5OiAwLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2VsZWN0aW9uRGlyZWN0aW9uOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWJvcnRDdXJzb3JBbmltYXRpb246IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfX3dpZHRoT2ZTcGFjZTogW10sXG5cbiAgICAvKipcbiAgICAgKiBIZWxwcyBkZXRlcm1pbmluZyB3aGVuIHRoZSB0ZXh0IGlzIGluIGNvbXBvc2l0aW9uLCBzbyB0aGF0IHRoZSBjdXJzb3JcbiAgICAgKiByZW5kZXJpbmcgaXMgYWx0ZXJlZC5cbiAgICAgKi9cbiAgICBpbkNvbXBvc2l0aW9uTW9kZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRleHQgc3RyaW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JVGV4dH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKHRleHQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuY2FsbFN1cGVyKCdpbml0aWFsaXplJywgdGV4dCwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmluaXRCZWhhdmlvcigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHNlbGVjdGlvbiBzdGFydCAobGVmdCBib3VuZGFyeSBvZiBhIHNlbGVjdGlvbilcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggdG8gc2V0IHNlbGVjdGlvbiBzdGFydCB0b1xuICAgICAqL1xuICAgIHNldFNlbGVjdGlvblN0YXJ0OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgaW5kZXggPSBNYXRoLm1heChpbmRleCwgMCk7XG4gICAgICB0aGlzLl91cGRhdGVBbmRGaXJlKCdzZWxlY3Rpb25TdGFydCcsIGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBzZWxlY3Rpb24gZW5kIChyaWdodCBib3VuZGFyeSBvZiBhIHNlbGVjdGlvbilcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggdG8gc2V0IHNlbGVjdGlvbiBlbmQgdG9cbiAgICAgKi9cbiAgICBzZXRTZWxlY3Rpb25FbmQ6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBpbmRleCA9IE1hdGgubWluKGluZGV4LCB0aGlzLnRleHQubGVuZ3RoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZUFuZEZpcmUoJ3NlbGVjdGlvbkVuZCcsIGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgJ3NlbGVjdGlvblN0YXJ0JyBvciAnc2VsZWN0aW9uRW5kJ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBuZXcgcG9zaXRpb24gb2YgcHJvcGVydHlcbiAgICAgKi9cbiAgICBfdXBkYXRlQW5kRmlyZTogZnVuY3Rpb24ocHJvcGVydHksIGluZGV4KSB7XG4gICAgICBpZiAodGhpc1twcm9wZXJ0eV0gIT09IGluZGV4KSB7XG4gICAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gaW5kZXg7XG4gICAgICB9XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyB0aGUgZXZlbiBvZiBzZWxlY3Rpb24gY2hhbmdlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZmlyZSgnc2VsZWN0aW9uOmNoYW5nZWQnKTtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmZpcmUoJ3RleHQ6c2VsZWN0aW9uOmNoYW5nZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0ZXh0IGRpbWVuc2lvbnMuIFJlbmRlciBhbGwgdGV4dCBvbiBnaXZlbiBjb250ZXh0XG4gICAgICogb3Igb24gYSBvZmZzY3JlZW4gY2FudmFzIHRvIGdldCB0aGUgdGV4dCB3aWR0aCB3aXRoIG1lYXN1cmVUZXh0LlxuICAgICAqIFVwZGF0ZXMgdGhpcy53aWR0aCBhbmQgdGhpcy5oZWlnaHQgd2l0aCB0aGUgcHJvcGVyIHZhbHVlcy5cbiAgICAgKiBEb2VzIG5vdCByZXR1cm4gZGltZW5zaW9ucy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGluaXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaXNFZGl0aW5nICYmIHRoaXMuaW5pdERlbGF5ZWRDdXJzb3IoKTtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0VG9wKCk7XG4gICAgICB0aGlzLmNhbGxTdXBlcignaW5pdERpbWVuc2lvbnMnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHQgdG8gcmVuZGVyIG9uXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0VG9wKCk7XG4gICAgICB0aGlzLmNhbGxTdXBlcigncmVuZGVyJywgY3R4KTtcbiAgICAgIC8vIGNsZWFyIHRoZSBjdXJzb3JPZmZzZXRDYWNoZSwgc28gd2UgZW5zdXJlIHRvIGNhbGN1bGF0ZSBvbmNlIHBlciByZW5kZXJDdXJzb3JcbiAgICAgIC8vIHRoZSBjb3JyZWN0IHBvc2l0aW9uIGJ1dCBub3QgYXQgZXZlcnkgY3Vyc29yIGFuaW1hdGlvbi5cbiAgICAgIHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGUgPSB7IH07XG4gICAgICB0aGlzLnJlbmRlckN1cnNvck9yU2VsZWN0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBDb250ZXh0IHRvIHJlbmRlciBvblxuICAgICAqL1xuICAgIF9yZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgdGhpcy5jYWxsU3VwZXIoJ19yZW5kZXInLCBjdHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIGFuZCBjbGVhbiB0aGUgY29udGV4dFRvcFxuICAgICAqL1xuICAgIGNsZWFyQ29udGV4dFRvcDogZnVuY3Rpb24oc2tpcFJlc3RvcmUpIHtcbiAgICAgIGlmICghdGhpcy5pc0VkaXRpbmcgfHwgIXRoaXMuY2FudmFzIHx8ICF0aGlzLmNhbnZhcy5jb250ZXh0VG9wKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5jb250ZXh0VG9wLCB2ID0gdGhpcy5jYW52YXMudmlld3BvcnRUcmFuc2Zvcm07XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zZm9ybSh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtKGN0eCk7XG4gICAgICB0aGlzLl9jbGVhclRleHRBcmVhKGN0eCk7XG4gICAgICBza2lwUmVzdG9yZSB8fCBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBjdXJzb3Igb3Igc2VsZWN0aW9uIChkZXBlbmRpbmcgb24gd2hhdCBleGlzdHMpXG4gICAgICogaXQgZG9lcyBvbiB0aGUgY29udGV4dFRvcC4gSWYgY29udGV4dFRvcCBpcyBub3QgYXZhaWxhYmxlLCBkbyBub3RoaW5nLlxuICAgICAqL1xuICAgIHJlbmRlckN1cnNvck9yU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5pc0VkaXRpbmcgfHwgIXRoaXMuY2FudmFzIHx8ICF0aGlzLmNhbnZhcy5jb250ZXh0VG9wKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBib3VuZGFyaWVzID0gdGhpcy5fZ2V0Q3Vyc29yQm91bmRhcmllcygpLFxuICAgICAgICAgIGN0eCA9IHRoaXMuY2FudmFzLmNvbnRleHRUb3A7XG4gICAgICB0aGlzLmNsZWFyQ29udGV4dFRvcCh0cnVlKTtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgICB0aGlzLnJlbmRlckN1cnNvcihib3VuZGFyaWVzLCBjdHgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMucmVuZGVyU2VsZWN0aW9uKGJvdW5kYXJpZXMsIGN0eCk7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICBfY2xlYXJUZXh0QXJlYTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICAvLyB3ZSBhZGQgNCBwaXhlbCwgdG8gYmUgc3VyZSB0byBkbyBub3QgbGVhdmUgYW55IHBpeGVsIG91dFxuICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCArIDQsIGhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgNDtcbiAgICAgIGN0eC5jbGVhclJlY3QoLXdpZHRoIC8gMiwgLWhlaWdodCAvIDIsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGN1cnNvciBib3VuZGFyaWVzIChsZWZ0LCB0b3AsIGxlZnRPZmZzZXQsIHRvcE9mZnNldClcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNoYXJzIEFycmF5IG9mIGNoYXJhY3RlcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZU9mQm91bmRhcmllc1xuICAgICAqL1xuICAgIF9nZXRDdXJzb3JCb3VuZGFyaWVzOiBmdW5jdGlvbihwb3NpdGlvbikge1xuXG4gICAgICAvLyBsZWZ0L3RvcCBhcmUgbGVmdC90b3Agb2YgZW50aXJlIHRleHQgYm94XG4gICAgICAvLyBsZWZ0T2Zmc2V0L3RvcE9mZnNldCBhcmUgb2Zmc2V0IGZyb20gdGhhdCBsZWZ0L3RvcCBwb2ludCBvZiBhIHRleHQgYm94XG5cbiAgICAgIGlmICh0eXBlb2YgcG9zaXRpb24gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHBvc2l0aW9uID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlZnQgPSB0aGlzLl9nZXRMZWZ0T2Zmc2V0KCksXG4gICAgICAgICAgdG9wID0gdGhpcy5fZ2V0VG9wT2Zmc2V0KCksXG4gICAgICAgICAgb2Zmc2V0cyA9IHRoaXMuX2dldEN1cnNvckJvdW5kYXJpZXNPZmZzZXRzKHBvc2l0aW9uKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIHRvcDogdG9wLFxuICAgICAgICBsZWZ0T2Zmc2V0OiBvZmZzZXRzLmxlZnQsXG4gICAgICAgIHRvcE9mZnNldDogb2Zmc2V0cy50b3BcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldEN1cnNvckJvdW5kYXJpZXNPZmZzZXRzOiBmdW5jdGlvbihwb3NpdGlvbikge1xuICAgICAgaWYgKHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGUgJiYgJ3RvcCcgaW4gdGhpcy5jdXJzb3JPZmZzZXRDYWNoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJzb3JPZmZzZXRDYWNoZTtcbiAgICAgIH1cbiAgICAgIHZhciBsaW5lTGVmdE9mZnNldCxcbiAgICAgICAgICBsaW5lSW5kZXgsXG4gICAgICAgICAgY2hhckluZGV4LFxuICAgICAgICAgIHRvcE9mZnNldCA9IDAsXG4gICAgICAgICAgbGVmdE9mZnNldCA9IDAsXG4gICAgICAgICAgYm91bmRhcmllcyxcbiAgICAgICAgICBjdXJzb3JQb3NpdGlvbiA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihwb3NpdGlvbik7XG4gICAgICBjaGFySW5kZXggPSBjdXJzb3JQb3NpdGlvbi5jaGFySW5kZXg7XG4gICAgICBsaW5lSW5kZXggPSBjdXJzb3JQb3NpdGlvbi5saW5lSW5kZXg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVJbmRleDsgaSsrKSB7XG4gICAgICAgIHRvcE9mZnNldCArPSB0aGlzLmdldEhlaWdodE9mTGluZShpKTtcbiAgICAgIH1cbiAgICAgIGxpbmVMZWZ0T2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQobGluZUluZGV4KTtcbiAgICAgIHZhciBib3VuZCA9IHRoaXMuX19jaGFyQm91bmRzW2xpbmVJbmRleF1bY2hhckluZGV4XTtcbiAgICAgIGJvdW5kICYmIChsZWZ0T2Zmc2V0ID0gYm91bmQubGVmdCk7XG4gICAgICBpZiAodGhpcy5jaGFyU3BhY2luZyAhPT0gMCAmJiBjaGFySW5kZXggPT09IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLmxlbmd0aCkge1xuICAgICAgICBsZWZ0T2Zmc2V0IC09IHRoaXMuX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpO1xuICAgICAgfVxuICAgICAgYm91bmRhcmllcyA9IHtcbiAgICAgICAgdG9wOiB0b3BPZmZzZXQsXG4gICAgICAgIGxlZnQ6IGxpbmVMZWZ0T2Zmc2V0ICsgKGxlZnRPZmZzZXQgPiAwID8gbGVmdE9mZnNldCA6IDApLFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICAgICAgYm91bmRhcmllcy5sZWZ0ICo9IC0xO1xuICAgICAgfVxuICAgICAgdGhpcy5jdXJzb3JPZmZzZXRDYWNoZSA9IGJvdW5kYXJpZXM7XG4gICAgICByZXR1cm4gdGhpcy5jdXJzb3JPZmZzZXRDYWNoZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBjdXJzb3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYm91bmRhcmllc1xuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggdHJhbnNmb3JtZWQgY29udGV4dCB0byBkcmF3IG9uXG4gICAgICovXG4gICAgcmVuZGVyQ3Vyc29yOiBmdW5jdGlvbihib3VuZGFyaWVzLCBjdHgpIHtcbiAgICAgIHZhciBjdXJzb3JMb2NhdGlvbiA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbigpLFxuICAgICAgICAgIGxpbmVJbmRleCA9IGN1cnNvckxvY2F0aW9uLmxpbmVJbmRleCxcbiAgICAgICAgICBjaGFySW5kZXggPSBjdXJzb3JMb2NhdGlvbi5jaGFySW5kZXggPiAwID8gY3Vyc29yTG9jYXRpb24uY2hhckluZGV4IC0gMSA6IDAsXG4gICAgICAgICAgY2hhckhlaWdodCA9IHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQobGluZUluZGV4LCBjaGFySW5kZXgsICdmb250U2l6ZScpLFxuICAgICAgICAgIG11bHRpcGxpZXIgPSB0aGlzLnNjYWxlWCAqIHRoaXMuY2FudmFzLmdldFpvb20oKSxcbiAgICAgICAgICBjdXJzb3JXaWR0aCA9IHRoaXMuY3Vyc29yV2lkdGggLyBtdWx0aXBsaWVyLFxuICAgICAgICAgIHRvcE9mZnNldCA9IGJvdW5kYXJpZXMudG9wT2Zmc2V0LFxuICAgICAgICAgIGR5ID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChsaW5lSW5kZXgsIGNoYXJJbmRleCwgJ2RlbHRhWScpO1xuICAgICAgdG9wT2Zmc2V0ICs9ICgxIC0gdGhpcy5fZm9udFNpemVGcmFjdGlvbikgKiB0aGlzLmdldEhlaWdodE9mTGluZShsaW5lSW5kZXgpIC8gdGhpcy5saW5lSGVpZ2h0XG4gICAgICAgIC0gY2hhckhlaWdodCAqICgxIC0gdGhpcy5fZm9udFNpemVGcmFjdGlvbik7XG5cbiAgICAgIGlmICh0aGlzLmluQ29tcG9zaXRpb25Nb2RlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyU2VsZWN0aW9uKGJvdW5kYXJpZXMsIGN0eCk7XG4gICAgICB9XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5jdXJzb3JDb2xvciB8fCB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGxpbmVJbmRleCwgY2hhckluZGV4LCAnZmlsbCcpO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5fX2lzTW91c2Vkb3duID8gMSA6IHRoaXMuX2N1cnJlbnRDdXJzb3JPcGFjaXR5O1xuICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICBib3VuZGFyaWVzLmxlZnQgKyBib3VuZGFyaWVzLmxlZnRPZmZzZXQgLSBjdXJzb3JXaWR0aCAvIDIsXG4gICAgICAgIHRvcE9mZnNldCArIGJvdW5kYXJpZXMudG9wICsgZHksXG4gICAgICAgIGN1cnNvcldpZHRoLFxuICAgICAgICBjaGFySGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0ZXh0IHNlbGVjdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBib3VuZGFyaWVzIE9iamVjdCB3aXRoIGxlZnQvdG9wL2xlZnRPZmZzZXQvdG9wT2Zmc2V0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCB0cmFuc2Zvcm1lZCBjb250ZXh0IHRvIGRyYXcgb25cbiAgICAgKi9cbiAgICByZW5kZXJTZWxlY3Rpb246IGZ1bmN0aW9uKGJvdW5kYXJpZXMsIGN0eCkge1xuXG4gICAgICB2YXIgc2VsZWN0aW9uU3RhcnQgPSB0aGlzLmluQ29tcG9zaXRpb25Nb2RlID8gdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25TdGFydCA6IHRoaXMuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgc2VsZWN0aW9uRW5kID0gdGhpcy5pbkNvbXBvc2l0aW9uTW9kZSA/IHRoaXMuaGlkZGVuVGV4dGFyZWEuc2VsZWN0aW9uRW5kIDogdGhpcy5zZWxlY3Rpb25FbmQsXG4gICAgICAgICAgaXNKdXN0aWZ5ID0gdGhpcy50ZXh0QWxpZ24uaW5kZXhPZignanVzdGlmeScpICE9PSAtMSxcbiAgICAgICAgICBzdGFydCA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihzZWxlY3Rpb25TdGFydCksXG4gICAgICAgICAgZW5kID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKHNlbGVjdGlvbkVuZCksXG4gICAgICAgICAgc3RhcnRMaW5lID0gc3RhcnQubGluZUluZGV4LFxuICAgICAgICAgIGVuZExpbmUgPSBlbmQubGluZUluZGV4LFxuICAgICAgICAgIHN0YXJ0Q2hhciA9IHN0YXJ0LmNoYXJJbmRleCA8IDAgPyAwIDogc3RhcnQuY2hhckluZGV4LFxuICAgICAgICAgIGVuZENoYXIgPSBlbmQuY2hhckluZGV4IDwgMCA/IDAgOiBlbmQuY2hhckluZGV4O1xuXG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRMaW5lOyBpIDw9IGVuZExpbmU7IGkrKykge1xuICAgICAgICB2YXIgbGluZU9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGkpIHx8IDAsXG4gICAgICAgICAgICBsaW5lSGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaSksXG4gICAgICAgICAgICByZWFsTGluZUhlaWdodCA9IDAsIGJveFN0YXJ0ID0gMCwgYm94RW5kID0gMDtcblxuICAgICAgICBpZiAoaSA9PT0gc3RhcnRMaW5lKSB7XG4gICAgICAgICAgYm94U3RhcnQgPSB0aGlzLl9fY2hhckJvdW5kc1tzdGFydExpbmVdW3N0YXJ0Q2hhcl0ubGVmdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+PSBzdGFydExpbmUgJiYgaSA8IGVuZExpbmUpIHtcbiAgICAgICAgICBib3hFbmQgPSBpc0p1c3RpZnkgJiYgIXRoaXMuaXNFbmRPZldyYXBwaW5nKGkpID8gdGhpcy53aWR0aCA6IHRoaXMuZ2V0TGluZVdpZHRoKGkpIHx8IDU7IC8vIFdURiBpcyB0aGlzIDU/XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaSA9PT0gZW5kTGluZSkge1xuICAgICAgICAgIGlmIChlbmRDaGFyID09PSAwKSB7XG4gICAgICAgICAgICBib3hFbmQgPSB0aGlzLl9fY2hhckJvdW5kc1tlbmRMaW5lXVtlbmRDaGFyXS5sZWZ0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjaGFyU3BhY2luZyA9IHRoaXMuX2dldFdpZHRoT2ZDaGFyU3BhY2luZygpO1xuICAgICAgICAgICAgYm94RW5kID0gdGhpcy5fX2NoYXJCb3VuZHNbZW5kTGluZV1bZW5kQ2hhciAtIDFdLmxlZnRcbiAgICAgICAgICAgICAgKyB0aGlzLl9fY2hhckJvdW5kc1tlbmRMaW5lXVtlbmRDaGFyIC0gMV0ud2lkdGggLSBjaGFyU3BhY2luZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVhbExpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy5saW5lSGVpZ2h0IDwgMSB8fCAoaSA9PT0gZW5kTGluZSAmJiB0aGlzLmxpbmVIZWlnaHQgPiAxKSkge1xuICAgICAgICAgIGxpbmVIZWlnaHQgLz0gdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBkcmF3U3RhcnQgPSBib3VuZGFyaWVzLmxlZnQgKyBsaW5lT2Zmc2V0ICsgYm94U3RhcnQsXG4gICAgICAgICAgICBkcmF3V2lkdGggPSBib3hFbmQgLSBib3hTdGFydCxcbiAgICAgICAgICAgIGRyYXdIZWlnaHQgPSBsaW5lSGVpZ2h0LCBleHRyYVRvcCA9IDA7XG4gICAgICAgIGlmICh0aGlzLmluQ29tcG9zaXRpb25Nb2RlKSB7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuY29tcG9zaXRpb25Db2xvciB8fCAnYmxhY2snO1xuICAgICAgICAgIGRyYXdIZWlnaHQgPSAxO1xuICAgICAgICAgIGV4dHJhVG9wID0gbGluZUhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5zZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgICAgICAgZHJhd1N0YXJ0ID0gdGhpcy53aWR0aCAtIGRyYXdTdGFydCAtIGRyYXdXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgZHJhd1N0YXJ0LFxuICAgICAgICAgIGJvdW5kYXJpZXMudG9wICsgYm91bmRhcmllcy50b3BPZmZzZXQgKyBleHRyYVRvcCxcbiAgICAgICAgICBkcmF3V2lkdGgsXG4gICAgICAgICAgZHJhd0hlaWdodCk7XG4gICAgICAgIGJvdW5kYXJpZXMudG9wT2Zmc2V0ICs9IHJlYWxMaW5lSGVpZ2h0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIaWdoIGxldmVsIGZ1bmN0aW9uIHRvIGtub3cgdGhlIGhlaWdodCBvZiB0aGUgY3Vyc29yLlxuICAgICAqIHRoZSBjdXJyZW50Q2hhciBpcyB0aGUgb25lIHRoYXQgcHJlY2VkZXMgdGhlIGN1cnNvclxuICAgICAqIFJldHVybnMgZm9udFNpemUgb2YgY2hhciBhdCB0aGUgY3VycmVudCBjdXJzb3JcbiAgICAgKiBVbnVzZWQgZnJvbSB0aGUgbGlicmFyeSwgaXMgZm9yIHRoZSBlbmQgdXNlclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gQ2hhcmFjdGVyIGZvbnQgc2l6ZVxuICAgICAqL1xuICAgIGdldEN1cnJlbnRDaGFyRm9udFNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNwID0gdGhpcy5fZ2V0Q3VycmVudENoYXJJbmRleCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVPZlByb3BlcnR5QXQoY3AubCwgY3AuYywgJ2ZvbnRTaXplJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhpZ2ggbGV2ZWwgZnVuY3Rpb24gdG8ga25vdyB0aGUgY29sb3Igb2YgdGhlIGN1cnNvci5cbiAgICAgKiB0aGUgY3VycmVudENoYXIgaXMgdGhlIG9uZSB0aGF0IHByZWNlZGVzIHRoZSBjdXJzb3JcbiAgICAgKiBSZXR1cm5zIGNvbG9yIChmaWxsKSBvZiBjaGFyIGF0IHRoZSBjdXJyZW50IGN1cnNvclxuICAgICAqIGlmIHRoZSB0ZXh0IG9iamVjdCBoYXMgYSBwYXR0ZXJuIG9yIGdyYWRpZW50IGZvciBmaWxsZXIsIGl0IHdpbGwgcmV0dXJuIHRoYXQuXG4gICAgICogVW51c2VkIGJ5IHRoZSBsaWJyYXJ5LCBpcyBmb3IgdGhlIGVuZCB1c2VyXG4gICAgICogQHJldHVybiB7U3RyaW5nIHwgZmFicmljLkdyYWRpZW50IHwgZmFicmljLlBhdHRlcm59IENoYXJhY3RlciBjb2xvciAoZmlsbClcbiAgICAgKi9cbiAgICBnZXRDdXJyZW50Q2hhckNvbG9yOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjcCA9IHRoaXMuX2dldEN1cnJlbnRDaGFySW5kZXgoKTtcbiAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGNwLmwsIGNwLmMsICdmaWxsJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnNvciBwb3NpdGlvbiBmb3IgdGhlIGdldEN1cnJlbnQuLiBmdW5jdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRDdXJyZW50Q2hhckluZGV4OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdXJzb3JQb3NpdGlvbiA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbih0aGlzLnNlbGVjdGlvblN0YXJ0LCB0cnVlKSxcbiAgICAgICAgICBjaGFySW5kZXggPSBjdXJzb3JQb3NpdGlvbi5jaGFySW5kZXggPiAwID8gY3Vyc29yUG9zaXRpb24uY2hhckluZGV4IC0gMSA6IDA7XG4gICAgICByZXR1cm4geyBsOiBjdXJzb3JQb3NpdGlvbi5saW5lSW5kZXgsIGM6IGNoYXJJbmRleCB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFicmljLklUZXh0IGluc3RhbmNlIGZyb20gYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIGZhYnJpYy5JVGV4dFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGludm9rZWQgd2l0aCBuZXcgaW5zdGFuY2UgYXMgYXJndW1lbnRcbiAgICovXG4gIGZhYnJpYy5JVGV4dC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHZhciBzdHlsZXMgPSBmYWJyaWMudXRpbC5zdHlsZXNGcm9tQXJyYXkob2JqZWN0LnN0eWxlcywgb2JqZWN0LnRleHQpO1xuICAgIC8vY29weSBvYmplY3QgdG8gcHJldmVudCBtdXRhdGlvblxuICAgIHZhciBvYmpDb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqZWN0LCB7IHN0eWxlczogc3R5bGVzIH0pO1xuICAgIGRlbGV0ZSBvYmpDb3B5LnBhdGg7XG4gICAgcGFyc2VEZWNvcmF0aW9uKG9iakNvcHkpO1xuICAgIGlmIChvYmpDb3B5LnN0eWxlcykge1xuICAgICAgZm9yICh2YXIgaSBpbiBvYmpDb3B5LnN0eWxlcykge1xuICAgICAgICBmb3IgKHZhciBqIGluIG9iakNvcHkuc3R5bGVzW2ldKSB7XG4gICAgICAgICAgcGFyc2VEZWNvcmF0aW9uKG9iakNvcHkuc3R5bGVzW2ldW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdJVGV4dCcsIG9iakNvcHksIGZ1bmN0aW9uKHRleHRJbnN0YW5jZSkge1xuICAgICAgaWYgKG9iamVjdC5wYXRoKSB7XG4gICAgICAgIGZhYnJpYy5PYmplY3QuX2Zyb21PYmplY3QoJ1BhdGgnLCBvYmplY3QucGF0aCwgZnVuY3Rpb24ocGF0aEluc3RhbmNlKSB7XG4gICAgICAgICAgdGV4dEluc3RhbmNlLnNldCgncGF0aCcsIHBhdGhJbnN0YW5jZSk7XG4gICAgICAgICAgY2FsbGJhY2sodGV4dEluc3RhbmNlKTtcbiAgICAgICAgfSwgJ3BhdGgnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjYWxsYmFjayh0ZXh0SW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH0sICd0ZXh0Jyk7XG4gIH07XG59KSgpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgY2xvbmUgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmU7XG5cbiAgZmFicmljLnV0aWwub2JqZWN0LmV4dGVuZChmYWJyaWMuSVRleHQucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5JVGV4dC5wcm90b3R5cGUgKi8ge1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYWxsIHRoZSBpbnRlcmFjdGl2ZSBiZWhhdmlvciBvZiBJVGV4dFxuICAgICAqL1xuICAgIGluaXRCZWhhdmlvcjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmluaXRBZGRlZEhhbmRsZXIoKTtcbiAgICAgIHRoaXMuaW5pdFJlbW92ZWRIYW5kbGVyKCk7XG4gICAgICB0aGlzLmluaXRDdXJzb3JTZWxlY3Rpb25IYW5kbGVycygpO1xuICAgICAgdGhpcy5pbml0RG91YmxlQ2xpY2tTaW11bGF0aW9uKCk7XG4gICAgICB0aGlzLm1vdXNlTW92ZUhhbmRsZXIgPSB0aGlzLm1vdXNlTW92ZUhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICB9LFxuXG4gICAgb25EZXNlbGVjdDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlzRWRpdGluZyAmJiB0aGlzLmV4aXRFZGl0aW5nKCk7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIFwiYWRkZWRcIiBldmVudCBoYW5kbGVyXG4gICAgICovXG4gICAgaW5pdEFkZGVkSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5vbignYWRkZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IF90aGlzLmNhbnZhcztcbiAgICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAgIGlmICghY2FudmFzLl9oYXNJVGV4dEhhbmRsZXJzKSB7XG4gICAgICAgICAgICBjYW52YXMuX2hhc0lUZXh0SGFuZGxlcnMgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMuX2luaXRDYW52YXNIYW5kbGVycyhjYW52YXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYW52YXMuX2lUZXh0SW5zdGFuY2VzID0gY2FudmFzLl9pVGV4dEluc3RhbmNlcyB8fCBbXTtcbiAgICAgICAgICBjYW52YXMuX2lUZXh0SW5zdGFuY2VzLnB1c2goX3RoaXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgaW5pdFJlbW92ZWRIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzLm9uKCdyZW1vdmVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSBfdGhpcy5jYW52YXM7XG4gICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICBjYW52YXMuX2lUZXh0SW5zdGFuY2VzID0gY2FudmFzLl9pVGV4dEluc3RhbmNlcyB8fCBbXTtcbiAgICAgICAgICBmYWJyaWMudXRpbC5yZW1vdmVGcm9tQXJyYXkoY2FudmFzLl9pVGV4dEluc3RhbmNlcywgX3RoaXMpO1xuICAgICAgICAgIGlmIChjYW52YXMuX2lUZXh0SW5zdGFuY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY2FudmFzLl9oYXNJVGV4dEhhbmRsZXJzID0gZmFsc2U7XG4gICAgICAgICAgICBfdGhpcy5fcmVtb3ZlQ2FudmFzSGFuZGxlcnMoY2FudmFzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZWdpc3RlciBjYW52YXMgZXZlbnQgdG8gbWFuYWdlIGV4aXRpbmcgb24gb3RoZXIgaW5zdGFuY2VzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdENhbnZhc0hhbmRsZXJzOiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgIGNhbnZhcy5fbW91c2VVcElUZXh0SGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoY2FudmFzLl9pVGV4dEluc3RhbmNlcykge1xuICAgICAgICAgIGNhbnZhcy5faVRleHRJbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIG9iai5fX2lzTW91c2Vkb3duID0gZmFsc2U7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjYW52YXMub24oJ21vdXNlOnVwJywgY2FudmFzLl9tb3VzZVVwSVRleHRIYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIGNhbnZhcyBldmVudCB0byBtYW5hZ2UgZXhpdGluZyBvbiBvdGhlciBpbnN0YW5jZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW1vdmVDYW52YXNIYW5kbGVyczogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICBjYW52YXMub2ZmKCdtb3VzZTp1cCcsIGNhbnZhcy5fbW91c2VVcElUZXh0SGFuZGxlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3RpY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY3VycmVudFRpY2tTdGF0ZSA9IHRoaXMuX2FuaW1hdGVDdXJzb3IodGhpcywgMSwgdGhpcy5jdXJzb3JEdXJhdGlvbiwgJ19vblRpY2tDb21wbGV0ZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hbmltYXRlQ3Vyc29yOiBmdW5jdGlvbihvYmosIHRhcmdldE9wYWNpdHksIGR1cmF0aW9uLCBjb21wbGV0ZU1ldGhvZCkge1xuXG4gICAgICB2YXIgdGlja1N0YXRlO1xuXG4gICAgICB0aWNrU3RhdGUgPSB7XG4gICAgICAgIGlzQWJvcnRlZDogZmFsc2UsXG4gICAgICAgIGFib3J0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmlzQWJvcnRlZCA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICBvYmouYW5pbWF0ZSgnX2N1cnJlbnRDdXJzb3JPcGFjaXR5JywgdGFyZ2V0T3BhY2l0eSwge1xuICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICghdGlja1N0YXRlLmlzQWJvcnRlZCkge1xuICAgICAgICAgICAgb2JqW2NvbXBsZXRlTWV0aG9kXSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGFuaW1hdGUgYSBzZWxlY3Rpb24sIG9ubHkgY3Vyc29yXG4gICAgICAgICAgaWYgKG9iai5jYW52YXMgJiYgb2JqLnNlbGVjdGlvblN0YXJ0ID09PSBvYmouc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICBvYmoucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFib3J0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGlja1N0YXRlLmlzQWJvcnRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGlja1N0YXRlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vblRpY2tDb21wbGV0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl9jdXJzb3JUaW1lb3V0MSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fY3Vyc29yVGltZW91dDEpO1xuICAgICAgfVxuICAgICAgdGhpcy5fY3Vyc29yVGltZW91dDEgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBfdGhpcy5fY3VycmVudFRpY2tDb21wbGV0ZVN0YXRlID0gX3RoaXMuX2FuaW1hdGVDdXJzb3IoX3RoaXMsIDAsIHRoaXMuY3Vyc29yRHVyYXRpb24gLyAyLCAnX3RpY2snKTtcbiAgICAgIH0sIDEwMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGRlbGF5ZWQgY3Vyc29yXG4gICAgICovXG4gICAgaW5pdERlbGF5ZWRDdXJzb3I6IGZ1bmN0aW9uKHJlc3RhcnQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgZGVsYXkgPSByZXN0YXJ0ID8gMCA6IHRoaXMuY3Vyc29yRGVsYXk7XG5cbiAgICAgIHRoaXMuYWJvcnRDdXJzb3JBbmltYXRpb24oKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRDdXJzb3JPcGFjaXR5ID0gMTtcbiAgICAgIHRoaXMuX2N1cnNvclRpbWVvdXQyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgX3RoaXMuX3RpY2soKTtcbiAgICAgIH0sIGRlbGF5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWJvcnRzIGN1cnNvciBhbmltYXRpb24gYW5kIGNsZWFycyBhbGwgdGltZW91dHNcbiAgICAgKi9cbiAgICBhYm9ydEN1cnNvckFuaW1hdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2hvdWxkQ2xlYXIgPSB0aGlzLl9jdXJyZW50VGlja1N0YXRlIHx8IHRoaXMuX2N1cnJlbnRUaWNrQ29tcGxldGVTdGF0ZSxcbiAgICAgICAgICBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgIHRoaXMuX2N1cnJlbnRUaWNrU3RhdGUgJiYgdGhpcy5fY3VycmVudFRpY2tTdGF0ZS5hYm9ydCgpO1xuICAgICAgdGhpcy5fY3VycmVudFRpY2tDb21wbGV0ZVN0YXRlICYmIHRoaXMuX2N1cnJlbnRUaWNrQ29tcGxldGVTdGF0ZS5hYm9ydCgpO1xuXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fY3Vyc29yVGltZW91dDEpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2N1cnNvclRpbWVvdXQyKTtcblxuICAgICAgdGhpcy5fY3VycmVudEN1cnNvck9wYWNpdHkgPSAwO1xuICAgICAgLy8gdG8gY2xlYXIganVzdCBpdGV4dCBhcmVhIHdlIG5lZWQgdG8gdHJhbnNmb3JtIHRoZSBjb250ZXh0XG4gICAgICAvLyBpdCBtYXkgbm90IGJlIHdvcnRoIGl0XG4gICAgICBpZiAoc2hvdWxkQ2xlYXIgJiYgY2FudmFzKSB7XG4gICAgICAgIGNhbnZhcy5jbGVhckNvbnRleHQoY2FudmFzLmNvbnRleHRUb3AgfHwgY2FudmFzLmNvbnRleHRDb250YWluZXIpO1xuICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgZW50aXJlIHRleHRcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2VsZWN0QWxsOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSAwO1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSB0aGlzLl90ZXh0Lmxlbmd0aDtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc2VsZWN0ZWQgdGV4dFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRTZWxlY3RlZFRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RleHQuc2xpY2UodGhpcy5zZWxlY3Rpb25TdGFydCwgdGhpcy5zZWxlY3Rpb25FbmQpLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIG5ldyBzZWxlY3Rpb24gaW5kZXggcmVwcmVzZW50aW5nIHN0YXJ0IG9mIGN1cnJlbnQgd29yZCBhY2NvcmRpbmcgdG8gY3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRGcm9tIEN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBOZXcgc2VsZWN0aW9uIGluZGV4XG4gICAgICovXG4gICAgZmluZFdvcmRCb3VuZGFyeUxlZnQ6IGZ1bmN0aW9uKHN0YXJ0RnJvbSkge1xuICAgICAgdmFyIG9mZnNldCA9IDAsIGluZGV4ID0gc3RhcnRGcm9tIC0gMTtcblxuICAgICAgLy8gcmVtb3ZlIHNwYWNlIGJlZm9yZSBjdXJzb3IgZmlyc3RcbiAgICAgIGlmICh0aGlzLl9yZVNwYWNlLnRlc3QodGhpcy5fdGV4dFtpbmRleF0pKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9yZVNwYWNlLnRlc3QodGhpcy5fdGV4dFtpbmRleF0pKSB7XG4gICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKC9cXFMvLnRlc3QodGhpcy5fdGV4dFtpbmRleF0pICYmIGluZGV4ID4gLTEpIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGFydEZyb20gLSBvZmZzZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgbmV3IHNlbGVjdGlvbiBpbmRleCByZXByZXNlbnRpbmcgZW5kIG9mIGN1cnJlbnQgd29yZCBhY2NvcmRpbmcgdG8gY3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRGcm9tIEN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHJldHVybiB7TnVtYmVyfSBOZXcgc2VsZWN0aW9uIGluZGV4XG4gICAgICovXG4gICAgZmluZFdvcmRCb3VuZGFyeVJpZ2h0OiBmdW5jdGlvbihzdGFydEZyb20pIHtcbiAgICAgIHZhciBvZmZzZXQgPSAwLCBpbmRleCA9IHN0YXJ0RnJvbTtcblxuICAgICAgLy8gcmVtb3ZlIHNwYWNlIGFmdGVyIGN1cnNvciBmaXJzdFxuICAgICAgaWYgKHRoaXMuX3JlU3BhY2UudGVzdCh0aGlzLl90ZXh0W2luZGV4XSkpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX3JlU3BhY2UudGVzdCh0aGlzLl90ZXh0W2luZGV4XSkpIHtcbiAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoL1xcUy8udGVzdCh0aGlzLl90ZXh0W2luZGV4XSkgJiYgaW5kZXggPCB0aGlzLl90ZXh0Lmxlbmd0aCkge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXJ0RnJvbSArIG9mZnNldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBuZXcgc2VsZWN0aW9uIGluZGV4IHJlcHJlc2VudGluZyBzdGFydCBvZiBjdXJyZW50IGxpbmUgYWNjb3JkaW5nIHRvIGN1cnJlbnQgc2VsZWN0aW9uIGluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0RnJvbSBDdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gTmV3IHNlbGVjdGlvbiBpbmRleFxuICAgICAqL1xuICAgIGZpbmRMaW5lQm91bmRhcnlMZWZ0OiBmdW5jdGlvbihzdGFydEZyb20pIHtcbiAgICAgIHZhciBvZmZzZXQgPSAwLCBpbmRleCA9IHN0YXJ0RnJvbSAtIDE7XG5cbiAgICAgIHdoaWxlICghL1xcbi8udGVzdCh0aGlzLl90ZXh0W2luZGV4XSkgJiYgaW5kZXggPiAtMSkge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXJ0RnJvbSAtIG9mZnNldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBuZXcgc2VsZWN0aW9uIGluZGV4IHJlcHJlc2VudGluZyBlbmQgb2YgY3VycmVudCBsaW5lIGFjY29yZGluZyB0byBjdXJyZW50IHNlbGVjdGlvbiBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEZyb20gQ3VycmVudCBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IE5ldyBzZWxlY3Rpb24gaW5kZXhcbiAgICAgKi9cbiAgICBmaW5kTGluZUJvdW5kYXJ5UmlnaHQ6IGZ1bmN0aW9uKHN0YXJ0RnJvbSkge1xuICAgICAgdmFyIG9mZnNldCA9IDAsIGluZGV4ID0gc3RhcnRGcm9tO1xuXG4gICAgICB3aGlsZSAoIS9cXG4vLnRlc3QodGhpcy5fdGV4dFtpbmRleF0pICYmIGluZGV4IDwgdGhpcy5fdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGFydEZyb20gKyBvZmZzZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIGluZGV4IGNvcnJlc3BvbmRpbmcgdG8gYmVnaW5uaW5nIG9yIGVuZCBvZiBhIHdvcmRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2VsZWN0aW9uU3RhcnQgSW5kZXggb2YgYSBjaGFyYWN0ZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGlyZWN0aW9uIDEgb3IgLTFcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IEluZGV4IG9mIHRoZSBiZWdpbm5pbmcgb3IgZW5kIG9mIGEgd29yZFxuICAgICAqL1xuICAgIHNlYXJjaFdvcmRCb3VuZGFyeTogZnVuY3Rpb24oc2VsZWN0aW9uU3RhcnQsIGRpcmVjdGlvbikge1xuICAgICAgdmFyIHRleHQgPSB0aGlzLl90ZXh0LFxuICAgICAgICAgIGluZGV4ICAgICA9IHRoaXMuX3JlU3BhY2UudGVzdCh0ZXh0W3NlbGVjdGlvblN0YXJ0XSkgPyBzZWxlY3Rpb25TdGFydCAtIDEgOiBzZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICBfY2hhciAgICAgPSB0ZXh0W2luZGV4XSxcbiAgICAgICAgICAvLyB3cm9uZ1xuICAgICAgICAgIHJlTm9uV29yZCA9IGZhYnJpYy5yZU5vbldvcmQ7XG5cbiAgICAgIHdoaWxlICghcmVOb25Xb3JkLnRlc3QoX2NoYXIpICYmIGluZGV4ID4gMCAmJiBpbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIGluZGV4ICs9IGRpcmVjdGlvbjtcbiAgICAgICAgX2NoYXIgPSB0ZXh0W2luZGV4XTtcbiAgICAgIH1cbiAgICAgIGlmIChyZU5vbldvcmQudGVzdChfY2hhcikpIHtcbiAgICAgICAgaW5kZXggKz0gZGlyZWN0aW9uID09PSAxID8gMCA6IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgYSB3b3JkIGJhc2VkIG9uIHRoZSBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzZWxlY3Rpb25TdGFydCBJbmRleCBvZiBhIGNoYXJhY3RlclxuICAgICAqL1xuICAgIHNlbGVjdFdvcmQ6IGZ1bmN0aW9uKHNlbGVjdGlvblN0YXJ0KSB7XG4gICAgICBzZWxlY3Rpb25TdGFydCA9IHNlbGVjdGlvblN0YXJ0IHx8IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICB2YXIgbmV3U2VsZWN0aW9uU3RhcnQgPSB0aGlzLnNlYXJjaFdvcmRCb3VuZGFyeShzZWxlY3Rpb25TdGFydCwgLTEpLCAvKiBzZWFyY2ggYmFja3dhcmRzICovXG4gICAgICAgICAgbmV3U2VsZWN0aW9uRW5kID0gdGhpcy5zZWFyY2hXb3JkQm91bmRhcnkoc2VsZWN0aW9uU3RhcnQsIDEpOyAvKiBzZWFyY2ggZm9yd2FyZCAqL1xuXG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uU3RhcnQ7XG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IG5ld1NlbGVjdGlvbkVuZDtcbiAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0YXJlYSgpO1xuICAgICAgdGhpcy5yZW5kZXJDdXJzb3JPclNlbGVjdGlvbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIGEgbGluZSBiYXNlZCBvbiB0aGUgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2VsZWN0aW9uU3RhcnQgSW5kZXggb2YgYSBjaGFyYWN0ZXJcbiAgICAgKiBAcmV0dXJuIHtmYWJyaWMuSVRleHR9IHRoaXNBcmdcbiAgICAgKiBAY2hhaW5hYmxlXG4gICAgICovXG4gICAgc2VsZWN0TGluZTogZnVuY3Rpb24oc2VsZWN0aW9uU3RhcnQpIHtcbiAgICAgIHNlbGVjdGlvblN0YXJ0ID0gc2VsZWN0aW9uU3RhcnQgfHwgdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICAgIHZhciBuZXdTZWxlY3Rpb25TdGFydCA9IHRoaXMuZmluZExpbmVCb3VuZGFyeUxlZnQoc2VsZWN0aW9uU3RhcnQpLFxuICAgICAgICAgIG5ld1NlbGVjdGlvbkVuZCA9IHRoaXMuZmluZExpbmVCb3VuZGFyeVJpZ2h0KHNlbGVjdGlvblN0YXJ0KTtcblxuICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvblN0YXJ0O1xuICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb25FbmQ7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbnRlcnMgZWRpdGluZyBzdGF0ZVxuICAgICAqIEByZXR1cm4ge2ZhYnJpYy5JVGV4dH0gdGhpc0FyZ1xuICAgICAqIEBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBlbnRlckVkaXRpbmc6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICh0aGlzLmlzRWRpdGluZyB8fCAhdGhpcy5lZGl0YWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLmNhbnZhcy5jYWxjT2Zmc2V0KCk7XG4gICAgICAgIHRoaXMuZXhpdEVkaXRpbmdPbk90aGVycyh0aGlzLmNhbnZhcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaXNFZGl0aW5nID0gdHJ1ZTtcblxuICAgICAgdGhpcy5pbml0SGlkZGVuVGV4dGFyZWEoZSk7XG4gICAgICB0aGlzLmhpZGRlblRleHRhcmVhLmZvY3VzKCk7XG4gICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnZhbHVlID0gdGhpcy50ZXh0O1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICAgIHRoaXMuX3NhdmVFZGl0aW5nUHJvcHMoKTtcbiAgICAgIHRoaXMuX3NldEVkaXRpbmdQcm9wcygpO1xuICAgICAgdGhpcy5fdGV4dEJlZm9yZUVkaXQgPSB0aGlzLnRleHQ7XG5cbiAgICAgIHRoaXMuX3RpY2soKTtcbiAgICAgIHRoaXMuZmlyZSgnZWRpdGluZzplbnRlcmVkJyk7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FudmFzLmZpcmUoJ3RleHQ6ZWRpdGluZzplbnRlcmVkJywgeyB0YXJnZXQ6IHRoaXMgfSk7XG4gICAgICB0aGlzLmluaXRNb3VzZU1vdmVIYW5kbGVyKCk7XG4gICAgICB0aGlzLmNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZXhpdEVkaXRpbmdPbk90aGVyczogZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICBpZiAoY2FudmFzLl9pVGV4dEluc3RhbmNlcykge1xuICAgICAgICBjYW52YXMuX2lUZXh0SW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgb2JqLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgaWYgKG9iai5pc0VkaXRpbmcpIHtcbiAgICAgICAgICAgIG9iai5leGl0RWRpdGluZygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIFwibW91c2Vtb3ZlXCIgZXZlbnQgaGFuZGxlclxuICAgICAqL1xuICAgIGluaXRNb3VzZU1vdmVIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY2FudmFzLm9uKCdtb3VzZTptb3ZlJywgdGhpcy5tb3VzZU1vdmVIYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBtb3VzZU1vdmVIYW5kbGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoIXRoaXMuX19pc01vdXNlZG93biB8fCAhdGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyByZWdhaW4gZm9jdXNcbiAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IHRoaXMuaGlkZGVuVGV4dGFyZWEgJiYgdGhpcy5oaWRkZW5UZXh0YXJlYS5mb2N1cygpO1xuXG4gICAgICB2YXIgbmV3U2VsZWN0aW9uU3RhcnQgPSB0aGlzLmdldFNlbGVjdGlvblN0YXJ0RnJvbVBvaW50ZXIob3B0aW9ucy5lKSxcbiAgICAgICAgICBjdXJyZW50U3RhcnQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgIGN1cnJlbnRFbmQgPSB0aGlzLnNlbGVjdGlvbkVuZDtcbiAgICAgIGlmIChcbiAgICAgICAgKG5ld1NlbGVjdGlvblN0YXJ0ICE9PSB0aGlzLl9fc2VsZWN0aW9uU3RhcnRPbk1vdXNlRG93biB8fCBjdXJyZW50U3RhcnQgPT09IGN1cnJlbnRFbmQpXG4gICAgICAgICYmXG4gICAgICAgIChjdXJyZW50U3RhcnQgPT09IG5ld1NlbGVjdGlvblN0YXJ0IHx8IGN1cnJlbnRFbmQgPT09IG5ld1NlbGVjdGlvblN0YXJ0KVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdTZWxlY3Rpb25TdGFydCA+IHRoaXMuX19zZWxlY3Rpb25TdGFydE9uTW91c2VEb3duKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSB0aGlzLl9fc2VsZWN0aW9uU3RhcnRPbk1vdXNlRG93bjtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb25TdGFydDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gbmV3U2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5fX3NlbGVjdGlvblN0YXJ0T25Nb3VzZURvd247XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zZWxlY3Rpb25TdGFydCAhPT0gY3VycmVudFN0YXJ0IHx8IHRoaXMuc2VsZWN0aW9uRW5kICE9PSBjdXJyZW50RW5kKSB7XG4gICAgICAgIHRoaXMucmVzdGFydEN1cnNvcklmTmVlZGVkKCk7XG4gICAgICAgIHRoaXMuX2ZpcmVTZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgICAgIHRoaXMucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfc2V0RWRpdGluZ1Byb3BzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaG92ZXJDdXJzb3IgPSAndGV4dCc7XG5cbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLmNhbnZhcy5kZWZhdWx0Q3Vyc29yID0gdGhpcy5jYW52YXMubW92ZUN1cnNvciA9ICd0ZXh0JztcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib3JkZXJDb2xvciA9IHRoaXMuZWRpdGluZ0JvcmRlckNvbG9yO1xuICAgICAgdGhpcy5oYXNDb250cm9scyA9IHRoaXMuc2VsZWN0YWJsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5sb2NrTW92ZW1lbnRYID0gdGhpcy5sb2NrTW92ZW1lbnRZID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29udmVydCBmcm9tIHRleHRhcmVhIHRvIGdyYXBoZW1lIGluZGV4ZXNcbiAgICAgKi9cbiAgICBmcm9tU3RyaW5nVG9HcmFwaGVtZVNlbGVjdGlvbjogZnVuY3Rpb24oc3RhcnQsIGVuZCwgdGV4dCkge1xuICAgICAgdmFyIHNtYWxsZXJUZXh0U3RhcnQgPSB0ZXh0LnNsaWNlKDAsIHN0YXJ0KSxcbiAgICAgICAgICBncmFwaGVtZVN0YXJ0ID0gZmFicmljLnV0aWwuc3RyaW5nLmdyYXBoZW1lU3BsaXQoc21hbGxlclRleHRTdGFydCkubGVuZ3RoO1xuICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHsgc2VsZWN0aW9uU3RhcnQ6IGdyYXBoZW1lU3RhcnQsIHNlbGVjdGlvbkVuZDogZ3JhcGhlbWVTdGFydCB9O1xuICAgICAgfVxuICAgICAgdmFyIHNtYWxsZXJUZXh0RW5kID0gdGV4dC5zbGljZShzdGFydCwgZW5kKSxcbiAgICAgICAgICBncmFwaGVtZUVuZCA9IGZhYnJpYy51dGlsLnN0cmluZy5ncmFwaGVtZVNwbGl0KHNtYWxsZXJUZXh0RW5kKS5sZW5ndGg7XG4gICAgICByZXR1cm4geyBzZWxlY3Rpb25TdGFydDogZ3JhcGhlbWVTdGFydCwgc2VsZWN0aW9uRW5kOiBncmFwaGVtZVN0YXJ0ICsgZ3JhcGhlbWVFbmQgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29udmVydCBmcm9tIGZhYnJpYyB0byB0ZXh0YXJlYSB2YWx1ZXNcbiAgICAgKi9cbiAgICBmcm9tR3JhcGhlbWVUb1N0cmluZ1NlbGVjdGlvbjogZnVuY3Rpb24oc3RhcnQsIGVuZCwgX3RleHQpIHtcbiAgICAgIHZhciBzbWFsbGVyVGV4dFN0YXJ0ID0gX3RleHQuc2xpY2UoMCwgc3RhcnQpLFxuICAgICAgICAgIGdyYXBoZW1lU3RhcnQgPSBzbWFsbGVyVGV4dFN0YXJ0LmpvaW4oJycpLmxlbmd0aDtcbiAgICAgIGlmIChzdGFydCA9PT0gZW5kKSB7XG4gICAgICAgIHJldHVybiB7IHNlbGVjdGlvblN0YXJ0OiBncmFwaGVtZVN0YXJ0LCBzZWxlY3Rpb25FbmQ6IGdyYXBoZW1lU3RhcnQgfTtcbiAgICAgIH1cbiAgICAgIHZhciBzbWFsbGVyVGV4dEVuZCA9IF90ZXh0LnNsaWNlKHN0YXJ0LCBlbmQpLFxuICAgICAgICAgIGdyYXBoZW1lRW5kID0gc21hbGxlclRleHRFbmQuam9pbignJykubGVuZ3RoO1xuICAgICAgcmV0dXJuIHsgc2VsZWN0aW9uU3RhcnQ6IGdyYXBoZW1lU3RhcnQsIHNlbGVjdGlvbkVuZDogZ3JhcGhlbWVTdGFydCArIGdyYXBoZW1lRW5kIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZVRleHRhcmVhOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY3Vyc29yT2Zmc2V0Q2FjaGUgPSB7IH07XG4gICAgICBpZiAoIXRoaXMuaGlkZGVuVGV4dGFyZWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmluQ29tcG9zaXRpb25Nb2RlKSB7XG4gICAgICAgIHZhciBuZXdTZWxlY3Rpb24gPSB0aGlzLmZyb21HcmFwaGVtZVRvU3RyaW5nU2VsZWN0aW9uKHRoaXMuc2VsZWN0aW9uU3RhcnQsIHRoaXMuc2VsZWN0aW9uRW5kLCB0aGlzLl90ZXh0KTtcbiAgICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvbi5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb24uc2VsZWN0aW9uRW5kO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVUZXh0YXJlYVBvc2l0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdXBkYXRlRnJvbVRleHRBcmVhOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5oaWRkZW5UZXh0YXJlYSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmN1cnNvck9mZnNldENhY2hlID0geyB9O1xuICAgICAgdGhpcy50ZXh0ID0gdGhpcy5oaWRkZW5UZXh0YXJlYS52YWx1ZTtcbiAgICAgIGlmICh0aGlzLl9zaG91bGRDbGVhckRpbWVuc2lvbkNhY2hlKCkpIHtcbiAgICAgICAgdGhpcy5pbml0RGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLnNldENvb3JkcygpO1xuICAgICAgfVxuICAgICAgdmFyIG5ld1NlbGVjdGlvbiA9IHRoaXMuZnJvbVN0cmluZ1RvR3JhcGhlbWVTZWxlY3Rpb24oXG4gICAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2VsZWN0aW9uU3RhcnQsIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2VsZWN0aW9uRW5kLCB0aGlzLmhpZGRlblRleHRhcmVhLnZhbHVlKTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvbi5zZWxlY3Rpb25FbmQ7XG4gICAgICBpZiAoIXRoaXMuaW5Db21wb3NpdGlvbk1vZGUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvbi5zZWxlY3Rpb25TdGFydDtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlVGV4dGFyZWFQb3NpdGlvbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHVwZGF0ZVRleHRhcmVhUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuX2NhbGNUZXh0YXJlYVBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc3R5bGUubGVmdCA9IHN0eWxlLmxlZnQ7XG4gICAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc3R5bGUudG9wID0gc3R5bGUudG9wO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gc3R5bGUgY29udGFpbnMgc3R5bGUgZm9yIGhpZGRlblRleHRhcmVhXG4gICAgICovXG4gICAgX2NhbGNUZXh0YXJlYVBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogMSwgeTogMSB9O1xuICAgICAgfVxuICAgICAgdmFyIGRlc2lyZWRQb3NpdGlvbiA9IHRoaXMuaW5Db21wb3NpdGlvbk1vZGUgPyB0aGlzLmNvbXBvc2l0aW9uU3RhcnQgOiB0aGlzLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgIGJvdW5kYXJpZXMgPSB0aGlzLl9nZXRDdXJzb3JCb3VuZGFyaWVzKGRlc2lyZWRQb3NpdGlvbiksXG4gICAgICAgICAgY3Vyc29yTG9jYXRpb24gPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oZGVzaXJlZFBvc2l0aW9uKSxcbiAgICAgICAgICBsaW5lSW5kZXggPSBjdXJzb3JMb2NhdGlvbi5saW5lSW5kZXgsXG4gICAgICAgICAgY2hhckluZGV4ID0gY3Vyc29yTG9jYXRpb24uY2hhckluZGV4LFxuICAgICAgICAgIGNoYXJIZWlnaHQgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGxpbmVJbmRleCwgY2hhckluZGV4LCAnZm9udFNpemUnKSAqIHRoaXMubGluZUhlaWdodCxcbiAgICAgICAgICBsZWZ0T2Zmc2V0ID0gYm91bmRhcmllcy5sZWZ0T2Zmc2V0LFxuICAgICAgICAgIG0gPSB0aGlzLmNhbGNUcmFuc2Zvcm1NYXRyaXgoKSxcbiAgICAgICAgICBwID0ge1xuICAgICAgICAgICAgeDogYm91bmRhcmllcy5sZWZ0ICsgbGVmdE9mZnNldCxcbiAgICAgICAgICAgIHk6IGJvdW5kYXJpZXMudG9wICsgYm91bmRhcmllcy50b3BPZmZzZXQgKyBjaGFySGVpZ2h0XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXRpbmFTY2FsaW5nID0gdGhpcy5jYW52YXMuZ2V0UmV0aW5hU2NhbGluZygpLFxuICAgICAgICAgIHVwcGVyQ2FudmFzID0gdGhpcy5jYW52YXMudXBwZXJDYW52YXNFbCxcbiAgICAgICAgICB1cHBlckNhbnZhc1dpZHRoID0gdXBwZXJDYW52YXMud2lkdGggLyByZXRpbmFTY2FsaW5nLFxuICAgICAgICAgIHVwcGVyQ2FudmFzSGVpZ2h0ID0gdXBwZXJDYW52YXMuaGVpZ2h0IC8gcmV0aW5hU2NhbGluZyxcbiAgICAgICAgICBtYXhXaWR0aCA9IHVwcGVyQ2FudmFzV2lkdGggLSBjaGFySGVpZ2h0LFxuICAgICAgICAgIG1heEhlaWdodCA9IHVwcGVyQ2FudmFzSGVpZ2h0IC0gY2hhckhlaWdodCxcbiAgICAgICAgICBzY2FsZVggPSB1cHBlckNhbnZhcy5jbGllbnRXaWR0aCAvIHVwcGVyQ2FudmFzV2lkdGgsXG4gICAgICAgICAgc2NhbGVZID0gdXBwZXJDYW52YXMuY2xpZW50SGVpZ2h0IC8gdXBwZXJDYW52YXNIZWlnaHQ7XG5cbiAgICAgIHAgPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludChwLCBtKTtcbiAgICAgIHAgPSBmYWJyaWMudXRpbC50cmFuc2Zvcm1Qb2ludChwLCB0aGlzLmNhbnZhcy52aWV3cG9ydFRyYW5zZm9ybSk7XG4gICAgICBwLnggKj0gc2NhbGVYO1xuICAgICAgcC55ICo9IHNjYWxlWTtcbiAgICAgIGlmIChwLnggPCAwKSB7XG4gICAgICAgIHAueCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAocC54ID4gbWF4V2lkdGgpIHtcbiAgICAgICAgcC54ID0gbWF4V2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAocC55IDwgMCkge1xuICAgICAgICBwLnkgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHAueSA+IG1heEhlaWdodCkge1xuICAgICAgICBwLnkgPSBtYXhIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZCBjYW52YXMgb2Zmc2V0IG9uIGRvY3VtZW50XG4gICAgICBwLnggKz0gdGhpcy5jYW52YXMuX29mZnNldC5sZWZ0O1xuICAgICAgcC55ICs9IHRoaXMuY2FudmFzLl9vZmZzZXQudG9wO1xuXG4gICAgICByZXR1cm4geyBsZWZ0OiBwLnggKyAncHgnLCB0b3A6IHAueSArICdweCcsIGZvbnRTaXplOiBjaGFySGVpZ2h0ICsgJ3B4JywgY2hhckhlaWdodDogY2hhckhlaWdodCB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zYXZlRWRpdGluZ1Byb3BzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3NhdmVkUHJvcHMgPSB7XG4gICAgICAgIGhhc0NvbnRyb2xzOiB0aGlzLmhhc0NvbnRyb2xzLFxuICAgICAgICBib3JkZXJDb2xvcjogdGhpcy5ib3JkZXJDb2xvcixcbiAgICAgICAgbG9ja01vdmVtZW50WDogdGhpcy5sb2NrTW92ZW1lbnRYLFxuICAgICAgICBsb2NrTW92ZW1lbnRZOiB0aGlzLmxvY2tNb3ZlbWVudFksXG4gICAgICAgIGhvdmVyQ3Vyc29yOiB0aGlzLmhvdmVyQ3Vyc29yLFxuICAgICAgICBzZWxlY3RhYmxlOiB0aGlzLnNlbGVjdGFibGUsXG4gICAgICAgIGRlZmF1bHRDdXJzb3I6IHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLmRlZmF1bHRDdXJzb3IsXG4gICAgICAgIG1vdmVDdXJzb3I6IHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLm1vdmVDdXJzb3JcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Jlc3RvcmVFZGl0aW5nUHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9zYXZlZFByb3BzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ob3ZlckN1cnNvciA9IHRoaXMuX3NhdmVkUHJvcHMuaG92ZXJDdXJzb3I7XG4gICAgICB0aGlzLmhhc0NvbnRyb2xzID0gdGhpcy5fc2F2ZWRQcm9wcy5oYXNDb250cm9scztcbiAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSB0aGlzLl9zYXZlZFByb3BzLmJvcmRlckNvbG9yO1xuICAgICAgdGhpcy5zZWxlY3RhYmxlID0gdGhpcy5fc2F2ZWRQcm9wcy5zZWxlY3RhYmxlO1xuICAgICAgdGhpcy5sb2NrTW92ZW1lbnRYID0gdGhpcy5fc2F2ZWRQcm9wcy5sb2NrTW92ZW1lbnRYO1xuICAgICAgdGhpcy5sb2NrTW92ZW1lbnRZID0gdGhpcy5fc2F2ZWRQcm9wcy5sb2NrTW92ZW1lbnRZO1xuXG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuZGVmYXVsdEN1cnNvciA9IHRoaXMuX3NhdmVkUHJvcHMuZGVmYXVsdEN1cnNvcjtcbiAgICAgICAgdGhpcy5jYW52YXMubW92ZUN1cnNvciA9IHRoaXMuX3NhdmVkUHJvcHMubW92ZUN1cnNvcjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRXhpdHMgZnJvbSBlZGl0aW5nIHN0YXRlXG4gICAgICogQHJldHVybiB7ZmFicmljLklUZXh0fSB0aGlzQXJnXG4gICAgICogQGNoYWluYWJsZVxuICAgICAqL1xuICAgIGV4aXRFZGl0aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpc1RleHRDaGFuZ2VkID0gKHRoaXMuX3RleHRCZWZvcmVFZGl0ICE9PSB0aGlzLnRleHQpO1xuICAgICAgdmFyIGhpZGRlblRleHRhcmVhID0gdGhpcy5oaWRkZW5UZXh0YXJlYTtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcblxuICAgICAgaWYgKGhpZGRlblRleHRhcmVhKSB7XG4gICAgICAgIGhpZGRlblRleHRhcmVhLmJsdXIgJiYgaGlkZGVuVGV4dGFyZWEuYmx1cigpO1xuICAgICAgICBoaWRkZW5UZXh0YXJlYS5wYXJlbnROb2RlICYmIGhpZGRlblRleHRhcmVhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaGlkZGVuVGV4dGFyZWEpO1xuICAgICAgfVxuICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYSA9IG51bGw7XG4gICAgICB0aGlzLmFib3J0Q3Vyc29yQW5pbWF0aW9uKCk7XG4gICAgICB0aGlzLl9yZXN0b3JlRWRpdGluZ1Byb3BzKCk7XG4gICAgICB0aGlzLl9jdXJyZW50Q3Vyc29yT3BhY2l0eSA9IDA7XG4gICAgICBpZiAodGhpcy5fc2hvdWxkQ2xlYXJEaW1lbnNpb25DYWNoZSgpKSB7XG4gICAgICAgIHRoaXMuaW5pdERpbWVuc2lvbnMoKTtcbiAgICAgICAgdGhpcy5zZXRDb29yZHMoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZmlyZSgnZWRpdGluZzpleGl0ZWQnKTtcbiAgICAgIGlzVGV4dENoYW5nZWQgJiYgdGhpcy5maXJlKCdtb2RpZmllZCcpO1xuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLm9mZignbW91c2U6bW92ZScsIHRoaXMubW91c2VNb3ZlSGFuZGxlcik7XG4gICAgICAgIHRoaXMuY2FudmFzLmZpcmUoJ3RleHQ6ZWRpdGluZzpleGl0ZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICAgICAgaXNUZXh0Q2hhbmdlZCAmJiB0aGlzLmNhbnZhcy5maXJlKCdvYmplY3Q6bW9kaWZpZWQnLCB7IHRhcmdldDogdGhpcyB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW1vdmVFeHRyYW5lb3VzU3R5bGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gdGhpcy5zdHlsZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90ZXh0TGluZXNbcHJvcF0pIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIGFuZCByZWZsb3cgYSBzdHlsZSBibG9jayBmcm9tIHN0YXJ0IHRvIGVuZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgbGluZWFyIHN0YXJ0IHBvc2l0aW9uIGZvciByZW1vdmFsIChpbmNsdWRlZCBpbiByZW1vdmFsKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgbGluZWFyIGVuZCBwb3NpdGlvbiBmb3IgcmVtb3ZhbCAoIGV4Y2x1ZGVkIGZyb20gcmVtb3ZhbCApXG4gICAgICovXG4gICAgcmVtb3ZlU3R5bGVGcm9tVG86IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBjdXJzb3JTdGFydCA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihzdGFydCwgdHJ1ZSksXG4gICAgICAgICAgY3Vyc29yRW5kID0gdGhpcy5nZXQyREN1cnNvckxvY2F0aW9uKGVuZCwgdHJ1ZSksXG4gICAgICAgICAgbGluZVN0YXJ0ID0gY3Vyc29yU3RhcnQubGluZUluZGV4LFxuICAgICAgICAgIGNoYXJTdGFydCA9IGN1cnNvclN0YXJ0LmNoYXJJbmRleCxcbiAgICAgICAgICBsaW5lRW5kID0gY3Vyc29yRW5kLmxpbmVJbmRleCxcbiAgICAgICAgICBjaGFyRW5kID0gY3Vyc29yRW5kLmNoYXJJbmRleCxcbiAgICAgICAgICBpLCBzdHlsZU9iajtcbiAgICAgIGlmIChsaW5lU3RhcnQgIT09IGxpbmVFbmQpIHtcbiAgICAgICAgLy8gc3RlcDEgcmVtb3ZlIHRoZSB0cmFpbGluZyBvZiBsaW5lU3RhcnRcbiAgICAgICAgaWYgKHRoaXMuc3R5bGVzW2xpbmVTdGFydF0pIHtcbiAgICAgICAgICBmb3IgKGkgPSBjaGFyU3RhcnQ7IGkgPCB0aGlzLl91bndyYXBwZWRUZXh0TGluZXNbbGluZVN0YXJ0XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW2xpbmVTdGFydF1baV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHN0ZXAyIG1vdmUgdGhlIHRyYWlsaW5nIG9mIGxpbmVFbmQgdG8gbGluZVN0YXJ0IGlmIG5lZWRlZFxuICAgICAgICBpZiAodGhpcy5zdHlsZXNbbGluZUVuZF0pIHtcbiAgICAgICAgICBmb3IgKGkgPSBjaGFyRW5kOyBpIDwgdGhpcy5fdW53cmFwcGVkVGV4dExpbmVzW2xpbmVFbmRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdHlsZU9iaiA9IHRoaXMuc3R5bGVzW2xpbmVFbmRdW2ldO1xuICAgICAgICAgICAgaWYgKHN0eWxlT2JqKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3R5bGVzW2xpbmVTdGFydF0gfHwgKHRoaXMuc3R5bGVzW2xpbmVTdGFydF0gPSB7IH0pO1xuICAgICAgICAgICAgICB0aGlzLnN0eWxlc1tsaW5lU3RhcnRdW2NoYXJTdGFydCArIGkgLSBjaGFyRW5kXSA9IHN0eWxlT2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzdGVwMyBkZXRlY3RzIGxpbmVzIHdpbGwgYmUgY29tcGxldGVseSByZW1vdmVkLlxuICAgICAgICBmb3IgKGkgPSBsaW5lU3RhcnQgKyAxOyBpIDw9IGxpbmVFbmQ7IGkrKykge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1tpXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdGVwNCBzaGlmdCByZW1haW5pbmcgbGluZXMuXG4gICAgICAgIHRoaXMuc2hpZnRMaW5lU3R5bGVzKGxpbmVFbmQsIGxpbmVTdGFydCAtIGxpbmVFbmQpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHJlbW92ZSBhbmQgc2hpZnQgbGVmdCBvbiB0aGUgc2FtZSBsaW5lXG4gICAgICAgIGlmICh0aGlzLnN0eWxlc1tsaW5lU3RhcnRdKSB7XG4gICAgICAgICAgc3R5bGVPYmogPSB0aGlzLnN0eWxlc1tsaW5lU3RhcnRdO1xuICAgICAgICAgIHZhciBkaWZmID0gY2hhckVuZCAtIGNoYXJTdGFydCwgbnVtZXJpY0NoYXIsIF9jaGFyO1xuICAgICAgICAgIGZvciAoaSA9IGNoYXJTdGFydDsgaSA8IGNoYXJFbmQ7IGkrKykge1xuICAgICAgICAgICAgZGVsZXRlIHN0eWxlT2JqW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKF9jaGFyIGluIHRoaXMuc3R5bGVzW2xpbmVTdGFydF0pIHtcbiAgICAgICAgICAgIG51bWVyaWNDaGFyID0gcGFyc2VJbnQoX2NoYXIsIDEwKTtcbiAgICAgICAgICAgIGlmIChudW1lcmljQ2hhciA+PSBjaGFyRW5kKSB7XG4gICAgICAgICAgICAgIHN0eWxlT2JqW251bWVyaWNDaGFyIC0gZGlmZl0gPSBzdHlsZU9ialtfY2hhcl07XG4gICAgICAgICAgICAgIGRlbGV0ZSBzdHlsZU9ialtfY2hhcl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNoaWZ0cyBsaW5lIHN0eWxlcyB1cCBvciBkb3duXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleCBJbmRleCBvZiBhIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IENhbiBhbnkgbnVtYmVyP1xuICAgICAqL1xuICAgIHNoaWZ0TGluZVN0eWxlczogZnVuY3Rpb24obGluZUluZGV4LCBvZmZzZXQpIHtcbiAgICAgIC8vIHNoaWZ0IGFsbCBsaW5lIHN0eWxlcyBieSBvZmZzZXQgdXB3YXJkIG9yIGRvd253YXJkXG4gICAgICAvLyBkbyBub3QgY2xvbmUgZGVlcC4gd2UgbmVlZCBuZXcgYXJyYXksIG5vdCBuZXcgc3R5bGUgb2JqZWN0c1xuICAgICAgdmFyIGNsb25lZFN0eWxlcyA9IGNsb25lKHRoaXMuc3R5bGVzKTtcbiAgICAgIGZvciAodmFyIGxpbmUgaW4gdGhpcy5zdHlsZXMpIHtcbiAgICAgICAgdmFyIG51bWVyaWNMaW5lID0gcGFyc2VJbnQobGluZSwgMTApO1xuICAgICAgICBpZiAobnVtZXJpY0xpbmUgPiBsaW5lSW5kZXgpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlc1tudW1lcmljTGluZSArIG9mZnNldF0gPSBjbG9uZWRTdHlsZXNbbnVtZXJpY0xpbmVdO1xuICAgICAgICAgIGlmICghY2xvbmVkU3R5bGVzW251bWVyaWNMaW5lIC0gb2Zmc2V0XSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc3R5bGVzW251bWVyaWNMaW5lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVzdGFydEN1cnNvcklmTmVlZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5fY3VycmVudFRpY2tTdGF0ZSB8fCB0aGlzLl9jdXJyZW50VGlja1N0YXRlLmlzQWJvcnRlZFxuICAgICAgICB8fCAhdGhpcy5fY3VycmVudFRpY2tDb21wbGV0ZVN0YXRlIHx8IHRoaXMuX2N1cnJlbnRUaWNrQ29tcGxldGVTdGF0ZS5pc0Fib3J0ZWRcbiAgICAgICkge1xuICAgICAgICB0aGlzLmluaXREZWxheWVkQ3Vyc29yKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBpbnNlcnRpb24gb2YgbW9yZSBjb25zZWN1dGl2ZSBzdHlsZSBsaW5lcyBmb3Igd2hlbiBvbmUgb3IgbW9yZVxuICAgICAqIG5ld2xpbmVzIGdldHMgYWRkZWQgdG8gdGhlIHRleHQuIFNpbmNlIGN1cnJlbnQgc3R5bGUgbmVlZHMgdG8gYmUgc2hpZnRlZFxuICAgICAqIGZpcnN0IHdlIHNoaWZ0IHRoZSBjdXJyZW50IHN0eWxlIG9mIHRoZSBudW1iZXIgbGluZXMgbmVlZGVkLCB0aGVuIHdlIGFkZFxuICAgICAqIG5ldyBsaW5lcyBmcm9tIHRoZSBsYXN0IHRvIHRoZSBmaXJzdC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IEluZGV4IG9mIGEgbGluZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXggSW5kZXggb2YgYSBjaGFyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHF0eSBudW1iZXIgb2YgbGluZXMgdG8gYWRkXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29waWVkU3R5bGUgQXJyYXkgb2Ygb2JqZWN0cyBzdHlsZXNcbiAgICAgKi9cbiAgICBpbnNlcnROZXdsaW5lU3R5bGVPYmplY3Q6IGZ1bmN0aW9uKGxpbmVJbmRleCwgY2hhckluZGV4LCBxdHksIGNvcGllZFN0eWxlKSB7XG4gICAgICB2YXIgY3VycmVudENoYXJTdHlsZSxcbiAgICAgICAgICBuZXdMaW5lU3R5bGVzID0ge30sXG4gICAgICAgICAgc29tZVN0eWxlSXNDYXJyeWluZ092ZXIgPSBmYWxzZSxcbiAgICAgICAgICBvcmlnaW5hbExpbmVMZW5ndGggPSB0aGlzLl91bndyYXBwZWRUZXh0TGluZXNbbGluZUluZGV4XS5sZW5ndGgsXG4gICAgICAgICAgaXNFbmRPZkxpbmUgPSBvcmlnaW5hbExpbmVMZW5ndGggPT09IGNoYXJJbmRleDtcblxuICAgICAgcXR5IHx8IChxdHkgPSAxKTtcbiAgICAgIHRoaXMuc2hpZnRMaW5lU3R5bGVzKGxpbmVJbmRleCwgcXR5KTtcbiAgICAgIGlmICh0aGlzLnN0eWxlc1tsaW5lSW5kZXhdKSB7XG4gICAgICAgIGN1cnJlbnRDaGFyU3R5bGUgPSB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2NoYXJJbmRleCA9PT0gMCA/IGNoYXJJbmRleCA6IGNoYXJJbmRleCAtIDFdO1xuICAgICAgfVxuICAgICAgLy8gd2UgY2xvbmUgc3R5bGVzIG9mIGFsbCBjaGFyc1xuICAgICAgLy8gYWZ0ZXIgY3Vyc29yIG9udG8gdGhlIGN1cnJlbnQgbGluZVxuICAgICAgZm9yICh2YXIgaW5kZXggaW4gdGhpcy5zdHlsZXNbbGluZUluZGV4XSkge1xuICAgICAgICB2YXIgbnVtSW5kZXggPSBwYXJzZUludChpbmRleCwgMTApO1xuICAgICAgICBpZiAobnVtSW5kZXggPj0gY2hhckluZGV4KSB7XG4gICAgICAgICAgc29tZVN0eWxlSXNDYXJyeWluZ092ZXIgPSB0cnVlO1xuICAgICAgICAgIG5ld0xpbmVTdHlsZXNbbnVtSW5kZXggLSBjaGFySW5kZXhdID0gdGhpcy5zdHlsZXNbbGluZUluZGV4XVtpbmRleF07XG4gICAgICAgICAgLy8gcmVtb3ZlIGxpbmVzIGZyb20gdGhlIHByZXZpb3VzIGxpbmUgc2luY2UgdGhleSdyZSBvbiBhIG5ldyBsaW5lIG5vd1xuICAgICAgICAgIGlmICghKGlzRW5kT2ZMaW5lICYmIGNoYXJJbmRleCA9PT0gMCkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZUNhcnJpZWRPdmVyID0gZmFsc2U7XG4gICAgICBpZiAoc29tZVN0eWxlSXNDYXJyeWluZ092ZXIgJiYgIWlzRW5kT2ZMaW5lKSB7XG4gICAgICAgIC8vIGlmIGlzIGVuZCBvZiBsaW5lLCB0aGUgZXh0cmEgc3R5bGUgd2UgY29waWVkXG4gICAgICAgIC8vIGlzIHByb2JhYmx5IG5vdCBzb21ldGhpbmcgd2Ugd2FudFxuICAgICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXggKyBxdHldID0gbmV3TGluZVN0eWxlcztcbiAgICAgICAgc3R5bGVDYXJyaWVkT3ZlciA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVDYXJyaWVkT3ZlciB8fCBvcmlnaW5hbExpbmVMZW5ndGggPiBjaGFySW5kZXgpIHtcbiAgICAgICAgLy8gc2tpcCB0aGUgbGFzdCBsaW5lIG9mIHNpbmNlIHdlIGFscmVhZHkgcHJlcGFyZWQgaXRcbiAgICAgICAgLy8gb3IgY29udGFpbnMgdGV4dCB3aXRob3V0IHN0eWxlIHRoYXQgd2UgZG9uJ3Qgd2FudCB0byBzdHlsZVxuICAgICAgICAvLyBqdXN0IGJlY2F1c2UgaXQgY2hhbmdlZCBsaW5lc1xuICAgICAgICBxdHktLTtcbiAgICAgIH1cbiAgICAgIC8vIGZvciB0aGUgYWxsIHRoZSBsaW5lcyBvciBhbGwgdGhlIG90aGVyIGxpbmVzXG4gICAgICAvLyB3ZSBjbG9uZSBjdXJyZW50IGNoYXIgc3R5bGUgb250byB0aGUgbmV4dCAob3RoZXJ3aXNlIGVtcHR5KSBsaW5lXG4gICAgICB3aGlsZSAocXR5ID4gMCkge1xuICAgICAgICBpZiAoY29waWVkU3R5bGUgJiYgY29waWVkU3R5bGVbcXR5IC0gMV0pIHtcbiAgICAgICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXggKyBxdHldID0geyAwOiBjbG9uZShjb3BpZWRTdHlsZVtxdHkgLSAxXSkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyZW50Q2hhclN0eWxlKSB7XG4gICAgICAgICAgdGhpcy5zdHlsZXNbbGluZUluZGV4ICsgcXR5XSA9IHsgMDogY2xvbmUoY3VycmVudENoYXJTdHlsZSkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbGluZUluZGV4ICsgcXR5XTtcbiAgICAgICAgfVxuICAgICAgICBxdHktLTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZvcmNlQ2xlYXJDYWNoZSA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgc3R5bGUgb2JqZWN0IGZvciBhIGdpdmVuIGxpbmUvY2hhciBpbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggSW5kZXggb2YgYSBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNoYXJJbmRleCBJbmRleCBvZiBhIGNoYXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcXVhbnRpdHkgbnVtYmVyIFN0eWxlIG9iamVjdCB0byBpbnNlcnQsIGlmIGdpdmVuXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29waWVkU3R5bGUgYXJyYXkgb2Ygc3R5bGUgb2JqZWN0c1xuICAgICAqL1xuICAgIGluc2VydENoYXJTdHlsZU9iamVjdDogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgsIHF1YW50aXR5LCBjb3BpZWRTdHlsZSkge1xuICAgICAgaWYgKCF0aGlzLnN0eWxlcykge1xuICAgICAgICB0aGlzLnN0eWxlcyA9IHt9O1xuICAgICAgfVxuICAgICAgdmFyIGN1cnJlbnRMaW5lU3R5bGVzICAgICAgID0gdGhpcy5zdHlsZXNbbGluZUluZGV4XSxcbiAgICAgICAgICBjdXJyZW50TGluZVN0eWxlc0Nsb25lZCA9IGN1cnJlbnRMaW5lU3R5bGVzID8gY2xvbmUoY3VycmVudExpbmVTdHlsZXMpIDoge307XG5cbiAgICAgIHF1YW50aXR5IHx8IChxdWFudGl0eSA9IDEpO1xuICAgICAgLy8gc2hpZnQgYWxsIGNoYXIgc3R5bGVzIGJ5IHF1YW50aXR5IGZvcndhcmRcbiAgICAgIC8vIDAsMSwyLDMgLT4gKGNoYXJJbmRleD0yKSAtPiAwLDEsMyw0IC0+IChpbnNlcnQgMikgLT4gMCwxLDIsMyw0XG4gICAgICBmb3IgKHZhciBpbmRleCBpbiBjdXJyZW50TGluZVN0eWxlc0Nsb25lZCkge1xuICAgICAgICB2YXIgbnVtZXJpY0luZGV4ID0gcGFyc2VJbnQoaW5kZXgsIDEwKTtcbiAgICAgICAgaWYgKG51bWVyaWNJbmRleCA+PSBjaGFySW5kZXgpIHtcbiAgICAgICAgICBjdXJyZW50TGluZVN0eWxlc1tudW1lcmljSW5kZXggKyBxdWFudGl0eV0gPSBjdXJyZW50TGluZVN0eWxlc0Nsb25lZFtudW1lcmljSW5kZXhdO1xuICAgICAgICAgIC8vIG9ubHkgZGVsZXRlIHRoZSBzdHlsZSBpZiB0aGVyZSB3YXMgbm90aGluZyBtb3ZlZCB0aGVyZVxuICAgICAgICAgIGlmICghY3VycmVudExpbmVTdHlsZXNDbG9uZWRbbnVtZXJpY0luZGV4IC0gcXVhbnRpdHldKSB7XG4gICAgICAgICAgICBkZWxldGUgY3VycmVudExpbmVTdHlsZXNbbnVtZXJpY0luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZvcmNlQ2xlYXJDYWNoZSA9IHRydWU7XG4gICAgICBpZiAoY29waWVkU3R5bGUpIHtcbiAgICAgICAgd2hpbGUgKHF1YW50aXR5LS0pIHtcbiAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKGNvcGllZFN0eWxlW3F1YW50aXR5XSkubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLnN0eWxlc1tsaW5lSW5kZXhdKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleF1bY2hhckluZGV4ICsgcXVhbnRpdHldID0gY2xvbmUoY29waWVkU3R5bGVbcXVhbnRpdHldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWN1cnJlbnRMaW5lU3R5bGVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdTdHlsZSA9IGN1cnJlbnRMaW5lU3R5bGVzW2NoYXJJbmRleCA/IGNoYXJJbmRleCAtIDEgOiAxXTtcbiAgICAgIHdoaWxlIChuZXdTdHlsZSAmJiBxdWFudGl0eS0tKSB7XG4gICAgICAgIHRoaXMuc3R5bGVzW2xpbmVJbmRleF1bY2hhckluZGV4ICsgcXVhbnRpdHldID0gY2xvbmUobmV3U3R5bGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIHN0eWxlIG9iamVjdChzKVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGluc2VydGVkVGV4dCBDaGFyYWN0ZXJzIGF0IHRoZSBsb2NhdGlvbiB3aGVyZSBzdHlsZSBpcyBpbnNlcnRlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBjdXJzb3IgaW5kZXggZm9yIGluc2VydGluZyBzdHlsZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb3BpZWRTdHlsZV0gYXJyYXkgb2Ygc3R5bGUgb2JqZWN0cyB0byBpbnNlcnQuXG4gICAgICovXG4gICAgaW5zZXJ0TmV3U3R5bGVCbG9jazogZnVuY3Rpb24oaW5zZXJ0ZWRUZXh0LCBzdGFydCwgY29waWVkU3R5bGUpIHtcbiAgICAgIHZhciBjdXJzb3JMb2MgPSB0aGlzLmdldDJEQ3Vyc29yTG9jYXRpb24oc3RhcnQsIHRydWUpLFxuICAgICAgICAgIGFkZGVkTGluZXMgPSBbMF0sIGxpbmVzTGVuZ3RoID0gMDtcbiAgICAgIC8vIGdldCBhbiBhcnJheSBvZiBob3cgbWFueSBjaGFyIHBlciBsaW5lcyBhcmUgYmVpbmcgYWRkZWQuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluc2VydGVkVGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaW5zZXJ0ZWRUZXh0W2ldID09PSAnXFxuJykge1xuICAgICAgICAgIGxpbmVzTGVuZ3RoKys7XG4gICAgICAgICAgYWRkZWRMaW5lc1tsaW5lc0xlbmd0aF0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGFkZGVkTGluZXNbbGluZXNMZW5ndGhdKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGZvciB0aGUgZmlyc3QgbGluZSBjb3B5IHRoZSBzdHlsZSBmcm9tIHRoZSBjdXJyZW50IGNoYXIgcG9zaXRpb24uXG4gICAgICBpZiAoYWRkZWRMaW5lc1swXSA+IDApIHtcbiAgICAgICAgdGhpcy5pbnNlcnRDaGFyU3R5bGVPYmplY3QoY3Vyc29yTG9jLmxpbmVJbmRleCwgY3Vyc29yTG9jLmNoYXJJbmRleCwgYWRkZWRMaW5lc1swXSwgY29waWVkU3R5bGUpO1xuICAgICAgICBjb3BpZWRTdHlsZSA9IGNvcGllZFN0eWxlICYmIGNvcGllZFN0eWxlLnNsaWNlKGFkZGVkTGluZXNbMF0gKyAxKTtcbiAgICAgIH1cbiAgICAgIGxpbmVzTGVuZ3RoICYmIHRoaXMuaW5zZXJ0TmV3bGluZVN0eWxlT2JqZWN0KFxuICAgICAgICBjdXJzb3JMb2MubGluZUluZGV4LCBjdXJzb3JMb2MuY2hhckluZGV4ICsgYWRkZWRMaW5lc1swXSwgbGluZXNMZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsaW5lc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhZGRlZExpbmVzW2ldID4gMCkge1xuICAgICAgICAgIHRoaXMuaW5zZXJ0Q2hhclN0eWxlT2JqZWN0KGN1cnNvckxvYy5saW5lSW5kZXggKyBpLCAwLCBhZGRlZExpbmVzW2ldLCBjb3BpZWRTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29waWVkU3R5bGUpIHtcbiAgICAgICAgICAvLyB0aGlzIHRlc3QgaXMgcmVxdWlyZWQgaW4gb3JkZXIgdG8gY2xvc2UgIzY4NDFcbiAgICAgICAgICAvLyB3aGVuIGEgcGFzdGVkIGJ1ZmZlciBiZWdpbnMgd2l0aCBhIG5ld2xpbmUgdGhlblxuICAgICAgICAgIC8vIHRoaXMuc3R5bGVzW2N1cnNvckxvYy5saW5lSW5kZXggKyBpXSBhbmQgY29waWVkU3R5bGVbMF1cbiAgICAgICAgICAvLyBtYXkgYmUgdW5kZWZpbmVkIGZvciBzb21lIHJlYXNvblxuICAgICAgICAgIGlmICh0aGlzLnN0eWxlc1tjdXJzb3JMb2MubGluZUluZGV4ICsgaV0gJiYgY29waWVkU3R5bGVbMF0pIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzW2N1cnNvckxvYy5saW5lSW5kZXggKyBpXVswXSA9IGNvcGllZFN0eWxlWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb3BpZWRTdHlsZSA9IGNvcGllZFN0eWxlICYmIGNvcGllZFN0eWxlLnNsaWNlKGFkZGVkTGluZXNbaV0gKyAxKTtcbiAgICAgIH1cbiAgICAgIC8vIHdlIHVzZSBpIG91dHNpZGUgdGhlIGxvb3AgdG8gZ2V0IGl0IGxpa2UgbGluZXNMZW5ndGhcbiAgICAgIGlmIChhZGRlZExpbmVzW2ldID4gMCkge1xuICAgICAgICB0aGlzLmluc2VydENoYXJTdHlsZU9iamVjdChjdXJzb3JMb2MubGluZUluZGV4ICsgaSwgMCwgYWRkZWRMaW5lc1tpXSwgY29waWVkU3R5bGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHNlbGVjdGlvblN0YXJ0IGFuZCBzZWxlY3Rpb25FbmQgYWNjb3JkaW5nIHRvIHRoZSBuZXcgcG9zaXRpb24gb2YgY3Vyc29yXG4gICAgICogbWltaWMgdGhlIGtleSAtIG1vdXNlIG5hdmlnYXRpb24gd2hlbiBzaGlmdCBpcyBwcmVzc2VkLlxuICAgICAqL1xuICAgIHNldFNlbGVjdGlvblN0YXJ0RW5kV2l0aFNoaWZ0OiBmdW5jdGlvbihzdGFydCwgZW5kLCBuZXdTZWxlY3Rpb24pIHtcbiAgICAgIGlmIChuZXdTZWxlY3Rpb24gPD0gc3RhcnQpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gc3RhcnQpIHtcbiAgICAgICAgICB0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPSAnbGVmdCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ2xlZnQnO1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvbjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG5ld1NlbGVjdGlvbiA+IHN0YXJ0ICYmIG5ld1NlbGVjdGlvbiA8IGVuZCkge1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25FbmQgPSBuZXdTZWxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IG5ld1NlbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIG5ld1NlbGVjdGlvbiBpcyA+IHNlbGVjdGlvbiBzdGFydCBhbmQgZW5kXG4gICAgICAgIGlmIChlbmQgPT09IHN0YXJ0KSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9zZWxlY3Rpb25EaXJlY3Rpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdyaWdodCc7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IG5ld1NlbGVjdGlvbjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0U2VsZWN0aW9uSW5Cb3VuZGFyaWVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsZW5ndGggPSB0aGlzLnRleHQubGVuZ3RoO1xuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPiBsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPCAwKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uRW5kID4gbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5zZWxlY3Rpb25FbmQgPCAwKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufSkoKTtcblxuXG5mYWJyaWMudXRpbC5vYmplY3QuZXh0ZW5kKGZhYnJpYy5JVGV4dC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgZmFicmljLklUZXh0LnByb3RvdHlwZSAqLyB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBcImRiY2xpY2tcIiBldmVudCBoYW5kbGVyXG4gICAqL1xuICBpbml0RG91YmxlQ2xpY2tTaW11bGF0aW9uOiBmdW5jdGlvbigpIHtcblxuICAgIC8vIGZvciBkb3VibGUgY2xpY2tcbiAgICB0aGlzLl9fbGFzdENsaWNrVGltZSA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgLy8gZm9yIHRyaXBsZSBjbGlja1xuICAgIHRoaXMuX19sYXN0TGFzdENsaWNrVGltZSA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgdGhpcy5fX2xhc3RQb2ludGVyID0geyB9O1xuXG4gICAgdGhpcy5vbignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlZmF1bHQgZXZlbnQgaGFuZGxlciB0byBzaW11bGF0ZSB0cmlwbGUgY2xpY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uTW91c2VEb3duOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9fbmV3Q2xpY2tUaW1lID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG5ld1BvaW50ZXIgPSBvcHRpb25zLnBvaW50ZXI7XG4gICAgaWYgKHRoaXMuaXNUcmlwbGVDbGljayhuZXdQb2ludGVyKSkge1xuICAgICAgdGhpcy5maXJlKCd0cmlwbGVjbGljaycsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5fc3RvcEV2ZW50KG9wdGlvbnMuZSk7XG4gICAgfVxuICAgIHRoaXMuX19sYXN0TGFzdENsaWNrVGltZSA9IHRoaXMuX19sYXN0Q2xpY2tUaW1lO1xuICAgIHRoaXMuX19sYXN0Q2xpY2tUaW1lID0gdGhpcy5fX25ld0NsaWNrVGltZTtcbiAgICB0aGlzLl9fbGFzdFBvaW50ZXIgPSBuZXdQb2ludGVyO1xuICAgIHRoaXMuX19sYXN0SXNFZGl0aW5nID0gdGhpcy5pc0VkaXRpbmc7XG4gICAgdGhpcy5fX2xhc3RTZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWQ7XG4gIH0sXG5cbiAgaXNUcmlwbGVDbGljazogZnVuY3Rpb24obmV3UG9pbnRlcikge1xuICAgIHJldHVybiB0aGlzLl9fbmV3Q2xpY2tUaW1lIC0gdGhpcy5fX2xhc3RDbGlja1RpbWUgPCA1MDAgJiZcbiAgICAgICAgdGhpcy5fX2xhc3RDbGlja1RpbWUgLSB0aGlzLl9fbGFzdExhc3RDbGlja1RpbWUgPCA1MDAgJiZcbiAgICAgICAgdGhpcy5fX2xhc3RQb2ludGVyLnggPT09IG5ld1BvaW50ZXIueCAmJlxuICAgICAgICB0aGlzLl9fbGFzdFBvaW50ZXIueSA9PT0gbmV3UG9pbnRlci55O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3N0b3BFdmVudDogZnVuY3Rpb24oZSkge1xuICAgIGUucHJldmVudERlZmF1bHQgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uICYmIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGV2ZW50IGhhbmRsZXJzIHJlbGF0ZWQgdG8gY3Vyc29yIG9yIHNlbGVjdGlvblxuICAgKi9cbiAgaW5pdEN1cnNvclNlbGVjdGlvbkhhbmRsZXJzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluaXRNb3VzZWRvd25IYW5kbGVyKCk7XG4gICAgdGhpcy5pbml0TW91c2V1cEhhbmRsZXIoKTtcbiAgICB0aGlzLmluaXRDbGlja3MoKTtcbiAgfSxcblxuICAvKipcbiAgICogRGVmYXVsdCBoYW5kbGVyIGZvciBkb3VibGUgY2xpY2ssIHNlbGVjdCBhIHdvcmRcbiAgICovXG4gIGRvdWJsZUNsaWNrSGFuZGxlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZWxlY3RXb3JkKHRoaXMuZ2V0U2VsZWN0aW9uU3RhcnRGcm9tUG9pbnRlcihvcHRpb25zLmUpKTtcbiAgfSxcblxuICAvKipcbiAgICogRGVmYXVsdCBoYW5kbGVyIGZvciB0cmlwbGUgY2xpY2ssIHNlbGVjdCBhIGxpbmVcbiAgICovXG4gIHRyaXBsZUNsaWNrSGFuZGxlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZWxlY3RMaW5lKHRoaXMuZ2V0U2VsZWN0aW9uU3RhcnRGcm9tUG9pbnRlcihvcHRpb25zLmUpKTtcbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgZG91YmxlIGFuZCB0cmlwbGUgY2xpY2sgZXZlbnQgaGFuZGxlcnNcbiAgICovXG4gIGluaXRDbGlja3M6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMub24oJ21vdXNlZGJsY2xpY2snLCB0aGlzLmRvdWJsZUNsaWNrSGFuZGxlcik7XG4gICAgdGhpcy5vbigndHJpcGxlY2xpY2snLCB0aGlzLnRyaXBsZUNsaWNrSGFuZGxlcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlZmF1bHQgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdGllcyBuZWVkZWQgb24gX21vdXNlRG93blxuICAgKiBjYW4gYmUgb3ZlcnJpZGRlbiB0byBkbyBzb21ldGhpbmcgZGlmZmVyZW50LlxuICAgKiBTY29wZSBvZiB0aGlzIGltcGxlbWVudGF0aW9uIGlzOiBmaW5kIHRoZSBjbGljayBwb3NpdGlvbiwgc2V0IHNlbGVjdGlvblN0YXJ0XG4gICAqIGZpbmQgc2VsZWN0aW9uRW5kLCBpbml0aWFsaXplIHRoZSBkcmF3aW5nIG9mIGVpdGhlciBjdXJzb3Igb3Igc2VsZWN0aW9uIGFyZWFcbiAgICogaW5pdGlhbGl6aW5nIGEgbW91c2VkRG93biBvbiBhIHRleHQgYXJlYSB3aWxsIGNhbmNlbCBmYWJyaWNqcyBrbm93bGVkZ2Ugb2ZcbiAgICogY3VycmVudCBjb21wb3NpdGlvbk1vZGUuIEl0IHdpbGwgYmUgc2V0IHRvIGZhbHNlLlxuICAgKi9cbiAgX21vdXNlRG93bkhhbmRsZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuY2FudmFzIHx8ICF0aGlzLmVkaXRhYmxlIHx8IChvcHRpb25zLmUuYnV0dG9uICYmIG9wdGlvbnMuZS5idXR0b24gIT09IDEpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fX2lzTW91c2Vkb3duID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICB0aGlzLmluQ29tcG9zaXRpb25Nb2RlID0gZmFsc2U7XG4gICAgICB0aGlzLnNldEN1cnNvckJ5Q2xpY2sob3B0aW9ucy5lKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgIHRoaXMuX19zZWxlY3Rpb25TdGFydE9uTW91c2VEb3duID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgICB0aGlzLmFib3J0Q3Vyc29yQW5pbWF0aW9uKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlckN1cnNvck9yU2VsZWN0aW9uKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBiYXNpYyBmdW5jdGlvbmFsaXRpZXMgbmVlZGVkIG9uIG1vdXNlZG93bjpiZWZvcmVcbiAgICogY2FuIGJlIG92ZXJyaWRkZW4gdG8gZG8gc29tZXRoaW5nIGRpZmZlcmVudC5cbiAgICogU2NvcGUgb2YgdGhpcyBpbXBsZW1lbnRhdGlvbiBpczogdmVyaWZ5IHRoZSBvYmplY3QgaXMgYWxyZWFkeSBzZWxlY3RlZCB3aGVuIG1vdXNpbmcgZG93blxuICAgKi9cbiAgX21vdXNlRG93bkhhbmRsZXJCZWZvcmU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuY2FudmFzIHx8ICF0aGlzLmVkaXRhYmxlIHx8IChvcHRpb25zLmUuYnV0dG9uICYmIG9wdGlvbnMuZS5idXR0b24gIT09IDEpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHdlIHdhbnQgdG8gYXZvaWQgdGhhdCBhbiBvYmplY3QgdGhhdCB3YXMgc2VsZWN0ZWQgYW5kIHRoZW4gYmVjb21lcyB1bnNlbGVjdGFibGUsXG4gICAgLy8gbWF5IHRyaWdnZXIgZWRpdGluZyBtb2RlIGluIHNvbWUgd2F5LlxuICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzID09PSB0aGlzLmNhbnZhcy5fYWN0aXZlT2JqZWN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBcIm1vdXNlZG93blwiIGV2ZW50IGhhbmRsZXJcbiAgICovXG4gIGluaXRNb3VzZWRvd25IYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm9uKCdtb3VzZWRvd24nLCB0aGlzLl9tb3VzZURvd25IYW5kbGVyKTtcbiAgICB0aGlzLm9uKCdtb3VzZWRvd246YmVmb3JlJywgdGhpcy5fbW91c2VEb3duSGFuZGxlckJlZm9yZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIFwibW91c2V1cFwiIGV2ZW50IGhhbmRsZXJcbiAgICovXG4gIGluaXRNb3VzZXVwSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5vbignbW91c2V1cCcsIHRoaXMubW91c2VVcEhhbmRsZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBzdGFuZGFyZCBoYW5kbGVyIGZvciBtb3VzZSB1cCwgb3ZlcnJpZGFibGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG1vdXNlVXBIYW5kbGVyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5fX2lzTW91c2Vkb3duID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLmVkaXRhYmxlIHx8IHRoaXMuZ3JvdXAgfHxcbiAgICAgIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvcHRpb25zLnRyYW5zZm9ybS5hY3Rpb25QZXJmb3JtZWQpIHx8XG4gICAgICAob3B0aW9ucy5lLmJ1dHRvbiAmJiBvcHRpb25zLmUuYnV0dG9uICE9PSAxKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgdmFyIGN1cnJlbnRBY3RpdmUgPSB0aGlzLmNhbnZhcy5fYWN0aXZlT2JqZWN0O1xuICAgICAgaWYgKGN1cnJlbnRBY3RpdmUgJiYgY3VycmVudEFjdGl2ZSAhPT0gdGhpcykge1xuICAgICAgICAvLyBhdm9pZCBydW5uaW5nIHRoaXMgbG9naWMgd2hlbiB0aGVyZSBpcyBhbiBhY3RpdmUgb2JqZWN0XG4gICAgICAgIC8vIHRoaXMgYmVjYXVzZSBpcyBwb3NzaWJsZSB3aXRoIHNoaWZ0IGNsaWNrIGFuZCBmYXN0IGNsaWNrcyxcbiAgICAgICAgLy8gdG8gcmFwaWRseSBkZXNlbGVjdCBhbmQgcmVzZWxlY3QgdGhpcyBvYmplY3QgYW5kIHRyaWdnZXIgYW4gZW50ZXJFZGl0XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fX2xhc3RTZWxlY3RlZCAmJiAhdGhpcy5fX2Nvcm5lcikge1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fX2xhc3RTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5lbnRlckVkaXRpbmcob3B0aW9ucy5lKTtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgICB0aGlzLmluaXREZWxheWVkQ3Vyc29yKHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMucmVuZGVyQ3Vyc29yT3JTZWxlY3Rpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoYW5nZXMgY3Vyc29yIGxvY2F0aW9uIGluIGEgdGV4dCBkZXBlbmRpbmcgb24gcGFzc2VkIHBvaW50ZXIgKHgveSkgb2JqZWN0XG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBzZXRDdXJzb3JCeUNsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIG5ld1NlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uU3RhcnRGcm9tUG9pbnRlcihlKSxcbiAgICAgICAgc3RhcnQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0LCBlbmQgPSB0aGlzLnNlbGVjdGlvbkVuZDtcbiAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgdGhpcy5zZXRTZWxlY3Rpb25TdGFydEVuZFdpdGhTaGlmdChzdGFydCwgZW5kLCBuZXdTZWxlY3Rpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBuZXdTZWxlY3Rpb247XG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IG5ld1NlbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNFZGl0aW5nKSB7XG4gICAgICB0aGlzLl9maXJlU2VsZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgdGhpcy5fdXBkYXRlVGV4dGFyZWEoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgaW5kZXggb2YgYSBjaGFyYWN0ZXIgY29ycmVzcG9uZGluZyB0byB3aGVyZSBhbiBvYmplY3Qgd2FzIGNsaWNrZWRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICogQHJldHVybiB7TnVtYmVyfSBJbmRleCBvZiBhIGNoYXJhY3RlclxuICAgKi9cbiAgZ2V0U2VsZWN0aW9uU3RhcnRGcm9tUG9pbnRlcjogZnVuY3Rpb24oZSkge1xuICAgIHZhciBtb3VzZU9mZnNldCA9IHRoaXMuZ2V0TG9jYWxQb2ludGVyKGUpLFxuICAgICAgICBwcmV2V2lkdGggPSAwLFxuICAgICAgICB3aWR0aCA9IDAsXG4gICAgICAgIGhlaWdodCA9IDAsXG4gICAgICAgIGNoYXJJbmRleCA9IDAsXG4gICAgICAgIGxpbmVJbmRleCA9IDAsXG4gICAgICAgIGxpbmVMZWZ0T2Zmc2V0LFxuICAgICAgICBsaW5lO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl90ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChoZWlnaHQgPD0gbW91c2VPZmZzZXQueSkge1xuICAgICAgICBoZWlnaHQgKz0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaSkgKiB0aGlzLnNjYWxlWTtcbiAgICAgICAgbGluZUluZGV4ID0gaTtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgY2hhckluZGV4ICs9IHRoaXMuX3RleHRMaW5lc1tpIC0gMV0ubGVuZ3RoICsgdGhpcy5taXNzaW5nTmV3bGluZU9mZnNldChpIC0gMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgbGluZUxlZnRPZmZzZXQgPSB0aGlzLl9nZXRMaW5lTGVmdE9mZnNldChsaW5lSW5kZXgpO1xuICAgIHdpZHRoID0gbGluZUxlZnRPZmZzZXQgKiB0aGlzLnNjYWxlWDtcbiAgICBsaW5lID0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF07XG4gICAgLy8gaGFuZGxpbmcgb2YgUlRMOiBpbiBvcmRlciB0byBnZXQgdGhpbmdzIHdvcmsgY29ycmVjdGx5LFxuICAgIC8vIHdlIGFzc3VtZSBSVEwgd3JpdGluZyBpcyBtaXJyb3JlZCBjb21wYXJlZCB0byBMVFIgd3JpdGluZy5cbiAgICAvLyBzbyBpbiBwb3NpdGlvbiBkZXRlY3Rpb24gd2UgbWlycm9yIHRoZSBYIG9mZnNldCwgYW5kIHdoZW4gaXMgdGltZVxuICAgIC8vIG9mIHJlbmRlcmluZyBpdCwgd2UgbWlycm9yIGl0IGFnYWluLlxuICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICAgIG1vdXNlT2Zmc2V0LnggPSB0aGlzLndpZHRoICogdGhpcy5zY2FsZVggLSBtb3VzZU9mZnNldC54ICsgd2lkdGg7XG4gICAgfVxuICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gbGluZS5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgIHByZXZXaWR0aCA9IHdpZHRoO1xuICAgICAgLy8gaSByZW1vdmVkIHNvbWV0aGluZyBhYm91dCBmbGlwWCBoZXJlLCBjaGVjay5cbiAgICAgIHdpZHRoICs9IHRoaXMuX19jaGFyQm91bmRzW2xpbmVJbmRleF1bal0ua2VybmVkV2lkdGggKiB0aGlzLnNjYWxlWDtcbiAgICAgIGlmICh3aWR0aCA8PSBtb3VzZU9mZnNldC54KSB7XG4gICAgICAgIGNoYXJJbmRleCsrO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZ2V0TmV3U2VsZWN0aW9uU3RhcnRGcm9tT2Zmc2V0KG1vdXNlT2Zmc2V0LCBwcmV2V2lkdGgsIHdpZHRoLCBjaGFySW5kZXgsIGpsZW4pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldE5ld1NlbGVjdGlvblN0YXJ0RnJvbU9mZnNldDogZnVuY3Rpb24obW91c2VPZmZzZXQsIHByZXZXaWR0aCwgd2lkdGgsIGluZGV4LCBqbGVuKSB7XG4gICAgLy8gd2UgbmVlZCBNYXRoLmFicyBiZWNhdXNlIHdoZW4gd2lkdGggaXMgYWZ0ZXIgdGhlIGxhc3QgY2hhciwgdGhlIG9mZnNldCBpcyBnaXZlbiBhcyAxLCB3aGlsZSBpcyAwXG4gICAgdmFyIGRpc3RhbmNlQnR3TGFzdENoYXJBbmRDdXJzb3IgPSBtb3VzZU9mZnNldC54IC0gcHJldldpZHRoLFxuICAgICAgICBkaXN0YW5jZUJ0d05leHRDaGFyQW5kQ3Vyc29yID0gd2lkdGggLSBtb3VzZU9mZnNldC54LFxuICAgICAgICBvZmZzZXQgPSBkaXN0YW5jZUJ0d05leHRDaGFyQW5kQ3Vyc29yID4gZGlzdGFuY2VCdHdMYXN0Q2hhckFuZEN1cnNvciB8fFxuICAgICAgICAgIGRpc3RhbmNlQnR3TmV4dENoYXJBbmRDdXJzb3IgPCAwID8gMCA6IDEsXG4gICAgICAgIG5ld1NlbGVjdGlvblN0YXJ0ID0gaW5kZXggKyBvZmZzZXQ7XG4gICAgLy8gaWYgb2JqZWN0IGlzIGhvcml6b250YWxseSBmbGlwcGVkLCBtaXJyb3IgY3Vyc29yIGxvY2F0aW9uIGZyb20gdGhlIGVuZFxuICAgIGlmICh0aGlzLmZsaXBYKSB7XG4gICAgICBuZXdTZWxlY3Rpb25TdGFydCA9IGpsZW4gLSBuZXdTZWxlY3Rpb25TdGFydDtcbiAgICB9XG5cbiAgICBpZiAobmV3U2VsZWN0aW9uU3RhcnQgPiB0aGlzLl90ZXh0Lmxlbmd0aCkge1xuICAgICAgbmV3U2VsZWN0aW9uU3RhcnQgPSB0aGlzLl90ZXh0Lmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3U2VsZWN0aW9uU3RhcnQ7XG4gIH1cbn0pO1xuXG5cbmZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLklUZXh0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBmYWJyaWMuSVRleHQucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgaGlkZGVuIHRleHRhcmVhIChuZWVkZWQgdG8gYnJpbmcgdXAga2V5Ym9hcmQgaW4gaU9TKVxuICAgKi9cbiAgaW5pdEhpZGRlblRleHRhcmVhOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhID0gZmFicmljLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZXRBdHRyaWJ1dGUoJ2F1dG9jYXBpdGFsaXplJywgJ29mZicpO1xuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2V0QXR0cmlidXRlKCdhdXRvY29ycmVjdCcsICdvZmYnKTtcbiAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNldEF0dHJpYnV0ZSgnYXV0b2NvbXBsZXRlJywgJ29mZicpO1xuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2V0QXR0cmlidXRlKCdzcGVsbGNoZWNrJywgJ2ZhbHNlJyk7XG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zZXRBdHRyaWJ1dGUoJ2RhdGEtZmFicmljLWhpZGRlbnRleHRhcmVhJywgJycpO1xuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2V0QXR0cmlidXRlKCd3cmFwJywgJ29mZicpO1xuICAgIHZhciBzdHlsZSA9IHRoaXMuX2NhbGNUZXh0YXJlYVBvc2l0aW9uKCk7XG4gICAgLy8gbGluZS1oZWlnaHQ6IDFweDsgd2FzIHJlbW92ZWQgZnJvbSB0aGUgc3R5bGUgdG8gZml4IHRoaXM6XG4gICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODcwOTY2XG4gICAgdGhpcy5oaWRkZW5UZXh0YXJlYS5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAnICsgc3R5bGUudG9wICtcbiAgICAnOyBsZWZ0OiAnICsgc3R5bGUubGVmdCArICc7IHotaW5kZXg6IC05OTk7IG9wYWNpdHk6IDA7IHdpZHRoOiAxcHg7IGhlaWdodDogMXB4OyBmb250LXNpemU6IDFweDsnICtcbiAgICAnIHBhZGRpbmctdG9wOiAnICsgc3R5bGUuZm9udFNpemUgKyAnOyc7XG5cbiAgICBpZiAodGhpcy5oaWRkZW5UZXh0YXJlYUNvbnRhaW5lcikge1xuICAgICAgdGhpcy5oaWRkZW5UZXh0YXJlYUNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmhpZGRlblRleHRhcmVhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmYWJyaWMuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmhpZGRlblRleHRhcmVhKTtcbiAgICB9XG5cbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAna2V5ZG93bicsIHRoaXMub25LZXlEb3duLmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdrZXl1cCcsIHRoaXMub25LZXlVcC5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAnaW5wdXQnLCB0aGlzLm9uSW5wdXQuYmluZCh0aGlzKSk7XG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ2NvcHknLCB0aGlzLmNvcHkuYmluZCh0aGlzKSk7XG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ2N1dCcsIHRoaXMuY29weS5iaW5kKHRoaXMpKTtcbiAgICBmYWJyaWMudXRpbC5hZGRMaXN0ZW5lcih0aGlzLmhpZGRlblRleHRhcmVhLCAncGFzdGUnLCB0aGlzLnBhc3RlLmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdjb21wb3NpdGlvbnN0YXJ0JywgdGhpcy5vbkNvbXBvc2l0aW9uU3RhcnQuYmluZCh0aGlzKSk7XG4gICAgZmFicmljLnV0aWwuYWRkTGlzdGVuZXIodGhpcy5oaWRkZW5UZXh0YXJlYSwgJ2NvbXBvc2l0aW9udXBkYXRlJywgdGhpcy5vbkNvbXBvc2l0aW9uVXBkYXRlLmJpbmQodGhpcykpO1xuICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuaGlkZGVuVGV4dGFyZWEsICdjb21wb3NpdGlvbmVuZCcsIHRoaXMub25Db21wb3NpdGlvbkVuZC5iaW5kKHRoaXMpKTtcblxuICAgIGlmICghdGhpcy5fY2xpY2tIYW5kbGVySW5pdGlhbGl6ZWQgJiYgdGhpcy5jYW52YXMpIHtcbiAgICAgIGZhYnJpYy51dGlsLmFkZExpc3RlbmVyKHRoaXMuY2FudmFzLnVwcGVyQ2FudmFzRWwsICdjbGljaycsIHRoaXMub25DbGljay5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuX2NsaWNrSGFuZGxlckluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvciBmdW5jdGlvbmFsaXRpZXMgb24ga2V5RG93blxuICAgKiBNYXAgYSBzcGVjaWFsIGtleSB0byBhIGZ1bmN0aW9uIG9mIHRoZSBpbnN0YW5jZS9wcm90b3R5cGVcbiAgICogSWYgeW91IG5lZWQgZGlmZmVyZW50IGJlaGF2aW91ciBmb3IgRVNDIG9yIFRBQiBvciBhcnJvd3MsIHlvdSBoYXZlIHRvIGNoYW5nZVxuICAgKiB0aGlzIG1hcCBzZXR0aW5nIHRoZSBuYW1lIG9mIGEgZnVuY3Rpb24gdGhhdCB5b3UgYnVpbGQgb24gdGhlIGZhYnJpYy5JdGV4dCBvclxuICAgKiB5b3VyIHByb3RvdHlwZS5cbiAgICogdGhlIG1hcCBjaGFuZ2Ugd2lsbCBhZmZlY3QgYWxsIEluc3RhbmNlcyB1bmxlc3MgeW91IG5lZWQgZm9yIG9ubHkgc29tZSB0ZXh0IEluc3RhbmNlc1xuICAgKiBpbiB0aGF0IGNhc2UgeW91IGhhdmUgdG8gY2xvbmUgdGhpcyBvYmplY3QgYW5kIGFzc2lnbiB5b3VyIEluc3RhbmNlLlxuICAgKiB0aGlzLmtleXNNYXAgPSBmYWJyaWMudXRpbC5vYmplY3QuY2xvbmUodGhpcy5rZXlzTWFwKTtcbiAgICogVGhlIGZ1bmN0aW9uIG11c3QgYmUgaW4gZmFicmljLkl0ZXh0LnByb3RvdHlwZS5teUZ1bmN0aW9uIEFuZCB3aWxsIHJlY2VpdmUgZXZlbnQgYXMgYXJnc1swXVxuICAgKi9cbiAga2V5c01hcDoge1xuICAgIDk6ICAnZXhpdEVkaXRpbmcnLFxuICAgIDI3OiAnZXhpdEVkaXRpbmcnLFxuICAgIDMzOiAnbW92ZUN1cnNvclVwJyxcbiAgICAzNDogJ21vdmVDdXJzb3JEb3duJyxcbiAgICAzNTogJ21vdmVDdXJzb3JSaWdodCcsXG4gICAgMzY6ICdtb3ZlQ3Vyc29yTGVmdCcsXG4gICAgMzc6ICdtb3ZlQ3Vyc29yTGVmdCcsXG4gICAgMzg6ICdtb3ZlQ3Vyc29yVXAnLFxuICAgIDM5OiAnbW92ZUN1cnNvclJpZ2h0JyxcbiAgICA0MDogJ21vdmVDdXJzb3JEb3duJyxcbiAgfSxcblxuICBrZXlzTWFwUnRsOiB7XG4gICAgOTogICdleGl0RWRpdGluZycsXG4gICAgMjc6ICdleGl0RWRpdGluZycsXG4gICAgMzM6ICdtb3ZlQ3Vyc29yVXAnLFxuICAgIDM0OiAnbW92ZUN1cnNvckRvd24nLFxuICAgIDM1OiAnbW92ZUN1cnNvckxlZnQnLFxuICAgIDM2OiAnbW92ZUN1cnNvclJpZ2h0JyxcbiAgICAzNzogJ21vdmVDdXJzb3JSaWdodCcsXG4gICAgMzg6ICdtb3ZlQ3Vyc29yVXAnLFxuICAgIDM5OiAnbW92ZUN1cnNvckxlZnQnLFxuICAgIDQwOiAnbW92ZUN1cnNvckRvd24nLFxuICB9LFxuXG4gIC8qKlxuICAgKiBGb3IgZnVuY3Rpb25hbGl0aWVzIG9uIGtleVVwICsgY3RybCB8fCBjbWRcbiAgICovXG4gIGN0cmxLZXlzTWFwVXA6IHtcbiAgICA2NzogJ2NvcHknLFxuICAgIDg4OiAnY3V0J1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3IgZnVuY3Rpb25hbGl0aWVzIG9uIGtleURvd24gKyBjdHJsIHx8IGNtZFxuICAgKi9cbiAgY3RybEtleXNNYXBEb3duOiB7XG4gICAgNjU6ICdzZWxlY3RBbGwnXG4gIH0sXG5cbiAgb25DbGljazogZnVuY3Rpb24oKSB7XG4gICAgLy8gTm8gbmVlZCB0byB0cmlnZ2VyIGNsaWNrIGV2ZW50IGhlcmUsIGZvY3VzIGlzIGVub3VnaCB0byBoYXZlIHRoZSBrZXlib2FyZCBhcHBlYXIgb24gQW5kcm9pZFxuICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEgJiYgdGhpcy5oaWRkZW5UZXh0YXJlYS5mb2N1cygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGtleWRvd24gZXZlbnRcbiAgICogb25seSB1c2VkIGZvciBhcnJvd3MgYW5kIGNvbWJpbmF0aW9uIG9mIG1vZGlmaWVyIGtleXMuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBvbktleURvd246IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoIXRoaXMuaXNFZGl0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBrZXlNYXAgPSB0aGlzLmRpcmVjdGlvbiA9PT0gJ3J0bCcgPyB0aGlzLmtleXNNYXBSdGwgOiB0aGlzLmtleXNNYXA7XG4gICAgaWYgKGUua2V5Q29kZSBpbiBrZXlNYXApIHtcbiAgICAgIHRoaXNba2V5TWFwW2Uua2V5Q29kZV1dKGUpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoZS5rZXlDb2RlIGluIHRoaXMuY3RybEtleXNNYXBEb3duKSAmJiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkpIHtcbiAgICAgIHRoaXNbdGhpcy5jdHJsS2V5c01hcERvd25bZS5rZXlDb2RlXV0oZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoZS5rZXlDb2RlID49IDMzICYmIGUua2V5Q29kZSA8PSA0MCkge1xuICAgICAgLy8gaWYgaSBwcmVzcyBhbiBhcnJvdyBrZXkganVzdCB1cGRhdGUgc2VsZWN0aW9uXG4gICAgICB0aGlzLmluQ29tcG9zaXRpb25Nb2RlID0gZmFsc2U7XG4gICAgICB0aGlzLmNsZWFyQ29udGV4dFRvcCgpO1xuICAgICAgdGhpcy5yZW5kZXJDdXJzb3JPclNlbGVjdGlvbigpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnJlcXVlc3RSZW5kZXJBbGwoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhhbmRsZXMga2V5dXAgZXZlbnRcbiAgICogV2UgaGFuZGxlIEtleVVwIGJlY2F1c2UgaWUxMSBhbmQgZWRnZSBoYXZlIGRpZmZpY3VsdGllcyBjb3B5L3Bhc3RpbmdcbiAgICogaWYgYSBjb3B5L2N1dCBldmVudCBmaXJlZCwga2V5dXAgaXMgZGlzbWlzc2VkXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBvbktleVVwOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCF0aGlzLmlzRWRpdGluZyB8fCB0aGlzLl9jb3B5RG9uZSB8fCB0aGlzLmluQ29tcG9zaXRpb25Nb2RlKSB7XG4gICAgICB0aGlzLl9jb3B5RG9uZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoKGUua2V5Q29kZSBpbiB0aGlzLmN0cmxLZXlzTWFwVXApICYmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSkge1xuICAgICAgdGhpc1t0aGlzLmN0cmxLZXlzTWFwVXBbZS5rZXlDb2RlXV0oZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgb25JbnB1dCBldmVudFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgb25JbnB1dDogZnVuY3Rpb24oZSkge1xuICAgIHZhciBmcm9tUGFzdGUgPSB0aGlzLmZyb21QYXN0ZTtcbiAgICB0aGlzLmZyb21QYXN0ZSA9IGZhbHNlO1xuICAgIGUgJiYgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBpZiAoIXRoaXMuaXNFZGl0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGRlY2lzaW9ucyBhYm91dCBzdHlsZSBjaGFuZ2VzLlxuICAgIHZhciBuZXh0VGV4dCA9IHRoaXMuX3NwbGl0VGV4dEludG9MaW5lcyh0aGlzLmhpZGRlblRleHRhcmVhLnZhbHVlKS5ncmFwaGVtZVRleHQsXG4gICAgICAgIGNoYXJDb3VudCA9IHRoaXMuX3RleHQubGVuZ3RoLFxuICAgICAgICBuZXh0Q2hhckNvdW50ID0gbmV4dFRleHQubGVuZ3RoLFxuICAgICAgICByZW1vdmVkVGV4dCwgaW5zZXJ0ZWRUZXh0LFxuICAgICAgICBjaGFyRGlmZiA9IG5leHRDaGFyQ291bnQgLSBjaGFyQ291bnQsXG4gICAgICAgIHNlbGVjdGlvblN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25FbmQsXG4gICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvblN0YXJ0ICE9PSBzZWxlY3Rpb25FbmQsXG4gICAgICAgIGNvcGllZFN0eWxlLCByZW1vdmVGcm9tLCByZW1vdmVUbztcbiAgICBpZiAodGhpcy5oaWRkZW5UZXh0YXJlYS52YWx1ZSA9PT0gJycpIHtcbiAgICAgIHRoaXMuc3R5bGVzID0geyB9O1xuICAgICAgdGhpcy51cGRhdGVGcm9tVGV4dEFyZWEoKTtcbiAgICAgIHRoaXMuZmlyZSgnY2hhbmdlZCcpO1xuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmZpcmUoJ3RleHQ6Y2hhbmdlZCcsIHsgdGFyZ2V0OiB0aGlzIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5yZXF1ZXN0UmVuZGVyQWxsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRleHRhcmVhU2VsZWN0aW9uID0gdGhpcy5mcm9tU3RyaW5nVG9HcmFwaGVtZVNlbGVjdGlvbihcbiAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEuc2VsZWN0aW9uU3RhcnQsXG4gICAgICB0aGlzLmhpZGRlblRleHRhcmVhLnNlbGVjdGlvbkVuZCxcbiAgICAgIHRoaXMuaGlkZGVuVGV4dGFyZWEudmFsdWVcbiAgICApO1xuICAgIHZhciBiYWNrRGVsZXRlID0gc2VsZWN0aW9uU3RhcnQgPiB0ZXh0YXJlYVNlbGVjdGlvbi5zZWxlY3Rpb25TdGFydDtcblxuICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgIHJlbW92ZWRUZXh0ID0gdGhpcy5fdGV4dC5zbGljZShzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKTtcbiAgICAgIGNoYXJEaWZmICs9IHNlbGVjdGlvbkVuZCAtIHNlbGVjdGlvblN0YXJ0O1xuICAgIH1cbiAgICBlbHNlIGlmIChuZXh0Q2hhckNvdW50IDwgY2hhckNvdW50KSB7XG4gICAgICBpZiAoYmFja0RlbGV0ZSkge1xuICAgICAgICByZW1vdmVkVGV4dCA9IHRoaXMuX3RleHQuc2xpY2Uoc2VsZWN0aW9uRW5kICsgY2hhckRpZmYsIHNlbGVjdGlvbkVuZCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVtb3ZlZFRleHQgPSB0aGlzLl90ZXh0LnNsaWNlKHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25TdGFydCAtIGNoYXJEaWZmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaW5zZXJ0ZWRUZXh0ID0gbmV4dFRleHQuc2xpY2UodGV4dGFyZWFTZWxlY3Rpb24uc2VsZWN0aW9uRW5kIC0gY2hhckRpZmYsIHRleHRhcmVhU2VsZWN0aW9uLnNlbGVjdGlvbkVuZCk7XG4gICAgaWYgKHJlbW92ZWRUZXh0ICYmIHJlbW92ZWRUZXh0Lmxlbmd0aCkge1xuICAgICAgaWYgKGluc2VydGVkVGV4dC5sZW5ndGgpIHtcbiAgICAgICAgLy8gbGV0J3MgY29weSBzb21lIHN0eWxlIGJlZm9yZSBkZWxldGluZy5cbiAgICAgICAgLy8gd2Ugd2FudCB0byBjb3B5IHRoZSBzdHlsZSBiZWZvcmUgdGhlIGN1cnNvciBPUiB0aGUgc3R5bGUgYXQgdGhlIGN1cnNvciBpZiBzZWxlY3Rpb25cbiAgICAgICAgLy8gaXMgYmlnZ2VyIHRoYW4gMC5cbiAgICAgICAgY29waWVkU3R5bGUgPSB0aGlzLmdldFNlbGVjdGlvblN0eWxlcyhzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uU3RhcnQgKyAxLCBmYWxzZSk7XG4gICAgICAgIC8vIG5vdyBkdXBsaWNhdGUgdGhlIHN0eWxlIG9uZSBmb3IgZWFjaCBpbnNlcnRlZCB0ZXh0LlxuICAgICAgICBjb3BpZWRTdHlsZSA9IGluc2VydGVkVGV4dC5tYXAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gdGhpcyByZXR1cm4gYW4gYXJyYXkgb2YgcmVmZXJlbmNlcywgYnV0IHRoYXQgaXMgZmluZSBzaW5jZSB3ZSBhcmVcbiAgICAgICAgICAvLyBjb3B5aW5nIHRoZSBzdHlsZSBsYXRlci5cbiAgICAgICAgICByZXR1cm4gY29waWVkU3R5bGVbMF07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICByZW1vdmVGcm9tID0gc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIHJlbW92ZVRvID0gc2VsZWN0aW9uRW5kO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYmFja0RlbGV0ZSkge1xuICAgICAgICAvLyBkZXRlY3QgZGlmZmVyZW5jZXMgYmV0d2VlbiBmb3J3YXJkRGVsZXRlIGFuZCBiYWNrRGVsZXRlXG4gICAgICAgIHJlbW92ZUZyb20gPSBzZWxlY3Rpb25FbmQgLSByZW1vdmVkVGV4dC5sZW5ndGg7XG4gICAgICAgIHJlbW92ZVRvID0gc2VsZWN0aW9uRW5kO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlbW92ZUZyb20gPSBzZWxlY3Rpb25FbmQ7XG4gICAgICAgIHJlbW92ZVRvID0gc2VsZWN0aW9uRW5kICsgcmVtb3ZlZFRleHQubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW1vdmVTdHlsZUZyb21UbyhyZW1vdmVGcm9tLCByZW1vdmVUbyk7XG4gICAgfVxuICAgIGlmIChpbnNlcnRlZFRleHQubGVuZ3RoKSB7XG4gICAgICBpZiAoZnJvbVBhc3RlICYmIGluc2VydGVkVGV4dC5qb2luKCcnKSA9PT0gZmFicmljLmNvcGllZFRleHQgJiYgIWZhYnJpYy5kaXNhYmxlU3R5bGVDb3B5UGFzdGUpIHtcbiAgICAgICAgY29waWVkU3R5bGUgPSBmYWJyaWMuY29waWVkVGV4dFN0eWxlO1xuICAgICAgfVxuICAgICAgdGhpcy5pbnNlcnROZXdTdHlsZUJsb2NrKGluc2VydGVkVGV4dCwgc2VsZWN0aW9uU3RhcnQsIGNvcGllZFN0eWxlKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVGcm9tVGV4dEFyZWEoKTtcbiAgICB0aGlzLmZpcmUoJ2NoYW5nZWQnKTtcbiAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzLmZpcmUoJ3RleHQ6Y2hhbmdlZCcsIHsgdGFyZ2V0OiB0aGlzIH0pO1xuICAgICAgdGhpcy5jYW52YXMucmVxdWVzdFJlbmRlckFsbCgpO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIENvbXBvc2l0aW9uIHN0YXJ0XG4gICAqL1xuICBvbkNvbXBvc2l0aW9uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5Db21wb3NpdGlvbk1vZGUgPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb21wb3NpdGlvbiBlbmRcbiAgICovXG4gIG9uQ29tcG9zaXRpb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5Db21wb3NpdGlvbk1vZGUgPSBmYWxzZTtcbiAgfSxcblxuICAvLyAvKipcbiAgLy8gICogQ29tcG9zaXRpb24gdXBkYXRlXG4gIC8vICAqL1xuICBvbkNvbXBvc2l0aW9uVXBkYXRlOiBmdW5jdGlvbihlKSB7XG4gICAgdGhpcy5jb21wb3NpdGlvblN0YXJ0ID0gZS50YXJnZXQuc2VsZWN0aW9uU3RhcnQ7XG4gICAgdGhpcy5jb21wb3NpdGlvbkVuZCA9IGUudGFyZ2V0LnNlbGVjdGlvbkVuZDtcbiAgICB0aGlzLnVwZGF0ZVRleHRhcmVhUG9zaXRpb24oKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29waWVzIHNlbGVjdGVkIHRleHRcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIGNvcHk6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgLy9kbyBub3QgY3V0LWNvcHkgaWYgbm8gc2VsZWN0aW9uXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmFicmljLmNvcGllZFRleHQgPSB0aGlzLmdldFNlbGVjdGVkVGV4dCgpO1xuICAgIGlmICghZmFicmljLmRpc2FibGVTdHlsZUNvcHlQYXN0ZSkge1xuICAgICAgZmFicmljLmNvcGllZFRleHRTdHlsZSA9IHRoaXMuZ2V0U2VsZWN0aW9uU3R5bGVzKHRoaXMuc2VsZWN0aW9uU3RhcnQsIHRoaXMuc2VsZWN0aW9uRW5kLCB0cnVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmYWJyaWMuY29waWVkVGV4dFN0eWxlID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fY29weURvbmUgPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQYXN0ZXMgdGV4dFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgcGFzdGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZnJvbVBhc3RlID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICogQHJldHVybiB7T2JqZWN0fSBDbGlwYm9hcmQgZGF0YSBvYmplY3RcbiAgICovXG4gIF9nZXRDbGlwYm9hcmREYXRhOiBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIChlICYmIGUuY2xpcGJvYXJkRGF0YSkgfHwgZmFicmljLndpbmRvdy5jbGlwYm9hcmREYXRhO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgd2lkdGggaW4gcGl4ZWxzIGJlZm9yZSB0aGUgY3Vyc29yIG9uIHRoZSBzYW1lIGxpbmVcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAqIEByZXR1cm4ge051bWJlcn0gd2lkdGhCZWZvcmVDdXJzb3Igd2lkdGggYmVmb3JlIGN1cnNvclxuICAgKi9cbiAgX2dldFdpZHRoQmVmb3JlQ3Vyc29yOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCkge1xuICAgIHZhciB3aWR0aEJlZm9yZUN1cnNvciA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGxpbmVJbmRleCksIGJvdW5kO1xuXG4gICAgaWYgKGNoYXJJbmRleCA+IDApIHtcbiAgICAgIGJvdW5kID0gdGhpcy5fX2NoYXJCb3VuZHNbbGluZUluZGV4XVtjaGFySW5kZXggLSAxXTtcbiAgICAgIHdpZHRoQmVmb3JlQ3Vyc29yICs9IGJvdW5kLmxlZnQgKyBib3VuZC53aWR0aDtcbiAgICB9XG4gICAgcmV0dXJuIHdpZHRoQmVmb3JlQ3Vyc29yO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHN0YXJ0IG9mZnNldCBvZiBhIHNlbGVjdGlvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzUmlnaHRcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0RG93bkN1cnNvck9mZnNldDogZnVuY3Rpb24oZSwgaXNSaWdodCkge1xuICAgIHZhciBzZWxlY3Rpb25Qcm9wID0gdGhpcy5fZ2V0U2VsZWN0aW9uRm9yT2Zmc2V0KGUsIGlzUmlnaHQpLFxuICAgICAgICBjdXJzb3JMb2NhdGlvbiA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihzZWxlY3Rpb25Qcm9wKSxcbiAgICAgICAgbGluZUluZGV4ID0gY3Vyc29yTG9jYXRpb24ubGluZUluZGV4O1xuICAgIC8vIGlmIG9uIGxhc3QgbGluZSwgZG93biBjdXJzb3IgZ29lcyB0byBlbmQgb2YgbGluZVxuICAgIGlmIChsaW5lSW5kZXggPT09IHRoaXMuX3RleHRMaW5lcy5sZW5ndGggLSAxIHx8IGUubWV0YUtleSB8fCBlLmtleUNvZGUgPT09IDM0KSB7XG4gICAgICAvLyBtb3ZlIHRvIHRoZSBlbmQgb2YgYSB0ZXh0XG4gICAgICByZXR1cm4gdGhpcy5fdGV4dC5sZW5ndGggLSBzZWxlY3Rpb25Qcm9wO1xuICAgIH1cbiAgICB2YXIgY2hhckluZGV4ID0gY3Vyc29yTG9jYXRpb24uY2hhckluZGV4LFxuICAgICAgICB3aWR0aEJlZm9yZUN1cnNvciA9IHRoaXMuX2dldFdpZHRoQmVmb3JlQ3Vyc29yKGxpbmVJbmRleCwgY2hhckluZGV4KSxcbiAgICAgICAgaW5kZXhPbk90aGVyTGluZSA9IHRoaXMuX2dldEluZGV4T25MaW5lKGxpbmVJbmRleCArIDEsIHdpZHRoQmVmb3JlQ3Vyc29yKSxcbiAgICAgICAgdGV4dEFmdGVyQ3Vyc29yID0gdGhpcy5fdGV4dExpbmVzW2xpbmVJbmRleF0uc2xpY2UoY2hhckluZGV4KTtcbiAgICByZXR1cm4gdGV4dEFmdGVyQ3Vyc29yLmxlbmd0aCArIGluZGV4T25PdGhlckxpbmUgKyAxICsgdGhpcy5taXNzaW5nTmV3bGluZU9mZnNldChsaW5lSW5kZXgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBwcml2YXRlXG4gICAqIEhlbHBzIGZpbmRpbmcgaWYgdGhlIG9mZnNldCBzaG91bGQgYmUgY291bnRlZCBmcm9tIFN0YXJ0IG9yIEVuZFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzUmlnaHRcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgX2dldFNlbGVjdGlvbkZvck9mZnNldDogZnVuY3Rpb24oZSwgaXNSaWdodCkge1xuICAgIGlmIChlLnNoaWZ0S2V5ICYmIHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IHRoaXMuc2VsZWN0aW9uRW5kICYmIGlzUmlnaHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbkVuZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNSaWdodFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRVcEN1cnNvck9mZnNldDogZnVuY3Rpb24oZSwgaXNSaWdodCkge1xuICAgIHZhciBzZWxlY3Rpb25Qcm9wID0gdGhpcy5fZ2V0U2VsZWN0aW9uRm9yT2Zmc2V0KGUsIGlzUmlnaHQpLFxuICAgICAgICBjdXJzb3JMb2NhdGlvbiA9IHRoaXMuZ2V0MkRDdXJzb3JMb2NhdGlvbihzZWxlY3Rpb25Qcm9wKSxcbiAgICAgICAgbGluZUluZGV4ID0gY3Vyc29yTG9jYXRpb24ubGluZUluZGV4O1xuICAgIGlmIChsaW5lSW5kZXggPT09IDAgfHwgZS5tZXRhS2V5IHx8IGUua2V5Q29kZSA9PT0gMzMpIHtcbiAgICAgIC8vIGlmIG9uIGZpcnN0IGxpbmUsIHVwIGN1cnNvciBnb2VzIHRvIHN0YXJ0IG9mIGxpbmVcbiAgICAgIHJldHVybiAtc2VsZWN0aW9uUHJvcDtcbiAgICB9XG4gICAgdmFyIGNoYXJJbmRleCA9IGN1cnNvckxvY2F0aW9uLmNoYXJJbmRleCxcbiAgICAgICAgd2lkdGhCZWZvcmVDdXJzb3IgPSB0aGlzLl9nZXRXaWR0aEJlZm9yZUN1cnNvcihsaW5lSW5kZXgsIGNoYXJJbmRleCksXG4gICAgICAgIGluZGV4T25PdGhlckxpbmUgPSB0aGlzLl9nZXRJbmRleE9uTGluZShsaW5lSW5kZXggLSAxLCB3aWR0aEJlZm9yZUN1cnNvciksXG4gICAgICAgIHRleHRCZWZvcmVDdXJzb3IgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XS5zbGljZSgwLCBjaGFySW5kZXgpLFxuICAgICAgICBtaXNzaW5nTmV3bGluZU9mZnNldCA9IHRoaXMubWlzc2luZ05ld2xpbmVPZmZzZXQobGluZUluZGV4IC0gMSk7XG4gICAgLy8gcmV0dXJuIGEgbmVnYXRpdmUgb2Zmc2V0XG4gICAgcmV0dXJuIC10aGlzLl90ZXh0TGluZXNbbGluZUluZGV4IC0gMV0ubGVuZ3RoXG4gICAgICsgaW5kZXhPbk90aGVyTGluZSAtIHRleHRCZWZvcmVDdXJzb3IubGVuZ3RoICsgKDEgLSBtaXNzaW5nTmV3bGluZU9mZnNldCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGZvciBhIGdpdmVuIHdpZHRoIGl0IGZvdW5kcyB0aGUgbWF0Y2hpbmcgY2hhcmFjdGVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldEluZGV4T25MaW5lOiBmdW5jdGlvbihsaW5lSW5kZXgsIHdpZHRoKSB7XG5cbiAgICB2YXIgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tsaW5lSW5kZXhdLFxuICAgICAgICBsaW5lTGVmdE9mZnNldCA9IHRoaXMuX2dldExpbmVMZWZ0T2Zmc2V0KGxpbmVJbmRleCksXG4gICAgICAgIHdpZHRoT2ZDaGFyc09uTGluZSA9IGxpbmVMZWZ0T2Zmc2V0LFxuICAgICAgICBpbmRleE9uTGluZSA9IDAsIGNoYXJXaWR0aCwgZm91bmRNYXRjaDtcblxuICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gbGluZS5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgIGNoYXJXaWR0aCA9IHRoaXMuX19jaGFyQm91bmRzW2xpbmVJbmRleF1bal0ud2lkdGg7XG4gICAgICB3aWR0aE9mQ2hhcnNPbkxpbmUgKz0gY2hhcldpZHRoO1xuICAgICAgaWYgKHdpZHRoT2ZDaGFyc09uTGluZSA+IHdpZHRoKSB7XG4gICAgICAgIGZvdW5kTWF0Y2ggPSB0cnVlO1xuICAgICAgICB2YXIgbGVmdEVkZ2UgPSB3aWR0aE9mQ2hhcnNPbkxpbmUgLSBjaGFyV2lkdGgsXG4gICAgICAgICAgICByaWdodEVkZ2UgPSB3aWR0aE9mQ2hhcnNPbkxpbmUsXG4gICAgICAgICAgICBvZmZzZXRGcm9tTGVmdEVkZ2UgPSBNYXRoLmFicyhsZWZ0RWRnZSAtIHdpZHRoKSxcbiAgICAgICAgICAgIG9mZnNldEZyb21SaWdodEVkZ2UgPSBNYXRoLmFicyhyaWdodEVkZ2UgLSB3aWR0aCk7XG5cbiAgICAgICAgaW5kZXhPbkxpbmUgPSBvZmZzZXRGcm9tUmlnaHRFZGdlIDwgb2Zmc2V0RnJvbUxlZnRFZGdlID8gaiA6IChqIC0gMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlYWNoZWQgZW5kXG4gICAgaWYgKCFmb3VuZE1hdGNoKSB7XG4gICAgICBpbmRleE9uTGluZSA9IGxpbmUubGVuZ3RoIC0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXhPbkxpbmU7XG4gIH0sXG5cblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIGRvd25cbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIG1vdmVDdXJzb3JEb3duOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPj0gdGhpcy5fdGV4dC5sZW5ndGggJiYgdGhpcy5zZWxlY3Rpb25FbmQgPj0gdGhpcy5fdGV4dC5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbW92ZUN1cnNvclVwT3JEb3duKCdEb3duJywgZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciB1cFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgbW92ZUN1cnNvclVwOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPT09IDAgJiYgdGhpcy5zZWxlY3Rpb25FbmQgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbW92ZUN1cnNvclVwT3JEb3duKCdVcCcsIGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgdXAgb3IgZG93biwgZmlyZXMgdGhlIGV2ZW50c1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZGlyZWN0aW9uICdVcCcgb3IgJ0Rvd24nXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBfbW92ZUN1cnNvclVwT3JEb3duOiBmdW5jdGlvbihkaXJlY3Rpb24sIGUpIHtcbiAgICAvLyBnZXRVcEN1cnNvck9mZnNldFxuICAgIC8vIGdldERvd25DdXJzb3JPZmZzZXRcbiAgICB2YXIgYWN0aW9uID0gJ2dldCcgKyBkaXJlY3Rpb24gKyAnQ3Vyc29yT2Zmc2V0JyxcbiAgICAgICAgb2Zmc2V0ID0gdGhpc1thY3Rpb25dKGUsIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jyk7XG4gICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgIHRoaXMubW92ZUN1cnNvcldpdGhTaGlmdChvZmZzZXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMubW92ZUN1cnNvcldpdGhvdXRTaGlmdChvZmZzZXQpO1xuICAgIH1cbiAgICBpZiAob2Zmc2V0ICE9PSAwKSB7XG4gICAgICB0aGlzLnNldFNlbGVjdGlvbkluQm91bmRhcmllcygpO1xuICAgICAgdGhpcy5hYm9ydEN1cnNvckFuaW1hdGlvbigpO1xuICAgICAgdGhpcy5fY3VycmVudEN1cnNvck9wYWNpdHkgPSAxO1xuICAgICAgdGhpcy5pbml0RGVsYXllZEN1cnNvcigpO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3Igd2l0aCBzaGlmdFxuICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0XG4gICAqL1xuICBtb3ZlQ3Vyc29yV2l0aFNoaWZ0OiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICB2YXIgbmV3U2VsZWN0aW9uID0gdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAnbGVmdCdcbiAgICAgID8gdGhpcy5zZWxlY3Rpb25TdGFydCArIG9mZnNldFxuICAgICAgOiB0aGlzLnNlbGVjdGlvbkVuZCArIG9mZnNldDtcbiAgICB0aGlzLnNldFNlbGVjdGlvblN0YXJ0RW5kV2l0aFNoaWZ0KHRoaXMuc2VsZWN0aW9uU3RhcnQsIHRoaXMuc2VsZWN0aW9uRW5kLCBuZXdTZWxlY3Rpb24pO1xuICAgIHJldHVybiBvZmZzZXQgIT09IDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciB1cCB3aXRob3V0IHNoaWZ0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIG1vdmVDdXJzb3JXaXRob3V0U2hpZnQ6IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ICs9IG9mZnNldDtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnNlbGVjdGlvbkVuZCArPSBvZmZzZXQ7XG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25FbmQ7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQgIT09IDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciBsZWZ0XG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBtb3ZlQ3Vyc29yTGVmdDogZnVuY3Rpb24oZSkge1xuICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSAwICYmIHRoaXMuc2VsZWN0aW9uRW5kID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX21vdmVDdXJzb3JMZWZ0T3JSaWdodCgnTGVmdCcsIGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGEgY2hhbmdlIGhhcHBlbmVkXG4gICAqL1xuICBfbW92ZTogZnVuY3Rpb24oZSwgcHJvcCwgZGlyZWN0aW9uKSB7XG4gICAgdmFyIG5ld1ZhbHVlO1xuICAgIGlmIChlLmFsdEtleSkge1xuICAgICAgbmV3VmFsdWUgPSB0aGlzWydmaW5kV29yZEJvdW5kYXJ5JyArIGRpcmVjdGlvbl0odGhpc1twcm9wXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGUubWV0YUtleSB8fCBlLmtleUNvZGUgPT09IDM1IHx8ICBlLmtleUNvZGUgPT09IDM2ICkge1xuICAgICAgbmV3VmFsdWUgPSB0aGlzWydmaW5kTGluZUJvdW5kYXJ5JyArIGRpcmVjdGlvbl0odGhpc1twcm9wXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpc1twcm9wXSArPSBkaXJlY3Rpb24gPT09ICdMZWZ0JyA/IC0xIDogMTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5ld1ZhbHVlICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzW3Byb3BdICE9PSBuZXdWYWx1ZSkge1xuICAgICAgdGhpc1twcm9wXSA9IG5ld1ZhbHVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21vdmVMZWZ0OiBmdW5jdGlvbihlLCBwcm9wKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vdmUoZSwgcHJvcCwgJ0xlZnQnKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tb3ZlUmlnaHQ6IGZ1bmN0aW9uKGUsIHByb3ApIHtcbiAgICByZXR1cm4gdGhpcy5fbW92ZShlLCBwcm9wLCAnUmlnaHQnKTtcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIGxlZnQgd2l0aG91dCBrZWVwaW5nIHNlbGVjdGlvblxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqL1xuICBtb3ZlQ3Vyc29yTGVmdFdpdGhvdXRTaGlmdDogZnVuY3Rpb24oZSkge1xuICAgIHZhciBjaGFuZ2UgPSB0cnVlO1xuICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdsZWZ0JztcblxuICAgIC8vIG9ubHkgbW92ZSBjdXJzb3Igd2hlbiB0aGVyZSBpcyBubyBzZWxlY3Rpb24sXG4gICAgLy8gb3RoZXJ3aXNlIHdlIGRpc2NhcmQgaXQsIGFuZCBsZWF2ZSBjdXJzb3Igb24gc2FtZSBwbGFjZVxuICAgIGlmICh0aGlzLnNlbGVjdGlvbkVuZCA9PT0gdGhpcy5zZWxlY3Rpb25TdGFydCAmJiB0aGlzLnNlbGVjdGlvblN0YXJ0ICE9PSAwKSB7XG4gICAgICBjaGFuZ2UgPSB0aGlzLl9tb3ZlTGVmdChlLCAnc2VsZWN0aW9uU3RhcnQnKTtcblxuICAgIH1cbiAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQ7XG4gICAgcmV0dXJuIGNoYW5nZTtcbiAgfSxcblxuICAvKipcbiAgICogTW92ZXMgY3Vyc29yIGxlZnQgd2hpbGUga2VlcGluZyBzZWxlY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKi9cbiAgbW92ZUN1cnNvckxlZnRXaXRoU2hpZnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID09PSAncmlnaHQnICYmIHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW92ZUxlZnQoZSwgJ3NlbGVjdGlvbkVuZCcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ICE9PSAwKXtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdsZWZ0JztcbiAgICAgIHJldHVybiB0aGlzLl9tb3ZlTGVmdChlLCAnc2VsZWN0aW9uU3RhcnQnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciByaWdodFxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIEV2ZW50IG9iamVjdFxuICAgKi9cbiAgbW92ZUN1cnNvclJpZ2h0OiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uU3RhcnQgPj0gdGhpcy5fdGV4dC5sZW5ndGggJiYgdGhpcy5zZWxlY3Rpb25FbmQgPj0gdGhpcy5fdGV4dC5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbW92ZUN1cnNvckxlZnRPclJpZ2h0KCdSaWdodCcsIGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgcmlnaHQgb3IgTGVmdCwgZmlyZXMgZXZlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRpcmVjdGlvbiAnTGVmdCcsICdSaWdodCdcbiAgICogQHBhcmFtIHtFdmVudH0gZSBFdmVudCBvYmplY3RcbiAgICovXG4gIF9tb3ZlQ3Vyc29yTGVmdE9yUmlnaHQ6IGZ1bmN0aW9uKGRpcmVjdGlvbiwgZSkge1xuICAgIHZhciBhY3Rpb25OYW1lID0gJ21vdmVDdXJzb3InICsgZGlyZWN0aW9uICsgJ1dpdGgnO1xuICAgIHRoaXMuX2N1cnJlbnRDdXJzb3JPcGFjaXR5ID0gMTtcblxuICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICBhY3Rpb25OYW1lICs9ICdTaGlmdCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYWN0aW9uTmFtZSArPSAnb3V0U2hpZnQnO1xuICAgIH1cbiAgICBpZiAodGhpc1thY3Rpb25OYW1lXShlKSkge1xuICAgICAgdGhpcy5hYm9ydEN1cnNvckFuaW1hdGlvbigpO1xuICAgICAgdGhpcy5pbml0RGVsYXllZEN1cnNvcigpO1xuICAgICAgdGhpcy5fZmlyZVNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVRleHRhcmVhKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNb3ZlcyBjdXJzb3IgcmlnaHQgd2hpbGUga2VlcGluZyBzZWxlY3Rpb25cbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKi9cbiAgbW92ZUN1cnNvclJpZ2h0V2l0aFNoaWZ0OiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9PT0gJ2xlZnQnICYmIHRoaXMuc2VsZWN0aW9uU3RhcnQgIT09IHRoaXMuc2VsZWN0aW9uRW5kKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW92ZVJpZ2h0KGUsICdzZWxlY3Rpb25TdGFydCcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbkVuZCAhPT0gdGhpcy5fdGV4dC5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbkRpcmVjdGlvbiA9ICdyaWdodCc7XG4gICAgICByZXR1cm4gdGhpcy5fbW92ZVJpZ2h0KGUsICdzZWxlY3Rpb25FbmQnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vdmVzIGN1cnNvciByaWdodCB3aXRob3V0IGtlZXBpbmcgc2VsZWN0aW9uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgRXZlbnQgb2JqZWN0XG4gICAqL1xuICBtb3ZlQ3Vyc29yUmlnaHRXaXRob3V0U2hpZnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgY2hhbmdlZCA9IHRydWU7XG4gICAgdGhpcy5fc2VsZWN0aW9uRGlyZWN0aW9uID0gJ3JpZ2h0JztcblxuICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLnNlbGVjdGlvbkVuZCkge1xuICAgICAgY2hhbmdlZCA9IHRoaXMuX21vdmVSaWdodChlLCAnc2VsZWN0aW9uU3RhcnQnKTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25TdGFydDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25FbmQ7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGNoYXJhY3RlcnMgZnJvbSBzdGFydC9lbmRcbiAgICogc3RhcnQvZW5kIGFyIHBlciBncmFwaGVtZSBwb3NpdGlvbiBpbiBfdGV4dCBhcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgZGVmYXVsdCB0byBzdGFydCArIDFcbiAgICovXG4gIHJlbW92ZUNoYXJzOiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbmQgPSBzdGFydCArIDE7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlU3R5bGVGcm9tVG8oc3RhcnQsIGVuZCk7XG4gICAgdGhpcy5fdGV4dC5zcGxpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0KTtcbiAgICB0aGlzLnRleHQgPSB0aGlzLl90ZXh0LmpvaW4oJycpO1xuICAgIHRoaXMuc2V0KCdkaXJ0eScsIHRydWUpO1xuICAgIGlmICh0aGlzLl9zaG91bGRDbGVhckRpbWVuc2lvbkNhY2hlKCkpIHtcbiAgICAgIHRoaXMuaW5pdERpbWVuc2lvbnMoKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgfVxuICAgIHRoaXMuX3JlbW92ZUV4dHJhbmVvdXNTdHlsZXMoKTtcbiAgfSxcblxuICAvKipcbiAgICogaW5zZXJ0IGNoYXJhY3RlcnMgYXQgc3RhcnQgcG9zaXRpb24sIGJlZm9yZSBzdGFydCBwb3NpdGlvbi5cbiAgICogc3RhcnQgIGVxdWFsIDEgaXQgbWVhbnMgdGhlIHRleHQgZ2V0IGluc2VydGVkIGJldHdlZW4gYWN0dWFsIGdyYXBoZW1lIDAgYW5kIDFcbiAgICogaWYgc3R5bGUgYXJyYXkgaXMgcHJvdmlkZWQsIGl0IG11c3QgYmUgYXMgdGhlIHNhbWUgbGVuZ3RoIG9mIHRleHQgaW4gZ3JhcGhlbWVzXG4gICAqIGlmIGVuZCBpcyBwcm92aWRlZCBhbmQgaXMgYmlnZ2VyIHRoYW4gc3RhcnQsIG9sZCB0ZXh0IGlzIHJlcGxhY2VkLlxuICAgKiBzdGFydC9lbmQgYXIgcGVyIGdyYXBoZW1lIHBvc2l0aW9uIGluIF90ZXh0IGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCB0ZXh0IHRvIGluc2VydFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdHlsZSBhcnJheSBvZiBzdHlsZSBvYmplY3RzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5kIGRlZmF1bHQgdG8gc3RhcnQgKyAxXG4gICAqL1xuICBpbnNlcnRDaGFyczogZnVuY3Rpb24odGV4dCwgc3R5bGUsIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVuZCA9IHN0YXJ0O1xuICAgIH1cbiAgICBpZiAoZW5kID4gc3RhcnQpIHtcbiAgICAgIHRoaXMucmVtb3ZlU3R5bGVGcm9tVG8oc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIHZhciBncmFwaGVtZXMgPSBmYWJyaWMudXRpbC5zdHJpbmcuZ3JhcGhlbWVTcGxpdCh0ZXh0KTtcbiAgICB0aGlzLmluc2VydE5ld1N0eWxlQmxvY2soZ3JhcGhlbWVzLCBzdGFydCwgc3R5bGUpO1xuICAgIHRoaXMuX3RleHQgPSBbXS5jb25jYXQodGhpcy5fdGV4dC5zbGljZSgwLCBzdGFydCksIGdyYXBoZW1lcywgdGhpcy5fdGV4dC5zbGljZShlbmQpKTtcbiAgICB0aGlzLnRleHQgPSB0aGlzLl90ZXh0LmpvaW4oJycpO1xuICAgIHRoaXMuc2V0KCdkaXJ0eScsIHRydWUpO1xuICAgIGlmICh0aGlzLl9zaG91bGRDbGVhckRpbWVuc2lvbkNhY2hlKCkpIHtcbiAgICAgIHRoaXMuaW5pdERpbWVuc2lvbnMoKTtcbiAgICAgIHRoaXMuc2V0Q29vcmRzKCk7XG4gICAgfVxuICAgIHRoaXMuX3JlbW92ZUV4dHJhbmVvdXNTdHlsZXMoKTtcbiAgfSxcblxufSk7XG5cblxuLyogX1RPX1NWR19TVEFSVF8gKi9cbihmdW5jdGlvbigpIHtcbiAgdmFyIHRvRml4ZWQgPSBmYWJyaWMudXRpbC50b0ZpeGVkLFxuICAgICAgcmFkaWFuc1RvRGVncmVlcyA9IGZhYnJpYy51dGlsLnJhZGlhbnNUb0RlZ3JlZXMsXG4gICAgICBjYWxjUm90YXRlTWF0cml4ID0gZmFicmljLnV0aWwuY2FsY1JvdGF0ZU1hdHJpeCxcbiAgICAgIHRyYW5zZm9ybVBvaW50ID0gZmFicmljLnV0aWwudHJhbnNmb3JtUG9pbnQsXG4gICAgICBtdWx0aXBsZVNwYWNlc1JlZ2V4ID0gLyAgKy9nO1xuXG4gIGZhYnJpYy51dGlsLm9iamVjdC5leHRlbmQoZmFicmljLlRleHQucHJvdG90eXBlLCAvKiogQGxlbmRzIGZhYnJpYy5UZXh0LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFNWRyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXZpdmVyXSBNZXRob2QgZm9yIGZ1cnRoZXIgcGFyc2luZyBvZiBzdmcgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfdG9TVkc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9mZnNldHMgPSB0aGlzLl9nZXRTVkdMZWZ0VG9wT2Zmc2V0cygpLFxuICAgICAgICAgIHRleHRBbmRCZyA9IHRoaXMuX2dldFNWR1RleHRBbmRCZyhvZmZzZXRzLnRleHRUb3AsIG9mZnNldHMudGV4dExlZnQpO1xuICAgICAgcmV0dXJuIHRoaXMuX3dyYXBTVkdUZXh0QW5kQmcodGV4dEFuZEJnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmV2aXZlcl0gTWV0aG9kIGZvciBmdXJ0aGVyIHBhcnNpbmcgb2Ygc3ZnIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gc3ZnIHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9TVkc6IGZ1bmN0aW9uKHJldml2ZXIpIHtcbiAgICAgIHZhciB0ZXh0U3ZnID0gdGhpcy5fY3JlYXRlQmFzZVNWR01hcmt1cChcbiAgICAgICAgICAgIHRoaXMuX3RvU1ZHKCksXG4gICAgICAgICAgICB7IHJldml2ZXI6IHJldml2ZXIsIG5vU3R5bGU6IHRydWUsIHdpdGhTaGFkb3c6IHRydWUgfVxuICAgICAgICAgICksXG4gICAgICAgICAgcGF0aCA9IHRoaXMucGF0aDtcblxuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICB0ZXh0U3ZnICtcbiAgICAgICAgICBwYXRoLl9jcmVhdGVCYXNlU1ZHTWFya3VwKHBhdGguX3RvU1ZHKCksIHtcbiAgICAgICAgICAgIHJldml2ZXI6IHJldml2ZXIsXG4gICAgICAgICAgICB3aXRoU2hhZG93OiB0cnVlLFxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGV4dFN2ZztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0U1ZHTGVmdFRvcE9mZnNldHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGV4dExlZnQ6IC10aGlzLndpZHRoIC8gMixcbiAgICAgICAgdGV4dFRvcDogLXRoaXMuaGVpZ2h0IC8gMixcbiAgICAgICAgbGluZVRvcDogdGhpcy5nZXRIZWlnaHRPZkxpbmUoMClcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3dyYXBTVkdUZXh0QW5kQmc6IGZ1bmN0aW9uKHRleHRBbmRCZykge1xuICAgICAgdmFyIG5vU2hhZG93ID0gdHJ1ZSxcbiAgICAgICAgICB0ZXh0RGVjb3JhdGlvbiA9IHRoaXMuZ2V0U3ZnVGV4dERlY29yYXRpb24odGhpcyk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB0ZXh0QW5kQmcudGV4dEJnUmVjdHMuam9pbignJyksXG4gICAgICAgICdcXHRcXHQ8dGV4dCB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiICcsXG4gICAgICAgICh0aGlzLmZvbnRGYW1pbHkgPyAnZm9udC1mYW1pbHk9XCInICsgdGhpcy5mb250RmFtaWx5LnJlcGxhY2UoL1wiL2csICdcXCcnKSArICdcIiAnIDogJycpLFxuICAgICAgICAodGhpcy5mb250U2l6ZSA/ICdmb250LXNpemU9XCInICsgdGhpcy5mb250U2l6ZSArICdcIiAnIDogJycpLFxuICAgICAgICAodGhpcy5mb250U3R5bGUgPyAnZm9udC1zdHlsZT1cIicgKyB0aGlzLmZvbnRTdHlsZSArICdcIiAnIDogJycpLFxuICAgICAgICAodGhpcy5mb250V2VpZ2h0ID8gJ2ZvbnQtd2VpZ2h0PVwiJyArIHRoaXMuZm9udFdlaWdodCArICdcIiAnIDogJycpLFxuICAgICAgICAodGV4dERlY29yYXRpb24gPyAndGV4dC1kZWNvcmF0aW9uPVwiJyArIHRleHREZWNvcmF0aW9uICsgJ1wiICcgOiAnJyksXG4gICAgICAgICdzdHlsZT1cIicsIHRoaXMuZ2V0U3ZnU3R5bGVzKG5vU2hhZG93KSwgJ1wiJywgdGhpcy5hZGRQYWludE9yZGVyKCksICcgPicsXG4gICAgICAgIHRleHRBbmRCZy50ZXh0U3BhbnMuam9pbignJyksXG4gICAgICAgICc8L3RleHQ+XFxuJ1xuICAgICAgXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGV4dFRvcE9mZnNldCBUZXh0IHRvcCBvZmZzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGV4dExlZnRPZmZzZXQgVGV4dCBsZWZ0IG9mZnNldFxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICBfZ2V0U1ZHVGV4dEFuZEJnOiBmdW5jdGlvbih0ZXh0VG9wT2Zmc2V0LCB0ZXh0TGVmdE9mZnNldCkge1xuICAgICAgdmFyIHRleHRTcGFucyA9IFtdLFxuICAgICAgICAgIHRleHRCZ1JlY3RzID0gW10sXG4gICAgICAgICAgaGVpZ2h0ID0gdGV4dFRvcE9mZnNldCwgbGluZU9mZnNldDtcbiAgICAgIC8vIGJvdW5kaW5nLWJveCBiYWNrZ3JvdW5kXG4gICAgICB0aGlzLl9zZXRTVkdCZyh0ZXh0QmdSZWN0cyk7XG5cbiAgICAgIC8vIHRleHQgYW5kIHRleHQtYmFja2dyb3VuZFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3RleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsaW5lT2Zmc2V0ID0gdGhpcy5fZ2V0TGluZUxlZnRPZmZzZXQoaSk7XG4gICAgICAgIGlmICh0aGlzLnRleHRCYWNrZ3JvdW5kQ29sb3IgfHwgdGhpcy5zdHlsZUhhcygndGV4dEJhY2tncm91bmRDb2xvcicsIGkpKSB7XG4gICAgICAgICAgdGhpcy5fc2V0U1ZHVGV4dExpbmVCZyh0ZXh0QmdSZWN0cywgaSwgdGV4dExlZnRPZmZzZXQgKyBsaW5lT2Zmc2V0LCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldFNWR1RleHRMaW5lVGV4dCh0ZXh0U3BhbnMsIGksIHRleHRMZWZ0T2Zmc2V0ICsgbGluZU9mZnNldCwgaGVpZ2h0KTtcbiAgICAgICAgaGVpZ2h0ICs9IHRoaXMuZ2V0SGVpZ2h0T2ZMaW5lKGkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0U3BhbnM6IHRleHRTcGFucyxcbiAgICAgICAgdGV4dEJnUmVjdHM6IHRleHRCZ1JlY3RzXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVUZXh0Q2hhclNwYW46IGZ1bmN0aW9uKF9jaGFyLCBzdHlsZURlY2wsIGxlZnQsIHRvcCwgY2hhckJveCkge1xuICAgICAgdmFyIHNob3VsZFVzZVdoaXRlc3BhY2UgPSBfY2hhciAhPT0gX2NoYXIudHJpbSgpIHx8IF9jaGFyLm1hdGNoKG11bHRpcGxlU3BhY2VzUmVnZXgpLFxuICAgICAgICAgIHN0eWxlUHJvcHMgPSB0aGlzLmdldFN2Z1NwYW5TdHlsZXMoc3R5bGVEZWNsLCBzaG91bGRVc2VXaGl0ZXNwYWNlKSxcbiAgICAgICAgICBmaWxsU3R5bGVzID0gc3R5bGVQcm9wcyA/ICdzdHlsZT1cIicgKyBzdHlsZVByb3BzICsgJ1wiJyA6ICcnLFxuICAgICAgICAgIGR5ID0gc3R5bGVEZWNsLmRlbHRhWSwgZHlTcGFuID0gJycsXG4gICAgICAgICAgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUyxcbiAgICAgICAgICBhbmdsZUF0dHIgPSAnJztcbiAgICAgIGlmIChkeSkge1xuICAgICAgICBkeVNwYW4gPSAnIGR5PVwiJyArIHRvRml4ZWQoZHksIE5VTV9GUkFDVElPTl9ESUdJVFMpICsgJ1wiICc7XG4gICAgICB9XG4gICAgICBpZiAoY2hhckJveC5yZW5kZXJMZWZ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGFuZ2xlID0gY2hhckJveC5hbmdsZTtcbiAgICAgICAgYW5nbGVBdHRyID0gJyByb3RhdGU9XCInICsgdG9GaXhlZChyYWRpYW5zVG9EZWdyZWVzKGFuZ2xlKSwgZmFicmljLk9iamVjdC5OVU1fRlJBQ1RJT05fRElHSVRTKSArICdcIiAnO1xuICAgICAgICB2YXIgd0J5MiA9IGNoYXJCb3gud2lkdGggLyAyLFxuICAgICAgICAgICAgbSA9IGNhbGNSb3RhdGVNYXRyaXgoeyBhbmdsZTogcmFkaWFuc1RvRGVncmVlcyhhbmdsZSkgfSk7XG4gICAgICAgIG1bNF0gPSBjaGFyQm94LnJlbmRlckxlZnQ7XG4gICAgICAgIG1bNV0gPSBjaGFyQm94LnJlbmRlclRvcDtcbiAgICAgICAgdmFyIHJlbmRlclBvaW50ID0gdHJhbnNmb3JtUG9pbnQoeyB4OiAtd0J5MiwgeTogMCB9LCBtKTtcbiAgICAgICAgbGVmdCA9IHJlbmRlclBvaW50Lng7XG4gICAgICAgIHRvcCA9IHJlbmRlclBvaW50Lnk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW1xuICAgICAgICAnPHRzcGFuIHg9XCInLCB0b0ZpeGVkKGxlZnQsIE5VTV9GUkFDVElPTl9ESUdJVFMpLCAnXCIgeT1cIicsXG4gICAgICAgIHRvRml4ZWQodG9wLCBOVU1fRlJBQ1RJT05fRElHSVRTKSwgJ1wiICcsIGR5U3BhbixcbiAgICAgICAgZmlsbFN0eWxlcywgYW5nbGVBdHRyLCAnPicsXG4gICAgICAgIGZhYnJpYy51dGlsLnN0cmluZy5lc2NhcGVYbWwoX2NoYXIpLFxuICAgICAgICAnPC90c3Bhbj4nXG4gICAgICBdLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICBfc2V0U1ZHVGV4dExpbmVUZXh0OiBmdW5jdGlvbih0ZXh0U3BhbnMsIGxpbmVJbmRleCwgdGV4dExlZnRPZmZzZXQsIHRleHRUb3BPZmZzZXQpIHtcbiAgICAgIC8vIHNldCBwcm9wZXIgbGluZSBvZmZzZXRcbiAgICAgIHZhciBsaW5lSGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUobGluZUluZGV4KSxcbiAgICAgICAgICBpc0p1c3RpZnkgPSB0aGlzLnRleHRBbGlnbi5pbmRleE9mKCdqdXN0aWZ5JykgIT09IC0xLFxuICAgICAgICAgIGFjdHVhbFN0eWxlLFxuICAgICAgICAgIG5leHRTdHlsZSxcbiAgICAgICAgICBjaGFyc1RvUmVuZGVyID0gJycsXG4gICAgICAgICAgY2hhckJveCwgc3R5bGUsXG4gICAgICAgICAgYm94V2lkdGggPSAwLFxuICAgICAgICAgIGxpbmUgPSB0aGlzLl90ZXh0TGluZXNbbGluZUluZGV4XSxcbiAgICAgICAgICB0aW1lVG9SZW5kZXI7XG5cbiAgICAgIHRleHRUb3BPZmZzZXQgKz0gbGluZUhlaWdodCAqICgxIC0gdGhpcy5fZm9udFNpemVGcmFjdGlvbikgLyB0aGlzLmxpbmVIZWlnaHQ7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZS5sZW5ndGggLSAxOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICAgIHRpbWVUb1JlbmRlciA9IGkgPT09IGxlbiB8fCB0aGlzLmNoYXJTcGFjaW5nIHx8IHRoaXMucGF0aDtcbiAgICAgICAgY2hhcnNUb1JlbmRlciArPSBsaW5lW2ldO1xuICAgICAgICBjaGFyQm94ID0gdGhpcy5fX2NoYXJCb3VuZHNbbGluZUluZGV4XVtpXTtcbiAgICAgICAgaWYgKGJveFdpZHRoID09PSAwKSB7XG4gICAgICAgICAgdGV4dExlZnRPZmZzZXQgKz0gY2hhckJveC5rZXJuZWRXaWR0aCAtIGNoYXJCb3gud2lkdGg7XG4gICAgICAgICAgYm94V2lkdGggKz0gY2hhckJveC53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBib3hXaWR0aCArPSBjaGFyQm94Lmtlcm5lZFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0p1c3RpZnkgJiYgIXRpbWVUb1JlbmRlcikge1xuICAgICAgICAgIGlmICh0aGlzLl9yZVNwYWNlQW5kVGFiLnRlc3QobGluZVtpXSkpIHtcbiAgICAgICAgICAgIHRpbWVUb1JlbmRlciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGltZVRvUmVuZGVyKSB7XG4gICAgICAgICAgLy8gaWYgd2UgaGF2ZSBjaGFyU3BhY2luZywgd2UgcmVuZGVyIGNoYXIgYnkgY2hhclxuICAgICAgICAgIGFjdHVhbFN0eWxlID0gYWN0dWFsU3R5bGUgfHwgdGhpcy5nZXRDb21wbGV0ZVN0eWxlRGVjbGFyYXRpb24obGluZUluZGV4LCBpKTtcbiAgICAgICAgICBuZXh0U3R5bGUgPSB0aGlzLmdldENvbXBsZXRlU3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGkgKyAxKTtcbiAgICAgICAgICB0aW1lVG9SZW5kZXIgPSBmYWJyaWMudXRpbC5oYXNTdHlsZUNoYW5nZWQoYWN0dWFsU3R5bGUsIG5leHRTdHlsZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVUb1JlbmRlcikge1xuICAgICAgICAgIHN0eWxlID0gdGhpcy5fZ2V0U3R5bGVEZWNsYXJhdGlvbihsaW5lSW5kZXgsIGkpIHx8IHsgfTtcbiAgICAgICAgICB0ZXh0U3BhbnMucHVzaCh0aGlzLl9jcmVhdGVUZXh0Q2hhclNwYW4oY2hhcnNUb1JlbmRlciwgc3R5bGUsIHRleHRMZWZ0T2Zmc2V0LCB0ZXh0VG9wT2Zmc2V0LCBjaGFyQm94KSk7XG4gICAgICAgICAgY2hhcnNUb1JlbmRlciA9ICcnO1xuICAgICAgICAgIGFjdHVhbFN0eWxlID0gbmV4dFN0eWxlO1xuICAgICAgICAgIHRleHRMZWZ0T2Zmc2V0ICs9IGJveFdpZHRoO1xuICAgICAgICAgIGJveFdpZHRoID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBfcHVzaFRleHRCZ1JlY3Q6IGZ1bmN0aW9uKHRleHRCZ1JlY3RzLCBjb2xvciwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgTlVNX0ZSQUNUSU9OX0RJR0lUUyA9IGZhYnJpYy5PYmplY3QuTlVNX0ZSQUNUSU9OX0RJR0lUUztcbiAgICAgIHRleHRCZ1JlY3RzLnB1c2goXG4gICAgICAgICdcXHRcXHQ8cmVjdCAnLFxuICAgICAgICB0aGlzLl9nZXRGaWxsQXR0cmlidXRlcyhjb2xvciksXG4gICAgICAgICcgeD1cIicsXG4gICAgICAgIHRvRml4ZWQobGVmdCwgTlVNX0ZSQUNUSU9OX0RJR0lUUyksXG4gICAgICAgICdcIiB5PVwiJyxcbiAgICAgICAgdG9GaXhlZCh0b3AsIE5VTV9GUkFDVElPTl9ESUdJVFMpLFxuICAgICAgICAnXCIgd2lkdGg9XCInLFxuICAgICAgICB0b0ZpeGVkKHdpZHRoLCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgJ1wiIGhlaWdodD1cIicsXG4gICAgICAgIHRvRml4ZWQoaGVpZ2h0LCBOVU1fRlJBQ1RJT05fRElHSVRTKSxcbiAgICAgICAgJ1wiPjwvcmVjdD5cXG4nKTtcbiAgICB9LFxuXG4gICAgX3NldFNWR1RleHRMaW5lQmc6IGZ1bmN0aW9uKHRleHRCZ1JlY3RzLCBpLCBsZWZ0T2Zmc2V0LCB0ZXh0VG9wT2Zmc2V0KSB7XG4gICAgICB2YXIgbGluZSA9IHRoaXMuX3RleHRMaW5lc1tpXSxcbiAgICAgICAgICBoZWlnaHRPZkxpbmUgPSB0aGlzLmdldEhlaWdodE9mTGluZShpKSAvIHRoaXMubGluZUhlaWdodCxcbiAgICAgICAgICBib3hXaWR0aCA9IDAsXG4gICAgICAgICAgYm94U3RhcnQgPSAwLFxuICAgICAgICAgIGNoYXJCb3gsIGN1cnJlbnRDb2xvcixcbiAgICAgICAgICBsYXN0Q29sb3IgPSB0aGlzLmdldFZhbHVlT2ZQcm9wZXJ0eUF0KGksIDAsICd0ZXh0QmFja2dyb3VuZENvbG9yJyk7XG4gICAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGxpbmUubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICAgIGNoYXJCb3ggPSB0aGlzLl9fY2hhckJvdW5kc1tpXVtqXTtcbiAgICAgICAgY3VycmVudENvbG9yID0gdGhpcy5nZXRWYWx1ZU9mUHJvcGVydHlBdChpLCBqLCAndGV4dEJhY2tncm91bmRDb2xvcicpO1xuICAgICAgICBpZiAoY3VycmVudENvbG9yICE9PSBsYXN0Q29sb3IpIHtcbiAgICAgICAgICBsYXN0Q29sb3IgJiYgdGhpcy5fcHVzaFRleHRCZ1JlY3QodGV4dEJnUmVjdHMsIGxhc3RDb2xvciwgbGVmdE9mZnNldCArIGJveFN0YXJ0LFxuICAgICAgICAgICAgdGV4dFRvcE9mZnNldCwgYm94V2lkdGgsIGhlaWdodE9mTGluZSk7XG4gICAgICAgICAgYm94U3RhcnQgPSBjaGFyQm94LmxlZnQ7XG4gICAgICAgICAgYm94V2lkdGggPSBjaGFyQm94LndpZHRoO1xuICAgICAgICAgIGxhc3RDb2xvciA9IGN1cnJlbnRDb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBib3hXaWR0aCArPSBjaGFyQm94Lmtlcm5lZFdpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdXJyZW50Q29sb3IgJiYgdGhpcy5fcHVzaFRleHRCZ1JlY3QodGV4dEJnUmVjdHMsIGN1cnJlbnRDb2xvciwgbGVmdE9mZnNldCArIGJveFN0YXJ0LFxuICAgICAgICB0ZXh0VG9wT2Zmc2V0LCBib3hXaWR0aCwgaGVpZ2h0T2ZMaW5lKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRvYmUgSWxsdXN0cmF0b3IgKGF0IGxlYXN0IENTNSkgaXMgdW5hYmxlIHRvIHJlbmRlciByZ2JhKCktYmFzZWQgZmlsbCB2YWx1ZXNcbiAgICAgKiB3ZSB3b3JrIGFyb3VuZCBpdCBieSBcIm1vdmluZ1wiIGFscGhhIGNoYW5uZWwgaW50byBvcGFjaXR5IGF0dHJpYnV0ZSBhbmQgc2V0dGluZyBmaWxsJ3MgYWxwaGEgdG8gMVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIF9nZXRGaWxsQXR0cmlidXRlczogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBmaWxsQ29sb3IgPSAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgPyBuZXcgZmFicmljLkNvbG9yKHZhbHVlKSA6ICcnO1xuICAgICAgaWYgKCFmaWxsQ29sb3IgfHwgIWZpbGxDb2xvci5nZXRTb3VyY2UoKSB8fCBmaWxsQ29sb3IuZ2V0QWxwaGEoKSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gJ2ZpbGw9XCInICsgdmFsdWUgKyAnXCInO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdvcGFjaXR5PVwiJyArIGZpbGxDb2xvci5nZXRBbHBoYSgpICsgJ1wiIGZpbGw9XCInICsgZmlsbENvbG9yLnNldEFscGhhKDEpLnRvUmdiKCkgKyAnXCInO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRTVkdMaW5lVG9wT2Zmc2V0OiBmdW5jdGlvbihsaW5lSW5kZXgpIHtcbiAgICAgIHZhciBsaW5lVG9wT2Zmc2V0ID0gMCwgbGFzdEhlaWdodCA9IDA7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmVJbmRleDsgaisrKSB7XG4gICAgICAgIGxpbmVUb3BPZmZzZXQgKz0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaik7XG4gICAgICB9XG4gICAgICBsYXN0SGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHRPZkxpbmUoaik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lVG9wOiBsaW5lVG9wT2Zmc2V0LFxuICAgICAgICBvZmZzZXQ6ICh0aGlzLl9mb250U2l6ZU11bHQgLSB0aGlzLl9mb250U2l6ZUZyYWN0aW9uKSAqIGxhc3RIZWlnaHQgLyAodGhpcy5saW5lSGVpZ2h0ICogdGhpcy5fZm9udFNpemVNdWx0KVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzdHlsZXMtc3RyaW5nIGZvciBzdmctZXhwb3J0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBza2lwU2hhZG93IGEgYm9vbGVhbiB0byBza2lwIHNoYWRvdyBmaWx0ZXIgb3V0cHV0XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFN2Z1N0eWxlczogZnVuY3Rpb24oc2tpcFNoYWRvdykge1xuICAgICAgdmFyIHN2Z1N0eWxlID0gZmFicmljLk9iamVjdC5wcm90b3R5cGUuZ2V0U3ZnU3R5bGVzLmNhbGwodGhpcywgc2tpcFNoYWRvdyk7XG4gICAgICByZXR1cm4gc3ZnU3R5bGUgKyAnIHdoaXRlLXNwYWNlOiBwcmU7JztcbiAgICB9LFxuICB9KTtcbn0pKCk7XG4vKiBfVE9fU1ZHX0VORF8gKi9cblxuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBmYWJyaWMgPSBnbG9iYWwuZmFicmljIHx8IChnbG9iYWwuZmFicmljID0ge30pO1xuXG4gIC8qKlxuICAgKiBUZXh0Ym94IGNsYXNzLCBiYXNlZCBvbiBJVGV4dCwgYWxsb3dzIHRoZSB1c2VyIHRvIHJlc2l6ZSB0aGUgdGV4dCByZWN0YW5nbGVcbiAgICogYW5kIHdyYXBzIGxpbmVzIGF1dG9tYXRpY2FsbHkuIFRleHRib3hlcyBoYXZlIHRoZWlyIFkgc2NhbGluZyBsb2NrZWQsIHRoZVxuICAgKiB1c2VyIGNhbiBvbmx5IGNoYW5nZSB3aWR0aC4gSGVpZ2h0IGlzIGFkanVzdGVkIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gdGhlXG4gICAqIHdyYXBwaW5nIG9mIGxpbmVzLlxuICAgKiBAY2xhc3MgZmFicmljLlRleHRib3hcbiAgICogQGV4dGVuZHMgZmFicmljLklUZXh0XG4gICAqIEBtaXhlcyBmYWJyaWMuT2JzZXJ2YWJsZVxuICAgKiBAcmV0dXJuIHtmYWJyaWMuVGV4dGJveH0gdGhpc0FyZ1xuICAgKiBAc2VlIHtAbGluayBmYWJyaWMuVGV4dGJveCNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgZGVmaW5pdGlvblxuICAgKi9cbiAgZmFicmljLlRleHRib3ggPSBmYWJyaWMudXRpbC5jcmVhdGVDbGFzcyhmYWJyaWMuSVRleHQsIGZhYnJpYy5PYnNlcnZhYmxlLCB7XG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGFuIG9iamVjdFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqIEBkZWZhdWx0XG4gICAgICovXG4gICAgdHlwZTogJ3RleHRib3gnLFxuXG4gICAgLyoqXG4gICAgICogTWluaW11bSB3aWR0aCBvZiB0ZXh0Ym94LCBpbiBwaXhlbHMuXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBtaW5XaWR0aDogMjAsXG5cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIGNhbGN1bGF0ZWQgd2lkdGggb2YgYSB0ZXh0Ym94LCBpbiBwaXhlbHMuXG4gICAgICogZml4ZWQgdG8gMiBzbyB0aGF0IGFuIGVtcHR5IHRleHRib3ggY2Fubm90IGdvIHRvIDBcbiAgICAgKiBhbmQgaXMgc3RpbGwgc2VsZWN0YWJsZSB3aXRob3V0IHRleHQuXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHRcbiAgICAgKi9cbiAgICBkeW5hbWljTWluV2lkdGg6IDIsXG5cbiAgICAvKipcbiAgICAgKiBDYWNoZWQgYXJyYXkgb2YgdGV4dCB3cmFwcGluZy5cbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqL1xuICAgIF9fY2FjaGVkTGluZXM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBzdGFuZGFyZCBPYmplY3QgY2xhc3MgdmFsdWVzXG4gICAgICovXG4gICAgbG9ja1NjYWxpbmdGbGlwOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgc3RhbmRhcmQgT2JqZWN0IGNsYXNzIHZhbHVlc1xuICAgICAqIFRleHRib3ggbmVlZHMgdGhpcyBvbiBmYWxzZVxuICAgICAqL1xuICAgIG5vU2NhbGVDYWNoZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIHdoaWNoIHdoZW4gc2V0IGNhdXNlIG9iamVjdCB0byBjaGFuZ2UgZGltZW5zaW9uc1xuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2RpbWVuc2lvbkFmZmVjdGluZ1Byb3BzOiBmYWJyaWMuVGV4dC5wcm90b3R5cGUuX2RpbWVuc2lvbkFmZmVjdGluZ1Byb3BzLmNvbmNhdCgnd2lkdGgnKSxcblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBzcGxpdCBzdHJpbmdzIGluIGJyZWFrYWJsZSBsaW5lc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3dvcmRKb2luZXJzOiAvWyBcXHRcXHJdLyxcblxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIGJvb2xlYW4gcHJvcGVydHkgaW4gb3JkZXIgdG8gc3BsaXQgc3RyaW5ncyB0aGF0IGhhdmUgbm8gd2hpdGUgc3BhY2UgY29uY2VwdC5cbiAgICAgKiB0aGlzIGlzIGEgY2hlYXAgd2F5IHRvIGhlbHAgd2l0aCBjaGluZXNlL2phcGFuZXNlXG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqIEBzaW5jZSAyLjYuMFxuICAgICAqL1xuICAgIHNwbGl0QnlHcmFwaGVtZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBVbmxpa2Ugc3VwZXJjbGFzcydzIHZlcnNpb24gb2YgdGhpcyBmdW5jdGlvbiwgVGV4dGJveCBkb2VzIG5vdCB1cGRhdGVcbiAgICAgKiBpdHMgd2lkdGguXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBpbml0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fX3NraXBEaW1lbnNpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5pc0VkaXRpbmcgJiYgdGhpcy5pbml0RGVsYXllZEN1cnNvcigpO1xuICAgICAgdGhpcy5jbGVhckNvbnRleHRUb3AoKTtcbiAgICAgIHRoaXMuX2NsZWFyQ2FjaGUoKTtcbiAgICAgIC8vIGNsZWFyIGR5bmFtaWNNaW5XaWR0aCBhcyBpdCB3aWxsIGJlIGRpZmZlcmVudCBhZnRlciB3ZSByZS13cmFwIGxpbmVcbiAgICAgIHRoaXMuZHluYW1pY01pbldpZHRoID0gMDtcbiAgICAgIC8vIHdyYXAgbGluZXNcbiAgICAgIHRoaXMuX3N0eWxlTWFwID0gdGhpcy5fZ2VuZXJhdGVTdHlsZU1hcCh0aGlzLl9zcGxpdFRleHQoKSk7XG4gICAgICAvLyBpZiBhZnRlciB3cmFwcGluZywgdGhlIHdpZHRoIGlzIHNtYWxsZXIgdGhhbiBkeW5hbWljTWluV2lkdGgsIGNoYW5nZSB0aGUgd2lkdGggYW5kIHJlLXdyYXBcbiAgICAgIGlmICh0aGlzLmR5bmFtaWNNaW5XaWR0aCA+IHRoaXMud2lkdGgpIHtcbiAgICAgICAgdGhpcy5fc2V0KCd3aWR0aCcsIHRoaXMuZHluYW1pY01pbldpZHRoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRleHRBbGlnbi5pbmRleE9mKCdqdXN0aWZ5JykgIT09IC0xKSB7XG4gICAgICAgIC8vIG9uY2UgdGV4dCBpcyBtZWFzdXJlZCB3ZSBuZWVkIHRvIG1ha2Ugc3BhY2UgZmF0dGVyIHRvIG1ha2UganVzdGlmaWVkIHRleHQuXG4gICAgICAgIHRoaXMuZW5sYXJnZVNwYWNlcygpO1xuICAgICAgfVxuICAgICAgLy8gY2xlYXIgY2FjaGUgYW5kIHJlLWNhbGN1bGF0ZSBoZWlnaHRcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jYWxjVGV4dEhlaWdodCgpO1xuICAgICAgdGhpcy5zYXZlU3RhdGUoeyBwcm9wZXJ0eVNldDogJ19kaW1lbnNpb25BZmZlY3RpbmdQcm9wcycgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGFuIG9iamVjdCB0aGF0IHRyYW5zbGF0ZXMgdGhlIHN0eWxlIG9iamVjdCBzbyB0aGF0IGl0IGlzXG4gICAgICogYnJva2VuIHVwIGJ5IHZpc3VhbCBsaW5lcyAobmV3IGxpbmVzIGFuZCBhdXRvbWF0aWMgd3JhcHBpbmcpLlxuICAgICAqIFRoZSBvcmlnaW5hbCB0ZXh0IHN0eWxlcyBvYmplY3QgaXMgYnJva2VuIHVwIGJ5IGFjdHVhbCBsaW5lcyAobmV3IGxpbmVzIG9ubHkpLFxuICAgICAqIHdoaWNoIGlzIG9ubHkgc3VmZmljaWVudCBmb3IgVGV4dCAvIElUZXh0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2VuZXJhdGVTdHlsZU1hcDogZnVuY3Rpb24odGV4dEluZm8pIHtcbiAgICAgIHZhciByZWFsTGluZUNvdW50ICAgICA9IDAsXG4gICAgICAgICAgcmVhbExpbmVDaGFyQ291bnQgPSAwLFxuICAgICAgICAgIGNoYXJDb3VudCAgICAgICAgID0gMCxcbiAgICAgICAgICBtYXAgICAgICAgICAgICAgICA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRJbmZvLmdyYXBoZW1lTGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRleHRJbmZvLmdyYXBoZW1lVGV4dFtjaGFyQ291bnRdID09PSAnXFxuJyAmJiBpID4gMCkge1xuICAgICAgICAgIHJlYWxMaW5lQ2hhckNvdW50ID0gMDtcbiAgICAgICAgICBjaGFyQ291bnQrKztcbiAgICAgICAgICByZWFsTGluZUNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuc3BsaXRCeUdyYXBoZW1lICYmIHRoaXMuX3JlU3BhY2VBbmRUYWIudGVzdCh0ZXh0SW5mby5ncmFwaGVtZVRleHRbY2hhckNvdW50XSkgJiYgaSA+IDApIHtcbiAgICAgICAgICAvLyB0aGlzIGNhc2UgZGVhbHMgd2l0aCBzcGFjZSdzIHRoYXQgYXJlIHJlbW92ZWQgZnJvbSBlbmQgb2YgbGluZXMgd2hlbiB3cmFwcGluZ1xuICAgICAgICAgIHJlYWxMaW5lQ2hhckNvdW50Kys7XG4gICAgICAgICAgY2hhckNvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICBtYXBbaV0gPSB7IGxpbmU6IHJlYWxMaW5lQ291bnQsIG9mZnNldDogcmVhbExpbmVDaGFyQ291bnQgfTtcblxuICAgICAgICBjaGFyQ291bnQgKz0gdGV4dEluZm8uZ3JhcGhlbWVMaW5lc1tpXS5sZW5ndGg7XG4gICAgICAgIHJlYWxMaW5lQ2hhckNvdW50ICs9IHRleHRJbmZvLmdyYXBoZW1lTGluZXNbaV0ubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGhhcyBhIHN0eWxlIHByb3BlcnR5IG9yIGhhcyBpdCBvbiBhIHNwZWNpZmllZCBsaW5lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3R5bGVIYXM6IGZ1bmN0aW9uKHByb3BlcnR5LCBsaW5lSW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLl9zdHlsZU1hcCAmJiAhdGhpcy5pc1dyYXBwaW5nKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgICBpZiAobWFwKSB7XG4gICAgICAgICAgbGluZUluZGV4ID0gbWFwLmxpbmU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWJyaWMuVGV4dC5wcm90b3R5cGUuc3R5bGVIYXMuY2FsbCh0aGlzLCBwcm9wZXJ0eSwgbGluZUluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBoYXMgbm8gc3R5bGluZyBvciBubyBzdHlsaW5nIGluIGEgbGluZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXggLCBsaW5lSW5kZXggaXMgb24gd3JhcHBlZCBsaW5lcy5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzRW1wdHlTdHlsZXM6IGZ1bmN0aW9uKGxpbmVJbmRleCkge1xuICAgICAgaWYgKCF0aGlzLnN0eWxlcykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBvZmZzZXQgPSAwLCBuZXh0TGluZUluZGV4ID0gbGluZUluZGV4ICsgMSwgbmV4dE9mZnNldCwgb2JqLCBzaG91bGRMaW1pdCA9IGZhbHNlLFxuICAgICAgICAgIG1hcCA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF0sIG1hcE5leHRMaW5lID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4ICsgMV07XG4gICAgICBpZiAobWFwKSB7XG4gICAgICAgIGxpbmVJbmRleCA9IG1hcC5saW5lO1xuICAgICAgICBvZmZzZXQgPSBtYXAub2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKG1hcE5leHRMaW5lKSB7XG4gICAgICAgIG5leHRMaW5lSW5kZXggPSBtYXBOZXh0TGluZS5saW5lO1xuICAgICAgICBzaG91bGRMaW1pdCA9IG5leHRMaW5lSW5kZXggPT09IGxpbmVJbmRleDtcbiAgICAgICAgbmV4dE9mZnNldCA9IG1hcE5leHRMaW5lLm9mZnNldDtcbiAgICAgIH1cbiAgICAgIG9iaiA9IHR5cGVvZiBsaW5lSW5kZXggPT09ICd1bmRlZmluZWQnID8gdGhpcy5zdHlsZXMgOiB7IGxpbmU6IHRoaXMuc3R5bGVzW2xpbmVJbmRleF0gfTtcbiAgICAgIGZvciAodmFyIHAxIGluIG9iaikge1xuICAgICAgICBmb3IgKHZhciBwMiBpbiBvYmpbcDFdKSB7XG4gICAgICAgICAgaWYgKHAyID49IG9mZnNldCAmJiAoIXNob3VsZExpbWl0IHx8IHAyIDwgbmV4dE9mZnNldCkpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgZm9yICh2YXIgcDMgaW4gb2JqW3AxXVtwMl0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2hhckluZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0U3R5bGVEZWNsYXJhdGlvbjogZnVuY3Rpb24obGluZUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLl9zdHlsZU1hcCAmJiAhdGhpcy5pc1dyYXBwaW5nKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgICBpZiAoIW1hcCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVJbmRleCA9IG1hcC5saW5lO1xuICAgICAgICBjaGFySW5kZXggPSBtYXAub2Zmc2V0ICsgY2hhckluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY2FsbFN1cGVyKCdfZ2V0U3R5bGVEZWNsYXJhdGlvbicsIGxpbmVJbmRleCwgY2hhckluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZXRTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCwgc3R5bGUpIHtcbiAgICAgIHZhciBtYXAgPSB0aGlzLl9zdHlsZU1hcFtsaW5lSW5kZXhdO1xuICAgICAgbGluZUluZGV4ID0gbWFwLmxpbmU7XG4gICAgICBjaGFySW5kZXggPSBtYXAub2Zmc2V0ICsgY2hhckluZGV4O1xuXG4gICAgICB0aGlzLnN0eWxlc1tsaW5lSW5kZXhdW2NoYXJJbmRleF0gPSBzdHlsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFySW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kZWxldGVTdHlsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihsaW5lSW5kZXgsIGNoYXJJbmRleCkge1xuICAgICAgdmFyIG1hcCA9IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF07XG4gICAgICBsaW5lSW5kZXggPSBtYXAubGluZTtcbiAgICAgIGNoYXJJbmRleCA9IG1hcC5vZmZzZXQgKyBjaGFySW5kZXg7XG4gICAgICBkZWxldGUgdGhpcy5zdHlsZXNbbGluZUluZGV4XVtjaGFySW5kZXhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBwcm9iYWJseSBicm9rZW4gbmVlZCBhIGZpeFxuICAgICAqIFJldHVybnMgdGhlIHJlYWwgc3R5bGUgbGluZSB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlIHdyYXBwZWQgbGluZUluZGV4IGxpbmVcbiAgICAgKiBVc2VkIGp1c3QgdG8gdmVyaWZ5IGlmIHRoZSBsaW5lIGRvZXMgZXhpc3Qgb3Igbm90LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gaWYgdGhlIGxpbmUgZXhpc3RzIG9yIG5vdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldExpbmVTdHlsZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICB2YXIgbWFwID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4XTtcbiAgICAgIHJldHVybiAhIXRoaXMuc3R5bGVzW21hcC5saW5lXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBsaW5lIHN0eWxlIHRvIGFuIGVtcHR5IG9iamVjdCBzbyB0aGF0IGlzIGluaXRpYWxpemVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldExpbmVTdHlsZTogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICB2YXIgbWFwID0gdGhpcy5fc3R5bGVNYXBbbGluZUluZGV4XTtcbiAgICAgIHRoaXMuc3R5bGVzW21hcC5saW5lXSA9IHt9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXcmFwcyB0ZXh0IHVzaW5nIHRoZSAnd2lkdGgnIHByb3BlcnR5IG9mIFRleHRib3guIEZpcnN0IHRoaXMgZnVuY3Rpb25cbiAgICAgKiBzcGxpdHMgdGV4dCBvbiBuZXdsaW5lcywgc28gd2UgcHJlc2VydmUgbmV3bGluZXMgZW50ZXJlZCBieSB0aGUgdXNlci5cbiAgICAgKiBUaGVuIGl0IHdyYXBzIGVhY2ggbGluZSB1c2luZyB0aGUgd2lkdGggb2YgdGhlIFRleHRib3ggYnkgY2FsbGluZ1xuICAgICAqIF93cmFwTGluZSgpLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpbmVzIFRoZSBzdHJpbmcgYXJyYXkgb2YgdGV4dCB0aGF0IGlzIHNwbGl0IGludG8gbGluZXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVzaXJlZFdpZHRoIHdpZHRoIHlvdSB3YW50IHRvIHdyYXAgdG9cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGxpbmVzXG4gICAgICovXG4gICAgX3dyYXBUZXh0OiBmdW5jdGlvbihsaW5lcywgZGVzaXJlZFdpZHRoKSB7XG4gICAgICB2YXIgd3JhcHBlZCA9IFtdLCBpO1xuICAgICAgdGhpcy5pc1dyYXBwaW5nID0gdHJ1ZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB3cmFwcGVkID0gd3JhcHBlZC5jb25jYXQodGhpcy5fd3JhcExpbmUobGluZXNbaV0sIGksIGRlc2lyZWRXaWR0aCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5pc1dyYXBwaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gd3JhcHBlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIG1lYXN1cmUgYSBzdHJpbmcgb2YgdGV4dCwgZ2l2ZW4gaXRzIGxpbmVJbmRleCBhbmQgY2hhckluZGV4IG9mZnNldFxuICAgICAqIGl0IGdldHMgY2FsbGVkIHdoZW4gY2hhckJvdW5kcyBhcmUgbm90IGF2YWlsYWJsZSB5ZXQuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVJbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjaGFyT2Zmc2V0XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tZWFzdXJlV29yZDogZnVuY3Rpb24od29yZCwgbGluZUluZGV4LCBjaGFyT2Zmc2V0KSB7XG4gICAgICB2YXIgd2lkdGggPSAwLCBwcmV2R3JhcGhlbWUsIHNraXBMZWZ0ID0gdHJ1ZTtcbiAgICAgIGNoYXJPZmZzZXQgPSBjaGFyT2Zmc2V0IHx8IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gd29yZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgYm94ID0gdGhpcy5fZ2V0R3JhcGhlbWVCb3god29yZFtpXSwgbGluZUluZGV4LCBpICsgY2hhck9mZnNldCwgcHJldkdyYXBoZW1lLCBza2lwTGVmdCk7XG4gICAgICAgIHdpZHRoICs9IGJveC5rZXJuZWRXaWR0aDtcbiAgICAgICAgcHJldkdyYXBoZW1lID0gd29yZFtpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV3JhcHMgYSBsaW5lIG9mIHRleHQgdXNpbmcgdGhlIHdpZHRoIG9mIHRoZSBUZXh0Ym94IGFuZCBhIGNvbnRleHQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGluZSBUaGUgZ3JhcGhlbWUgYXJyYXkgdGhhdCByZXByZXNlbnQgdGhlIGxpbmVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlc2lyZWRXaWR0aCB3aWR0aCB5b3Ugd2FudCB0byB3cmFwIHRoZSBsaW5lIHRvXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJlc2VydmVkU3BhY2Ugc3BhY2UgdG8gcmVtb3ZlIGZyb20gd3JhcHBpbmcgZm9yIGN1c3RvbSBmdW5jdGlvbmFsaXRpZXNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGxpbmUocykgaW50byB3aGljaCB0aGUgZ2l2ZW4gdGV4dCBpcyB3cmFwcGVkXG4gICAgICogdG8uXG4gICAgICovXG4gICAgX3dyYXBMaW5lOiBmdW5jdGlvbihfbGluZSwgbGluZUluZGV4LCBkZXNpcmVkV2lkdGgsIHJlc2VydmVkU3BhY2UpIHtcbiAgICAgIHZhciBsaW5lV2lkdGggPSAwLFxuICAgICAgICAgIHNwbGl0QnlHcmFwaGVtZSA9IHRoaXMuc3BsaXRCeUdyYXBoZW1lLFxuICAgICAgICAgIGdyYXBoZW1lTGluZXMgPSBbXSxcbiAgICAgICAgICBsaW5lID0gW10sXG4gICAgICAgICAgLy8gc3BhY2VzIGluIGRpZmZlcmVudCBsYW5ndWFnZXM/XG4gICAgICAgICAgd29yZHMgPSBzcGxpdEJ5R3JhcGhlbWUgPyBmYWJyaWMudXRpbC5zdHJpbmcuZ3JhcGhlbWVTcGxpdChfbGluZSkgOiBfbGluZS5zcGxpdCh0aGlzLl93b3JkSm9pbmVycyksXG4gICAgICAgICAgd29yZCA9ICcnLFxuICAgICAgICAgIG9mZnNldCA9IDAsXG4gICAgICAgICAgaW5maXggPSBzcGxpdEJ5R3JhcGhlbWUgPyAnJyA6ICcgJyxcbiAgICAgICAgICB3b3JkV2lkdGggPSAwLFxuICAgICAgICAgIGluZml4V2lkdGggPSAwLFxuICAgICAgICAgIGxhcmdlc3RXb3JkV2lkdGggPSAwLFxuICAgICAgICAgIGxpbmVKdXN0U3RhcnRlZCA9IHRydWUsXG4gICAgICAgICAgYWRkaXRpb25hbFNwYWNlID0gdGhpcy5fZ2V0V2lkdGhPZkNoYXJTcGFjaW5nKCksXG4gICAgICAgICAgcmVzZXJ2ZWRTcGFjZSA9IHJlc2VydmVkU3BhY2UgfHwgMDtcbiAgICAgIC8vIGZpeCBhIGRpZmZlcmVuY2UgYmV0d2VlbiBzcGxpdCBhbmQgZ3JhcGhlbWVTcGxpdFxuICAgICAgaWYgKHdvcmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB3b3Jkcy5wdXNoKFtdKTtcbiAgICAgIH1cbiAgICAgIGRlc2lyZWRXaWR0aCAtPSByZXNlcnZlZFNwYWNlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBpZiB1c2luZyBzcGxpdEJ5R3JhcGhlbWUgd29yZHMgYXJlIGFscmVhZHkgaW4gZ3JhcGhlbWVzLlxuICAgICAgICB3b3JkID0gc3BsaXRCeUdyYXBoZW1lID8gd29yZHNbaV0gOiBmYWJyaWMudXRpbC5zdHJpbmcuZ3JhcGhlbWVTcGxpdCh3b3Jkc1tpXSk7XG4gICAgICAgIHdvcmRXaWR0aCA9IHRoaXMuX21lYXN1cmVXb3JkKHdvcmQsIGxpbmVJbmRleCwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IHdvcmQubGVuZ3RoO1xuXG4gICAgICAgIGxpbmVXaWR0aCArPSBpbmZpeFdpZHRoICsgd29yZFdpZHRoIC0gYWRkaXRpb25hbFNwYWNlO1xuICAgICAgICBpZiAobGluZVdpZHRoID4gZGVzaXJlZFdpZHRoICYmICFsaW5lSnVzdFN0YXJ0ZWQpIHtcbiAgICAgICAgICBncmFwaGVtZUxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgICAgbGluZSA9IFtdO1xuICAgICAgICAgIGxpbmVXaWR0aCA9IHdvcmRXaWR0aDtcbiAgICAgICAgICBsaW5lSnVzdFN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGxpbmVXaWR0aCArPSBhZGRpdGlvbmFsU3BhY2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWxpbmVKdXN0U3RhcnRlZCAmJiAhc3BsaXRCeUdyYXBoZW1lKSB7XG4gICAgICAgICAgbGluZS5wdXNoKGluZml4KTtcbiAgICAgICAgfVxuICAgICAgICBsaW5lID0gbGluZS5jb25jYXQod29yZCk7XG5cbiAgICAgICAgaW5maXhXaWR0aCA9IHNwbGl0QnlHcmFwaGVtZSA/IDAgOiB0aGlzLl9tZWFzdXJlV29yZChbaW5maXhdLCBsaW5lSW5kZXgsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgICBsaW5lSnVzdFN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgLy8ga2VlcCB0cmFjayBvZiBsYXJnZXN0IHdvcmRcbiAgICAgICAgaWYgKHdvcmRXaWR0aCA+IGxhcmdlc3RXb3JkV2lkdGgpIHtcbiAgICAgICAgICBsYXJnZXN0V29yZFdpZHRoID0gd29yZFdpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGkgJiYgZ3JhcGhlbWVMaW5lcy5wdXNoKGxpbmUpO1xuXG4gICAgICBpZiAobGFyZ2VzdFdvcmRXaWR0aCArIHJlc2VydmVkU3BhY2UgPiB0aGlzLmR5bmFtaWNNaW5XaWR0aCkge1xuICAgICAgICB0aGlzLmR5bmFtaWNNaW5XaWR0aCA9IGxhcmdlc3RXb3JkV2lkdGggLSBhZGRpdGlvbmFsU3BhY2UgKyByZXNlcnZlZFNwYWNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdyYXBoZW1lTGluZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBpZiB0aGUgdGV4dCBsaW5lIGlzIGVuZGVkIHdpdGggYW4gaGFyZCBicmVha1xuICAgICAqIHRleHQgYW5kIGl0ZXh0IGRvIG5vdCBoYXZlIHdyYXBwaW5nLCByZXR1cm4gZmFsc2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUluZGV4IHRleHQgdG8gc3BsaXRcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzRW5kT2ZXcmFwcGluZzogZnVuY3Rpb24obGluZUluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleCArIDFdKSB7XG4gICAgICAgIC8vIGlzIGxhc3QgbGluZSwgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleCArIDFdLmxpbmUgIT09IHRoaXMuX3N0eWxlTWFwW2xpbmVJbmRleF0ubGluZSkge1xuICAgICAgICAvLyB0aGlzIGlzIGxhc3QgbGluZSBiZWZvcmUgYSBsaW5lIGJyZWFrLCByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVjdCBpZiBhIGxpbmUgaGFzIGEgbGluZWJyZWFrIGFuZCBzbyB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIGl0IHdoZW4gbW92aW5nXG4gICAgICogYW5kIGNvdW50aW5nIHN0eWxlLlxuICAgICAqIFRoaXMgaXMgaW1wb3J0YW50IG9ubHkgZm9yIHNwbGl0QnlHcmFwaGVtZSBhdCB0aGUgZW5kIG9mIHdyYXBwaW5nLlxuICAgICAqIElmIHdlIGFyZSBub3Qgd3JhcHBpbmcgdGhlIG9mZnNldCBpcyBhbHdheXMgMVxuICAgICAqIEByZXR1cm4gTnVtYmVyXG4gICAgICovXG4gICAgbWlzc2luZ05ld2xpbmVPZmZzZXQ6IGZ1bmN0aW9uKGxpbmVJbmRleCwgc2tpcFdyYXBwaW5nKSB7XG4gICAgICBpZiAodGhpcy5zcGxpdEJ5R3JhcGhlbWUgJiYgIXNraXBXcmFwcGluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0VuZE9mV3JhcHBpbmcobGluZUluZGV4KSA/IDEgOiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICogR2V0cyBsaW5lcyBvZiB0ZXh0IHRvIHJlbmRlciBpbiB0aGUgVGV4dGJveC4gVGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzXG4gICAgKiB0ZXh0IHdyYXBwaW5nIG9uIHRoZSBmbHkgZXZlcnkgdGltZSBpdCBpcyBjYWxsZWQuXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCB0ZXh0IHRvIHNwbGl0XG4gICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGxpbmVzIGluIHRoZSBUZXh0Ym94LlxuICAgICogQG92ZXJyaWRlXG4gICAgKi9cbiAgICBfc3BsaXRUZXh0SW50b0xpbmVzOiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICB2YXIgbmV3VGV4dCA9IGZhYnJpYy5UZXh0LnByb3RvdHlwZS5fc3BsaXRUZXh0SW50b0xpbmVzLmNhbGwodGhpcywgdGV4dCksXG4gICAgICAgICAgZ3JhcGhlbWVMaW5lcyA9IHRoaXMuX3dyYXBUZXh0KG5ld1RleHQubGluZXMsIHRoaXMud2lkdGgpLFxuICAgICAgICAgIGxpbmVzID0gbmV3IEFycmF5KGdyYXBoZW1lTGluZXMubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhcGhlbWVMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsaW5lc1tpXSA9IGdyYXBoZW1lTGluZXNbaV0uam9pbignJyk7XG4gICAgICB9XG4gICAgICBuZXdUZXh0LmxpbmVzID0gbGluZXM7XG4gICAgICBuZXdUZXh0LmdyYXBoZW1lTGluZXMgPSBncmFwaGVtZUxpbmVzO1xuICAgICAgcmV0dXJuIG5ld1RleHQ7XG4gICAgfSxcblxuICAgIGdldE1pbldpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLm1pbldpZHRoLCB0aGlzLmR5bmFtaWNNaW5XaWR0aCk7XG4gICAgfSxcblxuICAgIF9yZW1vdmVFeHRyYW5lb3VzU3R5bGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsaW5lc1RvS2VlcCA9IHt9O1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiB0aGlzLl9zdHlsZU1hcCkge1xuICAgICAgICBpZiAodGhpcy5fdGV4dExpbmVzW3Byb3BdKSB7XG4gICAgICAgICAgbGluZXNUb0tlZXBbdGhpcy5fc3R5bGVNYXBbcHJvcF0ubGluZV0gPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBwcm9wIGluIHRoaXMuc3R5bGVzKSB7XG4gICAgICAgIGlmICghbGluZXNUb0tlZXBbcHJvcF0pIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5zdHlsZXNbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYW4gaW5zdGFuY2VcbiAgICAgKiBAbWV0aG9kIHRvT2JqZWN0XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BlcnRpZXNUb0luY2x1ZGVdIEFueSBwcm9wZXJ0aWVzIHRoYXQgeW91IG1pZ2h0IHdhbnQgdG8gYWRkaXRpb25hbGx5IGluY2x1ZGUgaW4gdGhlIG91dHB1dFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGFuIGluc3RhbmNlXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKHByb3BlcnRpZXNUb0luY2x1ZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbGxTdXBlcigndG9PYmplY3QnLCBbJ21pbldpZHRoJywgJ3NwbGl0QnlHcmFwaGVtZSddLmNvbmNhdChwcm9wZXJ0aWVzVG9JbmNsdWRlKSk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUmV0dXJucyBmYWJyaWMuVGV4dGJveCBpbnN0YW5jZSBmcm9tIGFuIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBmYWJyaWMuVGV4dGJveFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdCB0byBjcmVhdGUgYW4gaW5zdGFuY2UgZnJvbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIGFuIGZhYnJpYy5UZXh0Ym94IGluc3RhbmNlIGlzIGNyZWF0ZWRcbiAgICovXG4gIGZhYnJpYy5UZXh0Ym94LmZyb21PYmplY3QgPSBmdW5jdGlvbihvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHN0eWxlcyA9IGZhYnJpYy51dGlsLnN0eWxlc0Zyb21BcnJheShvYmplY3Quc3R5bGVzLCBvYmplY3QudGV4dCk7XG4gICAgLy9jb3B5IG9iamVjdCB0byBwcmV2ZW50IG11dGF0aW9uXG4gICAgdmFyIG9iakNvcHkgPSBPYmplY3QuYXNzaWduKHt9LCBvYmplY3QsIHsgc3R5bGVzOiBzdHlsZXMgfSk7XG4gICAgZGVsZXRlIG9iakNvcHkucGF0aDtcbiAgICByZXR1cm4gZmFicmljLk9iamVjdC5fZnJvbU9iamVjdCgnVGV4dGJveCcsIG9iakNvcHksICBmdW5jdGlvbih0ZXh0SW5zdGFuY2UpIHtcbiAgICAgIGlmIChvYmplY3QucGF0aCkge1xuICAgICAgICBmYWJyaWMuT2JqZWN0Ll9mcm9tT2JqZWN0KCdQYXRoJywgb2JqZWN0LnBhdGgsIGZ1bmN0aW9uKHBhdGhJbnN0YW5jZSkge1xuICAgICAgICAgIHRleHRJbnN0YW5jZS5zZXQoJ3BhdGgnLCBwYXRoSW5zdGFuY2UpO1xuICAgICAgICAgIGNhbGxiYWNrKHRleHRJbnN0YW5jZSk7XG4gICAgICAgIH0sICdwYXRoJyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sodGV4dEluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9LCAndGV4dCcpO1xuICB9O1xufSkodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXMpO1xuXG5cbihmdW5jdGlvbigpIHtcblxuICB2YXIgY29udHJvbHNVdGlscyA9IGZhYnJpYy5jb250cm9sc1V0aWxzLFxuICAgICAgc2NhbGVTa2V3U3R5bGVIYW5kbGVyID0gY29udHJvbHNVdGlscy5zY2FsZVNrZXdDdXJzb3JTdHlsZUhhbmRsZXIsXG4gICAgICBzY2FsZVN0eWxlSGFuZGxlciA9IGNvbnRyb2xzVXRpbHMuc2NhbGVDdXJzb3JTdHlsZUhhbmRsZXIsXG4gICAgICBzY2FsaW5nRXF1YWxseSA9IGNvbnRyb2xzVXRpbHMuc2NhbGluZ0VxdWFsbHksXG4gICAgICBzY2FsaW5nWU9yU2tld2luZ1ggPSBjb250cm9sc1V0aWxzLnNjYWxpbmdZT3JTa2V3aW5nWCxcbiAgICAgIHNjYWxpbmdYT3JTa2V3aW5nWSA9IGNvbnRyb2xzVXRpbHMuc2NhbGluZ1hPclNrZXdpbmdZLFxuICAgICAgc2NhbGVPclNrZXdBY3Rpb25OYW1lID0gY29udHJvbHNVdGlscy5zY2FsZU9yU2tld0FjdGlvbk5hbWUsXG4gICAgICBvYmplY3RDb250cm9scyA9IGZhYnJpYy5PYmplY3QucHJvdG90eXBlLmNvbnRyb2xzO1xuXG4gIG9iamVjdENvbnRyb2xzLm1sID0gbmV3IGZhYnJpYy5Db250cm9sKHtcbiAgICB4OiAtMC41LFxuICAgIHk6IDAsXG4gICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBzY2FsZVNrZXdTdHlsZUhhbmRsZXIsXG4gICAgYWN0aW9uSGFuZGxlcjogc2NhbGluZ1hPclNrZXdpbmdZLFxuICAgIGdldEFjdGlvbk5hbWU6IHNjYWxlT3JTa2V3QWN0aW9uTmFtZSxcbiAgfSk7XG5cbiAgb2JqZWN0Q29udHJvbHMubXIgPSBuZXcgZmFicmljLkNvbnRyb2woe1xuICAgIHg6IDAuNSxcbiAgICB5OiAwLFxuICAgIGN1cnNvclN0eWxlSGFuZGxlcjogc2NhbGVTa2V3U3R5bGVIYW5kbGVyLFxuICAgIGFjdGlvbkhhbmRsZXI6IHNjYWxpbmdYT3JTa2V3aW5nWSxcbiAgICBnZXRBY3Rpb25OYW1lOiBzY2FsZU9yU2tld0FjdGlvbk5hbWUsXG4gIH0pO1xuXG4gIG9iamVjdENvbnRyb2xzLm1iID0gbmV3IGZhYnJpYy5Db250cm9sKHtcbiAgICB4OiAwLFxuICAgIHk6IDAuNSxcbiAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IHNjYWxlU2tld1N0eWxlSGFuZGxlcixcbiAgICBhY3Rpb25IYW5kbGVyOiBzY2FsaW5nWU9yU2tld2luZ1gsXG4gICAgZ2V0QWN0aW9uTmFtZTogc2NhbGVPclNrZXdBY3Rpb25OYW1lLFxuICB9KTtcblxuICBvYmplY3RDb250cm9scy5tdCA9IG5ldyBmYWJyaWMuQ29udHJvbCh7XG4gICAgeDogMCxcbiAgICB5OiAtMC41LFxuICAgIGN1cnNvclN0eWxlSGFuZGxlcjogc2NhbGVTa2V3U3R5bGVIYW5kbGVyLFxuICAgIGFjdGlvbkhhbmRsZXI6IHNjYWxpbmdZT3JTa2V3aW5nWCxcbiAgICBnZXRBY3Rpb25OYW1lOiBzY2FsZU9yU2tld0FjdGlvbk5hbWUsXG4gIH0pO1xuXG4gIG9iamVjdENvbnRyb2xzLnRsID0gbmV3IGZhYnJpYy5Db250cm9sKHtcbiAgICB4OiAtMC41LFxuICAgIHk6IC0wLjUsXG4gICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBzY2FsZVN0eWxlSGFuZGxlcixcbiAgICBhY3Rpb25IYW5kbGVyOiBzY2FsaW5nRXF1YWxseVxuICB9KTtcblxuICBvYmplY3RDb250cm9scy50ciA9IG5ldyBmYWJyaWMuQ29udHJvbCh7XG4gICAgeDogMC41LFxuICAgIHk6IC0wLjUsXG4gICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBzY2FsZVN0eWxlSGFuZGxlcixcbiAgICBhY3Rpb25IYW5kbGVyOiBzY2FsaW5nRXF1YWxseVxuICB9KTtcblxuICBvYmplY3RDb250cm9scy5ibCA9IG5ldyBmYWJyaWMuQ29udHJvbCh7XG4gICAgeDogLTAuNSxcbiAgICB5OiAwLjUsXG4gICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBzY2FsZVN0eWxlSGFuZGxlcixcbiAgICBhY3Rpb25IYW5kbGVyOiBzY2FsaW5nRXF1YWxseVxuICB9KTtcblxuICBvYmplY3RDb250cm9scy5iciA9IG5ldyBmYWJyaWMuQ29udHJvbCh7XG4gICAgeDogMC41LFxuICAgIHk6IDAuNSxcbiAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IHNjYWxlU3R5bGVIYW5kbGVyLFxuICAgIGFjdGlvbkhhbmRsZXI6IHNjYWxpbmdFcXVhbGx5XG4gIH0pO1xuXG4gIG9iamVjdENvbnRyb2xzLm10ciA9IG5ldyBmYWJyaWMuQ29udHJvbCh7XG4gICAgeDogMCxcbiAgICB5OiAtMC41LFxuICAgIGFjdGlvbkhhbmRsZXI6IGNvbnRyb2xzVXRpbHMucm90YXRpb25XaXRoU25hcHBpbmcsXG4gICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBjb250cm9sc1V0aWxzLnJvdGF0aW9uU3R5bGVIYW5kbGVyLFxuICAgIG9mZnNldFk6IC00MCxcbiAgICB3aXRoQ29ubmVjdGlvbjogdHJ1ZSxcbiAgICBhY3Rpb25OYW1lOiAncm90YXRlJyxcbiAgfSk7XG5cbiAgaWYgKGZhYnJpYy5UZXh0Ym94KSB7XG4gICAgLy8gdGhpcyBpcyBicmVha2luZyB0aGUgcHJvdG90eXBlIGluaGVyaXRhbmNlLCBubyB0aW1lIC8gaWRlYXMgdG8gZml4IGl0LlxuICAgIC8vIGlzIGltcG9ydGFudCB0byBkb2N1bWVudCB0aGF0IGlmIHlvdSB3YW50IHRvIGhhdmUgYWxsIG9iamVjdHMgdG8gaGF2ZSBhXG4gICAgLy8gc3BlY2lmaWMgY3VzdG9tIGNvbnRyb2wsIHlvdSBoYXZlIHRvIGFkZCBpdCB0byBPYmplY3QgcHJvdG90eXBlIGFuZCB0byBUZXh0Ym94XG4gICAgLy8gcHJvdG90eXBlLiBUaGUgY29udHJvbHMgYXJlIHNoYXJlZCBhcyByZWZlcmVuY2VzLiBTbyBjaGFuZ2VzIHRvIGNvbnRyb2wgYHRyYFxuICAgIC8vIGNhbiBzdGlsbCBhcHBseSB0byBhbGwgb2JqZWN0cyBpZiBuZWVkZWQuXG4gICAgdmFyIHRleHRCb3hDb250cm9scyA9IGZhYnJpYy5UZXh0Ym94LnByb3RvdHlwZS5jb250cm9scyA9IHsgfTtcblxuICAgIHRleHRCb3hDb250cm9scy5tdHIgPSBvYmplY3RDb250cm9scy5tdHI7XG4gICAgdGV4dEJveENvbnRyb2xzLnRyID0gb2JqZWN0Q29udHJvbHMudHI7XG4gICAgdGV4dEJveENvbnRyb2xzLmJyID0gb2JqZWN0Q29udHJvbHMuYnI7XG4gICAgdGV4dEJveENvbnRyb2xzLnRsID0gb2JqZWN0Q29udHJvbHMudGw7XG4gICAgdGV4dEJveENvbnRyb2xzLmJsID0gb2JqZWN0Q29udHJvbHMuYmw7XG4gICAgdGV4dEJveENvbnRyb2xzLm10ID0gb2JqZWN0Q29udHJvbHMubXQ7XG4gICAgdGV4dEJveENvbnRyb2xzLm1iID0gb2JqZWN0Q29udHJvbHMubWI7XG5cbiAgICB0ZXh0Qm94Q29udHJvbHMubXIgPSBuZXcgZmFicmljLkNvbnRyb2woe1xuICAgICAgeDogMC41LFxuICAgICAgeTogMCxcbiAgICAgIGFjdGlvbkhhbmRsZXI6IGNvbnRyb2xzVXRpbHMuY2hhbmdlV2lkdGgsXG4gICAgICBjdXJzb3JTdHlsZUhhbmRsZXI6IHNjYWxlU2tld1N0eWxlSGFuZGxlcixcbiAgICAgIGFjdGlvbk5hbWU6ICdyZXNpemluZycsXG4gICAgfSk7XG5cbiAgICB0ZXh0Qm94Q29udHJvbHMubWwgPSBuZXcgZmFicmljLkNvbnRyb2woe1xuICAgICAgeDogLTAuNSxcbiAgICAgIHk6IDAsXG4gICAgICBhY3Rpb25IYW5kbGVyOiBjb250cm9sc1V0aWxzLmNoYW5nZVdpZHRoLFxuICAgICAgY3Vyc29yU3R5bGVIYW5kbGVyOiBzY2FsZVNrZXdTdHlsZUhhbmRsZXIsXG4gICAgICBhY3Rpb25OYW1lOiAncmVzaXppbmcnLFxuICAgIH0pO1xuICB9XG59KSgpO1xuXG4iXSwibmFtZXMiOlsiZmFicmljIiwidmVyc2lvbiIsImV4cG9ydHMiLCJkZWZpbmUiLCJhbWQiLCJkb2N1bWVudCIsIkhUTUxEb2N1bWVudCIsIkRvY3VtZW50IiwiaW1wbGVtZW50YXRpb24iLCJjcmVhdGVIVE1MRG9jdW1lbnQiLCJ3aW5kb3ciLCJqc2RvbSIsInJlcXVpcmUiLCJ2aXJ0dWFsV2luZG93IiwiSlNET00iLCJkZWNvZGVVUklDb21wb25lbnQiLCJmZWF0dXJlcyIsIkZldGNoRXh0ZXJuYWxSZXNvdXJjZXMiLCJyZXNvdXJjZXMiLCJqc2RvbUltcGxGb3JXcmFwcGVyIiwiaW1wbEZvcldyYXBwZXIiLCJub2RlQ2FudmFzIiwiQ2FudmFzIiwiRE9NUGFyc2VyIiwiaXNUb3VjaFN1cHBvcnRlZCIsIm5hdmlnYXRvciIsIm1heFRvdWNoUG9pbnRzIiwiaXNMaWtlbHlOb2RlIiwiQnVmZmVyIiwiU0hBUkVEX0FUVFJJQlVURVMiLCJEUEkiLCJyZU51bSIsImNvbW1hV3NwIiwicmVQYXRoQ29tbWFuZCIsInJlTm9uV29yZCIsImZvbnRQYXRocyIsImlNYXRyaXgiLCJzdmdOUyIsInBlcmZMaW1pdFNpemVUb3RhbCIsIm1heENhY2hlU2lkZUxpbWl0IiwibWluQ2FjaGVTaWRlTGltaXQiLCJjaGFyV2lkdGhzQ2FjaGUiLCJ0ZXh0dXJlU2l6ZSIsImRpc2FibGVTdHlsZUNvcHlQYXN0ZSIsImVuYWJsZUdMRmlsdGVyaW5nIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIndlYmtpdERldmljZVBpeGVsUmF0aW8iLCJtb3pEZXZpY2VQaXhlbFJhdGlvIiwiYnJvd3NlclNoYWRvd0JsdXJDb25zdGFudCIsImFyY1RvU2VnbWVudHNDYWNoZSIsImJvdW5kc09mQ3VydmVDYWNoZSIsImNhY2hlc0JvdW5kc09mQ3VydmUiLCJmb3JjZUdMUHV0SW1hZ2VEYXRhIiwiaW5pdEZpbHRlckJhY2tlbmQiLCJpc1dlYmdsU3VwcG9ydGVkIiwiY29uc29sZSIsImxvZyIsIm1heFRleHR1cmVTaXplIiwiV2ViZ2xGaWx0ZXJCYWNrZW5kIiwidGlsZVNpemUiLCJDYW52YXMyZEZpbHRlckJhY2tlbmQiLCJfcmVtb3ZlRXZlbnRMaXN0ZW5lciIsImV2ZW50TmFtZSIsImhhbmRsZXIiLCJfX2V2ZW50TGlzdGVuZXJzIiwiZXZlbnRMaXN0ZW5lciIsImluZGV4T2YiLCJ1dGlsIiwiYXJyYXkiLCJmaWxsIiwib24iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJwcm9wIiwicHVzaCIsIl9vbmNlIiwiX2hhbmRsZXIiLCJhcHBseSIsIm9mZiIsImJpbmQiLCJvbmNlIiwiY2FsbCIsImZpcmUiLCJvcHRpb25zIiwibGlzdGVuZXJzRm9yRXZlbnQiLCJpIiwibGVuIiwiZmlsdGVyIiwidmFsdWUiLCJPYnNlcnZhYmxlIiwiQ29sbGVjdGlvbiIsIl9vYmplY3RzIiwiYWRkIiwiX29uT2JqZWN0QWRkZWQiLCJyZW5kZXJPbkFkZFJlbW92ZSIsInJlcXVlc3RSZW5kZXJBbGwiLCJpbnNlcnRBdCIsIm9iamVjdCIsImluZGV4Iiwibm9uU3BsaWNpbmciLCJvYmplY3RzIiwic3BsaWNlIiwicmVtb3ZlIiwic29tZXRoaW5nUmVtb3ZlZCIsIl9vbk9iamVjdFJlbW92ZWQiLCJmb3JFYWNoT2JqZWN0IiwiY2FsbGJhY2siLCJjb250ZXh0IiwiZ2V0T2JqZWN0cyIsInR5cGUiLCJjb25jYXQiLCJvIiwiaXRlbSIsImlzRW1wdHkiLCJzaXplIiwiY29udGFpbnMiLCJkZWVwIiwic29tZSIsIm9iaiIsImNvbXBsZXhpdHkiLCJyZWR1Y2UiLCJtZW1vIiwiY3VycmVudCIsIkNvbW1vbk1ldGhvZHMiLCJfc2V0T3B0aW9ucyIsInNldCIsIl9pbml0R3JhZGllbnQiLCJmaWxsZXIiLCJwcm9wZXJ0eSIsImNvbG9yU3RvcHMiLCJHcmFkaWVudCIsIl9pbml0UGF0dGVybiIsInNvdXJjZSIsIlBhdHRlcm4iLCJfc2V0T2JqZWN0IiwiX3NldCIsImtleSIsInRvZ2dsZSIsImdldCIsImdsb2JhbCIsInNxcnQiLCJNYXRoIiwiYXRhbjIiLCJwb3ciLCJQaUJ5MTgwIiwiUEkiLCJQaUJ5MiIsImNvcyIsImFuZ2xlIiwiYW5nbGVTbGljZSIsInNpbiIsInNpZ24iLCJyZW1vdmVGcm9tQXJyYXkiLCJpZHgiLCJnZXRSYW5kb21JbnQiLCJtaW4iLCJtYXgiLCJmbG9vciIsInJhbmRvbSIsImRlZ3JlZXNUb1JhZGlhbnMiLCJkZWdyZWVzIiwicmFkaWFuc1RvRGVncmVlcyIsInJhZGlhbnMiLCJyb3RhdGVQb2ludCIsInBvaW50Iiwib3JpZ2luIiwibmV3UG9pbnQiLCJQb2ludCIsIngiLCJ5IiwidiIsInJvdGF0ZVZlY3RvciIsImFkZEVxdWFscyIsInZlY3RvciIsInJ4IiwicnkiLCJjcmVhdGVWZWN0b3IiLCJmcm9tIiwidG8iLCJjYWxjQW5nbGVCZXR3ZWVuVmVjdG9ycyIsImEiLCJiIiwiYWNvcyIsImh5cG90IiwiZ2V0SGF0VmVjdG9yIiwibXVsdGlwbHkiLCJnZXRCaXNlY3RvciIsIkEiLCJCIiwiQyIsIkFCIiwiQUMiLCJhbHBoYSIsInJvIiwicGhpIiwicHJvamVjdFN0cm9rZU9uUG9pbnRzIiwicG9pbnRzIiwib3BlblBhdGgiLCJjb29yZHMiLCJzIiwic3Ryb2tlV2lkdGgiLCJzdHJva2VVbmlmb3JtU2NhbGFyIiwic3Ryb2tlVW5pZm9ybSIsInNjYWxlWCIsInNjYWxlWSIsImdldFN0cm9rZUhhdFZlY3RvciIsInNjYWxhciIsImZvckVhY2giLCJwIiwiYmlzZWN0b3IiLCJiaXNlY3RvclZlY3RvciIsIm1pdGVyVmVjdG9yIiwic3Ryb2tlTGluZUpvaW4iLCJzdHJva2VNaXRlckxpbWl0Iiwic3VidHJhY3QiLCJTUVJUMiIsInRyYW5zZm9ybVBvaW50IiwidCIsImlnbm9yZU9mZnNldCIsIm1ha2VCb3VuZGluZ0JveEZyb21Qb2ludHMiLCJ0cmFuc2Zvcm0iLCJ4UG9pbnRzIiwibWluWCIsIm1heFgiLCJ3aWR0aCIsInlQb2ludHMiLCJtaW5ZIiwibWF4WSIsImhlaWdodCIsImxlZnQiLCJ0b3AiLCJpbnZlcnRUcmFuc2Zvcm0iLCJyIiwidG9GaXhlZCIsIm51bWJlciIsImZyYWN0aW9uRGlnaXRzIiwicGFyc2VGbG9hdCIsIk51bWJlciIsInBhcnNlVW5pdCIsImZvbnRTaXplIiwidW5pdCIsImV4ZWMiLCJUZXh0IiwiREVGQVVMVF9TVkdfRk9OVF9TSVpFIiwiZmFsc2VGdW5jdGlvbiIsImdldEtsYXNzIiwibmFtZXNwYWNlIiwic3RyaW5nIiwiY2FtZWxpemUiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwicmVzb2x2ZU5hbWVzcGFjZSIsImdldFN2Z0F0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzIiwicGFydHMiLCJzcGxpdCIsImxvYWRJbWFnZSIsInVybCIsImNyb3NzT3JpZ2luIiwiaW1nIiwiY3JlYXRlSW1hZ2UiLCJvbkxvYWRDYWxsYmFjayIsIm9ubG9hZCIsIm9uZXJyb3IiLCJzcmMiLCJ1bmRlZmluZWQiLCJzdWJzdHJpbmciLCJsb2FkSW1hZ2VJbkRvbSIsImRpdiIsImNyZWF0ZUVsZW1lbnQiLCJzdHlsZSIsInBvc2l0aW9uIiwiYXBwZW5kQ2hpbGQiLCJxdWVyeVNlbGVjdG9yIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiZW5saXZlbk9iamVjdHMiLCJyZXZpdmVyIiwiZW5saXZlbmVkT2JqZWN0cyIsIm51bUxvYWRlZE9iamVjdHMiLCJudW1Ub3RhbE9iamVjdHMiLCJvbkxvYWRlZCIsImtsYXNzIiwiZnJvbU9iamVjdCIsImVycm9yIiwiZW5saXZlbk9iamVjdEVubGl2YWJsZXMiLCJlbmxpdmVuUHJvcHMiLCJPYmplY3QiLCJFTkxJVkVOX1BST1BTIiwibWFwIiwiZW5saXZlZFByb3BzIiwiZW5saXZlblBhdHRlcm5zIiwicGF0dGVybnMiLCJudW1Mb2FkZWRQYXR0ZXJucyIsIm51bVBhdHRlcm5zIiwiZW5saXZlbmVkUGF0dGVybnMiLCJwYXR0ZXJuIiwiZ3JvdXBTVkdFbGVtZW50cyIsImVsZW1lbnRzIiwicGF0aCIsInNvdXJjZVBhdGgiLCJjZW50ZXJQb2ludCIsIkdyb3VwIiwicG9wdWxhdGVXaXRoUHJvcGVydGllcyIsImRlc3RpbmF0aW9uIiwicHJvcGVydGllcyIsIkFycmF5IiwiaXNBcnJheSIsImNyZWF0ZUNhbnZhc0VsZW1lbnQiLCJjb3B5Q2FudmFzRWxlbWVudCIsImNhbnZhcyIsIm5ld0NhbnZhcyIsImdldENvbnRleHQiLCJkcmF3SW1hZ2UiLCJ0b0RhdGFVUkwiLCJjYW52YXNFbCIsImZvcm1hdCIsInF1YWxpdHkiLCJtdWx0aXBseVRyYW5zZm9ybU1hdHJpY2VzIiwiaXMyeDIiLCJxckRlY29tcG9zZSIsImRlbm9tIiwic2tld1giLCJza2V3WSIsInRyYW5zbGF0ZVgiLCJ0cmFuc2xhdGVZIiwiY2FsY1JvdGF0ZU1hdHJpeCIsInRoZXRhIiwiY2FsY0RpbWVuc2lvbnNNYXRyaXgiLCJzY2FsZU1hdHJpeCIsImZsaXBYIiwiZmxpcFkiLCJ0YW4iLCJjb21wb3NlTWF0cml4IiwibWF0cml4IiwicmVzZXRPYmplY3RUcmFuc2Zvcm0iLCJ0YXJnZXQiLCJyb3RhdGUiLCJzYXZlT2JqZWN0VHJhbnNmb3JtIiwiaXNUcmFuc3BhcmVudCIsImN0eCIsInRvbGVyYW5jZSIsIl9pc1RyYW5zcGFyZW50IiwidGVtcCIsImltYWdlRGF0YSIsImdldEltYWdlRGF0YSIsImwiLCJkYXRhIiwicGFyc2VQcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0cmlidXRlIiwiYXR0cmlidXRlIiwibWVldE9yU2xpY2UiLCJhbGlnblgiLCJhbGlnblkiLCJhc3BlY3RSYXRpb0F0dHJzIiwiYWxpZ24iLCJwb3AiLCJjbGVhckZhYnJpY0ZvbnRDYWNoZSIsImZvbnRGYW1pbHkiLCJ0b0xvd2VyQ2FzZSIsImxpbWl0RGltc0J5QXJlYSIsImFyIiwibWF4aW11bUFyZWEiLCJyb3VnaFdpZHRoIiwicGVyZkxpbWl0U2l6ZVkiLCJjYXBWYWx1ZSIsImZpbmRTY2FsZVRvRml0IiwiZmluZFNjYWxlVG9Db3ZlciIsIm1hdHJpeFRvU1ZHIiwiTlVNX0ZSQUNUSU9OX0RJR0lUUyIsImpvaW4iLCJyZW1vdmVUcmFuc2Zvcm1Gcm9tT2JqZWN0IiwiaW52ZXJ0ZWQiLCJmaW5hbFRyYW5zZm9ybSIsImNhbGNPd25NYXRyaXgiLCJhcHBseVRyYW5zZm9ybVRvT2JqZWN0IiwiYWRkVHJhbnNmb3JtVG9PYmplY3QiLCJjZW50ZXIiLCJzZXRQb3NpdGlvbkJ5T3JpZ2luIiwic2l6ZUFmdGVyVHJhbnNmb3JtIiwiZGltWCIsImRpbVkiLCJ0cmFuc2Zvcm1NYXRyaXgiLCJiYm94IiwibWVyZ2VDbGlwUGF0aHMiLCJjMSIsImMyIiwiY2FsY1RyYW5zZm9ybU1hdHJpeCIsImNsaXBQYXRoIiwiaGFzU3R5bGVDaGFuZ2VkIiwicHJldlN0eWxlIiwidGhpc1N0eWxlIiwiZm9yVGV4dFNwYW5zIiwic3Ryb2tlIiwiZm9udFdlaWdodCIsImZvbnRTdHlsZSIsInRleHRCYWNrZ3JvdW5kQ29sb3IiLCJkZWx0YVkiLCJvdmVybGluZSIsInVuZGVybGluZSIsImxpbmV0aHJvdWdoIiwic3R5bGVzVG9BcnJheSIsInN0eWxlcyIsInRleHQiLCJjbG9uZSIsInRleHRMaW5lcyIsImNoYXJJbmRleCIsInN0eWxlc0FycmF5IiwiYyIsImtleXMiLCJzdHlsZUNoYW5nZWQiLCJzdGFydCIsImVuZCIsInN0eWxlc0Zyb21BcnJheSIsInN0eWxlSW5kZXgiLCJzdHlsZXNPYmplY3QiLCJhc3NpZ24iLCJfam9pbiIsInByb3RvdHlwZSIsImNvbW1hbmRMZW5ndGhzIiwibSIsImgiLCJxIiwicmVwZWF0ZWRDb21tYW5kcyIsIk0iLCJzZWdtZW50VG9CZXppZXIiLCJ0aDIiLCJ0aDMiLCJjb3NUaCIsInNpblRoIiwiY3gxIiwiY3kxIiwibVQiLCJmcm9tWCIsImZyb21ZIiwiY29zdGgyIiwic2ludGgyIiwiY29zdGgzIiwic2ludGgzIiwidG9YIiwidG9ZIiwiY3AxWCIsImNwMVkiLCJjcDJYIiwiY3AyWSIsImFyY1RvU2VnbWVudHMiLCJsYXJnZSIsInN3ZWVwIiwicm90YXRlWCIsInRoIiwiYWJzIiwicHgiLCJweSIsInJ4MiIsInJ5MiIsInB5MiIsInB4MiIsInBsIiwicm9vdCIsImN4IiwiY3kiLCJtVGhldGEiLCJjYWxjVmVjdG9yQW5nbGUiLCJkdGhldGEiLCJzZWdtZW50cyIsImNlaWwiLCJyZXN1bHQiLCJtRGVsdGEiLCJ1eCIsInV5IiwidngiLCJ2eSIsInRhIiwidGIiLCJnZXRCb3VuZHNPZkN1cnZlIiwieDAiLCJ5MCIsIngxIiwieTEiLCJ4MiIsInkyIiwieDMiLCJ5MyIsImFyZ3NTdHJpbmciLCJ0dmFsdWVzIiwiYm91bmRzIiwidDEiLCJ0MiIsImIyYWMiLCJzcXJ0YjJhYyIsImoiLCJqbGVuIiwibXQiLCJmcm9tQXJjVG9CZXppZXJzIiwiZngiLCJmeSIsInJvdCIsInR4IiwidHkiLCJzZWdzTm9ybSIsIm1ha2VQYXRoU2ltcGxlciIsImNvbnZlcnRlZCIsImRlc3RpbmF0aW9uUGF0aCIsInByZXZpb3VzIiwiY29udHJvbFgiLCJjb250cm9sWSIsImNhbGNMaW5lTGVuZ3RoIiwiQ0IxIiwiQ0IyIiwiQ0IzIiwiQ0I0IiwiZ2V0UG9pbnRPbkN1YmljQmV6aWVySXRlcmF0b3IiLCJwMXgiLCJwMXkiLCJwMngiLCJwMnkiLCJwM3giLCJwM3kiLCJwNHgiLCJwNHkiLCJwY3QiLCJjMyIsImM0IiwiZ2V0VGFuZ2VudEN1YmljSXRlcmF0b3IiLCJpbnZUIiwidGFuZ2VudFgiLCJ0YW5nZW50WSIsIlFCMSIsIlFCMiIsIlFCMyIsImdldFBvaW50T25RdWFkcmF0aWNCZXppZXJJdGVyYXRvciIsImdldFRhbmdlbnRRdWFkcmF0aWNJdGVyYXRvciIsInBhdGhJdGVyYXRvciIsIml0ZXJhdG9yIiwidGVtcFAiLCJ0bXBMZW4iLCJwZXJjIiwiZmluZFBlcmNlbnRhZ2VGb3JEaXN0YW5jZSIsInNlZ0luZm8iLCJkaXN0YW5jZSIsIm5leHRMZW4iLCJuZXh0U3RlcCIsImFuZ2xlRmluZGVyIiwibGFzdFBlcmMiLCJnZXRQYXRoU2VnbWVudHNJbmZvIiwidG90YWxMZW5ndGgiLCJpbmZvIiwidGVtcEluZm8iLCJjb21tYW5kIiwiZGVzdFgiLCJkZXN0WSIsImdldFBvaW50T25QYXRoIiwiaW5mb3MiLCJzZWdQZXJjZW50Iiwic2VnbWVudCIsImxlcnAiLCJwYXJzZVBhdGgiLCJwYXRoU3RyaW5nIiwiY3VycmVudFBhdGgiLCJwYXJzZWQiLCJyZSIsInJOdW1iZXIiLCJyTnVtYmVyQ29tbWFXc3AiLCJyRmxhZ0NvbW1hV3NwIiwickFyY1NlcSIsInJlZ0FyY0FyZ3VtZW50U2VxdWVuY2UiLCJSZWdFeHAiLCJtYXRjaCIsImNvb3Jkc1N0ciIsImNvb3Jkc1BhcnNlZCIsInRyaW0iLCJhcmdzIiwiaXNOYU4iLCJjb21tYW5kTGVuZ3RoIiwicmVwZWF0ZWRDb21tYW5kIiwiayIsImtsZW4iLCJnZXRTbW9vdGhQYXRoRnJvbVBvaW50cyIsImNvcnJlY3Rpb24iLCJwMSIsInAyIiwibXVsdFNpZ25YIiwibXVsdFNpZ25ZIiwibWFueVBvaW50cyIsImVxIiwibWlkUG9pbnQiLCJtaWRQb2ludEZyb20iLCJ0cmFuc2Zvcm1QYXRoIiwicGF0aE9mZnNldCIsInBhdGhTZWdtZW50IiwibmV3U2VnbWVudCIsImpvaW5QYXRoIiwicGF0aERhdGEiLCJpbnZva2UiLCJtZXRob2QiLCJieVByb3BlcnR5IiwiZmluZCIsInZhbHVlMSIsInZhbHVlMiIsImNvbmRpdGlvbiIsImV4dGVuZCIsIkVsZW1lbnQiLCJoYXNPd25Qcm9wZXJ0eSIsInJlcGxhY2UiLCJjaGFyYWN0ZXIiLCJjYXBpdGFsaXplIiwiZmlyc3RMZXR0ZXJPbmx5IiwiZXNjYXBlWG1sIiwiZ3JhcGhlbWVTcGxpdCIsInRleHRzdHJpbmciLCJjaHIiLCJncmFwaGVtZXMiLCJnZXRXaG9sZUNoYXIiLCJzdHIiLCJjb2RlIiwiY2hhckNvZGVBdCIsIm5leHQiLCJwcmV2IiwiZW1wdHlGdW5jdGlvbiIsIklTX0RPTlRFTlVNX0JVR0dZIiwidG9TdHJpbmciLCJhZGRNZXRob2RzIiwicGFyZW50Iiwic3VwZXJjbGFzcyIsImNvbnN0cnVjdG9yIiwicmV0dXJuVmFsdWUiLCJ2YWx1ZU9mIiwiU3ViY2xhc3MiLCJjYWxsU3VwZXIiLCJtZXRob2ROYW1lIiwicGFyZW50TWV0aG9kIiwiX3RoaXMiLCJzdXBlckNsYXNzTWV0aG9kIiwiY3JlYXRlQ2xhc3MiLCJzaGlmdCIsImluaXRpYWxpemUiLCJzdWJjbGFzc2VzIiwiY291bGRVc2VBdHRhY2hFdmVudCIsImF0dGFjaEV2ZW50IiwidG91Y2hFdmVudHMiLCJhZGRMaXN0ZW5lciIsImVsZW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZ2V0VG91Y2hJbmZvIiwiZXZlbnQiLCJ0b3VjaFByb3AiLCJjaGFuZ2VkVG91Y2hlcyIsImdldFBvaW50ZXIiLCJzY3JvbGwiLCJnZXRTY3JvbGxMZWZ0VG9wIiwiX2V2dCIsImNsaWVudFgiLCJjbGllbnRZIiwiaXNUb3VjaEV2ZW50IiwicG9pbnRlclR5cGUiLCJzZXRTdHlsZSIsImVsZW1lbnRTdHlsZSIsImNzc1RleHQiLCJzZXRPcGFjaXR5Iiwibm9ybWFsaXplZFByb3BlcnR5Iiwic3R5bGVGbG9hdCIsInNldFByb3BlcnR5IiwicGFyc2VFbCIsInN1cHBvcnRzT3BhY2l0eSIsIm9wYWNpdHkiLCJzdXBwb3J0c0ZpbHRlcnMiLCJyZU9wYWNpdHkiLCJlcyIsImN1cnJlbnRTdHlsZSIsImhhc0xheW91dCIsInpvb20iLCJ0ZXN0IiwiX3NsaWNlIiwiZ2V0QnlJZCIsImlkIiwiZ2V0RWxlbWVudEJ5SWQiLCJzbGljZUNhbkNvbnZlcnROb2RlbGlzdHMiLCJ0b0FycmF5IiwiYXJyYXlMaWtlIiwiY2hpbGROb2RlcyIsImVyciIsImFyciIsIm1ha2VFbGVtZW50IiwidGFnTmFtZSIsImVsIiwiY2xhc3NOYW1lIiwiaHRtbEZvciIsInNldEF0dHJpYnV0ZSIsImFkZENsYXNzIiwid3JhcEVsZW1lbnQiLCJ3cmFwcGVyIiwicmVwbGFjZUNoaWxkIiwiZG9jRWxlbWVudCIsImRvY3VtZW50RWxlbWVudCIsImJvZHkiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsVG9wIiwiaG9zdCIsIm5vZGVUeXBlIiwiZ2V0RWxlbWVudE9mZnNldCIsImRvY0VsZW0iLCJkb2MiLCJvd25lckRvY3VtZW50IiwiYm94Iiwib2Zmc2V0Iiwic2Nyb2xsTGVmdFRvcCIsIm9mZnNldEF0dHJpYnV0ZXMiLCJib3JkZXJMZWZ0V2lkdGgiLCJib3JkZXJUb3BXaWR0aCIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1RvcCIsImF0dHIiLCJwYXJzZUludCIsImdldEVsZW1lbnRTdHlsZSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudExlZnQiLCJjbGllbnRUb3AiLCJkZWZhdWx0VmlldyIsImdldENvbXB1dGVkU3R5bGUiLCJzZWxlY3RQcm9wIiwibWFrZUVsZW1lbnRVbnNlbGVjdGFibGUiLCJvbnNlbGVjdHN0YXJ0IiwidW5zZWxlY3RhYmxlIiwibWFrZUVsZW1lbnRTZWxlY3RhYmxlIiwiZ2V0Tm9kZUNhbnZhcyIsImltcGwiLCJfY2FudmFzIiwiX2ltYWdlIiwiY2xlYW5VcEpzZG9tTm9kZSIsIl9jdXJyZW50U3JjIiwiX2F0dHJpYnV0ZXMiLCJfY2xhc3NMaXN0Iiwic2V0SW1hZ2VTbW9vdGhpbmciLCJpbWFnZVNtb290aGluZ0VuYWJsZWQiLCJ3ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWQiLCJtb3pJbWFnZVNtb290aGluZ0VuYWJsZWQiLCJtc0ltYWdlU21vb3RoaW5nRW5hYmxlZCIsIm9JbWFnZVNtb290aGluZ0VuYWJsZWQiLCJhZGRQYXJhbVRvVXJsIiwicGFyYW0iLCJlbXB0eUZuIiwicmVxdWVzdCIsIm9uQ29tcGxldGUiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsInBhcmFtZXRlcnMiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwib3BlbiIsInNldFJlcXVlc3RIZWFkZXIiLCJzZW5kIiwid2FybiIsIlJVTk5JTkdfQU5JTUFUSU9OUyIsImNhbmNlbEFsbCIsImFuaW1hdGlvbnMiLCJhbmltYXRpb24iLCJjYW5jZWwiLCJjYW5jZWxCeUNhbnZhcyIsImNhbmNlbGxlZCIsImNhbmNlbEJ5VGFyZ2V0IiwiZmluZEFuaW1hdGlvbnNCeVRhcmdldCIsImZpbmRBbmltYXRpb25JbmRleCIsImNhbmNlbEZ1bmMiLCJmaW5kQW5pbWF0aW9uIiwibm9vcCIsImRlZmF1bHRFYXNpbmciLCJkIiwiYW5pbWF0ZSIsInJlbW92ZUZyb21SZWdpc3RyeSIsInJ1bm5pbmdBbmltYXRpb25zIiwiY3VycmVudFZhbHVlIiwic3RhcnRWYWx1ZSIsImNvbXBsZXRpb25SYXRlIiwiZHVyYXRpb25SYXRlIiwicmVxdWVzdEFuaW1GcmFtZSIsInRpbWVzdGFtcCIsIkRhdGUiLCJkdXJhdGlvbiIsImZpbmlzaCIsInRpbWUiLCJvbkNoYW5nZSIsImFib3J0IiwiZWFzaW5nIiwiaXNNYW55IiwiZW5kVmFsdWUiLCJieVZhbHVlIiwib25TdGFydCIsInRpY2siLCJ0aWNrdGltZSIsImN1cnJlbnRUaW1lIiwidGltZVBlcmMiLCJfdmFsdWUiLCJ2YWx1ZVBlcmMiLCJfcmVxdWVzdEFuaW1GcmFtZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1velJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtc1JlcXVlc3RBbmltYXRpb25GcmFtZSIsInNldFRpbWVvdXQiLCJfY2FuY2VsQW5pbUZyYW1lIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJjbGVhclRpbWVvdXQiLCJjYW5jZWxBbmltRnJhbWUiLCJjYWxjdWxhdGVDb2xvciIsImJlZ2luIiwicG9zIiwiY29sb3IiLCJhbmltYXRlQ29sb3IiLCJmcm9tQ29sb3IiLCJ0b0NvbG9yIiwic3RhcnRDb2xvciIsIkNvbG9yIiwiZ2V0U291cmNlIiwiZW5kQ29sb3IiLCJvcmlnaW5hbE9uQ29tcGxldGUiLCJvcmlnaW5hbE9uQ2hhbmdlIiwicG9zVmFsdWUiLCJjb2xvckVhc2luZyIsIm5vcm1hbGl6ZSIsImFzaW4iLCJlbGFzdGljIiwib3B0cyIsImVhc2VPdXRDdWJpYyIsImVhc2VJbk91dEN1YmljIiwiZWFzZUluUXVhcnQiLCJlYXNlT3V0UXVhcnQiLCJlYXNlSW5PdXRRdWFydCIsImVhc2VJblF1aW50IiwiZWFzZU91dFF1aW50IiwiZWFzZUluT3V0UXVpbnQiLCJlYXNlSW5TaW5lIiwiZWFzZU91dFNpbmUiLCJlYXNlSW5PdXRTaW5lIiwiZWFzZUluRXhwbyIsImVhc2VPdXRFeHBvIiwiZWFzZUluT3V0RXhwbyIsImVhc2VJbkNpcmMiLCJlYXNlT3V0Q2lyYyIsImVhc2VJbk91dENpcmMiLCJlYXNlSW5FbGFzdGljIiwiZWFzZU91dEVsYXN0aWMiLCJlYXNlSW5PdXRFbGFzdGljIiwiZWFzZUluQmFjayIsImVhc2VPdXRCYWNrIiwiZWFzZUluT3V0QmFjayIsImVhc2VJbkJvdW5jZSIsImVhc2VPdXRCb3VuY2UiLCJlYXNlSW5PdXRCb3VuY2UiLCJlYXNlIiwiZWFzZUluUXVhZCIsImVhc2VPdXRRdWFkIiwiZWFzZUluT3V0UXVhZCIsImVhc2VJbkN1YmljIiwic3ZnVmFsaWRUYWdOYW1lcyIsInN2Z1ZpZXdCb3hFbGVtZW50cyIsInN2Z0ludmFsaWRBbmNlc3RvcnMiLCJzdmdWYWxpZFBhcmVudHMiLCJhdHRyaWJ1dGVzTWFwIiwiZGlzcGxheSIsInZpc2liaWxpdHkiLCJjb2xvckF0dHJpYnV0ZXMiLCJmU2l6ZSIsImNQYXRoIiwic3ZnVmFsaWRUYWdOYW1lc1JlZ0V4IiwiZ2V0U3ZnUmVnZXgiLCJzdmdWaWV3Qm94RWxlbWVudHNSZWdFeCIsInN2Z0ludmFsaWRBbmNlc3RvcnNSZWdFeCIsInN2Z1ZhbGlkUGFyZW50c1JlZ0V4IiwiY3NzUnVsZXMiLCJncmFkaWVudERlZnMiLCJjbGlwUGF0aHMiLCJub3JtYWxpemVBdHRyIiwibm9ybWFsaXplVmFsdWUiLCJwYXJlbnRBdHRyaWJ1dGVzIiwicGFyc2VUcmFuc2Zvcm1BdHRyaWJ1dGUiLCJ2aXNpYmxlIiwiZmlsbEluZGV4Iiwic3Ryb2tlSW5kZXgiLCJfc2V0U3Ryb2tlRmlsbE9wYWNpdHkiLCJzZXRBbHBoYSIsImdldEFscGhhIiwidG9SZ2JhIiwiX2dldE11bHRpcGxlTm9kZXMiLCJub2RlTmFtZXMiLCJub2RlTmFtZSIsIm5vZGVBcnJheSIsIm5vZGVMaXN0IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJyb3RhdGVNYXRyaXgiLCJtdWx0aXBsaWVyWCIsIm11bHRpcGxpZXJZIiwic2tld01hdHJpeCIsInRyYW5zbGF0ZU1hdHJpeCIsInNjYWxlIiwidHJhbnNsYXRlIiwidHJhbnNmb3JtcyIsInRyYW5zZm9ybUxpc3QiLCJyZVRyYW5zZm9ybUxpc3QiLCJyZVRyYW5zZm9ybSIsImF0dHJpYnV0ZVZhbHVlIiwibWF0cmljZXMiLCJvcGVyYXRpb24iLCJjb21iaW5lZE1hdHJpeCIsInBhcnNlU3R5bGVTdHJpbmciLCJvU3R5bGUiLCJjaHVuayIsInBhaXIiLCJwYXJzZVN0eWxlT2JqZWN0IiwiZ2V0R2xvYmFsU3R5bGVzRm9yRWxlbWVudCIsInN2Z1VpZCIsInJ1bGUiLCJlbGVtZW50TWF0Y2hlc1J1bGUiLCJzZWxlY3RvcnMiLCJmaXJzdE1hdGNoaW5nIiwicGFyZW50TWF0Y2hpbmciLCJzZWxlY3Rvck1hdGNoZXMiLCJkb2VzU29tZVBhcmVudE1hdGNoIiwic2VsZWN0b3IiLCJjbGFzc05hbWVzIiwiZ2V0QXR0cmlidXRlIiwibWF0Y2hlciIsImVsZW1lbnRCeUlkIiwibm9kZSIsIm5vZGVsaXN0IiwicGFyc2VVc2VEaXJlY3RpdmVzIiwieGxpbmtBdHRyaWJ1dGUiLCJ4bGluayIsImVsMiIsImNsb25lTm9kZSIsImN1cnJlbnRUcmFucyIsIm9sZExlbmd0aCIsImF0dHJzIiwiYXBwbHlWaWV3Ym94VHJhbnNmb3JtIiwiZWwzIiwiY3JlYXRlRWxlbWVudE5TIiwic2V0QXR0cmlidXRlTlMiLCJub2RlVmFsdWUiLCJmaXJzdENoaWxkIiwicmVtb3ZlQXR0cmlidXRlIiwicmVWaWV3Qm94QXR0clZhbHVlIiwidmlld0JveEF0dHIiLCJ2aWV3Qm94V2lkdGgiLCJ2aWV3Qm94SGVpZ2h0Iiwid2lkdGhBdHRyIiwiaGVpZ2h0QXR0ciIsInByZXNlcnZlQXNwZWN0UmF0aW8iLCJtaXNzaW5nVmlld0JveCIsIm1pc3NpbmdEaW1BdHRyIiwidG9CZVBhcnNlZCIsInBhcnNlZERpbSIsIndpZHRoRGlmZiIsImhlaWdodERpZmYiLCJoYXNBbmNlc3RvcldpdGhOb2RlTmFtZSIsInBhcnNlU1ZHRG9jdW1lbnQiLCJwYXJzaW5nT3B0aW9ucyIsIl9fdWlkIiwiZGVzY2VuZGFudHMiLCJzZWxlY3ROb2RlcyIsImdldEdyYWRpZW50RGVmcyIsImdldENTU1J1bGVzIiwicGFyc2VFbGVtZW50cyIsImluc3RhbmNlcyIsInJlY3Vyc2l2ZWx5UGFyc2VHcmFkaWVudHNYbGluayIsImdyYWRpZW50IiwiZ3JhZGllbnRzQXR0cnMiLCJ4bGlua0F0dHIiLCJ4TGluayIsInJlZmVyZW5jZWRHcmFkaWVudCIsImhhc0F0dHJpYnV0ZSIsImNoaWxkcmVuIiwicmVmZXJlbmNlQ2xvbmUiLCJyZUZvbnREZWNsYXJhdGlvbiIsInBhcnNlRm9udERlY2xhcmF0aW9uIiwibGluZUhlaWdodCIsInRhZ0FycmF5IiwiZWxMaXN0IiwicGFyc2VBdHRyaWJ1dGVzIiwicGFyZW50Rm9udFNpemUiLCJvd25BdHRyaWJ1dGVzIiwiY3NzQXR0cnMiLCJwYXJzZVN0eWxlQXR0cmlidXRlIiwibm9ybWFsaXplZEF0dHIiLCJub3JtYWxpemVkVmFsdWUiLCJub3JtYWxpemVkU3R5bGUiLCJmb250IiwibWVyZ2VkQXR0cnMiLCJFbGVtZW50c1BhcnNlciIsInBhcnNlIiwicGFyc2VQb2ludHNBdHRyaWJ1dGUiLCJwYXJzZWRQb2ludHMiLCJhbGxSdWxlcyIsInJ1bGVzIiwic3R5bGVDb250ZW50cyIsInRleHRDb250ZW50IiwicnVsZU9iaiIsImRlY2xhcmF0aW9uIiwicHJvcGVydHlWYWx1ZVBhaXJzIiwiX3J1bGUiLCJsb2FkU1ZHRnJvbVVSTCIsInhtbCIsInJlc3BvbnNlWE1MIiwicmVzdWx0cyIsIl9vcHRpb25zIiwiYWxsRWxlbWVudHMiLCJsb2FkU1ZHRnJvbVN0cmluZyIsInBhcnNlciIsInBhcnNlRnJvbVN0cmluZyIsInJlZ2V4VXJsIiwicHJvdG8iLCJudW1FbGVtZW50cyIsImNyZWF0ZU9iamVjdHMiLCJjcmVhdGVPYmplY3QiLCJmaW5kVGFnIiwiZnJvbUVsZW1lbnQiLCJjcmVhdGVDYWxsYmFjayIsImNoZWNrSWZEb25lIiwicmVzb2x2ZUdyYWRpZW50IiwiSW1hZ2UiLCJfb3JpZ2luYWxFbGVtZW50IiwiX3JlbW92ZVRyYW5zZm9ybU1hdHJpeCIsInJlc29sdmVDbGlwUGF0aCIsImV4dHJhY3RQcm9wZXJ0eURlZmluaXRpb24iLCJzdG9yYWdlIiwicmVnZXgiLCJsYXN0SW5kZXgiLCJncmFkaWVudERlZiIsIm9wYWNpdHlBdHRyIiwiY3JlYXRlQ2xpcFBhdGhDYWxsYmFjayIsImNvbnRhaW5lciIsIl9uZXdPYmoiLCJmaWxsUnVsZSIsImNsaXBSdWxlIiwidXNpbmdFbGVtZW50Iiwib2JqVHJhbnNmb3JtSW52IiwiZ1RyYW5zZm9ybSIsImNsaXBQYXRoVGFnIiwiY2xpcFBhdGhPd25lciIsInRoYXQiLCJzY2FsYXJBZGQiLCJzY2FsYXJBZGRFcXVhbHMiLCJzdWJ0cmFjdEVxdWFscyIsInNjYWxhclN1YnRyYWN0Iiwic2NhbGFyU3VidHJhY3RFcXVhbHMiLCJtdWx0aXBseUVxdWFscyIsImRpdmlkZSIsImRpdmlkZUVxdWFscyIsImx0IiwibHRlIiwiZ3QiLCJndGUiLCJkaXN0YW5jZUZyb20iLCJkeCIsImR5Iiwic2V0WFkiLCJzZXRYIiwic2V0WSIsInNldEZyb21Qb2ludCIsInN3YXAiLCJJbnRlcnNlY3Rpb24iLCJzdGF0dXMiLCJhcHBlbmRQb2ludCIsImFwcGVuZFBvaW50cyIsImludGVyc2VjdExpbmVMaW5lIiwiYTEiLCJhMiIsImIxIiwiYjIiLCJ1YVQiLCJ1YlQiLCJ1QiIsInVhIiwidWIiLCJpbnRlcnNlY3RMaW5lUG9seWdvbiIsImludGVyIiwiaW50ZXJzZWN0UG9seWdvblBvbHlnb24iLCJwb2ludHMxIiwicG9pbnRzMiIsImludGVyc2VjdFBvbHlnb25SZWN0YW5nbGUiLCJyMSIsInIyIiwidG9wUmlnaHQiLCJib3R0b21MZWZ0IiwiaW50ZXIxIiwiaW50ZXIyIiwiaW50ZXIzIiwiaW50ZXI0Iiwic2V0U291cmNlIiwiX3RyeVBhcnNpbmdDb2xvciIsImNvbG9yTmFtZU1hcCIsInNvdXJjZUZyb21IZXgiLCJzb3VyY2VGcm9tUmdiIiwic291cmNlRnJvbUhzbCIsIl9yZ2JUb0hzbCIsImciLCJyb3VuZCIsIl9zb3VyY2UiLCJ0b1JnYiIsInRvSHNsIiwiaHNsIiwidG9Ic2xhIiwidG9IZXgiLCJ0b0hleGEiLCJ0b0dyYXlzY2FsZSIsImF2ZXJhZ2UiLCJjdXJyZW50QWxwaGEiLCJ0b0JsYWNrV2hpdGUiLCJ0aHJlc2hvbGQiLCJvdmVybGF5V2l0aCIsIm90aGVyQ29sb3IiLCJvdGhlckFscGhhIiwib3RoZXJTb3VyY2UiLCJyZVJHQmEiLCJyZUhTTGEiLCJyZUhleCIsImFsaWNlYmx1ZSIsImFudGlxdWV3aGl0ZSIsImFxdWEiLCJhcXVhbWFyaW5lIiwiYXp1cmUiLCJiZWlnZSIsImJpc3F1ZSIsImJsYWNrIiwiYmxhbmNoZWRhbG1vbmQiLCJibHVlIiwiYmx1ZXZpb2xldCIsImJyb3duIiwiYnVybHl3b29kIiwiY2FkZXRibHVlIiwiY2hhcnRyZXVzZSIsImNob2NvbGF0ZSIsImNvcmFsIiwiY29ybmZsb3dlcmJsdWUiLCJjb3Juc2lsayIsImNyaW1zb24iLCJjeWFuIiwiZGFya2JsdWUiLCJkYXJrY3lhbiIsImRhcmtnb2xkZW5yb2QiLCJkYXJrZ3JheSIsImRhcmtncmV5IiwiZGFya2dyZWVuIiwiZGFya2toYWtpIiwiZGFya21hZ2VudGEiLCJkYXJrb2xpdmVncmVlbiIsImRhcmtvcmFuZ2UiLCJkYXJrb3JjaGlkIiwiZGFya3JlZCIsImRhcmtzYWxtb24iLCJkYXJrc2VhZ3JlZW4iLCJkYXJrc2xhdGVibHVlIiwiZGFya3NsYXRlZ3JheSIsImRhcmtzbGF0ZWdyZXkiLCJkYXJrdHVycXVvaXNlIiwiZGFya3Zpb2xldCIsImRlZXBwaW5rIiwiZGVlcHNreWJsdWUiLCJkaW1ncmF5IiwiZGltZ3JleSIsImRvZGdlcmJsdWUiLCJmaXJlYnJpY2siLCJmbG9yYWx3aGl0ZSIsImZvcmVzdGdyZWVuIiwiZnVjaHNpYSIsImdhaW5zYm9ybyIsImdob3N0d2hpdGUiLCJnb2xkIiwiZ29sZGVucm9kIiwiZ3JheSIsImdyZXkiLCJncmVlbiIsImdyZWVueWVsbG93IiwiaG9uZXlkZXciLCJob3RwaW5rIiwiaW5kaWFucmVkIiwiaW5kaWdvIiwiaXZvcnkiLCJraGFraSIsImxhdmVuZGVyIiwibGF2ZW5kZXJibHVzaCIsImxhd25ncmVlbiIsImxlbW9uY2hpZmZvbiIsImxpZ2h0Ymx1ZSIsImxpZ2h0Y29yYWwiLCJsaWdodGN5YW4iLCJsaWdodGdvbGRlbnJvZHllbGxvdyIsImxpZ2h0Z3JheSIsImxpZ2h0Z3JleSIsImxpZ2h0Z3JlZW4iLCJsaWdodHBpbmsiLCJsaWdodHNhbG1vbiIsImxpZ2h0c2VhZ3JlZW4iLCJsaWdodHNreWJsdWUiLCJsaWdodHNsYXRlZ3JheSIsImxpZ2h0c2xhdGVncmV5IiwibGlnaHRzdGVlbGJsdWUiLCJsaWdodHllbGxvdyIsImxpbWUiLCJsaW1lZ3JlZW4iLCJsaW5lbiIsIm1hZ2VudGEiLCJtYXJvb24iLCJtZWRpdW1hcXVhbWFyaW5lIiwibWVkaXVtYmx1ZSIsIm1lZGl1bW9yY2hpZCIsIm1lZGl1bXB1cnBsZSIsIm1lZGl1bXNlYWdyZWVuIiwibWVkaXVtc2xhdGVibHVlIiwibWVkaXVtc3ByaW5nZ3JlZW4iLCJtZWRpdW10dXJxdW9pc2UiLCJtZWRpdW12aW9sZXRyZWQiLCJtaWRuaWdodGJsdWUiLCJtaW50Y3JlYW0iLCJtaXN0eXJvc2UiLCJtb2NjYXNpbiIsIm5hdmFqb3doaXRlIiwibmF2eSIsIm9sZGxhY2UiLCJvbGl2ZSIsIm9saXZlZHJhYiIsIm9yYW5nZSIsIm9yYW5nZXJlZCIsIm9yY2hpZCIsInBhbGVnb2xkZW5yb2QiLCJwYWxlZ3JlZW4iLCJwYWxldHVycXVvaXNlIiwicGFsZXZpb2xldHJlZCIsInBhcGF5YXdoaXAiLCJwZWFjaHB1ZmYiLCJwZXJ1IiwicGluayIsInBsdW0iLCJwb3dkZXJibHVlIiwicHVycGxlIiwicmViZWNjYXB1cnBsZSIsInJlZCIsInJvc3licm93biIsInJveWFsYmx1ZSIsInNhZGRsZWJyb3duIiwic2FsbW9uIiwic2FuZHlicm93biIsInNlYWdyZWVuIiwic2Vhc2hlbGwiLCJzaWVubmEiLCJzaWx2ZXIiLCJza3libHVlIiwic2xhdGVibHVlIiwic2xhdGVncmF5Iiwic2xhdGVncmV5Iiwic25vdyIsInNwcmluZ2dyZWVuIiwic3RlZWxibHVlIiwidGVhbCIsInRoaXN0bGUiLCJ0b21hdG8iLCJ0dXJxdW9pc2UiLCJ2aW9sZXQiLCJ3aGVhdCIsIndoaXRlIiwid2hpdGVzbW9rZSIsInllbGxvdyIsInllbGxvd2dyZWVuIiwiaHVlMnJnYiIsImZyb21SZ2IiLCJmcm9tU291cmNlIiwiZnJvbVJnYmEiLCJmcm9tSHNsIiwiZnJvbUhzbGEiLCJmcm9tSGV4IiwiaXNTaG9ydE5vdGF0aW9uIiwiaXNSR0JhIiwib0NvbG9yIiwic2NhbGVNYXAiLCJza2V3TWFwIiwiY29udHJvbHMiLCJMRUZUIiwiVE9QIiwiUklHSFQiLCJCT1RUT00iLCJDRU5URVIiLCJvcHBvc2l0ZSIsImJvdHRvbSIsInJpZ2h0IiwiZmluZENvcm5lclF1YWRyYW50IiwiZmFicmljT2JqZWN0IiwiY29udHJvbCIsImNvcm5lckFuZ2xlIiwiZmlyZUV2ZW50IiwiY2FudmFzT3B0aW9ucyIsInNjYWxlSXNQcm9wb3J0aW9uYWwiLCJldmVudERhdGEiLCJ1bmlTY2FsZUtleSIsInVuaWZvcm1Jc1RvZ2dsZWQiLCJ1bmlmb3JtU2NhbGluZyIsImlzVHJhbnNmb3JtQ2VudGVyZWQiLCJvcmlnaW5YIiwib3JpZ2luWSIsInNjYWxpbmdJc0ZvcmJpZGRlbiIsImJ5Iiwic2NhbGVQcm9wb3J0aW9uYWxseSIsImxvY2tYIiwibG9ja1NjYWxpbmdYIiwibG9ja1kiLCJsb2NrU2NhbGluZ1kiLCJzY2FsZUN1cnNvclN0eWxlSGFuZGxlciIsIm5vdEFsbG93ZWQiLCJuIiwic2tld0N1cnNvclN0eWxlSGFuZGxlciIsImxvY2tTa2V3aW5nWSIsImxvY2tTa2V3aW5nWCIsInNjYWxlU2tld0N1cnNvclN0eWxlSGFuZGxlciIsImFsdEFjdGlvbktleSIsInNjYWxlT3JTa2V3QWN0aW9uTmFtZSIsImlzQWx0ZXJuYXRpdmUiLCJyb3RhdGlvblN0eWxlSGFuZGxlciIsImxvY2tSb3RhdGlvbiIsImN1cnNvclN0eWxlIiwiY29tbW9uRXZlbnRJbmZvIiwiZSIsInBvaW50ZXIiLCJ3cmFwV2l0aEZpeGVkQW5jaG9yIiwiYWN0aW9uSGFuZGxlciIsImdldENlbnRlclBvaW50IiwiY29uc3RyYWludCIsInRyYW5zbGF0ZVRvT3JpZ2luUG9pbnQiLCJhY3Rpb25QZXJmb3JtZWQiLCJ3cmFwV2l0aEZpcmVFdmVudCIsImdldExvY2FsUG9pbnQiLCJjb3JuZXIiLCJnZXRab29tIiwicGFkZGluZyIsImxvY2FsUG9pbnQiLCJ0b0xvY2FsUG9pbnQiLCJvZmZzZXRYIiwib2Zmc2V0WSIsInRhcmdldEhhc09uZUZsaXAiLCJjb21wZW5zYXRlU2NhbGVGb3JTa2V3Iiwib3Bwb3NpdGVTa2V3Iiwic2NhbGVUb0NvbXBlbnNhdGUiLCJheGlzIiwicmVmZXJlbmNlIiwibmV3RGltIiwiX2dldFRyYW5zZm9ybWVkRGltZW5zaW9ucyIsIm5ld1ZhbHVlIiwic2tld09iamVjdFgiLCJkaW1Ob1NrZXciLCJ0b3RhbFNrZXdTaXplIiwiY3VycmVudFNrZXciLCJuZXdTa2V3IiwiaGFzU2tld2VkIiwiZGltQmVmb3JlU2tld2luZyIsInNrZXdPYmplY3RZIiwic2tld0hhbmRsZXJYIiwibG9jYWxQb2ludEZyb21DZW50ZXIiLCJmaW5hbEhhbmRsZXIiLCJza2V3SGFuZGxlclkiLCJyb3RhdGlvbldpdGhTbmFwcGluZyIsInBpdm90UG9pbnQiLCJsYXN0QW5nbGUiLCJleSIsImV4IiwiY3VyQW5nbGUiLCJoYXNSb3RhdGVkIiwic25hcEFuZ2xlIiwic25hcFRocmVzaG9sZCIsInJpZ2h0QW5nbGVMb2NrZWQiLCJsZWZ0QW5nbGVMb2NrZWQiLCJzY2FsZU9iamVjdCIsImRpbSIsImZvcmJpZFNjYWxpbmciLCJzaWduWCIsInNpZ25ZIiwiZ2VzdHVyZVNjYWxlIiwibG9ja1NjYWxpbmdGbGlwIiwib3JpZ2luYWwiLCJvcmlnaW5hbERpc3RhbmNlIiwib2xkU2NhbGVYIiwib2xkU2NhbGVZIiwic2NhbGVPYmplY3RGcm9tQ29ybmVyIiwic2NhbGVPYmplY3RYIiwic2NhbGVPYmplY3RZIiwic2NhbGluZ1lPclNrZXdpbmdYIiwic2NhbGluZ1kiLCJzY2FsaW5nWE9yU2tld2luZ1kiLCJzY2FsaW5nWCIsImNoYW5nZVdpZHRoIiwic3Ryb2tlUGFkZGluZyIsIm11bHRpcGxpZXIiLCJvbGRXaWR0aCIsIm5ld1dpZHRoIiwiZHJhZ0hhbmRsZXIiLCJuZXdMZWZ0IiwibmV3VG9wIiwibW92ZVgiLCJtb3ZlWSIsInNjYWxpbmdFcXVhbGx5IiwiY29udHJvbHNVdGlscyIsInJlbmRlckNpcmNsZUNvbnRyb2wiLCJzdHlsZU92ZXJyaWRlIiwieFNpemUiLCJzaXplWCIsImNvcm5lclNpemUiLCJ5U2l6ZSIsInNpemVZIiwidHJhbnNwYXJlbnRDb3JuZXJzIiwiY29ybmVyU3Ryb2tlQ29sb3IiLCJteUxlZnQiLCJteVRvcCIsInNhdmUiLCJmaWxsU3R5bGUiLCJjb3JuZXJDb2xvciIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwiYmVnaW5QYXRoIiwiYXJjIiwicmVzdG9yZSIsInJlbmRlclNxdWFyZUNvbnRyb2wiLCJ4U2l6ZUJ5MiIsInlTaXplQnkyIiwic3Ryb2tlUmVjdCIsIkNvbnRyb2wiLCJhY3Rpb25OYW1lIiwidG91Y2hTaXplWCIsInRvdWNoU2l6ZVkiLCJ3aXRoQ29ubmVjdGlvbiIsIm1vdXNlRG93bkhhbmRsZXIiLCJtb3VzZVVwSGFuZGxlciIsImdldEFjdGlvbkhhbmRsZXIiLCJnZXRNb3VzZURvd25IYW5kbGVyIiwiZ2V0TW91c2VVcEhhbmRsZXIiLCJjdXJzb3JTdHlsZUhhbmRsZXIiLCJnZXRBY3Rpb25OYW1lIiwiZ2V0VmlzaWJpbGl0eSIsImNvbnRyb2xLZXkiLCJvYmplY3RWaXNpYmlsaXR5IiwiX2NvbnRyb2xzVmlzaWJpbGl0eSIsInNldFZpc2liaWxpdHkiLCJwb3NpdGlvbkhhbmRsZXIiLCJmaW5hbE1hdHJpeCIsImNhbGNDb3JuZXJDb29yZHMiLCJvYmplY3RBbmdsZSIsIm9iamVjdENvcm5lclNpemUiLCJjZW50ZXJYIiwiY2VudGVyWSIsImlzVG91Y2giLCJjb3NIYWxmT2Zmc2V0Iiwic2luSGFsZk9mZnNldCIsImNvc0hhbGZPZmZzZXRDb21wIiwic2luSGFsZk9mZnNldENvbXAiLCJjb250cm9sVHJpYW5nbGVBbmdsZSIsImNvcm5lckh5cG90ZW51c2UiLCJuZXdUaGV0YSIsIm5ld1RoZXRhQ29tcCIsInRsIiwidHIiLCJibCIsImJyIiwicmVuZGVyIiwiY29ybmVyU3R5bGUiLCJnZXRDb2xvclN0b3AiLCJjb2xvckFscGhhIiwia2V5VmFsdWVQYWlycyIsImdldExpbmVhckNvb3JkcyIsImdldFJhZGlhbENvb3JkcyIsImdyYWRpZW50VHJhbnNmb3JtIiwiZ3JhZGllbnRVbml0cyIsIm9wdGlvbiIsImFkZENvbG9yU3RvcCIsInRvT2JqZWN0IiwicHJvcGVydGllc1RvSW5jbHVkZSIsInRvU1ZHIiwibWFya3VwIiwiY29tbW9uQXR0cmlidXRlcyIsIm5lZWRzU3dhcCIsIndpdGhWaWV3cG9ydCIsImFkZGl0aW9uYWxUcmFuc2Zvcm0iLCJzb3J0IiwicmV2ZXJzZSIsIm1pblJhZGl1cyIsIm1heFJhZGl1cyIsInBlcmNlbnRhZ2VTaGlmdCIsImNvbG9yU3RvcCIsInRvTGl2ZSIsImNyZWF0ZUxpbmVhckdyYWRpZW50IiwiY3JlYXRlUmFkaWFsR3JhZGllbnQiLCJpbnN0YW5jZSIsInN2Z09wdGlvbnMiLCJjb2xvclN0b3BFbHMiLCJfX2NvbnZlcnRQZXJjZW50VW5pdHNUb1ZhbHVlcyIsInByb3BWYWx1ZSIsImZpbmFsVmFsdWUiLCJyZXBlYXQiLCJwYXR0ZXJuVHJhbnNmb3JtIiwic2V0T3B0aW9ucyIsImlzRXJyb3IiLCJwYXR0ZXJuU291cmNlIiwicGF0dGVybldpZHRoIiwicGF0dGVybkhlaWdodCIsInBhdHRlcm5PZmZzZXRYIiwicGF0dGVybk9mZnNldFkiLCJwYXR0ZXJuSW1nU3JjIiwiY29tcGxldGUiLCJuYXR1cmFsV2lkdGgiLCJuYXR1cmFsSGVpZ2h0IiwiY3JlYXRlUGF0dGVybiIsIlNoYWRvdyIsImJsdXIiLCJhZmZlY3RTdHJva2UiLCJpbmNsdWRlRGVmYXVsdFZhbHVlcyIsIm5vblNjYWxpbmciLCJfcGFyc2VTaGFkb3ciLCJzaGFkb3ciLCJzaGFkb3dTdHIiLCJvZmZzZXRzQW5kQmx1ciIsInJlT2Zmc2V0c0FuZEJsdXIiLCJmQm94WCIsImZCb3hZIiwiQkxVUl9CT1giLCJTdGF0aWNDYW52YXMiLCJDQU5WQVNfSU5JVF9FUlJPUiIsIkVycm9yIiwicmVuZGVyQW5kUmVzZXRCb3VuZCIsInJlbmRlckFuZFJlc2V0IiwicmVxdWVzdFJlbmRlckFsbEJvdW5kIiwiX2luaXRTdGF0aWMiLCJiYWNrZ3JvdW5kQ29sb3IiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJvdmVybGF5Q29sb3IiLCJvdmVybGF5SW1hZ2UiLCJzdGF0ZWZ1bCIsImNvbnRyb2xzQWJvdmVPdmVybGF5IiwiYWxsb3dUb3VjaFNjcm9sbGluZyIsInZpZXdwb3J0VHJhbnNmb3JtIiwiYmFja2dyb3VuZFZwdCIsIm92ZXJsYXlWcHQiLCJlbmFibGVSZXRpbmFTY2FsaW5nIiwidnB0Q29vcmRzIiwic2tpcE9mZnNjcmVlbiIsImNiIiwiX2NyZWF0ZUxvd2VyQ2FudmFzIiwiX2luaXRPcHRpb25zIiwiaW50ZXJhY3RpdmUiLCJfaW5pdFJldGluYVNjYWxpbmciLCJzZXRPdmVybGF5SW1hZ2UiLCJzZXRCYWNrZ3JvdW5kSW1hZ2UiLCJzZXRCYWNrZ3JvdW5kQ29sb3IiLCJzZXRPdmVybGF5Q29sb3IiLCJjYWxjT2Zmc2V0IiwiX2lzUmV0aW5hU2NhbGluZyIsImdldFJldGluYVNjYWxpbmciLCJzY2FsZVJhdGlvIiwiX19pbml0UmV0aW5hU2NhbGluZyIsImxvd2VyQ2FudmFzRWwiLCJjb250ZXh0Q29udGFpbmVyIiwidXBwZXJDYW52YXNFbCIsImNvbnRleHRUb3AiLCJfb2Zmc2V0IiwiaW1hZ2UiLCJfX3NldEJnT3ZlcmxheUltYWdlIiwiX19zZXRCZ092ZXJsYXlDb2xvciIsIl9jcmVhdGVDYW52YXNFbGVtZW50IiwiX29yaWdpbmFsQ2FudmFzU3R5bGUiLCJfYXBwbHlDYW52YXNTdHlsZSIsImdldFdpZHRoIiwiZ2V0SGVpZ2h0Iiwic2V0V2lkdGgiLCJzZXREaW1lbnNpb25zIiwic2V0SGVpZ2h0IiwiZGltZW5zaW9ucyIsImNzc1ZhbHVlIiwiY3NzT25seSIsIl9zZXRCYWNrc3RvcmVEaW1lbnNpb24iLCJoYXNMb3N0Q29udGV4dCIsImJhY2tzdG9yZU9ubHkiLCJfc2V0Q3NzRGltZW5zaW9uIiwiX2lzQ3VycmVudGx5RHJhd2luZyIsImZyZWVEcmF3aW5nQnJ1c2giLCJfc2V0QnJ1c2hTdHlsZXMiLCJjYWNoZUNhbnZhc0VsIiwid3JhcHBlckVsIiwic2V0Vmlld3BvcnRUcmFuc2Zvcm0iLCJ2cHQiLCJhY3RpdmVPYmplY3QiLCJfYWN0aXZlT2JqZWN0IiwiYmFja2dyb3VuZE9iamVjdCIsIm92ZXJsYXlPYmplY3QiLCJncm91cCIsInNldENvb3JkcyIsImNhbGNWaWV3cG9ydEJvdW5kYXJpZXMiLCJ6b29tVG9Qb2ludCIsImJlZm9yZSIsImFmdGVyIiwic2V0Wm9vbSIsImFic29sdXRlUGFuIiwicmVsYXRpdmVQYW4iLCJnZXRFbGVtZW50Iiwic2V0dXBTdGF0ZSIsImNsZWFyQ29udGV4dCIsImNsZWFyUmVjdCIsImNsZWFyIiwiX2hhc0lUZXh0SGFuZGxlcnMiLCJfbW91c2VVcElUZXh0SGFuZGxlciIsIl9pVGV4dEluc3RhbmNlcyIsInJlbmRlckFsbCIsImNhbnZhc1RvRHJhd09uIiwicmVuZGVyQ2FudmFzIiwiaXNSZW5kZXJpbmciLCJpVnB0IiwiY2FuY2VsUmVxdWVzdGVkUmVuZGVyIiwiX3JlbmRlckJhY2tncm91bmQiLCJfcmVuZGVyT2JqZWN0cyIsImRyYXdDb250cm9scyIsInNob3VsZENhY2hlIiwiX3RyYW5zZm9ybURvbmUiLCJyZW5kZXJDYWNoZSIsImZvckNsaXBwaW5nIiwiZHJhd0NsaXBQYXRoT25DYW52YXMiLCJfcmVuZGVyT3ZlcmxheSIsImdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiIsInpvb21YIiwiem9vbVkiLCJfY2FjaGVDYW52YXMiLCJjYWNoZVRyYW5zbGF0aW9uWCIsImNhY2hlVHJhbnNsYXRpb25ZIiwiX3JlbmRlckJhY2tncm91bmRPck92ZXJsYXkiLCJuZWVkc1ZwdCIsIm1vdmVUbyIsImxpbmVUbyIsImNsb3NlUGF0aCIsImdldENlbnRlciIsImNlbnRlck9iamVjdEgiLCJfY2VudGVyT2JqZWN0IiwiY2VudGVyT2JqZWN0ViIsImNlbnRlck9iamVjdCIsInZpZXdwb3J0Q2VudGVyT2JqZWN0IiwidnBDZW50ZXIiLCJnZXRWcENlbnRlciIsInZpZXdwb3J0Q2VudGVyT2JqZWN0SCIsInZpZXdwb3J0Q2VudGVyT2JqZWN0ViIsInRvRGF0YWxlc3NKU09OIiwidG9EYXRhbGVzc09iamVjdCIsIl90b09iamVjdE1ldGhvZCIsIl90b09iamVjdHMiLCJleGNsdWRlRnJvbUV4cG9ydCIsIl90b09iamVjdCIsIl9fc2VyaWFsaXplQmdPdmVybGF5Iiwib3JpZ2luYWxWYWx1ZSIsImJnSW1hZ2UiLCJiZ0NvbG9yIiwiYmFja2dyb3VuZCIsIm92ZXJsYXkiLCJzdmdWaWV3cG9ydFRyYW5zZm9ybWF0aW9uIiwiX3NldFNWR1ByZWFtYmxlIiwiX3NldFNWR0hlYWRlciIsImNsaXBQYXRoSWQiLCJfc2V0U1ZHQmdPdmVybGF5Q29sb3IiLCJfc2V0U1ZHQmdPdmVybGF5SW1hZ2UiLCJfc2V0U1ZHT2JqZWN0cyIsInN1cHByZXNzUHJlYW1ibGUiLCJlbmNvZGluZyIsInZpZXdCb3giLCJjcmVhdGVTVkdGb250RmFjZXNNYXJrdXAiLCJjcmVhdGVTVkdSZWZFbGVtZW50c01hcmt1cCIsImNyZWF0ZVNWR0NsaXBQYXRoTWFya3VwIiwidG9DbGlwUGF0aFNWRyIsInNob3VsZFRyYW5zZm9ybSIsImZvbnRMaXN0Iiwicm93Iiwicm93SW5kZXgiLCJfY2hhciIsIl9zZXRTVkdPYmplY3QiLCJmaW5hbFdpZHRoIiwiZmluYWxIZWlnaHQiLCJzaG91bGRJbnZlcnQiLCJzZW5kVG9CYWNrIiwiYWN0aXZlU2VsZWN0aW9uIiwib2JqcyIsInVuc2hpZnQiLCJicmluZ1RvRnJvbnQiLCJzZW5kQmFja3dhcmRzIiwiaW50ZXJzZWN0aW5nIiwibmV3SWR4Iiwib2Jqc01vdmVkIiwiX2ZpbmROZXdMb3dlckluZGV4IiwiaXNJbnRlcnNlY3RpbmciLCJpbnRlcnNlY3RzV2l0aE9iamVjdCIsImlzQ29udGFpbmVkV2l0aGluT2JqZWN0IiwiYnJpbmdGb3J3YXJkIiwiX2ZpbmROZXdVcHBlckluZGV4IiwiZGlzcG9zZSIsImNsYXNzTGlzdCIsIkRhdGFVUkxFeHBvcnRlciIsIkVNUFRZX0pTT04iLCJzdXBwb3J0cyIsInNldExpbmVEYXNoIiwidG9KU09OIiwiY3JlYXRlUE5HU3RyZWFtIiwiY3JlYXRlSlBFR1N0cmVhbSIsIkJhc2VCcnVzaCIsInN0cm9rZUxpbmVDYXAiLCJzdHJva2VEYXNoQXJyYXkiLCJsaW1pdGVkVG9DYW52YXNTaXplIiwibGluZUNhcCIsIm1pdGVyTGltaXQiLCJsaW5lSm9pbiIsIl9zYXZlQW5kVHJhbnNmb3JtIiwiX3NldFNoYWRvdyIsInNoYWRvd0NvbG9yIiwic2hhZG93Qmx1ciIsInNoYWRvd09mZnNldFgiLCJzaGFkb3dPZmZzZXRZIiwibmVlZHNGdWxsUmVuZGVyIiwiX3Jlc2V0U2hhZG93IiwiX2lzT3V0U2lkZUNhbnZhcyIsIlBlbmNpbEJydXNoIiwiZGVjaW1hdGUiLCJkcmF3U3RyYWlnaHRMaW5lIiwic3RyYWlnaHRMaW5lS2V5IiwiX3BvaW50cyIsIl9oYXNTdHJhaWdodExpbmUiLCJfZHJhd1NlZ21lbnQiLCJxdWFkcmF0aWNDdXJ2ZVRvIiwib25Nb3VzZURvd24iLCJfaXNNYWluRXZlbnQiLCJfcHJlcGFyZUZvckRyYXdpbmciLCJfY2FwdHVyZURyYXdpbmdQYXRoIiwiX3JlbmRlciIsIm9uTW91c2VNb3ZlIiwib2xkRW5kIiwib25Nb3VzZVVwIiwiX2ZpbmFsaXplQW5kQWRkUGF0aCIsIl9yZXNldCIsIl9hZGRQb2ludCIsInBvaW50ZXJQb2ludCIsImNvbnZlcnRQb2ludHNUb1NWR1BhdGgiLCJfaXNFbXB0eVNWR1BhdGgiLCJjcmVhdGVQYXRoIiwiUGF0aCIsImRlY2ltYXRlUG9pbnRzIiwiYWRqdXN0ZWREaXN0YW5jZSIsImxhc3RQb2ludCIsIm5ld1BvaW50cyIsImNEaXN0YW5jZSIsIkNpcmNsZUJydXNoIiwiZHJhd0RvdCIsImFkZFBvaW50IiwiZG90IiwicmFkaXVzIiwib3JpZ2luYWxSZW5kZXJPbkFkZFJlbW92ZSIsImNpcmNsZXMiLCJjaXJjbGUiLCJDaXJjbGUiLCJjaXJjbGVSYWRpdXMiLCJjaXJjbGVDb2xvciIsIlNwcmF5QnJ1c2giLCJkZW5zaXR5IiwiZG90V2lkdGgiLCJkb3RXaWR0aFZhcmlhbmNlIiwicmFuZG9tT3BhY2l0eSIsIm9wdGltaXplT3ZlcmxhcHBpbmciLCJzcHJheUNodW5rcyIsImFkZFNwcmF5Q2h1bmsiLCJzcHJheUNodW5rUG9pbnRzIiwicmVjdHMiLCJpbGVuIiwic3ByYXlDaHVuayIsInJlY3QiLCJSZWN0IiwiX2dldE9wdGltaXplZFJlY3RzIiwidW5pcXVlUmVjdHMiLCJ1bmlxdWVSZWN0c0FycmF5IiwiZ2xvYmFsQWxwaGEiLCJmaWxsUmVjdCIsIlBhdHRlcm5CcnVzaCIsImdldFBhdHRlcm5TcmMiLCJkb3REaXN0YW5jZSIsInBhdHRlcm5DYW52YXMiLCJwYXR0ZXJuQ3R4IiwiZ2V0UGF0dGVyblNyY0Z1bmN0aW9uIiwiU3RyaW5nIiwiZ2V0UGF0dGVybiIsInRvcExlZnQiLCJfZ2V0TGVmdFRvcENvb3JkcyIsIl9pbml0SW50ZXJhY3RpdmUiLCJfY3JlYXRlQ2FjaGVDYW52YXMiLCJjZW50ZXJlZFNjYWxpbmciLCJjZW50ZXJlZFJvdGF0aW9uIiwiY2VudGVyZWRLZXkiLCJzZWxlY3Rpb24iLCJzZWxlY3Rpb25LZXkiLCJhbHRTZWxlY3Rpb25LZXkiLCJzZWxlY3Rpb25Db2xvciIsInNlbGVjdGlvbkRhc2hBcnJheSIsInNlbGVjdGlvbkJvcmRlckNvbG9yIiwic2VsZWN0aW9uTGluZVdpZHRoIiwic2VsZWN0aW9uRnVsbHlDb250YWluZWQiLCJob3ZlckN1cnNvciIsIm1vdmVDdXJzb3IiLCJkZWZhdWx0Q3Vyc29yIiwiZnJlZURyYXdpbmdDdXJzb3IiLCJub3RBbGxvd2VkQ3Vyc29yIiwiY29udGFpbmVyQ2xhc3MiLCJwZXJQaXhlbFRhcmdldEZpbmQiLCJ0YXJnZXRGaW5kVG9sZXJhbmNlIiwic2tpcFRhcmdldEZpbmQiLCJpc0RyYXdpbmdNb2RlIiwicHJlc2VydmVPYmplY3RTdGFja2luZyIsInN0b3BDb250ZXh0TWVudSIsImZpcmVSaWdodENsaWNrIiwiZmlyZU1pZGRsZUNsaWNrIiwidGFyZ2V0cyIsImVuYWJsZVBvaW50ZXJFdmVudHMiLCJfaG92ZXJlZFRhcmdldCIsIl9ob3ZlcmVkVGFyZ2V0cyIsIl9jdXJyZW50VHJhbnNmb3JtIiwiX2dyb3VwU2VsZWN0b3IiLCJfaW5pdFdyYXBwZXJFbGVtZW50IiwiX2NyZWF0ZVVwcGVyQ2FudmFzIiwiX2luaXRFdmVudExpc3RlbmVycyIsIl9jaG9vc2VPYmplY3RzVG9SZW5kZXIiLCJhY3RpdmVPYmplY3RzIiwiZ2V0QWN0aXZlT2JqZWN0cyIsIm9ianNUb1JlbmRlciIsImFjdGl2ZUdyb3VwT2JqZWN0cyIsImNvbnRleHRUb3BEaXJ0eSIsInJlbmRlclRvcExheWVyIiwiX2RyYXdTZWxlY3Rpb24iLCJyZW5kZXJUb3AiLCJfbm9ybWFsaXplUG9pbnRlciIsImludmVydGVkTSIsInZwdFBvaW50ZXIiLCJyZXN0b3JlUG9pbnRlclZwdCIsImlzVGFyZ2V0VHJhbnNwYXJlbnQiLCJub3JtYWxpemVkUG9pbnRlciIsInRhcmdldFJlbGF0aXZlWCIsInRhcmdldFJlbGF0aXZlWSIsIl9jYWNoZUNvbnRleHQiLCJjb250ZXh0Q2FjaGUiLCJvcmlnaW5hbENvbG9yIiwic2VsZWN0aW9uQmFja2dyb3VuZENvbG9yIiwiX2lzU2VsZWN0aW9uS2V5UHJlc3NlZCIsInNlbGVjdGlvbktleVByZXNzZWQiLCJfc2hvdWxkQ2xlYXJTZWxlY3Rpb24iLCJldmVudGVkIiwic2VsZWN0YWJsZSIsIl9zaG91bGRDZW50ZXJUcmFuc2Zvcm0iLCJhY3Rpb24iLCJhbHRLZXkiLCJjZW50ZXJUcmFuc2Zvcm0iLCJfZ2V0T3JpZ2luRnJvbUNvcm5lciIsIl9nZXRBY3Rpb25Gcm9tQ29ybmVyIiwiYWxyZWFkeVNlbGVjdGVkIiwiX3NldHVwQ3VycmVudFRyYW5zZm9ybSIsIl9fY29ybmVyIiwibGFzdFgiLCJsYXN0WSIsInNoaWZ0S2V5IiwiX2JlZm9yZVRyYW5zZm9ybSIsInNldEN1cnNvciIsImN1cnNvciIsInZpZXdwb3J0U3RhcnQiLCJ2aWV3cG9ydEV4dGVudCIsImV4dGVudCIsInN0cm9rZU9mZnNldCIsIl9zZXRMaW5lRGFzaCIsImZpbmRUYXJnZXQiLCJza2lwR3JvdXAiLCJpZ25vcmVab29tIiwiYU9iamVjdHMiLCJhY3RpdmVUYXJnZXQiLCJhY3RpdmVUYXJnZXRTdWJzIiwic2hvdWxkTG9va0ZvckFjdGl2ZSIsIl9maW5kVGFyZ2V0Q29ybmVyIiwiX3NlYXJjaFBvc3NpYmxlVGFyZ2V0cyIsIl9jaGVja1RhcmdldCIsImdsb2JhbFBvaW50ZXIiLCJjb250YWluc1BvaW50IiwiaXNFZGl0aW5nIiwic3ViVGFyZ2V0Iiwib2JqVG9DaGVjayIsInBvaW50ZXJUb1VzZSIsInN1YlRhcmdldENoZWNrIiwiX2Fic29sdXRlUG9pbnRlciIsIl9wb2ludGVyIiwiYm91bmRzV2lkdGgiLCJib3VuZHNIZWlnaHQiLCJjc3NTY2FsZSIsInJldGluYVNjYWxpbmciLCJsb3dlckNhbnZhc0NsYXNzIiwiX2NvcHlDYW52YXNTdHlsZSIsImdldFRvcENvbnRleHQiLCJmcm9tRWwiLCJ0b0VsIiwiZ2V0U2VsZWN0aW9uQ29udGV4dCIsImdldFNlbGVjdGlvbkVsZW1lbnQiLCJnZXRBY3RpdmVPYmplY3QiLCJhY3RpdmUiLCJfZGlzY2FyZEFjdGl2ZU9iamVjdCIsIl9maXJlU2VsZWN0aW9uRXZlbnRzIiwib2xkT2JqZWN0cyIsInNvbWV0aGluZ0NoYW5nZWQiLCJhZGRlZCIsInJlbW92ZWQiLCJvbGRPYmplY3QiLCJzZWxlY3RlZCIsImRlc2VsZWN0ZWQiLCJzZXRBY3RpdmVPYmplY3QiLCJjdXJyZW50QWN0aXZlcyIsIl9zZXRBY3RpdmVPYmplY3QiLCJvblNlbGVjdCIsIm9uRGVzZWxlY3QiLCJkaXNjYXJkQWN0aXZlT2JqZWN0IiwicmVtb3ZlTGlzdGVuZXJzIiwiX3JlbmRlckNvbnRyb2xzIiwib3JpZ2luYWxQcm9wZXJ0aWVzIiwiX3JlYWxpemVHcm91cFRyYW5zZm9ybU9uT2JqZWN0IiwiX3Vud2luZEdyb3VwVHJhbnNmb3JtT25PYmplY3QiLCJsYXlvdXRQcm9wcyIsIm9yaWdpbmFsVmFsdWVzIiwiY2xlYXJDb250ZXh0VG9wIiwiUklHSFRfQ0xJQ0siLCJNSURETEVfQ0xJQ0siLCJMRUZUX0NMSUNLIiwiYWRkRXZlbnRPcHRpb25zIiwicGFzc2l2ZSIsImNoZWNrQ2xpY2siLCJidXR0b24iLCJtYWluVG91Y2hJZCIsIl9iaW5kRXZlbnRzIiwiYWRkT3JSZW1vdmUiLCJfZ2V0RXZlbnRQcmVmaXgiLCJmdW5jdG9yIiwiZXZlbnRqc0Z1bmN0b3IiLCJjYW52YXNFbGVtZW50IiwiZXZlbnRUeXBlUHJlZml4IiwiX29uUmVzaXplIiwiX29uTW91c2VEb3duIiwiX29uTW91c2VNb3ZlIiwiX29uTW91c2VPdXQiLCJfb25Nb3VzZUVudGVyIiwiX29uTW91c2VXaGVlbCIsIl9vbkNvbnRleHRNZW51IiwiX29uRG91YmxlQ2xpY2siLCJfb25EcmFnT3ZlciIsIl9vbkRyYWdFbnRlciIsIl9vbkRyYWdMZWF2ZSIsIl9vbkRyb3AiLCJfb25Ub3VjaFN0YXJ0IiwiZXZlbnRqcyIsIl9vbkdlc3R1cmUiLCJfb25EcmFnIiwiX29uT3JpZW50YXRpb25DaGFuZ2UiLCJfb25TaGFrZSIsIl9vbkxvbmdQcmVzcyIsIl9vbk1vdXNlVXAiLCJfb25Ub3VjaEVuZCIsImV2ZW50c0JvdW5kIiwiX3NpbXBsZUV2ZW50SGFuZGxlciIsInNlbGYiLCJfX29uVHJhbnNmb3JtR2VzdHVyZSIsIl9fb25EcmFnIiwiX19vbk1vdXNlV2hlZWwiLCJfdGFyZ2V0IiwiX19vbk9yaWVudGF0aW9uQ2hhbmdlIiwiX19vblNoYWtlIiwiX19vbkxvbmdQcmVzcyIsInByZXZlbnREZWZhdWx0IiwiX2ZpcmVFbnRlckxlYXZlRXZlbnRzIiwic3RvcFByb3BhZ2F0aW9uIiwiX2NhY2hlVHJhbnNmb3JtRXZlbnREYXRhIiwiX2hhbmRsZUV2ZW50IiwiX3Jlc2V0VHJhbnNmb3JtRXZlbnREYXRhIiwiZ2V0UG9pbnRlcklkIiwiZXZ0IiwiaWRlbnRpZmllciIsInBvaW50ZXJJZCIsImlzUHJpbWFyeSIsInRvdWNoZXMiLCJfX29uTW91c2VEb3duIiwiX19vbk1vdXNlVXAiLCJfd2lsbEFkZE1vdXNlRG93biIsIl9fb25Nb3VzZU1vdmUiLCJfc2hvdWxkUmVuZGVyIiwiZ3JvdXBTZWxlY3RvciIsInNob3VsZFJlbmRlciIsImlzQ2xpY2siLCJfb25Nb3VzZVVwSW5EcmF3aW5nTW9kZSIsIl9maW5hbGl6ZUN1cnJlbnRUcmFuc2Zvcm0iLCJ0YXJnZXRXYXNBY3RpdmUiLCJfbWF5YmVHcm91cE9iamVjdHMiLCJhY3RpdmVPbiIsImlzTW92aW5nIiwib3JpZ2luYWxDb250cm9sIiwib3JpZ2luYWxNb3VzZVVwSGFuZGxlciIsIl9zZXRDdXJzb3JGcm9tRXZlbnQiLCJldmVudFR5cGUiLCJzdWJUYXJnZXRzIiwiYWJzb2x1dGVQb2ludGVyIiwiY3VycmVudFRhcmdldCIsImN1cnJlbnRTdWJUYXJnZXRzIiwiX3NjYWxpbmciLCJoYXNTdGF0ZUNoYW5nZWQiLCJfZmlyZSIsIl9vbk1vdXNlRG93bkluRHJhd2luZ01vZGUiLCJfb25Nb3VzZU1vdmVJbkRyYXdpbmdNb2RlIiwiX3ByZXZpb3VzUG9pbnRlciIsInNob3VsZEdyb3VwIiwiX3Nob3VsZEdyb3VwIiwiX2hhbmRsZUdyb3VwaW5nIiwic2F2ZVN0YXRlIiwiX2ZpcmVPdmVyT3V0RXZlbnRzIiwiX3RyYW5zZm9ybU9iamVjdCIsImZpcmVTeW50aGV0aWNJbk91dEV2ZW50cyIsIm9sZFRhcmdldCIsImV2dE91dCIsImNhbnZhc0V2dE91dCIsImV2dEluIiwiY2FudmFzRXZ0SW4iLCJfZHJhZ2dlZG92ZXJUYXJnZXQiLCJjb25maWciLCJpbk9wdCIsIm91dE9wdCIsIm91dEZpcmVzIiwiaW5GaXJlcyIsInRhcmdldENoYW5nZWQiLCJwcmV2aW91c1RhcmdldCIsIm5leHRUYXJnZXQiLCJyZXNldCIsIl9wZXJmb3JtVHJhbnNmb3JtQWN0aW9uIiwiZ2V0Q29ybmVyQ3Vyc29yIiwiX3VwZGF0ZUFjdGl2ZVNlbGVjdGlvbiIsIl9jcmVhdGVBY3RpdmVTZWxlY3Rpb24iLCJjdXJyZW50QWN0aXZlT2JqZWN0cyIsInJlbW92ZVdpdGhVcGRhdGUiLCJhZGRXaXRoVXBkYXRlIiwiX2NyZWF0ZUdyb3VwIiwiaXNBY3RpdmVMb3dlciIsImdyb3VwT2JqZWN0cyIsImV4aXRFZGl0aW5nIiwiQWN0aXZlU2VsZWN0aW9uIiwiX2dyb3VwU2VsZWN0ZWRPYmplY3RzIiwiX2NvbGxlY3RPYmplY3RzIiwiYUdyb3VwIiwiY3VycmVudE9iamVjdCIsInNlbGVjdGlvblgxWTEiLCJzZWxlY3Rpb25YMlkyIiwiYWxsb3dJbnRlcnNlY3QiLCJpbnRlcnNlY3RzV2l0aFJlY3QiLCJpc0NvbnRhaW5lZFdpdGhpblJlY3QiLCJ0b0NhbnZhc0VsZW1lbnQiLCJjcm9wcGluZyIsInNjYWxlZFdpZHRoIiwic2NhbGVkSGVpZ2h0Iiwib3JpZ2luYWxXaWR0aCIsIm9yaWdpbmFsSGVpZ2h0IiwibmV3Wm9vbSIsInZwIiwib3JpZ2luYWxJbnRlcmFjdGl2ZSIsIm5ld1ZwIiwib3JpZ2luYWxSZXRpbmEiLCJvcmlnaW5hbENvbnRleHRUb3AiLCJsb2FkRnJvbUpTT04iLCJqc29uIiwic2VyaWFsaXplZCIsIkpTT04iLCJfZW5saXZlbk9iamVjdHMiLCJfc2V0QmdPdmVybGF5IiwiZW5saXZlbmVkQ2FudmFzQ2xpcCIsIl9fc2V0dXBDYW52YXMiLCJsb2FkZWQiLCJjYklmTG9hZGVkIiwiX19zZXRCZ092ZXJsYXkiLCJlbmxpdmVkT2JqZWN0IiwiX3RvRGF0YVVSTCIsIl90b0RhdGFVUkxXaXRoTXVsdGlwbGllciIsInRvRGF0YVVSTFdpdGhNdWx0aXBsaWVyIiwic3RyaW5naWZ5IiwiY2xvbmVXaXRob3V0RGF0YSIsImJhY2tncm91bmRJbWFnZU9wYWNpdHkiLCJiYWNrZ3JvdW5kSW1hZ2VTdHJldGNoIiwib2JqZWN0Q2FjaGluZyIsIkFMSUFTSU5HX0xJTUlUIiwidG91Y2hDb3JuZXJTaXplIiwiYm9yZGVyQ29sb3IiLCJib3JkZXJEYXNoQXJyYXkiLCJjb3JuZXJEYXNoQXJyYXkiLCJzdHJva2VEYXNoT2Zmc2V0IiwiYm9yZGVyT3BhY2l0eVdoZW5Nb3ZpbmciLCJib3JkZXJTY2FsZUZhY3RvciIsIm1pblNjYWxlTGltaXQiLCJoYXNDb250cm9scyIsImhhc0JvcmRlcnMiLCJsb2NrTW92ZW1lbnRYIiwibG9ja01vdmVtZW50WSIsInN0YXRlZnVsbENhY2hlIiwibm9TY2FsZUNhY2hlIiwiZGlydHkiLCJwYWludEZpcnN0Iiwic3RhdGVQcm9wZXJ0aWVzIiwiY2FjaGVQcm9wZXJ0aWVzIiwiY29sb3JQcm9wZXJ0aWVzIiwiYWJzb2x1dGVQb3NpdGlvbmVkIiwiX2NhY2hlUHJvcGVydGllcyIsIl91cGRhdGVDYWNoZUNhbnZhcyIsIl9saW1pdENhY2hlU2l6ZSIsImRpbXMiLCJsaW1pdGVkRGltcyIsImNhcHBlZCIsIl9nZXRDYWNoZUNhbnZhc0RpbWVuc2lvbnMiLCJvYmplY3RTY2FsZSIsImdldFRvdGFsT2JqZWN0U2NhbGluZyIsIm5lZWRlZFgiLCJuZWVkZWRZIiwidGFyZ2V0Q2FudmFzIiwiZHJhd2luZ1dpZHRoIiwiZHJhd2luZ0hlaWdodCIsImRpbWVuc2lvbnNDaGFuZ2VkIiwiY2FjaGVXaWR0aCIsImNhY2hlSGVpZ2h0Iiwiem9vbUNoYW5nZWQiLCJzaG91bGRSZWRyYXciLCJzZXRUcmFuc2Zvcm0iLCJuZWVkRnVsbFRyYW5zZm9ybSIsIl9yZW1vdmVEZWZhdWx0VmFsdWVzIiwiZ2V0T2JqZWN0U2NhbGluZyIsInJldGluYSIsImdldE9iamVjdE9wYWNpdHkiLCJzaG91bGRDb25zdHJhaW5WYWx1ZSIsImlzQ2hhbmdlZCIsImdyb3VwTmVlZHNVcGRhdGUiLCJfY29uc3RyYWluU2NhbGUiLCJpc09uQUNhY2hlIiwic2V0T25Hcm91cCIsImdldFZpZXdwb3J0VHJhbnNmb3JtIiwiaXNOb3RWaXNpYmxlIiwiaXNPblNjcmVlbiIsIl9zZXR1cENvbXBvc2l0ZU9wZXJhdGlvbiIsImRyYXdTZWxlY3Rpb25CYWNrZ3JvdW5kIiwiX3NldE9wYWNpdHkiLCJkcmF3Q2FjaGVPbkNhbnZhcyIsIl9yZW1vdmVDYWNoZUNhbnZhcyIsImRyYXdPYmplY3QiLCJwcm9wZXJ0eVNldCIsImlzQ2FjaGVEaXJ0eSIsImhhc1N0cm9rZSIsImhhc0ZpbGwiLCJuZWVkc0l0c093bkNhY2hlIiwib3duQ2FjaGluZyIsIndpbGxEcmF3U2hhZG93IiwiZHJhd0NsaXBQYXRoT25DYWNoZSIsIm9yaWdpbmFsRmlsbCIsIm9yaWdpbmFsU3Ryb2tlIiwiX3NldENsaXBwaW5nUHJvcGVydGllcyIsIl9kcmF3Q2xpcFBhdGgiLCJza2lwQ2FudmFzIiwiX2dldE5vblRyYW5zZm9ybWVkRGltZW5zaW9ucyIsIl9yZW1vdmVTaGFkb3ciLCJfc2V0U3Ryb2tlU3R5bGVzIiwiZGVjbCIsImxpbmVEYXNoT2Zmc2V0IiwiX2FwcGx5UGF0dGVybkZvclRyYW5zZm9ybWVkR3JhZGllbnQiLCJfYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm0iLCJfc2V0RmlsbFN0eWxlcyIsImRhc2hBcnJheSIsImRyYXdCb3JkZXJzIiwiZm9yQWN0aXZlU2VsZWN0aW9uIiwiZHJhd0JvcmRlcnNJbkdyb3VwIiwic2NhbGluZyIsIm11bHRYIiwibXVsdFkiLCJfcmVuZGVyUGFpbnRJbk9yZGVyIiwiX3JlbmRlclN0cm9rZSIsIl9yZW5kZXJGaWxsIiwicENhbnZhcyIsInBDdHgiLCJfZmluZENlbnRlckZyb21FbGVtZW50IiwiX2Fzc2lnblRyYW5zZm9ybU1hdHJpeFByb3BzIiwicHJlc2VydmVBc3BlY3RSYXRpb09wdGlvbnMiLCJjcm9wWCIsImNyb3BZIiwib2Zmc2V0TGVmdCIsIm9mZnNldFRvcCIsIm9iamVjdEZvcm0iLCJfZnJvbU9iamVjdCIsImNsb25lQXNJbWFnZSIsInV0aWxzIiwib3JpZ1BhcmFtcyIsIm9yaWdpbmFsR3JvdXAiLCJvcmlnaW5hbFNoYWRvdyIsIndpdGhvdXRUcmFuc2Zvcm0iLCJ3aXRob3V0U2hhZG93IiwiYm91bmRpbmdSZWN0IiwiZ2V0Qm91bmRpbmdSZWN0Iiwic2hhZG93T2Zmc2V0Iiwib3JpZ2luYWxDYW52YXMiLCJpc1R5cGUiLCJpbmNsdWRlcyIsInNob3VsZENlbnRlck9yaWdpbiIsIl9zZXRPcmlnaW5Ub0NlbnRlciIsIl9yZXNldE9yaWdpbiIsImNlbnRlckgiLCJ2aWV3cG9ydENlbnRlckgiLCJjZW50ZXJWIiwidmlld3BvcnRDZW50ZXJWIiwidmlld3BvcnRDZW50ZXIiLCJnZXRMb2NhbFBvaW50ZXIiLCJwQ2xpY2tlZCIsIm9iamVjdExlZnRUb3AiLCJjcmVhdGVBY2Nlc3NvcnMiLCJleHRyYVBhcmFtIiwib3JpZ2luWE9mZnNldCIsIm9yaWdpbllPZmZzZXQiLCJ0cmFuc2xhdGVUb0dpdmVuT3JpZ2luIiwiZnJvbU9yaWdpblgiLCJmcm9tT3JpZ2luWSIsInRvT3JpZ2luWCIsInRvT3JpZ2luWSIsInRyYW5zbGF0ZVRvQ2VudGVyUG9pbnQiLCJsZWZ0VG9wIiwiZ2V0UG9pbnRCeU9yaWdpbiIsImFkanVzdFBvc2l0aW9uIiwiaHlwb3RGdWxsIiwiZ2V0U2NhbGVkV2lkdGgiLCJ4RnVsbCIsInlGdWxsIiwib2Zmc2V0RnJvbSIsIm9mZnNldFRvIiwiX29yaWdpbmFsT3JpZ2luWCIsIl9vcmlnaW5hbE9yaWdpblkiLCJvcmlnaW5Qb2ludCIsImFycmF5RnJvbUNvb3JkcyIsIm11bHRpcGx5TWF0cmljZXMiLCJvQ29vcmRzIiwiYUNvb3JkcyIsImxpbmVDb29yZHMiLCJvd25NYXRyaXhDYWNoZSIsIm1hdHJpeENhY2hlIiwiX2dldENvb3JkcyIsImFic29sdXRlIiwiY2FsY3VsYXRlIiwiY2FsY0FDb29yZHMiLCJjYWxjTGluZUNvb3JkcyIsImdldENvb3JkcyIsInBvaW50VEwiLCJwb2ludEJSIiwiaW50ZXJzZWN0aW9uIiwib3RoZXIiLCJvdGhlckNvb3JkcyIsImxpbmVzIiwiX2dldEltYWdlTGluZXMiLCJfZmluZENyb3NzUG9pbnRzIiwiX2NvbnRhaW5zQ2VudGVyT2ZDYW52YXMiLCJpc1BhcnRpYWxseU9uU2NyZWVuIiwiYWxsUG9pbnRzQXJlT3V0c2lkZSIsImV2ZXJ5IiwidG9wbGluZSIsInJpZ2h0bGluZSIsImJvdHRvbWxpbmUiLCJsZWZ0bGluZSIsInhpIiwieGNvdW50IiwiaUxpbmUiLCJsaW5lS2V5IiwiZ2V0U2NhbGVkSGVpZ2h0Iiwic2NhbGVUb1dpZHRoIiwiYm91bmRpbmdSZWN0RmFjdG9yIiwic2NhbGVUb0hlaWdodCIsImNvc1AiLCJzaW5QIiwiY29zUFNpblAiLCJjb3NQTWludXNTaW5QIiwiY2FsY09Db29yZHMiLCJfY2FsY1JvdGF0ZU1hdHJpeCIsIl9jYWxjVHJhbnNsYXRlTWF0cml4Iiwic3RhcnRNYXRyaXgiLCJfY2FsY3VsYXRlQ3VycmVudERpbWVuc2lvbnMiLCJmb3JFYWNoQ29udHJvbCIsInciLCJza2lwQ29ybmVycyIsIl9zZXRDb3JuZXJDb29yZHMiLCJ0cmFuc2Zvcm1NYXRyaXhLZXkiLCJzZXAiLCJwcmVmaXgiLCJjYWNoZSIsInRNYXRyaXgiLCJub1NrZXciLCJfZmluYWxpemVEaW1lbnNpb25zIiwiZ2V0U3ZnQ29sb3JTdHJpbmciLCJnZXRTdmdTdHlsZXMiLCJza2lwU2hhZG93IiwiZ2V0U3ZnRmlsdGVyIiwiZ2V0U3ZnU3BhblN0eWxlcyIsInVzZVdoaXRlU3BhY2UiLCJ0ZXJtIiwidGV4dERlY29yYXRpb24iLCJnZXRTdmdUZXh0RGVjb3JhdGlvbiIsImRlY29yYXRpb24iLCJnZXRTdmdDb21tb25zIiwiZ2V0U3ZnVHJhbnNmb3JtIiwiZnVsbCIsInN2Z1RyYW5zZm9ybSIsIl9zZXRTVkdCZyIsInRleHRCZ1JlY3RzIiwiX2dldEZpbGxBdHRyaWJ1dGVzIiwiX2NyZWF0ZUJhc2VTVkdNYXJrdXAiLCJfdG9TVkciLCJfY3JlYXRlQmFzZUNsaXBQYXRoU1ZHTWFya3VwIiwib2JqZWN0TWFya3VwIiwiY29tbW9uUGllY2VzIiwibm9TdHlsZSIsInN0eWxlSW5mbyIsInNoYWRvd0luZm8iLCJ3aXRoU2hhZG93IiwidmVjdG9yRWZmZWN0IiwiYWJzb2x1dGVDbGlwUGF0aCIsImNsaXBQYXRoTWFya3VwIiwiYWRkUGFpbnRPcmRlciIsIm9yaWdpbmFsU2V0Iiwic2F2ZVByb3BzIiwicHJvcHMiLCJ0bXBPYmoiLCJfaXNFcXVhbCIsIm9yaWdWYWx1ZSIsImZpcnN0UGFzcyIsImRhc2hlZFByb3BlcnR5U2V0IiwiZm9yVG91Y2giLCJpc0NvbnRyb2xWaXNpYmxlIiwidG91Y2hDb3JuZXIiLCJmbiIsImNvbnRyb2xPYmplY3QiLCJ3aCIsInNob3VsZFN0cm9rZSIsInNldENvbnRyb2xWaXNpYmxlIiwic2V0Q29udHJvbHNWaXNpYmlsaXR5IiwiRlhfRFVSQVRJT04iLCJmeENlbnRlck9iamVjdEgiLCJjYWxsYmFja3MiLCJlbXB0eSIsImZ4Q2VudGVyT2JqZWN0ViIsImZ4UmVtb3ZlIiwicHJvcHNUb0FuaW1hdGUiLCJza2lwQ2FsbGJhY2tzIiwib3V0IiwiX2FuaW1hdGUiLCJwcm9wUGFpciIsInByb3BJc0NvbG9yIiwidmFsdWVQcm9ncmVzcyIsInRpbWVQcm9ncmVzcyIsImNvb3JkUHJvcHMiLCJMaW5lIiwiX3NldFdpZHRoSGVpZ2h0IiwiX2dldExlZnRUb09yaWdpblgiLCJfZ2V0VG9wVG9PcmlnaW5ZIiwibWFrZUVkZ2VUb09yaWdpbkdldHRlciIsImF4aXMxIiwiYXhpczIiLCJkaW1lbnNpb24iLCJuZWFyZXN0IiwiZmFydGhlc3QiLCJjYWxjTGluZVBvaW50cyIsIm9yaWdTdHJva2VTdHlsZSIsInhNdWx0IiwieU11bHQiLCJBVFRSSUJVVEVfTkFNRVMiLCJwYXJzZWRBdHRyaWJ1dGVzIiwiX2NhbGxiYWNrIiwicHJvcGVydHlOYW1lcyIsIm9yaWdpblZhbHVlcyIsInN0YXJ0QW5nbGUiLCJlbmRBbmdsZSIsInNldFJhZGl1cyIsInN2Z1N0cmluZyIsInN0YXJ0WCIsInN0YXJ0WSIsImVuZFgiLCJlbmRZIiwibGFyZ2VGbGFnIiwiZ2V0UmFkaXVzWCIsImdldFJhZGl1c1kiLCJpc1ZhbGlkUmFkaXVzIiwiVHJpYW5nbGUiLCJ3aWR0aEJ5MiIsImhlaWdodEJ5MiIsInBpQnkyIiwiRWxsaXBzZSIsImdldFJ4IiwiZ2V0UnkiLCJfaW5pdFJ4UnkiLCJpc1JvdW5kZWQiLCJiZXppZXJDdXJ2ZVRvIiwiUG9seWxpbmUiLCJleGFjdEJvdW5kaW5nQm94IiwiX3NldFBvc2l0aW9uRGltZW5zaW9ucyIsIl9wcm9qZWN0U3Ryb2tlT25Qb2ludHMiLCJjYWxjRGltIiwiX2NhbGNEaW1lbnNpb25zIiwiY29ycmVjdExlZnRUb3AiLCJjb3JyZWN0U2l6ZSIsImZyb21TVkciLCJkaWZmWCIsImRpZmZZIiwiY29tbW9uUmVuZGVyIiwiZnJvbUVsZW1lbnRHZW5lcmF0b3IiLCJfY2xhc3MiLCJQb2x5Z29uIiwiX3NldFBhdGgiLCJfcmVuZGVyUGF0aENvbW1hbmRzIiwic3VicGF0aFN0YXJ0WCIsInN1YnBhdGhTdGFydFkiLCJfZ2V0T2Zmc2V0VHJhbnNmb3JtIiwiZGlnaXRzIiwiYVgiLCJhWSIsImRlbHRhWCIsInBhdGhVcmwiLCJlbGl2ZW5lZE9iamVjdHMiLCJ1c2VTZXRPbkdyb3VwIiwiaXNBbHJlYWR5R3JvdXBlZCIsIl9jYWxjQm91bmRzIiwiX3VwZGF0ZU9iamVjdHNDb29yZHMiLCJfdXBkYXRlT2JqZWN0c0FDb29yZHMiLCJza2lwQ29udHJvbHMiLCJfdXBkYXRlT2JqZWN0Q29vcmRzIiwib2JqZWN0TGVmdCIsIm9iamVjdFRvcCIsIm5lc3RlZCIsIl9yZXN0b3JlT2JqZWN0c1N0YXRlIiwiX2luY2x1ZGVEZWZhdWx0VmFsdWVzIiwib2Jqc1RvT2JqZWN0Iiwib3JpZ2luYWxEZWZhdWx0cyIsIl9vYmoiLCJvd25DYWNoZSIsImdyb3VwTWF0cml4IiwiZGVzdHJveSIsInRvQWN0aXZlU2VsZWN0aW9uIiwidW5ncm91cE9uQ2FudmFzIiwic2V0T2JqZWN0c0Nvb3JkcyIsIm9ubHlXaWR0aEhlaWdodCIsImlMZW4iLCJqTGVuIiwiX2dldEJvdW5kcyIsIm1pblhZIiwibWF4WFkiLCJ0b0dyb3VwIiwibmV3R3JvdXAiLCJjaGlsZHJlbk92ZXJyaWRlIiwic3JjRnJvbUF0dHJpYnV0ZSIsIl9sYXN0U2NhbGVYIiwiX2xhc3RTY2FsZVkiLCJfZmlsdGVyU2NhbGluZ1giLCJfZmlsdGVyU2NhbGluZ1kiLCJtaW5pbXVtU2NhbGVUcmlnZ2VyIiwiY2FjaGVLZXkiLCJpbWFnZVNtb290aGluZyIsImZpbHRlcnMiLCJfaW5pdEVsZW1lbnQiLCJfZWxlbWVudCIsInNldEVsZW1lbnQiLCJyZW1vdmVUZXh0dXJlIiwiX2luaXRDb25maWciLCJhcHBseUZpbHRlcnMiLCJyZXNpemVGaWx0ZXIiLCJhcHBseVJlc2l6ZUZpbHRlcnMiLCJiYWNrZW5kIiwiZmlsdGVyQmFja2VuZCIsImV2aWN0Q2FjaGVzRm9yS2V5IiwiZ2V0Q3Jvc3NPcmlnaW4iLCJnZXRPcmlnaW5hbFNpemUiLCJfc3Ryb2tlIiwiZmlsdGVyT2JqIiwiZ2V0U3JjIiwiaGFzQ3JvcCIsImltYWdlTWFya3VwIiwic3Ryb2tlU3ZnIiwiaW1hZ2VSZW5kZXJpbmciLCJnZXRTdmdTcmMiLCJvcmlnRmlsbCIsImZpbHRlcmVkIiwic2V0U3JjIiwibWluaW11bVNjYWxlIiwiZWxlbWVudFRvRmlsdGVyIiwiX2ZpbHRlcmVkRWwiLCJzb3VyY2VXaWR0aCIsInNvdXJjZUhlaWdodCIsImlzTmV1dHJhbFN0YXRlIiwiaW1nRWxlbWVudCIsIl9uZWVkc1Jlc2l6ZSIsImVsZW1lbnRUb0RyYXciLCJlbFdpZHRoIiwiZWxIZWlnaHQiLCJzWCIsInNZIiwic1ciLCJzSCIsIm1heERlc3RXIiwibWF4RGVzdEgiLCJfcmVzZXRXaWR0aEhlaWdodCIsIkNTU19DQU5WQVMiLCJfaW5pdEZpbHRlcnMiLCJwQVIiLCJyV2lkdGgiLCJySGVpZ2h0IiwicFdpZHRoIiwicEhlaWdodCIsIl9vYmplY3QiLCJyZXNpemVGaWx0ZXJzIiwiZnJvbVVSTCIsImltZ09wdGlvbnMiLCJfZ2V0QW5nbGVWYWx1ZUZvclN0cmFpZ2h0ZW4iLCJzdHJhaWdodGVuIiwiZnhTdHJhaWdodGVuIiwic3RyYWlnaHRlbk9iamVjdCIsImZ4U3RyYWlnaHRlbk9iamVjdCIsInRlc3RQcmVjaXNpb24iLCJnbCIsInByZWNpc2lvbiIsImZyYWdtZW50U291cmNlIiwiZnJhZ21lbnRTaGFkZXIiLCJjcmVhdGVTaGFkZXIiLCJGUkFHTUVOVF9TSEFERVIiLCJzaGFkZXJTb3VyY2UiLCJjb21waWxlU2hhZGVyIiwiZ2V0U2hhZGVyUGFyYW1ldGVyIiwiQ09NUElMRV9TVEFUVVMiLCJpc1N1cHBvcnRlZCIsImdldFBhcmFtZXRlciIsIk1BWF9URVhUVVJFX1NJWkUiLCJwcmVjaXNpb25zIiwid2ViR2xQcmVjaXNpb24iLCJzZXR1cEdMQ29udGV4dCIsImNhcHR1cmVHUFVJbmZvIiwiY3JlYXRlV2ViR0xDYW52YXMiLCJhUG9zaXRpb24iLCJGbG9hdDMyQXJyYXkiLCJjaG9vc2VGYXN0ZXN0Q29weUdMVG8yRE1ldGhvZCIsImNhbk1lYXN1cmVQZXJmIiwicGVyZm9ybWFuY2UiLCJjYW5Vc2VJbWFnZURhdGEiLCJJbWFnZURhdGEiLCJjYW5Vc2VBcnJheUJ1ZmZlciIsIkFycmF5QnVmZmVyIiwiY2FuVXNlVWludDhDbGFtcGVkIiwiVWludDhDbGFtcGVkQXJyYXkiLCJpbWFnZUJ1ZmZlciIsImNvcHlHTFRvMkQiLCJjb3B5R0xUbzJEUHV0SW1hZ2VEYXRhIiwidGVzdENvbnRleHQiLCJkZXN0aW5hdGlvbldpZHRoIiwiZGVzdGluYXRpb25IZWlnaHQiLCJzdGFydFRpbWUiLCJkcmF3SW1hZ2VUaW1lIiwicHV0SW1hZ2VEYXRhVGltZSIsIm5vdyIsImNvcHlHTFRvMkREcmF3SW1hZ2UiLCJnbE9wdGlvbnMiLCJwcmVtdWx0aXBsaWVkQWxwaGEiLCJkZXB0aCIsInN0ZW5jaWwiLCJhbnRpYWxpYXMiLCJjbGVhckNvbG9yIiwiY2FjaGVkVGV4dHVyZSIsImdldENhY2hlZFRleHR1cmUiLCJwaXBlbGluZVN0YXRlIiwic291cmNlVGV4dHVyZSIsImNyZWF0ZVRleHR1cmUiLCJ0YXJnZXRUZXh0dXJlIiwib3JpZ2luYWxUZXh0dXJlIiwicGFzc2VzIiwid2ViZ2wiLCJwcm9ncmFtQ2FjaGUiLCJwYXNzIiwidGVtcEZibyIsImNyZWF0ZUZyYW1lYnVmZmVyIiwiYmluZEZyYW1lYnVmZmVyIiwiRlJBTUVCVUZGRVIiLCJhcHBseVRvIiwicmVzaXplQ2FudmFzSWZOZWVkZWQiLCJiaW5kVGV4dHVyZSIsIlRFWFRVUkVfMkQiLCJkZWxldGVUZXh0dXJlIiwiZGVsZXRlRnJhbWVidWZmZXIiLCJjbGVhcldlYkdMQ2FjaGVzIiwidGV4dHVyZUNhY2hlIiwidGV4dHVyZUltYWdlU291cmNlIiwiZmlsdGVyVHlwZSIsInRleHR1cmUiLCJ0ZXhQYXJhbWV0ZXJpIiwiVEVYVFVSRV9NQUdfRklMVEVSIiwiTkVBUkVTVCIsIlRFWFRVUkVfTUlOX0ZJTFRFUiIsIlRFWFRVUkVfV1JBUF9TIiwiQ0xBTVBfVE9fRURHRSIsIlRFWFRVUkVfV1JBUF9UIiwidGV4SW1hZ2UyRCIsIlJHQkEiLCJVTlNJR05FRF9CWVRFIiwidW5pcXVlSWQiLCJncHVJbmZvIiwicmVuZGVyZXIiLCJ2ZW5kb3IiLCJleHQiLCJnZXRFeHRlbnNpb24iLCJVTk1BU0tFRF9SRU5ERVJFUl9XRUJHTCIsIlVOTUFTS0VEX1ZFTkRPUl9XRUJHTCIsImRXaWR0aCIsImRIZWlnaHQiLCJnbENhbnZhcyIsInNvdXJjZVkiLCJudW1CeXRlcyIsInU4IiwiVWludDhBcnJheSIsInU4Q2xhbXBlZCIsInJlYWRQaXhlbHMiLCJpbWdEYXRhIiwicHV0SW1hZ2VEYXRhIiwic291cmNlRWxlbWVudCIsIm9yaWdpbmFsSW1hZ2VEYXRhIiwib3JpZ2luYWxFbCIsIkJhc2VGaWx0ZXIiLCJ2ZXJ0ZXhTb3VyY2UiLCJjcmVhdGVQcm9ncmFtIiwidmVydGV4U2hhZGVyIiwiVkVSVEVYX1NIQURFUiIsImdldFNoYWRlckluZm9Mb2ciLCJwcm9ncmFtIiwiYXR0YWNoU2hhZGVyIiwibGlua1Byb2dyYW0iLCJnZXRQcm9ncmFtUGFyYW1ldGVyIiwiTElOS19TVEFUVVMiLCJnZXRQcm9ncmFtSW5mb0xvZyIsImF0dHJpYnV0ZUxvY2F0aW9ucyIsImdldEF0dHJpYnV0ZUxvY2F0aW9ucyIsInVuaWZvcm1Mb2NhdGlvbnMiLCJnZXRVbmlmb3JtTG9jYXRpb25zIiwidVN0ZXBXIiwiZ2V0VW5pZm9ybUxvY2F0aW9uIiwidVN0ZXBIIiwiZ2V0QXR0cmliTG9jYXRpb24iLCJzZW5kQXR0cmlidXRlRGF0YSIsImFQb3NpdGlvbkRhdGEiLCJhdHRyaWJ1dGVMb2NhdGlvbiIsImJ1ZmZlciIsImNyZWF0ZUJ1ZmZlciIsImJpbmRCdWZmZXIiLCJBUlJBWV9CVUZGRVIiLCJlbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSIsInZlcnRleEF0dHJpYlBvaW50ZXIiLCJGTE9BVCIsImJ1ZmZlckRhdGEiLCJTVEFUSUNfRFJBVyIsIl9zZXR1cEZyYW1lQnVmZmVyIiwiZnJhbWVidWZmZXJUZXh0dXJlMkQiLCJDT0xPUl9BVFRBQ0hNRU5UMCIsIl9zd2FwVGV4dHVyZXMiLCJtYWluIiwibWFpblBhcmFtZXRlciIsImFwcGx5VG9XZWJHTCIsImFwcGx5VG8yZCIsInJldHJpZXZlU2hhZGVyIiwic2hhZGVyIiwidXNlUHJvZ3JhbSIsInVuaWZvcm0xZiIsInNlbmRVbmlmb3JtRGF0YSIsInZpZXdwb3J0IiwiZHJhd0FycmF5cyIsIlRSSUFOR0xFX1NUUklQIiwiYmluZEFkZGl0aW9uYWxUZXh0dXJlIiwidGV4dHVyZVVuaXQiLCJhY3RpdmVUZXh0dXJlIiwiVEVYVFVSRTAiLCJ1bmJpbmRBZGRpdGlvbmFsVGV4dHVyZSIsImdldE1haW5QYXJhbWV0ZXIiLCJzZXRNYWluUGFyYW1ldGVyIiwiY3JlYXRlSGVscExheWVyIiwiaGVscExheWVyIiwibWFpblAiLCJDb2xvck1hdHJpeCIsImNvbG9yc09ubHkiLCJ1Q29sb3JNYXRyaXgiLCJ1Q29uc3RhbnRzIiwiY29uc3RhbnRzIiwidW5pZm9ybU1hdHJpeDRmdiIsInVuaWZvcm00ZnYiLCJCcmlnaHRuZXNzIiwiYnJpZ2h0bmVzcyIsInVCcmlnaHRuZXNzIiwiQ29udm9sdXRlIiwib3BhcXVlIiwiQ29udm9sdXRlXzNfMSIsIkNvbnZvbHV0ZV8zXzAiLCJDb252b2x1dGVfNV8xIiwiQ29udm9sdXRlXzVfMCIsIkNvbnZvbHV0ZV83XzEiLCJDb252b2x1dGVfN18wIiwiQ29udm9sdXRlXzlfMSIsIkNvbnZvbHV0ZV85XzAiLCJ3ZWlnaHRzIiwic2lkZSIsImhhbGZTaWRlIiwic3ciLCJzaCIsIm91dHB1dCIsImNyZWF0ZUltYWdlRGF0YSIsImRzdCIsImFscGhhRmFjIiwiZHN0T2ZmIiwic2N4Iiwic2N5Iiwic3JjT2ZmIiwid3QiLCJ1TWF0cml4IiwidU9wYXF1ZSIsInVIYWxmU2l6ZSIsInVTaXplIiwidW5pZm9ybTFmdiIsIkdyYXlzY2FsZSIsImxpZ2h0bmVzcyIsImx1bWlub3NpdHkiLCJtb2RlIiwidU1vZGUiLCJ1bmlmb3JtMWkiLCJJbnZlcnQiLCJpbnZlcnQiLCJ1SW52ZXJ0IiwiTm9pc2UiLCJub2lzZSIsInJhbmQiLCJ1Tm9pc2UiLCJ1U2VlZCIsIlBpeGVsYXRlIiwiYmxvY2tzaXplIiwiX2kiLCJfaiIsIl9pTGVuIiwiX2pMZW4iLCJ1QmxvY2tzaXplIiwiUmVtb3ZlQ29sb3IiLCJ1c2VBbHBoYSIsImxvd0MiLCJoaWdoQyIsInVMb3ciLCJ1SGlnaCIsIkJyb3duaWUiLCJWaW50YWdlIiwiS29kYWNocm9tZSIsIlRlY2huaWNvbG9yIiwiUG9sYXJvaWQiLCJTZXBpYSIsIkJsYWNrV2hpdGUiLCJCbGVuZENvbG9yIiwic2NyZWVuIiwiZGlmZiIsImxpZ2h0ZW4iLCJkYXJrZW4iLCJleGNsdXNpb24iLCJ0aW50IiwiYnVpbGRTb3VyY2UiLCJ0ZyIsImFscGhhMSIsInVDb2xvciIsIkJsZW5kSW1hZ2UiLCJtYXNrIiwiVEVYVFVSRTEiLCJjYWxjdWxhdGVNYXRyaXgiLCJjYW52YXMxIiwiYmxlbmREYXRhIiwiYmxlbmRJbWFnZSIsInVUcmFuc2Zvcm1NYXRyaXgiLCJ1SW1hZ2UiLCJ1bmlmb3JtTWF0cml4M2Z2IiwiUmVzaXplIiwicmVzaXplVHlwZSIsImxhbmN6b3NMb2JlcyIsInVEZWx0YSIsInVUYXBzIiwidW5pZm9ybTJmdiIsImhvcml6b250YWwiLCJ0YXBzIiwiZmlsdGVyV2luZG93IiwiZ2V0RmlsdGVyV2luZG93IiwiZ2VuZXJhdGVTaGFkZXIiLCJ0ZW1wU2NhbGUiLCJnZXRUYXBzIiwibG9iZUZ1bmN0aW9uIiwibGFuY3pvc0NyZWF0ZSIsIm9mZnNldHMiLCJmcmFnbWVudFNvdXJjZVRPUCIsImRXIiwiZEgiLCJsb2JlcyIsInh4IiwicmNwU2NhbGVYIiwicmNwU2NhbGVZIiwib1ciLCJvSCIsIm5ld0RhdGEiLCJzbGljZUJ5VHdvIiwiaGVybWl0ZUZhc3RSZXNpemUiLCJiaWxpbmVhckZpbHRlcmluZyIsImxhbmN6b3NSZXNpemUiLCJtdWx0IiwiZG9uZVciLCJkb25lSCIsInN0ZXBXIiwic3RlcEgiLCJ0bXBDYW52YXMiLCJkWCIsImRZIiwicHJvY2VzcyIsInUiLCJ3ZWlnaHQiLCJmWCIsImZZIiwicmF0aW9YIiwiaWNlbnRlciIsInJhdGlvWSIsInJhbmdlMlgiLCJjYWNoZUxhbmMiLCJyYW5nZTJZIiwibGFuY3pvcyIsInJjcFJhdGlvWCIsInJjcFJhdGlvWSIsInNyY0RhdGEiLCJkZXN0RGF0YSIsImRlc3RJbWciLCJ4RGlmZiIsInlEaWZmIiwiY2hubCIsIm9yaWdQaXgiLCJ3NCIsInBpeGVscyIsImRlc3RJbWFnZSIsImRlc3RQaXhlbHMiLCJyYXRpb1ciLCJyYXRpb0giLCJyYXRpb1dIYWxmIiwicmF0aW9ISGFsZiIsImltZzIiLCJkYXRhMiIsIndlaWdodHNBbHBoYSIsImd4UiIsImd4RyIsImd4QiIsImd4QSIsInl5IiwidzAiLCJDb250cmFzdCIsImNvbnRyYXN0IiwiY29udHJhc3RGIiwidUNvbnRyYXN0IiwiU2F0dXJhdGlvbiIsInNhdHVyYXRpb24iLCJhZGp1c3QiLCJ1U2F0dXJhdGlvbiIsIlZpYnJhbmNlIiwidmlicmFuY2UiLCJhdmciLCJhbXQiLCJ1VmlicmFuY2UiLCJCbHVyIiwiYXNwZWN0UmF0aW8iLCJzaW1wbGVCbHVyIiwiY2FudmFzMiIsImJsdXJMYXllcjEiLCJibHVyTGF5ZXIyIiwiY3R4MSIsImN0eDIiLCJuU2FtcGxlcyIsInBlcmNlbnQiLCJuZXdJbWFnZURhdGEiLCJkZWx0YSIsImNob29zZVJpZ2h0RGVsdGEiLCJibHVyU2NhbGUiLCJHYW1tYSIsImdhbW1hIiwickludiIsImdJbnYiLCJiSW52IiwiclZhbHMiLCJnVmFscyIsImJWYWxzIiwidUdhbW1hIiwidW5pZm9ybTNmdiIsIkNvbXBvc2VkIiwic3ViRmlsdGVycyIsIkh1ZVJvdGF0aW9uIiwicm90YXRpb24iLCJyYWQiLCJhVGhpcmQiLCJhVGhpcmRTcXRTaW4iLCJPbmVNaW51c0NvcyIsImFkZGl0aW9uYWxQcm9wcyIsIl9kaW1lbnNpb25BZmZlY3RpbmdQcm9wcyIsIl9yZU5ld2xpbmUiLCJfcmVTcGFjZXNBbmRUYWJzIiwiX3JlU3BhY2VBbmRUYWIiLCJfcmVXb3JkcyIsInRleHRBbGlnbiIsInN1cGVyc2NyaXB0IiwiYmFzZWxpbmUiLCJzdWJzY3JpcHQiLCJwYXRoU3RhcnRPZmZzZXQiLCJwYXRoU2lkZSIsInBhdGhBbGlnbiIsIl9mb250U2l6ZUZyYWN0aW9uIiwiX2ZvbnRTaXplTXVsdCIsImNoYXJTcGFjaW5nIiwiX21lYXN1cmluZ0NvbnRleHQiLCJkaXJlY3Rpb24iLCJfc3R5bGVQcm9wZXJ0aWVzIiwiX19jaGFyQm91bmRzIiwiQ0FDSEVfRk9OVF9TSVpFIiwiTUlOX1RFWFRfV0lEVEgiLCJfX3NraXBEaW1lbnNpb24iLCJzZXRQYXRoSW5mbyIsImluaXREaW1lbnNpb25zIiwic2VnbWVudHNJbmZvIiwiZ2V0TWVhc3VyaW5nQ29udGV4dCIsIl9zcGxpdFRleHQiLCJuZXdMaW5lcyIsIl9zcGxpdFRleHRJbnRvTGluZXMiLCJfdGV4dExpbmVzIiwiZ3JhcGhlbWVMaW5lcyIsIl91bndyYXBwZWRUZXh0TGluZXMiLCJfdW53cmFwcGVkTGluZXMiLCJfdGV4dCIsImdyYXBoZW1lVGV4dCIsIl9jbGVhckNhY2hlIiwiYWRkaXRpb25hbFdpZHRoIiwiZ2V0SGVpZ2h0T2ZMaW5lIiwiY2FsY1RleHRXaWR0aCIsImN1cnNvcldpZHRoIiwiY2FsY1RleHRIZWlnaHQiLCJlbmxhcmdlU3BhY2VzIiwiZGlmZlNwYWNlIiwiY3VycmVudExpbmVXaWR0aCIsIm51bWJlck9mU3BhY2VzIiwiYWNjdW11bGF0ZWRTcGFjZSIsImxpbmUiLCJjaGFyQm91bmQiLCJzcGFjZXMiLCJpc0VuZE9mV3JhcHBpbmciLCJnZXRMaW5lV2lkdGgiLCJrZXJuZWRXaWR0aCIsImxpbmVJbmRleCIsIm1pc3NpbmdOZXdsaW5lT2Zmc2V0IiwiX3NldFRleHRTdHlsZXMiLCJfcmVuZGVyVGV4dExpbmVzQmFja2dyb3VuZCIsIl9yZW5kZXJUZXh0RGVjb3JhdGlvbiIsIl9yZW5kZXJUZXh0IiwiX3JlbmRlclRleHRTdHJva2UiLCJfcmVuZGVyVGV4dEZpbGwiLCJjaGFyU3R5bGUiLCJmb3JNZWFzdXJpbmciLCJ0ZXh0QmFzZWxpbmUiLCJfZ2V0Rm9udERlY2xhcmF0aW9uIiwibWF4V2lkdGgiLCJfcmVuZGVyVGV4dExpbmUiLCJfcmVuZGVyQ2hhcnMiLCJzdHlsZUhhcyIsImhlaWdodE9mTGluZSIsImxpbmVMZWZ0T2Zmc2V0IiwibGFzdENvbG9yIiwibGVmdE9mZnNldCIsIl9nZXRMZWZ0T2Zmc2V0IiwibGluZVRvcE9mZnNldCIsIl9nZXRUb3BPZmZzZXQiLCJib3hTdGFydCIsImJveFdpZHRoIiwiY2hhckJveCIsImN1cnJlbnRDb2xvciIsImRyYXdTdGFydCIsIl9nZXRMaW5lTGVmdE9mZnNldCIsImdldFZhbHVlT2ZQcm9wZXJ0eUF0IiwicmVuZGVyTGVmdCIsImdldEZvbnRDYWNoZSIsImNhY2hlUHJvcCIsIl9tZWFzdXJlQ2hhciIsInByZXZpb3VzQ2hhciIsInByZXZDaGFyU3R5bGUiLCJmb250Q2FjaGUiLCJmb250RGVjbGFyYXRpb24iLCJwcmV2aW91c0ZvbnREZWNsYXJhdGlvbiIsImNvdXBsZSIsInN0eWxlc0FyZUVxdWFsIiwiY291cGxlV2lkdGgiLCJwcmV2aW91c1dpZHRoIiwiZm9udE11bHRpcGxpZXIiLCJtZWFzdXJlVGV4dCIsImdldEhlaWdodE9mQ2hhciIsIm1lYXN1cmVMaW5lIiwibGluZUluZm8iLCJfbWVhc3VyZUxpbmUiLCJfZ2V0V2lkdGhPZkNoYXJTcGFjaW5nIiwiZ3JhcGhlbWUiLCJwcmV2R3JhcGhlbWUiLCJncmFwaGVtZUluZm8iLCJudW1PZlNwYWNlcyIsImxpbmVCb3VuZHMiLCJwb3NpdGlvbkluUGF0aCIsInN0YXJ0aW5nUG9pbnQiLCJ0b3RhbFBhdGhMZW5ndGgiLCJfZ2V0R3JhcGhlbWVCb3giLCJfc2V0R3JhcGhlbWVPblBhdGgiLCJjZW50ZXJQb3NpdGlvbiIsInNraXBMZWZ0IiwiZ2V0Q29tcGxldGVTdHlsZURlY2xhcmF0aW9uIiwicHJldmlvdXNCb3giLCJfX2xpbmVIZWlnaHRzIiwibWF4SGVpZ2h0IiwiX3JlbmRlclRleHRDb21tb24iLCJsaW5lSGVpZ2h0cyIsImlzRW1wdHlTdHlsZXMiLCJpc0p1c3RpZnkiLCJhY3R1YWxTdHlsZSIsIm5leHRTdHlsZSIsImNoYXJzVG9SZW5kZXIiLCJ0aW1lVG9SZW5kZXIiLCJzaG9ydEN1dCIsImlzTHRyIiwiZHJhd2luZ0xlZnQiLCJjdXJyZW50RGlyZWN0aW9uIiwiX3JlbmRlckNoYXIiLCJfYXBwbHlQYXR0ZXJuR3JhZGllbnRUcmFuc2Zvcm1UZXh0IiwiaGFuZGxlRmlsbGVyIiwiX2dldFN0eWxlRGVjbGFyYXRpb24iLCJmdWxsRGVjbCIsInNob3VsZEZpbGwiLCJmaWxsT2Zmc2V0cyIsInN0cm9rZU9mZnNldHMiLCJmaWxsVGV4dCIsInN0cm9rZVRleHQiLCJzZXRTdXBlcnNjcmlwdCIsIl9zZXRTY3JpcHQiLCJzZXRTdWJzY3JpcHQiLCJzY2hlbWEiLCJsb2MiLCJnZXQyREN1cnNvckxvY2F0aW9uIiwic2V0U2VsZWN0aW9uU3R5bGVzIiwibGluZURpZmYiLCJfX2xpbmVXaWR0aHMiLCJfc2hvdWxkQ2xlYXJEaW1lbnNpb25DYWNoZSIsInNob3VsZENsZWFyIiwiX2ZvcmNlQ2xlYXJDYWNoZSIsIl9zaXplIiwiX2R5IiwibGFzdERlY29yYXRpb24iLCJ0b3BPZmZzZXQiLCJjdXJyZW50RGVjb3JhdGlvbiIsImN1cnJlbnRGaWxsIiwibGFzdEZpbGwiLCJzdHlsZU9iamVjdCIsImZhbWlseSIsImZvbnRJc0dlbmVyaWMiLCJnZW5lcmljRm9udHMiLCJuZXdMaW5lIiwibmV3VGV4dCIsImFsbFByb3BlcnRpZXMiLCJuZWVkc0RpbXMiLCJpc0FkZGluZ1BhdGgiLCJfa2V5IiwicGFyc2VkQW5jaG9yIiwidGV4dEFuY2hvciIsIm9yaWdpbmFsU3Ryb2tlV2lkdGgiLCJ0ZXh0SGVpZ2h0U2NhbGVGYWN0b3IiLCJsaW5lSGVpZ2h0RGlmZiIsInNjYWxlZERpZmYiLCJ0ZXh0SGVpZ2h0Iiwib2ZmWCIsIm9iamVjdENvcHkiLCJ0ZXh0SW5zdGFuY2UiLCJwYXRoSW5zdGFuY2UiLCJwMyIsImNsZWFuU3R5bGUiLCJzdHlsZXNDb3VudCIsImxldHRlckNvdW50Iiwic3R5bGVQcm9wZXJ0eVZhbHVlIiwiYWxsU3R5bGVPYmplY3RQcm9wZXJ0aWVzTWF0Y2giLCJncmFwaGVtZUNvdW50Iiwic3R5bGVQcm9wZXJ0eUhhc0JlZW5TZXQiLCJyZW1vdmVTdHlsZSIsImxpbmVOdW0iLCJjaGFyTnVtIiwiX2V4dGVuZFN0eWxlcyIsIl9nZXRMaW5lU3R5bGUiLCJfc2V0TGluZVN0eWxlIiwiX3NldFN0eWxlRGVjbGFyYXRpb24iLCJzZWxlY3Rpb25TdGFydCIsInNraXBXcmFwcGluZyIsImdldFNlbGVjdGlvblN0eWxlcyIsInN0YXJ0SW5kZXgiLCJlbmRJbmRleCIsInNlbGVjdGlvbkVuZCIsImdldFN0eWxlQXRQb3NpdGlvbiIsImxpbmVTdHlsZSIsIl9kZWxldGVTdHlsZURlY2xhcmF0aW9uIiwiX2RlbGV0ZUxpbmVTdHlsZSIsInBhcnNlRGVjb3JhdGlvbiIsIklUZXh0IiwiZWRpdGFibGUiLCJlZGl0aW5nQm9yZGVyQ29sb3IiLCJjdXJzb3JDb2xvciIsImN1cnNvckRlbGF5IiwiY3Vyc29yRHVyYXRpb24iLCJjYWNoaW5nIiwiaGlkZGVuVGV4dGFyZWFDb250YWluZXIiLCJfcmVTcGFjZSIsIl9jdXJyZW50Q3Vyc29yT3BhY2l0eSIsIl9zZWxlY3Rpb25EaXJlY3Rpb24iLCJfYWJvcnRDdXJzb3JBbmltYXRpb24iLCJfX3dpZHRoT2ZTcGFjZSIsImluQ29tcG9zaXRpb25Nb2RlIiwiaW5pdEJlaGF2aW9yIiwic2V0U2VsZWN0aW9uU3RhcnQiLCJfdXBkYXRlQW5kRmlyZSIsInNldFNlbGVjdGlvbkVuZCIsIl9maXJlU2VsZWN0aW9uQ2hhbmdlZCIsIl91cGRhdGVUZXh0YXJlYSIsImluaXREZWxheWVkQ3Vyc29yIiwiY3Vyc29yT2Zmc2V0Q2FjaGUiLCJyZW5kZXJDdXJzb3JPclNlbGVjdGlvbiIsInNraXBSZXN0b3JlIiwiX2NsZWFyVGV4dEFyZWEiLCJib3VuZGFyaWVzIiwiX2dldEN1cnNvckJvdW5kYXJpZXMiLCJyZW5kZXJDdXJzb3IiLCJyZW5kZXJTZWxlY3Rpb24iLCJfZ2V0Q3Vyc29yQm91bmRhcmllc09mZnNldHMiLCJjdXJzb3JQb3NpdGlvbiIsImJvdW5kIiwiY3Vyc29yTG9jYXRpb24iLCJjaGFySGVpZ2h0IiwiX19pc01vdXNlZG93biIsImhpZGRlblRleHRhcmVhIiwic3RhcnRMaW5lIiwiZW5kTGluZSIsInN0YXJ0Q2hhciIsImVuZENoYXIiLCJsaW5lT2Zmc2V0IiwicmVhbExpbmVIZWlnaHQiLCJib3hFbmQiLCJkcmF3V2lkdGgiLCJkcmF3SGVpZ2h0IiwiZXh0cmFUb3AiLCJjb21wb3NpdGlvbkNvbG9yIiwiZ2V0Q3VycmVudENoYXJGb250U2l6ZSIsImNwIiwiX2dldEN1cnJlbnRDaGFySW5kZXgiLCJnZXRDdXJyZW50Q2hhckNvbG9yIiwib2JqQ29weSIsImluaXRBZGRlZEhhbmRsZXIiLCJpbml0UmVtb3ZlZEhhbmRsZXIiLCJpbml0Q3Vyc29yU2VsZWN0aW9uSGFuZGxlcnMiLCJpbml0RG91YmxlQ2xpY2tTaW11bGF0aW9uIiwibW91c2VNb3ZlSGFuZGxlciIsIl9pbml0Q2FudmFzSGFuZGxlcnMiLCJfcmVtb3ZlQ2FudmFzSGFuZGxlcnMiLCJfdGljayIsIl9jdXJyZW50VGlja1N0YXRlIiwiX2FuaW1hdGVDdXJzb3IiLCJ0YXJnZXRPcGFjaXR5IiwiY29tcGxldGVNZXRob2QiLCJ0aWNrU3RhdGUiLCJpc0Fib3J0ZWQiLCJfb25UaWNrQ29tcGxldGUiLCJfY3Vyc29yVGltZW91dDEiLCJfY3VycmVudFRpY2tDb21wbGV0ZVN0YXRlIiwicmVzdGFydCIsImRlbGF5IiwiYWJvcnRDdXJzb3JBbmltYXRpb24iLCJfY3Vyc29yVGltZW91dDIiLCJzZWxlY3RBbGwiLCJnZXRTZWxlY3RlZFRleHQiLCJmaW5kV29yZEJvdW5kYXJ5TGVmdCIsInN0YXJ0RnJvbSIsImZpbmRXb3JkQm91bmRhcnlSaWdodCIsImZpbmRMaW5lQm91bmRhcnlMZWZ0IiwiZmluZExpbmVCb3VuZGFyeVJpZ2h0Iiwic2VhcmNoV29yZEJvdW5kYXJ5Iiwic2VsZWN0V29yZCIsIm5ld1NlbGVjdGlvblN0YXJ0IiwibmV3U2VsZWN0aW9uRW5kIiwic2VsZWN0TGluZSIsImVudGVyRWRpdGluZyIsImV4aXRFZGl0aW5nT25PdGhlcnMiLCJpbml0SGlkZGVuVGV4dGFyZWEiLCJmb2N1cyIsIl9zYXZlRWRpdGluZ1Byb3BzIiwiX3NldEVkaXRpbmdQcm9wcyIsIl90ZXh0QmVmb3JlRWRpdCIsImluaXRNb3VzZU1vdmVIYW5kbGVyIiwiYWN0aXZlRWxlbWVudCIsImdldFNlbGVjdGlvblN0YXJ0RnJvbVBvaW50ZXIiLCJjdXJyZW50U3RhcnQiLCJjdXJyZW50RW5kIiwiX19zZWxlY3Rpb25TdGFydE9uTW91c2VEb3duIiwicmVzdGFydEN1cnNvcklmTmVlZGVkIiwiZnJvbVN0cmluZ1RvR3JhcGhlbWVTZWxlY3Rpb24iLCJzbWFsbGVyVGV4dFN0YXJ0IiwiZ3JhcGhlbWVTdGFydCIsInNtYWxsZXJUZXh0RW5kIiwiZ3JhcGhlbWVFbmQiLCJmcm9tR3JhcGhlbWVUb1N0cmluZ1NlbGVjdGlvbiIsIm5ld1NlbGVjdGlvbiIsInVwZGF0ZVRleHRhcmVhUG9zaXRpb24iLCJ1cGRhdGVGcm9tVGV4dEFyZWEiLCJfY2FsY1RleHRhcmVhUG9zaXRpb24iLCJkZXNpcmVkUG9zaXRpb24iLCJjb21wb3NpdGlvblN0YXJ0IiwidXBwZXJDYW52YXMiLCJ1cHBlckNhbnZhc1dpZHRoIiwidXBwZXJDYW52YXNIZWlnaHQiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsIl9zYXZlZFByb3BzIiwiX3Jlc3RvcmVFZGl0aW5nUHJvcHMiLCJpc1RleHRDaGFuZ2VkIiwiX3JlbW92ZUV4dHJhbmVvdXNTdHlsZXMiLCJyZW1vdmVTdHlsZUZyb21UbyIsImN1cnNvclN0YXJ0IiwiY3Vyc29yRW5kIiwibGluZVN0YXJ0IiwiY2hhclN0YXJ0IiwibGluZUVuZCIsImNoYXJFbmQiLCJzdHlsZU9iaiIsInNoaWZ0TGluZVN0eWxlcyIsIm51bWVyaWNDaGFyIiwiY2xvbmVkU3R5bGVzIiwibnVtZXJpY0xpbmUiLCJpbnNlcnROZXdsaW5lU3R5bGVPYmplY3QiLCJxdHkiLCJjb3BpZWRTdHlsZSIsImN1cnJlbnRDaGFyU3R5bGUiLCJuZXdMaW5lU3R5bGVzIiwic29tZVN0eWxlSXNDYXJyeWluZ092ZXIiLCJvcmlnaW5hbExpbmVMZW5ndGgiLCJpc0VuZE9mTGluZSIsIm51bUluZGV4Iiwic3R5bGVDYXJyaWVkT3ZlciIsImluc2VydENoYXJTdHlsZU9iamVjdCIsInF1YW50aXR5IiwiY3VycmVudExpbmVTdHlsZXMiLCJjdXJyZW50TGluZVN0eWxlc0Nsb25lZCIsIm51bWVyaWNJbmRleCIsIm5ld1N0eWxlIiwiaW5zZXJ0TmV3U3R5bGVCbG9jayIsImluc2VydGVkVGV4dCIsImN1cnNvckxvYyIsImFkZGVkTGluZXMiLCJsaW5lc0xlbmd0aCIsInNldFNlbGVjdGlvblN0YXJ0RW5kV2l0aFNoaWZ0Iiwic2V0U2VsZWN0aW9uSW5Cb3VuZGFyaWVzIiwiX19sYXN0Q2xpY2tUaW1lIiwiX19sYXN0TGFzdENsaWNrVGltZSIsIl9fbGFzdFBvaW50ZXIiLCJfX25ld0NsaWNrVGltZSIsIm5ld1BvaW50ZXIiLCJpc1RyaXBsZUNsaWNrIiwiX3N0b3BFdmVudCIsIl9fbGFzdElzRWRpdGluZyIsIl9fbGFzdFNlbGVjdGVkIiwiaW5pdE1vdXNlZG93bkhhbmRsZXIiLCJpbml0TW91c2V1cEhhbmRsZXIiLCJpbml0Q2xpY2tzIiwiZG91YmxlQ2xpY2tIYW5kbGVyIiwidHJpcGxlQ2xpY2tIYW5kbGVyIiwiX21vdXNlRG93bkhhbmRsZXIiLCJzZXRDdXJzb3JCeUNsaWNrIiwiX21vdXNlRG93bkhhbmRsZXJCZWZvcmUiLCJjdXJyZW50QWN0aXZlIiwibW91c2VPZmZzZXQiLCJwcmV2V2lkdGgiLCJfZ2V0TmV3U2VsZWN0aW9uU3RhcnRGcm9tT2Zmc2V0IiwiZGlzdGFuY2VCdHdMYXN0Q2hhckFuZEN1cnNvciIsImRpc3RhbmNlQnR3TmV4dENoYXJBbmRDdXJzb3IiLCJvbktleURvd24iLCJvbktleVVwIiwib25JbnB1dCIsImNvcHkiLCJwYXN0ZSIsIm9uQ29tcG9zaXRpb25TdGFydCIsIm9uQ29tcG9zaXRpb25VcGRhdGUiLCJvbkNvbXBvc2l0aW9uRW5kIiwiX2NsaWNrSGFuZGxlckluaXRpYWxpemVkIiwib25DbGljayIsImtleXNNYXAiLCJrZXlzTWFwUnRsIiwiY3RybEtleXNNYXBVcCIsImN0cmxLZXlzTWFwRG93biIsImtleU1hcCIsImtleUNvZGUiLCJjdHJsS2V5IiwibWV0YUtleSIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsIl9jb3B5RG9uZSIsImZyb21QYXN0ZSIsIm5leHRUZXh0IiwiY2hhckNvdW50IiwibmV4dENoYXJDb3VudCIsInJlbW92ZWRUZXh0IiwiY2hhckRpZmYiLCJyZW1vdmVGcm9tIiwicmVtb3ZlVG8iLCJ0ZXh0YXJlYVNlbGVjdGlvbiIsImJhY2tEZWxldGUiLCJjb3BpZWRUZXh0IiwiY29waWVkVGV4dFN0eWxlIiwiY29tcG9zaXRpb25FbmQiLCJfZ2V0Q2xpcGJvYXJkRGF0YSIsImNsaXBib2FyZERhdGEiLCJfZ2V0V2lkdGhCZWZvcmVDdXJzb3IiLCJ3aWR0aEJlZm9yZUN1cnNvciIsImdldERvd25DdXJzb3JPZmZzZXQiLCJpc1JpZ2h0Iiwic2VsZWN0aW9uUHJvcCIsIl9nZXRTZWxlY3Rpb25Gb3JPZmZzZXQiLCJpbmRleE9uT3RoZXJMaW5lIiwiX2dldEluZGV4T25MaW5lIiwidGV4dEFmdGVyQ3Vyc29yIiwiZ2V0VXBDdXJzb3JPZmZzZXQiLCJ0ZXh0QmVmb3JlQ3Vyc29yIiwid2lkdGhPZkNoYXJzT25MaW5lIiwiaW5kZXhPbkxpbmUiLCJjaGFyV2lkdGgiLCJmb3VuZE1hdGNoIiwibGVmdEVkZ2UiLCJyaWdodEVkZ2UiLCJvZmZzZXRGcm9tTGVmdEVkZ2UiLCJvZmZzZXRGcm9tUmlnaHRFZGdlIiwibW92ZUN1cnNvckRvd24iLCJfbW92ZUN1cnNvclVwT3JEb3duIiwibW92ZUN1cnNvclVwIiwibW92ZUN1cnNvcldpdGhTaGlmdCIsIm1vdmVDdXJzb3JXaXRob3V0U2hpZnQiLCJtb3ZlQ3Vyc29yTGVmdCIsIl9tb3ZlQ3Vyc29yTGVmdE9yUmlnaHQiLCJfbW92ZSIsIl9tb3ZlTGVmdCIsIl9tb3ZlUmlnaHQiLCJtb3ZlQ3Vyc29yTGVmdFdpdGhvdXRTaGlmdCIsImNoYW5nZSIsIm1vdmVDdXJzb3JMZWZ0V2l0aFNoaWZ0IiwibW92ZUN1cnNvclJpZ2h0IiwibW92ZUN1cnNvclJpZ2h0V2l0aFNoaWZ0IiwibW92ZUN1cnNvclJpZ2h0V2l0aG91dFNoaWZ0IiwiY2hhbmdlZCIsInJlbW92ZUNoYXJzIiwiaW5zZXJ0Q2hhcnMiLCJtdWx0aXBsZVNwYWNlc1JlZ2V4IiwiX2dldFNWR0xlZnRUb3BPZmZzZXRzIiwidGV4dEFuZEJnIiwiX2dldFNWR1RleHRBbmRCZyIsInRleHRUb3AiLCJ0ZXh0TGVmdCIsIl93cmFwU1ZHVGV4dEFuZEJnIiwidGV4dFN2ZyIsImxpbmVUb3AiLCJub1NoYWRvdyIsInRleHRTcGFucyIsInRleHRUb3BPZmZzZXQiLCJ0ZXh0TGVmdE9mZnNldCIsIl9zZXRTVkdUZXh0TGluZUJnIiwiX3NldFNWR1RleHRMaW5lVGV4dCIsIl9jcmVhdGVUZXh0Q2hhclNwYW4iLCJzdHlsZURlY2wiLCJzaG91bGRVc2VXaGl0ZXNwYWNlIiwic3R5bGVQcm9wcyIsImZpbGxTdHlsZXMiLCJkeVNwYW4iLCJhbmdsZUF0dHIiLCJ3QnkyIiwicmVuZGVyUG9pbnQiLCJfcHVzaFRleHRCZ1JlY3QiLCJmaWxsQ29sb3IiLCJfZ2V0U1ZHTGluZVRvcE9mZnNldCIsImxhc3RIZWlnaHQiLCJzdmdTdHlsZSIsIlRleHRib3giLCJtaW5XaWR0aCIsImR5bmFtaWNNaW5XaWR0aCIsIl9fY2FjaGVkTGluZXMiLCJfd29yZEpvaW5lcnMiLCJzcGxpdEJ5R3JhcGhlbWUiLCJfc3R5bGVNYXAiLCJfZ2VuZXJhdGVTdHlsZU1hcCIsInRleHRJbmZvIiwicmVhbExpbmVDb3VudCIsInJlYWxMaW5lQ2hhckNvdW50IiwiaXNXcmFwcGluZyIsIm5leHRMaW5lSW5kZXgiLCJuZXh0T2Zmc2V0Iiwic2hvdWxkTGltaXQiLCJtYXBOZXh0TGluZSIsIl93cmFwVGV4dCIsImRlc2lyZWRXaWR0aCIsIndyYXBwZWQiLCJfd3JhcExpbmUiLCJfbWVhc3VyZVdvcmQiLCJ3b3JkIiwiY2hhck9mZnNldCIsIl9saW5lIiwicmVzZXJ2ZWRTcGFjZSIsIndvcmRzIiwiaW5maXgiLCJ3b3JkV2lkdGgiLCJpbmZpeFdpZHRoIiwibGFyZ2VzdFdvcmRXaWR0aCIsImxpbmVKdXN0U3RhcnRlZCIsImFkZGl0aW9uYWxTcGFjZSIsImdldE1pbldpZHRoIiwibGluZXNUb0tlZXAiLCJzY2FsZVNrZXdTdHlsZUhhbmRsZXIiLCJzY2FsZVN0eWxlSGFuZGxlciIsIm9iamVjdENvbnRyb2xzIiwibWwiLCJtciIsIm1iIiwibXRyIiwidGV4dEJveENvbnRyb2xzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/fabric@5.5.2/node_modules/fabric/dist/fabric.js\n");

/***/ })

};
;